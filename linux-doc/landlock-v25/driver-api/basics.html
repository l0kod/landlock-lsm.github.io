

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Driver Basics &mdash; The Linux Kernel 5.10.0-rc6+ documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Device drivers infrastructure" href="infrastructure.html" />
    <link rel="prev" title="Porting Drivers to the New Driver Model" href="driver-model/porting.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Driver Basics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#driver-entry-and-exit-points">Driver Entry and Exit points</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-device-table">Driver device table</a></li>
<li class="toctree-l3"><a class="reference internal" href="#delaying-scheduling-and-timer-routines">Delaying, scheduling, and timer routines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wait-queues-and-wake-events">Wait queues and Wake events</a></li>
<li class="toctree-l3"><a class="reference internal" href="#high-resolution-timers">High-resolution timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#internal-functions">Internal Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference-counting">Reference counting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomics">Atomics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-objects-manipulation">Kernel objects manipulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-utility-functions">Kernel utility functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-resource-management">Device Resource Management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Driver Basics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/basics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="driver-basics">
<h1>Driver Basics<a class="headerlink" href="#driver-basics" title="Permalink to this headline">¶</a></h1>
<div class="section" id="driver-entry-and-exit-points">
<h2>Driver Entry and Exit points<a class="headerlink" href="#driver-entry-and-exit-points" title="Permalink to this headline">¶</a></h2>
<dl class="c macro">
<dt id="c.module_init">
<code class="sig-name descname">module_init</code><a class="headerlink" href="#c.module_init" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">module_init</span> <span class="pre">(x)</span></code></p>
<blockquote>
<div><p>driver initialization entry point</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>function to be run at kernel boot time or module insertion</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> will either be called during do_initcalls() (if
builtin) or at module insertion time (if a module).  There can only
be one per module.</p>
<dl class="c macro">
<dt id="c.module_exit">
<code class="sig-name descname">module_exit</code><a class="headerlink" href="#c.module_exit" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">module_exit</span> <span class="pre">(x)</span></code></p>
<blockquote>
<div><p>driver exit entry point</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>function to be run when driver is removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a> will wrap the driver clean-up code
with cleanup_module() when used with rmmod when
the driver is a module.  If the driver is statically
compiled into the kernel, <a class="reference internal" href="#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a> has no effect.
There can only be one per module.</p>
</div>
<div class="section" id="driver-device-table">
<h2>Driver device table<a class="headerlink" href="#driver-device-table" title="Permalink to this headline">¶</a></h2>
<dl class="c struct">
<dt id="c.usb_device_id">
<em class="property">struct </em><code class="sig-name descname">usb_device_id</code><a class="headerlink" href="#c.usb_device_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>identifies USB devices for probing and hotplugging</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_device_id {
  __u16 match_flags;
  __u16 idVendor;
  __u16 idProduct;
  __u16 bcdDevice_lo;
  __u16 bcdDevice_hi;
  __u8 bDeviceClass;
  __u8 bDeviceSubClass;
  __u8 bDeviceProtocol;
  __u8 bInterfaceClass;
  __u8 bInterfaceSubClass;
  __u8 bInterfaceProtocol;
  __u8 bInterfaceNumber;
  kernel_ulong_t driver_info ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">match_flags</span></code></dt><dd><p>Bit mask controlling which of the other fields are used to
match against new devices. Any field except for driver_info may be
used, although some only make sense in conjunction with other fields.
This is usually set by a USB_DEVICE_*() macro, which sets all
other fields in this structure except for driver_info.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idVendor</span></code></dt><dd><p>USB vendor ID for a device; numbers are assigned
by the USB forum to its members.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idProduct</span></code></dt><dd><p>Vendor-assigned product ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bcdDevice_lo</span></code></dt><dd><p>Low end of range of vendor-assigned product version numbers.
This is also used to identify individual product versions, for
a range consisting of a single device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bcdDevice_hi</span></code></dt><dd><p>High end of version number range.  The range of product
versions is inclusive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bDeviceClass</span></code></dt><dd><p>Class of device; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Device classes specify behavior of all
the interfaces on a device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bDeviceSubClass</span></code></dt><dd><p>Subclass of device; associated with bDeviceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bDeviceProtocol</span></code></dt><dd><p>Protocol of device; associated with bDeviceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceClass</span></code></dt><dd><p>Class of interface; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Interface classes specify behavior only
of a given interface; other interfaces may support other classes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceSubClass</span></code></dt><dd><p>Subclass of interface; associated with bInterfaceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceProtocol</span></code></dt><dd><p>Protocol of interface; associated with bInterfaceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceNumber</span></code></dt><dd><p>Number of interface; composite devices may use
fixed interface numbers to differentiate between vendor-specific
interfaces.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_info</span></code></dt><dd><p>Holds information used by the driver.  Usually it holds
a pointer to a descriptor understood by the driver, or perhaps
device flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In most cases, drivers will create a table of device IDs by using
<a class="reference internal" href="usb/usb.html#c.USB_DEVICE" title="USB_DEVICE"><code class="xref c c-func docutils literal notranslate"><span class="pre">USB_DEVICE()</span></code></a>, or similar macros designed for that purpose.
They will then export it to userspace using MODULE_DEVICE_TABLE(),
and provide it to the USB core through their usb_driver structure.</p>
<p>See the <a class="reference internal" href="usb/usb.html#c.usb_match_id" title="usb_match_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_match_id()</span></code></a> function for information about how matches are
performed.  Briefly, you will normally use one of several macros to help
construct these entries.  Each entry you provide will either identify
one or more specific products, or will identify a class of products
which have agreed to behave the same.  You should put the more specific
matches towards the beginning of your table, so that driver_info can
record quirks of specific products.</p>
<dl class="c struct">
<dt id="c.mdio_device_id">
<em class="property">struct </em><code class="sig-name descname">mdio_device_id</code><a class="headerlink" href="#c.mdio_device_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>identifies PHY devices on an MDIO/MII bus</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mdio_device_id {
  __u32 phy_id;
  __u32 phy_id_mask;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_id</span></code></dt><dd><p>The result of
(mdio_read(<code class="xref c c-type docutils literal notranslate"><span class="pre">MII_PHYSID1</span></code>) &lt;&lt; 16 | mdio_read(<code class="xref c c-type docutils literal notranslate"><span class="pre">MII_PHYSID2</span></code>)) &amp; <strong>phy_id_mask</strong>
for this PHY type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_id_mask</span></code></dt><dd><p>Defines the significant bits of <strong>phy_id</strong>.  A value of 0
is used to terminate an array of <a class="reference internal" href="#c.mdio_device_id" title="mdio_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device_id</span></code></a>.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.amba_id">
<em class="property">struct </em><code class="sig-name descname">amba_id</code><a class="headerlink" href="#c.amba_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>identifies a device on an AMBA bus</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amba_id {
  unsigned int            id;
  unsigned int            mask;
  void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>The significant bits if the hardware device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>Bitmask specifying which bits of the id field are significant when
matching.  A driver binds to a device when ((hardware device ID) &amp; mask)
== id.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Private data used by the driver.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.mips_cdmm_device_id">
<em class="property">struct </em><code class="sig-name descname">mips_cdmm_device_id</code><a class="headerlink" href="#c.mips_cdmm_device_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>identifies devices in MIPS CDMM bus</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mips_cdmm_device_id {
  __u8 type;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Device type identifier.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.mei_cl_device_id">
<em class="property">struct </em><code class="sig-name descname">mei_cl_device_id</code><a class="headerlink" href="#c.mei_cl_device_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>MEI client device identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mei_cl_device_id {
  char name[MEI_CL_NAME_SIZE];
  uuid_le uuid;
  __u8 version;
  kernel_ulong_t driver_info;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>helper name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>client uuid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt><dd><p>client protocol version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_info</span></code></dt><dd><p>information used by the driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>identifies mei client device by uuid and name</p>
<dl class="c struct">
<dt id="c.rio_device_id">
<em class="property">struct </em><code class="sig-name descname">rio_device_id</code><a class="headerlink" href="#c.rio_device_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>RIO device identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rio_device_id {
  __u16 did, vid;
  __u16 asm_did, asm_vid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">did</span></code></dt><dd><p>RapidIO device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vid</span></code></dt><dd><p>RapidIO vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asm_did</span></code></dt><dd><p>RapidIO assembly device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asm_vid</span></code></dt><dd><p>RapidIO assembly vendor ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Identifies a RapidIO device based on both the device/vendor IDs and
the assembly device/vendor IDs.</p>
<dl class="c struct">
<dt id="c.fsl_mc_device_id">
<em class="property">struct </em><code class="sig-name descname">fsl_mc_device_id</code><a class="headerlink" href="#c.fsl_mc_device_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>MC object device identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsl_mc_device_id {
  __u16 vendor;
  const char obj_type[16];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vendor</span></code></dt><dd><p>vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj_type</span></code></dt><dd><p>MC object type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Type of entries in the “device Id” table for MC object devices supported by
a MC object device driver. The last entry of the table has vendor set to 0x0</p>
<dl class="c struct">
<dt id="c.tb_service_id">
<em class="property">struct </em><code class="sig-name descname">tb_service_id</code><a class="headerlink" href="#c.tb_service_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Thunderbolt service identifiers</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tb_service_id {
  __u32 match_flags;
  char protocol_key[8 + 1];
  __u32 protocol_id;
  __u32 protocol_version;
  __u32 protocol_revision;
  kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">match_flags</span></code></dt><dd><p>Flags used to match the structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_key</span></code></dt><dd><p>Protocol key the service supports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_id</span></code></dt><dd><p>Protocol id the service supports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_version</span></code></dt><dd><p>Version of the protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_revision</span></code></dt><dd><p>Revision of the protocol software</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Driver specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Thunderbolt XDomain services are exposed as devices where each device
carries the protocol information the service supports. Thunderbolt
XDomain service drivers match against that information.</p>
<dl class="c struct">
<dt id="c.typec_device_id">
<em class="property">struct </em><code class="sig-name descname">typec_device_id</code><a class="headerlink" href="#c.typec_device_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>USB Type-C alternate mode identifiers</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct typec_device_id {
  __u16 svid;
  __u8 mode;
  kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">svid</span></code></dt><dd><p>Standard or Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Mode index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Driver specific data</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.tee_client_device_id">
<em class="property">struct </em><code class="sig-name descname">tee_client_device_id</code><a class="headerlink" href="#c.tee_client_device_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tee based device identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tee_client_device_id {
  uuid_t uuid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>For TEE based client devices we use the device uuid as
the identifier.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.wmi_device_id">
<em class="property">struct </em><code class="sig-name descname">wmi_device_id</code><a class="headerlink" href="#c.wmi_device_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>WMI device identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct wmi_device_id {
  const char guid_string[UUID_STRING_LEN+1];
  const void *context;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">guid_string</span></code></dt><dd><p>36 char string of the form fa50ff2b-f2e8-45de-83fa-65417f2f49ba</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">context</span></code></dt><dd><p>pointer to driver specific data</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.mhi_device_id">
<em class="property">struct </em><code class="sig-name descname">mhi_device_id</code><a class="headerlink" href="#c.mhi_device_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>MHI device identification</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mhi_device_id {
  const char chan[MHI_NAME_SIZE];
  kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chan</span></code></dt><dd><p>MHI channel name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>driver data;</p>
</dd>
</dl>
</div>
<div class="section" id="delaying-scheduling-and-timer-routines">
<h2>Delaying, scheduling, and timer routines<a class="headerlink" href="#delaying-scheduling-and-timer-routines" title="Permalink to this headline">¶</a></h2>
<dl class="c struct">
<dt id="c.prev_cputime">
<em class="property">struct </em><code class="sig-name descname">prev_cputime</code><a class="headerlink" href="#c.prev_cputime" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>snapshot of system and user cputime</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct prev_cputime {
#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE;
  u64 utime;
  u64 stime;
  raw_spinlock_t lock;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">utime</span></code></dt><dd><p>time spent in user mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stime</span></code></dt><dd><p>time spent in system mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>protects the above two fields</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stores previous user/system time values such that we can guarantee
monotonicity.</p>
<dl class="c struct">
<dt id="c.util_est">
<em class="property">struct </em><code class="sig-name descname">util_est</code><a class="headerlink" href="#c.util_est" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Estimation utilization of FAIR tasks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct util_est {
  unsigned int                    enqueued;
  unsigned int                    ewma;
#define UTIL_EST_WEIGHT_SHIFT           2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enqueued</span></code></dt><dd><p>instantaneous estimated utilization of a task/cpu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ewma</span></code></dt><dd><p>the Exponential Weighted Moving Average (EWMA)
utilization of a task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Support data structure to track an Exponential Weighted Moving Average
(EWMA) of a FAIR task’s utilization. New samples are added to the moving
average each time a task completes an activation. Sample’s weight is chosen
so that the EWMA will be relatively insensitive to transient changes to the
task’s workload.</p>
<p>The enqueued attribute has a slightly different meaning for tasks and cpus:
- task:   the task’s util_avg at last task dequeue time
- cfs_rq: the sum of util_est.enqueued for each RUNNABLE task on that CPU
Thus, the util_est.enqueued of a task represents the contribution on the
estimated utilization of the CPU where that task is currently enqueued.</p>
<p>Only for tasks we track a moving average of the past instantaneous
estimated utilization. This allows to absorb sporadic drops in utilization
of an otherwise almost periodic task.</p>
<dl class="c function">
<dt id="c.pid_alive">
int <code class="sig-name descname">pid_alive</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> task_struct *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pid_alive" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check that a task structure is not stale</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>Task structure to be checked.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if a process is not yet dead (at most zombie state)
If pid_alive fails, then pointers within the task structure
can be stale and must not be dereferenced.</p>
<p><strong>Return</strong></p>
<p>1 if the process is alive. 0 otherwise.</p>
<dl class="c function">
<dt id="c.is_global_init">
int <code class="sig-name descname">is_global_init</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_global_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if a task structure is init. Since init is free to have sub-threads we need to check tgid.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>Task structure to be checked.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if a task structure is the first user space task the kernel created.</p>
<p><strong>Return</strong></p>
<p>1 if the task structure is init. 0 otherwise.</p>
<dl class="c function">
<dt id="c.task_nice">
int <code class="sig-name descname">task_nice</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> task_struct *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_nice" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the nice value of a given task.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>the task in question.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The nice value [ -20 … 0 … 19 ].</p>
<dl class="c function">
<dt id="c.is_idle_task">
bool <code class="sig-name descname">is_idle_task</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> task_struct *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_idle_task" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is the specified task an idle task?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>the task in question.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if <strong>p</strong> is an idle task. 0 otherwise.</p>
<dl class="c function">
<dt id="c.wake_up_process">
int <code class="sig-name descname">wake_up_process</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wake_up_process" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wake up a specific process</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>The process to be woken up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to wake up the nominated process and move it to the set of runnable
processes.</p>
<p>This function executes a full memory barrier before accessing the task state.</p>
<p><strong>Return</strong></p>
<p>1 if the process was woken up, 0 if it was already running.</p>
<dl class="c function">
<dt id="c.preempt_notifier_register">
void <code class="sig-name descname">preempt_notifier_register</code><span class="sig-paren">(</span><em class="property">struct</em> preempt_notifier *<em>notifier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_notifier_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tell me when current is being preempted &amp; rescheduled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">preempt_notifier</span> <span class="pre">*notifier</span></code></dt><dd><p>notifier struct to register</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.preempt_notifier_unregister">
void <code class="sig-name descname">preempt_notifier_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> preempt_notifier *<em>notifier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_notifier_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>no longer interested in preemption notifications</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">preempt_notifier</span> <span class="pre">*notifier</span></code></dt><dd><p>notifier struct to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <em>not</em> safe to call from within a preemption notifier.</p>
<dl class="c function">
<dt id="c.preempt_schedule_notrace">
__visible void notrace <code class="sig-name descname">preempt_schedule_notrace</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_schedule_notrace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>preempt_schedule called by tracing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The tracing infrastructure uses preempt_enable_notrace to prevent
recursion and tracing preempt enabling caused by the tracing
infrastructure itself. But as tracing can happen in areas coming
from userspace or just about to enter userspace, a preempt enable
can occur before user_exit() is called. This will cause the scheduler
to be called when the system is still in usermode.</p>
<p>To prevent this, the preempt_enable_notrace will use this function
instead of preempt_schedule() to exit user context if needed before
calling the scheduler.</p>
<dl class="c function">
<dt id="c.yield">
void <code class="sig-name descname">yield</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.yield" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>yield the current processor to other threads.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not ever use this function, there’s a 99% chance you’re doing it wrong.</p>
<p>The scheduler is at all times free to pick the calling task as the most
eligible task to run, if removing the <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a> call from your code breaks
it, its already broken.</p>
<p>Typical broken usage is:</p>
<dl class="simple">
<dt>while (!event)</dt><dd><p><a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a>;</p>
</dd>
</dl>
<p>where one assumes that <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a> will let ‘the other’ process run that will
make event true. If the current task is a SCHED_FIFO task that will never
happen. Never use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a> as a progress guarantee!!</p>
<p>If you want to use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a> to wait for something, use <a class="reference internal" href="#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event()</span></code></a>.
If you want to use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a> to be ‘nice’ for others, use cond_resched().
If you still want to use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a>, do not!</p>
<dl class="c function">
<dt id="c.yield_to">
int <code class="sig-name descname">yield_to</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>p</em>, bool <em>preempt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.yield_to" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>yield the current processor to another thread in your thread group, or accelerate that thread toward the processor it’s on.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">preempt</span></code></dt><dd><p>whether task preemption is allowed or not</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It’s the caller’s job to ensure that the target task struct
can’t go away on us before we can do any checks.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>true (&gt;0) if we indeed boosted the target task.
false (0) if we failed to boost the target.
-ESRCH if there’s no task to yield to.</p>
</div></blockquote>
<dl class="c function">
<dt id="c.cpupri_find_fitness">
int <code class="sig-name descname">cpupri_find_fitness</code><span class="sig-paren">(</span><em class="property">struct</em> cpupri *<em>cp</em>, <em class="property">struct</em> task_struct *<em>p</em>, <em class="property">struct</em> cpumask *<em>lowest_mask</em>, bool (*<em>fitness_fn</em>)<span class="sig-paren">(</span><em class="property">struct</em> task_struct *p, int cpu<span class="sig-paren">)</span><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_find_fitness" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the best (lowest-pri) CPU in the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>The task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpumask</span> <span class="pre">*lowest_mask</span></code></dt><dd><p>A mask to fill in with selected CPUs (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(*fitness_fn)(struct</span> <span class="pre">task_struct</span> <span class="pre">*p,</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>A pointer to a function to do custom checks whether the CPU
fits a specific criteria so that we only return those CPUs.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function returns the recommended CPUs as calculated during the
current invocation.  By the time the call returns, the CPUs may have in
fact changed priorities any number of times.  While not ideal, it is not
an issue of correctness since the normal rebalancer logic will correct
any discrepancies created by racing against the uncertainty of the current
priority configuration.</p>
<p><strong>Return</strong></p>
<p>(int)bool - CPUs were found</p>
<dl class="c function">
<dt id="c.cpupri_set">
void <code class="sig-name descname">cpupri_set</code><span class="sig-paren">(</span><em class="property">struct</em> cpupri *<em>cp</em>, int <em>cpu</em>, int <em>newpri</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update the CPU priority setting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>The target CPU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">newpri</span></code></dt><dd><p>The priority (INVALID-RT99) to assign to this CPU</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>Assumes cpu_rq(cpu)-&gt;lock is locked</p>
<p><strong>Return</strong></p>
<p>(void)</p>
<dl class="c function">
<dt id="c.cpupri_init">
int <code class="sig-name descname">cpupri_init</code><span class="sig-paren">(</span><em class="property">struct</em> cpupri *<em>cp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize the cpupri structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>-ENOMEM on memory allocation failure.</p>
<dl class="c function">
<dt id="c.cpupri_cleanup">
void <code class="sig-name descname">cpupri_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> cpupri *<em>cp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clean up the cpupri structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.update_tg_load_avg">
void <code class="sig-name descname">update_tg_load_avg</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.update_tg_load_avg" title="cfs_rq">cfs_rq</a> *<em>cfs_rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_tg_load_avg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update the tg’s load avg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>the cfs_rq whose avg changed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function ‘ensures’: tg-&gt;load_avg := Sum tg-&gt;cfs_rq[]-&gt;avg.load.
However, because tg-&gt;load_avg is a global value there are performance
considerations.</p>
<p>In order to avoid having to look at the other cfs_rq’s, we use a
differential update where we store the last value we propagated. This in
turn allows skipping updates if the differential is ‘small’.</p>
<p>Updating tg’s load_avg is necessary before update_cfs_share().</p>
<dl class="c function">
<dt id="c.update_cfs_rq_load_avg">
int <code class="sig-name descname">update_cfs_rq_load_avg</code><span class="sig-paren">(</span>u64 <em>now</em>, <em class="property">struct</em> <a class="reference internal" href="#c.update_cfs_rq_load_avg" title="cfs_rq">cfs_rq</a> *<em>cfs_rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_cfs_rq_load_avg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update the cfs_rq’s load/util averages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">now</span></code></dt><dd><p>current time, as per cfs_rq_clock_pelt()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>cfs_rq to update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The cfs_rq avg is the direct sum of all its entities (blocked and runnable)
avg. The immediate corollary is that all (fair) tasks must be attached, see
post_init_entity_util_avg().</p>
<p>cfs_rq-&gt;avg is used for task_h_load() and update_cfs_share() for example.</p>
<p>Returns true if the load decayed or we removed load.</p>
<p>Since both these conditions indicate a changed cfs_rq-&gt;avg.load we should
call <a class="reference internal" href="#c.update_tg_load_avg" title="update_tg_load_avg"><code class="xref c c-func docutils literal notranslate"><span class="pre">update_tg_load_avg()</span></code></a> when this function returns true.</p>
<dl class="c function">
<dt id="c.attach_entity_load_avg">
void <code class="sig-name descname">attach_entity_load_avg</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.attach_entity_load_avg" title="cfs_rq">cfs_rq</a> *<em>cfs_rq</em>, <em class="property">struct</em> sched_entity *<em>se</em><span class="sig-paren">)</span><a class="headerlink" href="#c.attach_entity_load_avg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attach this entity to its cfs_rq load avg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>cfs_rq to attach to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_entity</span> <span class="pre">*se</span></code></dt><dd><p>sched_entity to attach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must call <a class="reference internal" href="#c.update_cfs_rq_load_avg" title="update_cfs_rq_load_avg"><code class="xref c c-func docutils literal notranslate"><span class="pre">update_cfs_rq_load_avg()</span></code></a> before this, since we rely on
cfs_rq-&gt;avg.last_update_time being current.</p>
<dl class="c function">
<dt id="c.detach_entity_load_avg">
void <code class="sig-name descname">detach_entity_load_avg</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.detach_entity_load_avg" title="cfs_rq">cfs_rq</a> *<em>cfs_rq</em>, <em class="property">struct</em> sched_entity *<em>se</em><span class="sig-paren">)</span><a class="headerlink" href="#c.detach_entity_load_avg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>detach this entity from its cfs_rq load avg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>cfs_rq to detach from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_entity</span> <span class="pre">*se</span></code></dt><dd><p>sched_entity to detach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must call <a class="reference internal" href="#c.update_cfs_rq_load_avg" title="update_cfs_rq_load_avg"><code class="xref c c-func docutils literal notranslate"><span class="pre">update_cfs_rq_load_avg()</span></code></a> before this, since we rely on
cfs_rq-&gt;avg.last_update_time being current.</p>
<dl class="c function">
<dt id="c.cpu_util">
unsigned long <code class="sig-name descname">cpu_util</code><span class="sig-paren">(</span>int <em>cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpu_util" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the CPU to get the utilization of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The unit of the return value must be the one of capacity so we can compare
the utilization with the capacity of the CPU that is available for CFS task
(ie cpu_capacity).</p>
<p>cfs_rq.avg.util_avg is the sum of running time of runnable tasks plus the
recent utilization of currently non-runnable tasks on a CPU. It represents
the amount of utilization of a CPU in the range [0..capacity_orig] where
capacity_orig is the cpu_capacity available at the highest frequency
(arch_scale_freq_capacity()).
The utilization of a CPU converges towards a sum equal to or less than the
current capacity (capacity_curr &lt;= capacity_orig) of the CPU because it is
the running time on this CPU scaled by capacity_curr.</p>
<p>The estimated utilization of a CPU is defined to be the maximum between its
cfs_rq.avg.util_avg and the sum of the estimated utilization of the tasks
currently RUNNABLE on that CPU.
This allows to properly represent the expected utilization of a CPU which
has just got a big task running since a long sleep period. At the same time
however it preserves the benefits of the “blocked utilization” in
describing the potential for other tasks waking up on the same CPU.</p>
<p>Nevertheless, cfs_rq.avg.util_avg can be higher than capacity_curr or even
higher than capacity_orig because of unfortunate rounding in
cfs.avg.util_avg or just after migrating tasks and new task wakeups until
the average stabilizes with the new running time. We need to check that the
utilization stays within the range of [0..capacity_orig] and cap it if
necessary. Without utilization capping, a group could be seen as overloaded
(CPU0 utilization at 121% + CPU1 utilization at 80%) whereas CPU1 has 20% of
available capacity. We allow utilization to overshoot capacity_curr (but not
capacity_orig) as it useful for predicting the capacity required after task
migrations (scheduler-driven DVFS).</p>
<p><strong>Return</strong></p>
<p>the (estimated) utilization for the specified CPU</p>
<dl class="c function">
<dt id="c.update_sg_lb_stats">
void <code class="sig-name descname">update_sg_lb_stats</code><span class="sig-paren">(</span><em class="property">struct</em> lb_env *<em>env</em>, <em class="property">struct</em> sched_group *<em>group</em>, <em class="property">struct</em> sg_lb_stats *<em>sgs</em>, int *<em>sg_status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sg_lb_stats" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update sched_group’s statistics for load balancing.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_group</span> <span class="pre">*group</span></code></dt><dd><p>sched_group whose statistics are to be updated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_lb_stats</span> <span class="pre">*sgs</span></code></dt><dd><p>variable to hold the statistics for this group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*sg_status</span></code></dt><dd><p>Holds flag indicating the status of the sched_group</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.update_sd_pick_busiest">
bool <code class="sig-name descname">update_sd_pick_busiest</code><span class="sig-paren">(</span><em class="property">struct</em> lb_env *<em>env</em>, <em class="property">struct</em> sd_lb_stats *<em>sds</em>, <em class="property">struct</em> sched_group *<em>sg</em>, <em class="property">struct</em> sg_lb_stats *<em>sgs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sd_pick_busiest" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return 1 on busiest group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>sched_domain statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_group</span> <span class="pre">*sg</span></code></dt><dd><p>sched_group candidate to be checked for being the busiest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_lb_stats</span> <span class="pre">*sgs</span></code></dt><dd><p>sched_group statistics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if <strong>sg</strong> is a busier group than the previously selected
busiest group.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>sg</strong> is a busier group than the previously selected
busiest group. <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.idle_cpu_without">
int <code class="sig-name descname">idle_cpu_without</code><span class="sig-paren">(</span>int <em>cpu</em>, <em class="property">struct</em> task_struct *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idle_cpu_without" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>would a given CPU be idle without p ?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor on which idleness is tested.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task which should be ignored.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the CPU would be idle. 0 otherwise.</p>
<dl class="c function">
<dt id="c.update_sd_lb_stats">
void <code class="sig-name descname">update_sd_lb_stats</code><span class="sig-paren">(</span><em class="property">struct</em> lb_env *<em>env</em>, <em class="property">struct</em> sd_lb_stats *<em>sds</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sd_lb_stats" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update sched_domain’s statistics for load balancing.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>variable to hold the statistics for this sched_domain.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.calculate_imbalance">
void <code class="sig-name descname">calculate_imbalance</code><span class="sig-paren">(</span><em class="property">struct</em> lb_env *<em>env</em>, <em class="property">struct</em> sd_lb_stats *<em>sds</em><span class="sig-paren">)</span><a class="headerlink" href="#c.calculate_imbalance" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate the amount of imbalance present within the groups of a given sched_domain during load balance.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>load balance environment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>statistics of the sched_domain whose imbalance is to be calculated.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.find_busiest_group">
<em class="property">struct</em> sched_group *<code class="sig-name descname">find_busiest_group</code><span class="sig-paren">(</span><em class="property">struct</em> lb_env *<em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_busiest_group" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the busiest group within the sched_domain if there is an imbalance.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Also calculates the amount of runnable load which should be moved
to restore balance.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>The busiest group if imbalance exists.</p></li>
</ul>
<dl class="c macro">
<dt id="c.DECLARE_COMPLETION">
<code class="sig-name descname">DECLARE_COMPLETION</code><a class="headerlink" href="#c.DECLARE_COMPLETION" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DECLARE_COMPLETION</span> <span class="pre">(work)</span></code></p>
<blockquote>
<div><p>declare and initialize a completion structure</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>identifier for the completion structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro declares and initializes a completion structure. Generally used
for static declarations. You should use the _ONSTACK variant for automatic
variables.</p>
<dl class="c macro">
<dt id="c.DECLARE_COMPLETION_ONSTACK">
<code class="sig-name descname">DECLARE_COMPLETION_ONSTACK</code><a class="headerlink" href="#c.DECLARE_COMPLETION_ONSTACK" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DECLARE_COMPLETION_ONSTACK</span> <span class="pre">(work)</span></code></p>
<blockquote>
<div><p>declare and initialize a completion structure</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>identifier for the completion structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro declares and initializes a completion structure on the kernel
stack.</p>
<dl class="c function">
<dt id="c.__init_completion">
void <code class="sig-name descname">__init_completion</code><span class="sig-paren">(</span><em class="property">struct</em> completion *<em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__init_completion" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a dynamically allocated completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">completion</span> <span class="pre">*x</span></code></dt><dd><p>pointer to completion structure that is to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This inline function will initialize a dynamically created completion
structure.</p>
<dl class="c function">
<dt id="c.reinit_completion">
void <code class="sig-name descname">reinit_completion</code><span class="sig-paren">(</span><em class="property">struct</em> completion *<em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reinit_completion" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reinitialize a completion structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">completion</span> <span class="pre">*x</span></code></dt><dd><p>pointer to completion structure that is to be reinitialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This inline function should be used to reinitialize a completion structure so it can
be reused. This is especially important after complete_all() is used.</p>
<dl class="c function">
<dt id="c.__round_jiffies">
unsigned long <code class="sig-name descname">__round_jiffies</code><span class="sig-paren">(</span>unsigned long <em>j</em>, int <em>cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (absolute) jiffies that should be rounded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor number on which the timeout will happen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.__round_jiffies" title="__round_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">__round_jiffies()</span></code></a> rounds an absolute time in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The exact rounding is skewed for each processor to avoid all
processors firing at the exact same time, which could lead
to lock contention or spurious cache line bouncing.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
<dl class="c function">
<dt id="c.__round_jiffies_relative">
unsigned long <code class="sig-name descname">__round_jiffies_relative</code><span class="sig-paren">(</span>unsigned long <em>j</em>, int <em>cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_relative" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor number on which the timeout will happen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.__round_jiffies_relative" title="__round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">__round_jiffies_relative()</span></code></a> rounds a time delta  in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The exact rounding is skewed for each processor to avoid all
processors firing at the exact same time, which could lead
to lock contention or spurious cache line bouncing.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
<dl class="c function">
<dt id="c.round_jiffies">
unsigned long <code class="sig-name descname">round_jiffies</code><span class="sig-paren">(</span>unsigned long <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (absolute) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.round_jiffies" title="round_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies()</span></code></a> rounds an absolute time in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
<dl class="c function">
<dt id="c.round_jiffies_relative">
unsigned long <code class="sig-name descname">round_jiffies_relative</code><span class="sig-paren">(</span>unsigned long <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_relative" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.round_jiffies_relative" title="round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies_relative()</span></code></a> rounds a time delta  in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
<dl class="c function">
<dt id="c.__round_jiffies_up">
unsigned long <code class="sig-name descname">__round_jiffies_up</code><span class="sig-paren">(</span>unsigned long <em>j</em>, int <em>cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_up" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (absolute) jiffies that should be rounded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor number on which the timeout will happen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.__round_jiffies" title="__round_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">__round_jiffies()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
<dl class="c function">
<dt id="c.__round_jiffies_up_relative">
unsigned long <code class="sig-name descname">__round_jiffies_up_relative</code><span class="sig-paren">(</span>unsigned long <em>j</em>, int <em>cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_up_relative" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor number on which the timeout will happen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.__round_jiffies_relative" title="__round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">__round_jiffies_relative()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
<dl class="c function">
<dt id="c.round_jiffies_up">
unsigned long <code class="sig-name descname">round_jiffies_up</code><span class="sig-paren">(</span>unsigned long <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_up" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (absolute) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.round_jiffies" title="round_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
<dl class="c function">
<dt id="c.round_jiffies_up_relative">
unsigned long <code class="sig-name descname">round_jiffies_up_relative</code><span class="sig-paren">(</span>unsigned long <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_up_relative" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.round_jiffies_relative" title="round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies_relative()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
<dl class="c function">
<dt id="c.init_timer_key">
void <code class="sig-name descname">init_timer_key</code><span class="sig-paren">(</span><em class="property">struct</em> timer_list *<em>timer</em>, void (*<em>func</em>)<span class="sig-paren">(</span><em class="property">struct</em> timer_list*<span class="sig-paren">)</span>, unsigned int <em>flags</em>, <em class="property">const</em> char *<em>name</em>, <em class="property">struct</em> lock_class_key *<em>key</em>, <span class="sig-paren">)</span><a class="headerlink" href="#c.init_timer_key" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*func)(struct</span> <span class="pre">timer_list</span> <span class="pre">*)</span></code></dt><dd><p>timer callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>timer flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*key</span></code></dt><dd><p>lockdep class key of the fake lock used for tracking timer
sync lock dependencies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.init_timer_key" title="init_timer_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">init_timer_key()</span></code></a> must be done to a timer prior calling <em>any</em> of the
other timer functions.</p>
<dl class="c function">
<dt id="c.mod_timer_pending">
int <code class="sig-name descname">mod_timer_pending</code><span class="sig-paren">(</span><em class="property">struct</em> timer_list *<em>timer</em>, unsigned long <em>expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_timer_pending" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>modify a pending timer’s timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>the pending timer to be modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt><dd><p>new timeout in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mod_timer_pending" title="mod_timer_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer_pending()</span></code></a> is the same for pending timers as <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a>,
but will not re-activate and modify already deleted timers.</p>
<p>It is useful for unserialized use of timers.</p>
<dl class="c function">
<dt id="c.mod_timer">
int <code class="sig-name descname">mod_timer</code><span class="sig-paren">(</span><em class="property">struct</em> timer_list *<em>timer</em>, unsigned long <em>expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_timer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>modify a timer’s timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt><dd><p>new timeout in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a> is a more efficient way to update the expire field of an
active timer (if the timer is inactive it will be activated)</p>
<p>mod_timer(timer, expires) is equivalent to:</p>
<blockquote>
<div><p>del_timer(timer); timer-&gt;expires = expires; add_timer(timer);</p>
</div></blockquote>
<p>Note that if there are multiple unserialized concurrent users of the
same timer, then <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a> is the only safe way to modify the timeout,
since <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> cannot modify an already running timer.</p>
<p>The function returns whether it has modified a pending timer or not.
(ie. <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a> of an inactive timer returns 0, <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a> of an
active timer returns 1.)</p>
<dl class="c function">
<dt id="c.timer_reduce">
int <code class="sig-name descname">timer_reduce</code><span class="sig-paren">(</span><em class="property">struct</em> timer_list *<em>timer</em>, unsigned long <em>expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_reduce" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Modify a timer’s timeout if it would reduce the timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt><dd><p>New timeout in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.timer_reduce" title="timer_reduce"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_reduce()</span></code></a> is very similar to <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a>, except that it will only
modify a running timer if that would reduce the expiration time (it will
start a timer that isn’t running).</p>
<dl class="c function">
<dt id="c.add_timer">
void <code class="sig-name descname">add_timer</code><span class="sig-paren">(</span><em class="property">struct</em> timer_list *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_timer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>start a timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The kernel will do a -&gt;function(<strong>timer</strong>) callback from the
timer interrupt at the -&gt;expires point in the future. The
current time is ‘jiffies’.</p>
<p>The timer’s -&gt;expires, -&gt;function fields must be set prior calling this
function.</p>
<p>Timers with an -&gt;expires field in the past will be executed in the next
timer tick.</p>
<dl class="c function">
<dt id="c.add_timer_on">
void <code class="sig-name descname">add_timer_on</code><span class="sig-paren">(</span><em class="property">struct</em> timer_list *<em>timer</em>, int <em>cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_timer_on" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>start a timer on a particular CPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the CPU to start it on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is not very scalable on SMP. Double adds are not possible.</p>
<dl class="c function">
<dt id="c.del_timer">
int <code class="sig-name descname">del_timer</code><span class="sig-paren">(</span><em class="property">struct</em> timer_list *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.del_timer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deactivate a timer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be deactivated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.del_timer" title="del_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">del_timer()</span></code></a> deactivates a timer - this works on both active and inactive
timers.</p>
<p>The function returns whether it has deactivated a pending timer or not.
(ie. <a class="reference internal" href="#c.del_timer" title="del_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">del_timer()</span></code></a> of an inactive timer returns 0, <a class="reference internal" href="#c.del_timer" title="del_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">del_timer()</span></code></a> of an
active timer returns 1.)</p>
<dl class="c function">
<dt id="c.try_to_del_timer_sync">
int <code class="sig-name descname">try_to_del_timer_sync</code><span class="sig-paren">(</span><em class="property">struct</em> timer_list *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_del_timer_sync" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Try to deactivate a timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>timer to delete</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tries to deactivate a timer. Upon successful (ret &gt;= 0)
exit the timer is not queued and the handler is not running on any CPU.</p>
<dl class="c function">
<dt id="c.del_timer_sync">
int <code class="sig-name descname">del_timer_sync</code><span class="sig-paren">(</span><em class="property">struct</em> timer_list *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.del_timer_sync" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deactivate a timer and wait for the handler to finish.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be deactivated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function only differs from <a class="reference internal" href="#c.del_timer" title="del_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">del_timer()</span></code></a> on SMP: besides deactivating
the timer it also makes sure the handler has finished executing on other
CPUs.</p>
<p>Synchronization rules: Callers must prevent restarting of the timer,
otherwise this function is meaningless. It must not be called from
interrupt contexts unless the timer is an irqsafe one. The caller must
not hold locks which would prevent completion of the timer’s
handler. The timer’s handler must not call <a class="reference internal" href="#c.add_timer_on" title="add_timer_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer_on()</span></code></a>. Upon exit the
timer is not queued and the handler is not running on any CPU.</p>
<p>Now <a class="reference internal" href="#c.del_timer_sync" title="del_timer_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">del_timer_sync()</span></code></a> will never return and never release somelock.
The interrupt on the other CPU is waiting to grab somelock but
it has interrupted the softirq that CPU0 is waiting to finish.</p>
<p>The function returns whether it has deactivated a pending timer or not.</p>
<p><strong>Note</strong></p>
<dl>
<dt>For !irqsafe timers, you must not hold locks that are held in</dt><dd><p>interrupt context while calling this function. Even if the lock has
nothing to do with the timer in question.  Here’s why:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU0                             CPU1
----                             ----
                                 &lt;SOFTIRQ&gt;
                                   call_timer_fn();
                                   base-&gt;running_timer = mytimer;
spin_lock_irq(somelock);
                                 &lt;IRQ&gt;
                                    spin_lock(somelock);
del_timer_sync(mytimer);
while (base-&gt;running_timer == mytimer);
</pre></div>
</div>
</dd>
</dl>
<dl class="c function">
<dt id="c.schedule_timeout">
signed long <code class="sig-name descname">schedule_timeout</code><span class="sig-paren">(</span>signed long <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sleep until timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make the current task sleep until <strong>timeout</strong> jiffies have elapsed.
The function behavior depends on the current task state
(see also set_current_state() description):</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_RUNNING</span></code> - the scheduler is called, but the task does not sleep
at all. That happens because sched_submit_work() does nothing for
tasks in <code class="docutils literal notranslate"><span class="pre">TASK_RUNNING</span></code> state.</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_UNINTERRUPTIBLE</span></code> - at least <strong>timeout</strong> jiffies are guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>).</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_INTERRUPTIBLE</span></code> - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.</p>
<p>The current task state is guaranteed to be <code class="docutils literal notranslate"><span class="pre">TASK_RUNNING</span></code> when this
routine returns.</p>
<p>Specifying a <strong>timeout</strong> value of <code class="docutils literal notranslate"><span class="pre">MAX_SCHEDULE_TIMEOUT</span></code> will schedule
the CPU away without a bound on the timeout. In this case the return
value will be <code class="docutils literal notranslate"><span class="pre">MAX_SCHEDULE_TIMEOUT</span></code>.</p>
<p>Returns 0 when the timer has expired otherwise the remaining time in
jiffies will be returned. In all cases the return value is guaranteed
to be non-negative.</p>
<dl class="c function">
<dt id="c.msleep">
void <code class="sig-name descname">msleep</code><span class="sig-paren">(</span>unsigned int <em>msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.msleep" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sleep safely even with waitqueue interruptions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msecs</span></code></dt><dd><p>Time in milliseconds to sleep for</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.msleep_interruptible">
unsigned long <code class="sig-name descname">msleep_interruptible</code><span class="sig-paren">(</span>unsigned int <em>msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.msleep_interruptible" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sleep waiting for signals</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msecs</span></code></dt><dd><p>Time in milliseconds to sleep for</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.usleep_range">
void <code class="sig-name descname">usleep_range</code><span class="sig-paren">(</span>unsigned long <em>min</em>, unsigned long <em>max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usleep_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sleep for an approximate time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt><dd><p>Minimum time in usecs to sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>Maximum time in usecs to sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In non-atomic context where the exact wakeup time is flexible, use
<a class="reference internal" href="#c.usleep_range" title="usleep_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">usleep_range()</span></code></a> instead of udelay().  The sleep improves responsiveness
by avoiding the CPU-hogging busy-wait of udelay(), and the range reduces
power usage by allowing hrtimers to take advantage of an already-
scheduled interrupt instead of scheduling a new one just for this sleep.</p>
</div>
<div class="section" id="wait-queues-and-wake-events">
<h2>Wait queues and Wake events<a class="headerlink" href="#wait-queues-and-wake-events" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt id="c.waitqueue_active">
int <code class="sig-name descname">waitqueue_active</code><span class="sig-paren">(</span><em class="property">struct</em> wait_queue_head *<em>wq_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.waitqueue_active" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>locklessly test for waiters on the queue</p></li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue to test for waiters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns true if the wait list is not empty</p>
<p>Use either while holding wait_queue_head::lock or when used for wakeups
with an extra smp_mb() like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU0 - waker                    CPU1 - waiter

                                for (;;) {
@cond = true;                     prepare_to_wait(&amp;wq_head, &amp;wait, state);
smp_mb();                         // smp_mb() from set_current_state()
if (waitqueue_active(wq_head))         if (@cond)
  wake_up(wq_head);                      break;
                                  schedule();
                                }
                                finish_wait(&amp;wq_head, &amp;wait);
</pre></div>
</div>
<p>Because without the explicit smp_mb() it’s possible for the
<a class="reference internal" href="#c.waitqueue_active" title="waitqueue_active"><code class="xref c c-func docutils literal notranslate"><span class="pre">waitqueue_active()</span></code></a> load to get hoisted over the <strong>cond</strong> store such that we’ll
observe an empty wait list while the waiter might not observe <strong>cond</strong>.</p>
<p>Also note that this ‘optimization’ trades a spin_lock() for an smp_mb(),
which (when the lock is uncontended) are of roughly equal cost.</p>
<p><strong>NOTE</strong></p>
<p>this function is lockless and requires care, incorrect usage _will_
lead to sporadic and non-obvious failure.</p>
<dl class="c function">
<dt id="c.wq_has_single_sleeper">
bool <code class="sig-name descname">wq_has_single_sleeper</code><span class="sig-paren">(</span><em class="property">struct</em> wait_queue_head *<em>wq_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_has_single_sleeper" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if there is only one sleeper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>wait queue head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true of wq_head has only one sleeper on the list.</p>
<p>Please refer to the comment for waitqueue_active.</p>
<dl class="c function">
<dt id="c.wq_has_sleeper">
bool <code class="sig-name descname">wq_has_sleeper</code><span class="sig-paren">(</span><em class="property">struct</em> wait_queue_head *<em>wq_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_has_sleeper" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if there are any waiting processes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>wait queue head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if wq_head has waiting processes</p>
<p>Please refer to the comment for waitqueue_active.</p>
<dl class="c macro">
<dt id="c.wait_event">
<code class="sig-name descname">wait_event</code><a class="headerlink" href="#c.wait_event" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<dl class="c macro">
<dt id="c.wait_event_freezable">
<code class="sig-name descname">wait_event_freezable</code><a class="headerlink" href="#c.wait_event_freezable" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_freezable</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep (or freeze) until a condition gets true</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE – so as not to contribute
to system load) until the <strong>condition</strong> evaluates to true. The
<strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<dl class="c macro">
<dt id="c.wait_event_timeout">
<code class="sig-name descname">wait_event_timeout</code><a class="headerlink" href="#c.wait_event_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
<dl class="c macro">
<dt id="c.wait_event_cmd">
<code class="sig-name descname">wait_event_cmd</code><a class="headerlink" href="#c.wait_event_cmd" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_cmd</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">cmd1,</span> <span class="pre">cmd2)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd1</span></code></dt><dd><p>the command will be executed before sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd2</span></code></dt><dd><p>the command will be executed after sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<dl class="c macro">
<dt id="c.wait_event_interruptible">
<code class="sig-name descname">wait_event_interruptible</code><a class="headerlink" href="#c.wait_event_interruptible" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="c macro">
<dt id="c.wait_event_interruptible_timeout">
<code class="sig-name descname">wait_event_interruptible_timeout</code><a class="headerlink" href="#c.wait_event_interruptible_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed, or -<code class="docutils literal notranslate"><span class="pre">ERESTARTSYS</span></code> if it was
interrupted by a signal.</p>
<dl class="c macro">
<dt id="c.wait_event_hrtimeout">
<code class="sig-name descname">wait_event_hrtimeout</code><a class="headerlink" href="#c.wait_event_hrtimeout" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_hrtimeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, as a ktime_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function returns 0 if <strong>condition</strong> became true, or -ETIME if the timeout
elapsed.</p>
<dl class="c macro">
<dt id="c.wait_event_interruptible_hrtimeout">
<code class="sig-name descname">wait_event_interruptible_hrtimeout</code><a class="headerlink" href="#c.wait_event_interruptible_hrtimeout" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_hrtimeout</span> <span class="pre">(wq,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, as a ktime_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function returns 0 if <strong>condition</strong> became true, -ERESTARTSYS if it was
interrupted by a signal, or -ETIME if the timeout elapsed.</p>
<dl class="c macro">
<dt id="c.wait_event_idle">
<code class="sig-name descname">wait_event_idle</code><a class="headerlink" href="#c.wait_event_idle" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_idle</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>wait for a condition without contributing to system load</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<dl class="c macro">
<dt id="c.wait_event_idle_exclusive">
<code class="sig-name descname">wait_event_idle_exclusive</code><a class="headerlink" href="#c.wait_event_idle_exclusive" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_idle_exclusive</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>wait for a condition with contributing to system load</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus if other processes wait on the same list, when this
process is woken further processes are not considered.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<dl class="c macro">
<dt id="c.wait_event_idle_timeout">
<code class="sig-name descname">wait_event_idle_timeout</code><a class="headerlink" href="#c.wait_event_idle_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_idle_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep without load until a condition becomes true or a timeout elapses</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
<dl class="c macro">
<dt id="c.wait_event_idle_exclusive_timeout">
<code class="sig-name descname">wait_event_idle_exclusive_timeout</code><a class="headerlink" href="#c.wait_event_idle_exclusive_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_idle_exclusive_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep without load until a condition becomes true or a timeout elapses</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus if other processes wait on the same list, when this
process is woken further processes are not considered.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
<dl class="c macro">
<dt id="c.wait_event_interruptible_locked">
<code class="sig-name descname">wait_event_interruptible_locked</code><a class="headerlink" href="#c.wait_event_interruptible_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_locked</span> <span class="pre">(wq,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock()/spin_unlock()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="c macro">
<dt id="c.wait_event_interruptible_locked_irq">
<code class="sig-name descname">wait_event_interruptible_locked_irq</code><a class="headerlink" href="#c.wait_event_interruptible_locked_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_locked_irq</span> <span class="pre">(wq,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock_irq()/spin_unlock_irq()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="c macro">
<dt id="c.wait_event_interruptible_exclusive_locked">
<code class="sig-name descname">wait_event_interruptible_exclusive_locked</code><a class="headerlink" href="#c.wait_event_interruptible_exclusive_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_exclusive_locked</span> <span class="pre">(wq,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep exclusively until a condition gets true</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock()/spin_unlock()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus when other process waits process on the list if this
process is awaken further processes are not considered.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="c macro">
<dt id="c.wait_event_interruptible_exclusive_locked_irq">
<code class="sig-name descname">wait_event_interruptible_exclusive_locked_irq</code><a class="headerlink" href="#c.wait_event_interruptible_exclusive_locked_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_exclusive_locked_irq</span> <span class="pre">(wq,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock_irq()/spin_unlock_irq()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus when other process waits process on the list if this
process is awaken further processes are not considered.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="c macro">
<dt id="c.wait_event_killable">
<code class="sig-name descname">wait_event_killable</code><a class="headerlink" href="#c.wait_event_killable" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_killable</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_KILLABLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="c macro">
<dt id="c.wait_event_killable_timeout">
<code class="sig-name descname">wait_event_killable_timeout</code><a class="headerlink" href="#c.wait_event_killable_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_killable_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_KILLABLE) until the
<strong>condition</strong> evaluates to true or a kill signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>Only kill signals interrupt this process.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed, or -<code class="docutils literal notranslate"><span class="pre">ERESTARTSYS</span></code> if it was
interrupted by a kill signal.</p>
<dl class="c macro">
<dt id="c.wait_event_lock_irq_cmd">
<code class="sig-name descname">wait_event_lock_irq_cmd</code><a class="headerlink" href="#c.wait_event_lock_irq_cmd" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_lock_irq_cmd</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">lock,</span> <span class="pre">cmd)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before cmd
and schedule() and reacquired afterwards.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>a command which is invoked outside the critical section before
sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before invoking the cmd and going to sleep and is reacquired
afterwards.</p>
<dl class="c macro">
<dt id="c.wait_event_lock_irq">
<code class="sig-name descname">wait_event_lock_irq</code><a class="headerlink" href="#c.wait_event_lock_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_lock_irq</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before schedule()
and reacquired afterwards.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
<dl class="c macro">
<dt id="c.wait_event_interruptible_lock_irq_cmd">
<code class="sig-name descname">wait_event_interruptible_lock_irq_cmd</code><a class="headerlink" href="#c.wait_event_interruptible_lock_irq_cmd" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_lock_irq_cmd</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">lock,</span> <span class="pre">cmd)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before cmd and
schedule() and reacquired afterwards.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>a command which is invoked outside the critical section before
sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before invoking the cmd and going to sleep and is reacquired
afterwards.</p>
<p>The macro will return -ERESTARTSYS if it was interrupted by a signal
and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="c macro">
<dt id="c.wait_event_interruptible_lock_irq">
<code class="sig-name descname">wait_event_interruptible_lock_irq</code><a class="headerlink" href="#c.wait_event_interruptible_lock_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_lock_irq</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before schedule()
and reacquired afterwards.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
<p>The macro will return -ERESTARTSYS if it was interrupted by a signal
and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="c macro">
<dt id="c.wait_event_interruptible_lock_irq_timeout">
<code class="sig-name descname">wait_event_interruptible_lock_irq_timeout</code><a class="headerlink" href="#c.wait_event_interruptible_lock_irq_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_lock_irq_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">lock,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before schedule()
and reacquired afterwards.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
<p>The function returns 0 if the <strong>timeout</strong> elapsed, -ERESTARTSYS if it
was interrupted by a signal, and the remaining jiffies otherwise
if the condition evaluated to true before the timeout elapsed.</p>
<dl class="c function">
<dt id="c.__wake_up">
void <code class="sig-name descname">__wake_up</code><span class="sig-paren">(</span><em class="property">struct</em> wait_queue_head *<em>wq_head</em>, unsigned int <em>mode</em>, int <em>nr_exclusive</em>, void *<em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wake up threads blocked on a waitqueue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>which threads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_exclusive</span></code></dt><dd><p>how many wake-one or wake-many threads to wake up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*key</span></code></dt><dd><p>is directly passed to the wakeup function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this function wakes up a task, it executes a full memory barrier before
accessing the task state.</p>
<dl class="c function">
<dt id="c.__wake_up_sync_key">
void <code class="sig-name descname">__wake_up_sync_key</code><span class="sig-paren">(</span><em class="property">struct</em> wait_queue_head *<em>wq_head</em>, unsigned int <em>mode</em>, void *<em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up_sync_key" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wake up threads blocked on a waitqueue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>which threads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*key</span></code></dt><dd><p>opaque value to be passed to wakeup targets</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The sync wakeup differs that the waker knows that it will schedule
away soon, so while the target thread will be woken up, it will not
be migrated to another CPU - ie. the two threads are ‘synchronized’
with each other. This can prevent needless bouncing between CPUs.</p>
<p>On UP it can prevent extra preemption.</p>
<p>If this function wakes up a task, it executes a full memory barrier before
accessing the task state.</p>
<dl class="c function">
<dt id="c.__wake_up_locked_sync_key">
void <code class="sig-name descname">__wake_up_locked_sync_key</code><span class="sig-paren">(</span><em class="property">struct</em> wait_queue_head *<em>wq_head</em>, unsigned int <em>mode</em>, void *<em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up_locked_sync_key" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wake up a thread blocked on a locked waitqueue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>which threads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*key</span></code></dt><dd><p>opaque value to be passed to wakeup targets</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The sync wakeup differs in that the waker knows that it will schedule
away soon, so while the target thread will be woken up, it will not
be migrated to another CPU - ie. the two threads are ‘synchronized’
with each other. This can prevent needless bouncing between CPUs.</p>
<p>On UP it can prevent extra preemption.</p>
<p>If this function wakes up a task, it executes a full memory barrier before
accessing the task state.</p>
<dl class="c function">
<dt id="c.finish_wait">
void <code class="sig-name descname">finish_wait</code><span class="sig-paren">(</span><em class="property">struct</em> wait_queue_head *<em>wq_head</em>, <em class="property">struct</em> wait_queue_entry *<em>wq_entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.finish_wait" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clean up after waiting in a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>waitqueue waited on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_entry</span> <span class="pre">*wq_entry</span></code></dt><dd><p>wait descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets current thread back to running state and removes
the wait descriptor from the given waitqueue if still
queued.</p>
</div>
<div class="section" id="high-resolution-timers">
<h2>High-resolution timers<a class="headerlink" href="#high-resolution-timers" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt id="c.ktime_set">
ktime_t <code class="sig-name descname">ktime_set</code><span class="sig-paren">(</span><em class="property">const</em> s64 <em>secs</em>, <em class="property">const</em> unsigned long <em>nsecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a ktime_t variable from a seconds/nanoseconds value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">s64</span> <span class="pre">secs</span></code></dt><dd><p>seconds to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nsecs</span></code></dt><dd><p>nanoseconds to set</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The ktime_t representation of the value.</p>
<dl class="c function">
<dt id="c.ktime_compare">
int <code class="sig-name descname">ktime_compare</code><span class="sig-paren">(</span><em class="property">const</em> ktime_t <em>cmp1</em>, <em class="property">const</em> ktime_t <em>cmp2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_compare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compares two ktime_t variables for less, greater or equal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt><dd><p>comparable1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt><dd><p>comparable2</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>…</dt><dd><p>cmp1  &lt; cmp2: return &lt;0
cmp1 == cmp2: return 0
cmp1  &gt; cmp2: return &gt;0</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.ktime_after">
bool <code class="sig-name descname">ktime_after</code><span class="sig-paren">(</span><em class="property">const</em> ktime_t <em>cmp1</em>, <em class="property">const</em> ktime_t <em>cmp2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_after" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compare if a ktime_t value is bigger than another one.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt><dd><p>comparable1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt><dd><p>comparable2</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if cmp1 happened after cmp2.</p>
<dl class="c function">
<dt id="c.ktime_before">
bool <code class="sig-name descname">ktime_before</code><span class="sig-paren">(</span><em class="property">const</em> ktime_t <em>cmp1</em>, <em class="property">const</em> ktime_t <em>cmp2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_before" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compare if a ktime_t value is smaller than another one.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt><dd><p>comparable1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt><dd><p>comparable2</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if cmp1 happened before cmp2.</p>
<dl class="c function">
<dt id="c.ktime_to_timespec64_cond">
bool <code class="sig-name descname">ktime_to_timespec64_cond</code><span class="sig-paren">(</span><em class="property">const</em> ktime_t <em>kt</em>, <em class="property">struct</em> timespec64 *<em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_to_timespec64_cond" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a ktime_t variable to timespec64 format only if the variable contains data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">kt</span></code></dt><dd><p>the ktime_t variable to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>the timespec variable to store the result in</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if there was a successful conversion, <code class="docutils literal notranslate"><span class="pre">false</span></code> if kt was 0.</p>
<dl class="c struct">
<dt id="c.hrtimer">
<em class="property">struct </em><code class="sig-name descname">hrtimer</code><a class="headerlink" href="#c.hrtimer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>the basic hrtimer structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hrtimer {
  struct timerqueue_node          node;
  ktime_t _softexpires;
  enum hrtimer_restart            (*function)(struct hrtimer *);
  struct hrtimer_clock_base       *base;
  u8 state;
  u8 is_rel;
  u8 is_soft;
  u8 is_hard;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>timerqueue node, which also manages node.expires,
the absolute expiry time in the hrtimers internal
representation. The time is related to the clock on
which the timer is based. Is setup by adding
slack to the _softexpires value. For non range timers
identical to _softexpires.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_softexpires</span></code></dt><dd><p>the absolute earliest expiry time of the hrtimer.
The time which was given as expiry time when the timer
was armed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function</span></code></dt><dd><p>timer expiry callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>pointer to the timer base (per cpu and per clock)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>state information (See bit values above)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_rel</span></code></dt><dd><p>Set if the timer was armed relative</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_soft</span></code></dt><dd><p>Set if hrtimer will be expired in soft interrupt context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_hard</span></code></dt><dd><p>Set if hrtimer will be expired in hard interrupt context
even on RT.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The hrtimer structure must be initialized by <a class="reference internal" href="#c.hrtimer_init" title="hrtimer_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">hrtimer_init()</span></code></a></p>
<dl class="c struct">
<dt id="c.hrtimer_sleeper">
<em class="property">struct </em><code class="sig-name descname">hrtimer_sleeper</code><a class="headerlink" href="#c.hrtimer_sleeper" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>simple sleeper structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hrtimer_sleeper {
  struct hrtimer timer;
  struct task_struct *task;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">timer</span></code></dt><dd><p>embedded timer structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task</span></code></dt><dd><p>task to wake up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>task is set to NULL, when the timer expires.</p>
<dl class="c struct">
<dt id="c.hrtimer_clock_base">
<em class="property">struct </em><code class="sig-name descname">hrtimer_clock_base</code><a class="headerlink" href="#c.hrtimer_clock_base" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>the timer base for a specific clock</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hrtimer_clock_base {
  struct hrtimer_cpu_base *cpu_base;
  unsigned int            index;
  clockid_t clockid;
  seqcount_raw_spinlock_t seq;
  struct hrtimer          *running;
  struct timerqueue_head  active;
  ktime_t (*get_time)(void);
  ktime_t offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cpu_base</span></code></dt><dd><p>per cpu clock base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>clock type index for per_cpu support when moving a
timer to a base on another cpu.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid</span></code></dt><dd><p>clock id for per_cpu support</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seq</span></code></dt><dd><p>seqcount around __run_hrtimer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">running</span></code></dt><dd><p>pointer to the currently running hrtimer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active</span></code></dt><dd><p>red black tree root node for the active timers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_time</span></code></dt><dd><p>function to retrieve the current time of the clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>offset of this clock to the monotonic base</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.hrtimer_cpu_base">
<em class="property">struct </em><code class="sig-name descname">hrtimer_cpu_base</code><a class="headerlink" href="#c.hrtimer_cpu_base" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>the per cpu clock bases</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hrtimer_cpu_base {
  raw_spinlock_t lock;
  unsigned int                    cpu;
  unsigned int                    active_bases;
  unsigned int                    clock_was_set_seq;
  unsigned int                    hres_active             : 1,in_hrtirq               : 1,hang_detected           : 1, softirq_activated       : 1;
#ifdef CONFIG_HIGH_RES_TIMERS;
  unsigned int                    nr_events;
  unsigned short                  nr_retries;
  unsigned short                  nr_hangs;
  unsigned int                    max_hang_time;
#endif;
#ifdef CONFIG_PREEMPT_RT;
  spinlock_t softirq_expiry_lock;
  atomic_t timer_waiters;
#endif;
  ktime_t expires_next;
  struct hrtimer                  *next_timer;
  ktime_t softirq_expires_next;
  struct hrtimer                  *softirq_next_timer;
  struct hrtimer_clock_base       clock_base[HRTIMER_MAX_CLOCK_BASES];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>lock protecting the base and associated clock bases
and timers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu</span></code></dt><dd><p>cpu number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_bases</span></code></dt><dd><p>Bitfield to mark bases with active timers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clock_was_set_seq</span></code></dt><dd><p>Sequence counter of clock was set events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hres_active</span></code></dt><dd><p>State of high resolution mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in_hrtirq</span></code></dt><dd><p>hrtimer_interrupt() is currently executing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hang_detected</span></code></dt><dd><p>The last hrtimer interrupt detected a hang</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">softirq_activated</span></code></dt><dd><p>displays, if the softirq is raised - update of softirq
related settings is not required then.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_events</span></code></dt><dd><p>Total number of hrtimer interrupt events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_retries</span></code></dt><dd><p>Total number of hrtimer interrupt retries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_hangs</span></code></dt><dd><p>Total number of hrtimer interrupt hangs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_hang_time</span></code></dt><dd><p>Maximum time spent in hrtimer_interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">softirq_expiry_lock</span></code></dt><dd><p>Lock which is taken while softirq based hrtimer are
expired</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer_waiters</span></code></dt><dd><p>A <a class="reference internal" href="#c.hrtimer_cancel" title="hrtimer_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">hrtimer_cancel()</span></code></a> invocation waits for the timer
callback to finish.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">expires_next</span></code></dt><dd><p>absolute time of the next event, is required for remote
hrtimer enqueue; it is the total first expiry time (hard
and soft hrtimer are taken into account)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next_timer</span></code></dt><dd><p>Pointer to the first expiring timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">softirq_expires_next</span></code></dt><dd><p>Time to check, if soft queues needs also to be expired</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">softirq_next_timer</span></code></dt><dd><p>Pointer to the first expiring softirq based timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clock_base</span></code></dt><dd><p>array of clock bases for this cpu</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>next_timer is just an optimization for __remove_hrtimer().</dt><dd><p>Do not dereference the pointer because it is not reliable on
cross cpu removals.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.hrtimer_start">
void <code class="sig-name descname">hrtimer_start</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>timer</em>, ktime_t <em>tim</em>, <em class="property">const</em> <em class="property">enum</em> hrtimer_mode <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_start" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>(re)start an hrtimer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">tim</span></code></dt><dd><p>expiry time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode: absolute (HRTIMER_MODE_ABS) or
relative (HRTIMER_MODE_REL), and pinned (HRTIMER_MODE_PINNED);
softirq based mode is considered for debug purpose only!</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.hrtimer_is_queued">
bool <code class="sig-name descname">hrtimer_is_queued</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_is_queued" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>Timer to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the timer is queued, false otherwise</p>
<p><strong>Description</strong></p>
<p>The function can be used lockless, but it gives only a current snapshot.</p>
<dl class="c function">
<dt id="c.hrtimer_forward_now">
u64 <code class="sig-name descname">hrtimer_forward_now</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>timer</em>, ktime_t <em>interval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_forward_now" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>forward the timer expiry so it expires after now</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>hrtimer to forward</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">interval</span></code></dt><dd><p>the interval to forward</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forward the timer expiry so it will expire after the current time
of the hrtimer clock base. Returns the number of overruns.</p>
<p>Can be safely called from the callback function of <strong>timer</strong>. If
called from other contexts <strong>timer</strong> must neither be enqueued nor
running the callback and the caller needs to take care of
serialization.</p>
<p><strong>Note</strong></p>
<p>This only updates the timer expiry value and does not requeue
the timer.</p>
<dl class="c function">
<dt id="c.hrtimer_forward">
u64 <code class="sig-name descname">hrtimer_forward</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>timer</em>, ktime_t <em>now</em>, ktime_t <em>interval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_forward" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>forward the timer expiry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>hrtimer to forward</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">now</span></code></dt><dd><p>forward past this time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">interval</span></code></dt><dd><p>the interval to forward</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forward the timer expiry so it will expire in the future.
Returns the number of overruns.</p>
<p>Can be safely called from the callback function of <strong>timer</strong>. If
called from other contexts <strong>timer</strong> must neither be enqueued nor
running the callback and the caller needs to take care of
serialization.</p>
<p><strong>Note</strong></p>
<p>This only updates the timer expiry value and does not requeue
the timer.</p>
<dl class="c function">
<dt id="c.hrtimer_start_range_ns">
void <code class="sig-name descname">hrtimer_start_range_ns</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>timer</em>, ktime_t <em>tim</em>, u64 <em>delta_ns</em>, <em class="property">const</em> <em class="property">enum</em> hrtimer_mode <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_start_range_ns" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>(re)start an hrtimer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">tim</span></code></dt><dd><p>expiry time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">delta_ns</span></code></dt><dd><p>“slack” range for the timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode: absolute (HRTIMER_MODE_ABS) or
relative (HRTIMER_MODE_REL), and pinned (HRTIMER_MODE_PINNED);
softirq based mode is considered for debug purpose only!</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.hrtimer_try_to_cancel">
int <code class="sig-name descname">hrtimer_try_to_cancel</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_try_to_cancel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>try to deactivate a timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>hrtimer to stop</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 when the timer was not active</p></li>
<li><p>1 when the timer was active</p></li>
<li><p>-1 when the timer is currently executing the callback function and
cannot be stopped</p></li>
</ul>
</div></blockquote>
<dl class="c function">
<dt id="c.hrtimer_cancel">
int <code class="sig-name descname">hrtimer_cancel</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_cancel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cancel a timer and wait for the handler to finish.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be cancelled</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 when the timer was not active
1 when the timer was active</p>
</div></blockquote>
<dl class="c function">
<dt id="c.__hrtimer_get_remaining">
ktime_t <code class="sig-name descname">__hrtimer_get_remaining</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>timer</em>, bool <em>adjust</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__hrtimer_get_remaining" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get remaining time for the timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">adjust</span></code></dt><dd><p>adjust relative timers when CONFIG_TIME_LOW_RES=y</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.hrtimer_init">
void <code class="sig-name descname">hrtimer_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>timer</em>, clockid_t <em>clock_id</em>, <em class="property">enum</em> hrtimer_mode <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a timer to the given clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid_t</span> <span class="pre">clock_id</span></code></dt><dd><p>the clock to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>The modes which are relevant for intitialization:
HRTIMER_MODE_ABS, HRTIMER_MODE_REL, HRTIMER_MODE_ABS_SOFT,
HRTIMER_MODE_REL_SOFT</p>
<p>The PINNED variants of the above can be handed in,
but the PINNED bit is ignored as pinning happens
when the hrtimer is started</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.hrtimer_sleeper_start_expires">
void <code class="sig-name descname">hrtimer_sleeper_start_expires</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a> *<em>sl</em>, <em class="property">enum</em> hrtimer_mode <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_sleeper_start_expires" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start a hrtimer sleeper timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*sl</span></code></dt><dd><p>sleeper to be started</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode abs/rel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper around hrtimer_start_expires() for hrtimer_sleeper based timers
to allow PREEMPT_RT to tweak the delivery mode (soft/hardirq context)</p>
<dl class="c function">
<dt id="c.hrtimer_init_sleeper">
void <code class="sig-name descname">hrtimer_init_sleeper</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a> *<em>sl</em>, clockid_t <em>clock_id</em>, <em class="property">enum</em> hrtimer_mode <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_init_sleeper" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize sleeper to the given clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*sl</span></code></dt><dd><p>sleeper to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid_t</span> <span class="pre">clock_id</span></code></dt><dd><p>the clock to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode abs/rel</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.schedule_hrtimeout_range">
int <code class="sig-name descname">schedule_hrtimeout_range</code><span class="sig-paren">(</span>ktime_t *<em>expires</em>, u64 <em>delta</em>, <em class="property">const</em> <em class="property">enum</em> hrtimer_mode <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_hrtimeout_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sleep until timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*expires</span></code></dt><dd><p>timeout value (ktime_t)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">delta</span></code></dt><dd><p>slack in expires timeout (ktime_t)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make the current task sleep until the given expiry time has
elapsed. The routine will return immediately unless
the current task state has been set (see set_current_state()).</p>
<p>The <strong>delta</strong> argument gives the kernel the freedom to schedule the
actual wakeup to a time that is both power and performance friendly.
The kernel give the normal best effort behavior for “<strong>expires**+**delta</strong>”,
but may decide to fire the timer earlier, but no earlier than <strong>expires</strong>.</p>
<p>You can set the task state as follows -</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_UNINTERRUPTIBLE</span></code> - at least <strong>timeout</strong> time is guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>).</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_INTERRUPTIBLE</span></code> - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.</p>
<p>The current task state is guaranteed to be TASK_RUNNING when this
routine returns.</p>
<p>Returns 0 when the timer has expired. If the task was woken before the
timer expired by a signal (only possible in state TASK_INTERRUPTIBLE) or
by an explicit wakeup, it returns -EINTR.</p>
<dl class="c function">
<dt id="c.schedule_hrtimeout">
int <code class="sig-name descname">schedule_hrtimeout</code><span class="sig-paren">(</span>ktime_t *<em>expires</em>, <em class="property">const</em> <em class="property">enum</em> hrtimer_mode <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_hrtimeout" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sleep until timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*expires</span></code></dt><dd><p>timeout value (ktime_t)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make the current task sleep until the given expiry time has
elapsed. The routine will return immediately unless
the current task state has been set (see set_current_state()).</p>
<p>You can set the task state as follows -</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_UNINTERRUPTIBLE</span></code> - at least <strong>timeout</strong> time is guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>).</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_INTERRUPTIBLE</span></code> - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.</p>
<p>The current task state is guaranteed to be TASK_RUNNING when this
routine returns.</p>
<p>Returns 0 when the timer has expired. If the task was woken before the
timer expired by a signal (only possible in state TASK_INTERRUPTIBLE) or
by an explicit wakeup, it returns -EINTR.</p>
</div>
<div class="section" id="internal-functions">
<h2>Internal Functions<a class="headerlink" href="#internal-functions" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt id="c.wait_task_stopped">
int <code class="sig-name descname">wait_task_stopped</code><span class="sig-paren">(</span><em class="property">struct</em> wait_opts *<em>wo</em>, int <em>ptrace</em>, <em class="property">struct</em> task_struct *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_task_stopped" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for <code class="docutils literal notranslate"><span class="pre">TASK_STOPPED</span></code> or <code class="docutils literal notranslate"><span class="pre">TASK_TRACED</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_opts</span> <span class="pre">*wo</span></code></dt><dd><p>wait options</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ptrace</span></code></dt><dd><p>is the wait for ptrace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle sys_wait4() work for <code class="docutils literal notranslate"><span class="pre">p</span></code> in state <code class="docutils literal notranslate"><span class="pre">TASK_STOPPED</span></code> or <code class="docutils literal notranslate"><span class="pre">TASK_TRACED</span></code>.</p>
<p><strong>Context</strong></p>
<p>read_lock(<code class="xref c c-type docutils literal notranslate"><span class="pre">tasklist_lock</span></code>), which is released if return value is
non-zero.  Also, grabs and releases <strong>p-&gt;sighand-&gt;siglock</strong>.</p>
<p><strong>Return</strong></p>
<p>0 if wait condition didn’t exist and search for other wait conditions
should continue.  Non-zero return, -errno on failure and <strong>p</strong>’s pid on
success, implies that tasklist_lock is released and wait condition
search should terminate.</p>
<dl class="c function">
<dt id="c.task_set_jobctl_pending">
bool <code class="sig-name descname">task_set_jobctl_pending</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>task</em>, unsigned long <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_set_jobctl_pending" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set jobctl pending bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>pending bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear <strong>mask</strong> from <strong>task-&gt;jobctl</strong>.  <strong>mask</strong> must be subset of
<code class="docutils literal notranslate"><span class="pre">JOBCTL_PENDING_MASK</span></code> | <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_CONSUME</span></code> | <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_SIGMASK</span></code> |
<code class="docutils literal notranslate"><span class="pre">JOBCTL_TRAPPING</span></code>.  If stop signo is being set, the existing signo is
cleared.  If <strong>task</strong> is already being killed or exiting, this function
becomes noop.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>mask</strong> is set, <code class="docutils literal notranslate"><span class="pre">false</span></code> if made noop because <strong>task</strong> was dying.</p>
<dl class="c function">
<dt id="c.task_clear_jobctl_trapping">
void <code class="sig-name descname">task_clear_jobctl_trapping</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_clear_jobctl_trapping" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clear jobctl trapping bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>target task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If JOBCTL_TRAPPING is set, a ptracer is waiting for us to enter TRACED.
Clear it and wake up the ptracer.  Note that we don’t need any further
locking.  <strong>task-&gt;siglock</strong> guarantees that <strong>task-&gt;parent</strong> points to the
ptracer.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
<dl class="c function">
<dt id="c.task_clear_jobctl_pending">
void <code class="sig-name descname">task_clear_jobctl_pending</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>task</em>, unsigned long <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_clear_jobctl_pending" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clear jobctl pending bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>pending bits to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear <strong>mask</strong> from <strong>task-&gt;jobctl</strong>.  <strong>mask</strong> must be subset of
<code class="docutils literal notranslate"><span class="pre">JOBCTL_PENDING_MASK</span></code>.  If <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_PENDING</span></code> is being cleared, other
STOP bits are cleared together.</p>
<p>If clearing of <strong>mask</strong> leaves no stop or trap pending, this function calls
<a class="reference internal" href="#c.task_clear_jobctl_trapping" title="task_clear_jobctl_trapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">task_clear_jobctl_trapping()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
<dl class="c function">
<dt id="c.task_participate_group_stop">
bool <code class="sig-name descname">task_participate_group_stop</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_participate_group_stop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>participate in a group stop</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>task participating in a group stop</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>task</strong> has <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_PENDING</span></code> set and is participating in a group stop.
Group stop states are cleared and the group stop count is consumed if
<code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_CONSUME</span></code> was set.  If the consumption completes the group
stop, the appropriate <cite>SIGNAL_*</cite> flags are set.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if group stop completion should be notified to the parent, <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise.</p>
<dl class="c function">
<dt id="c.ptrace_trap_notify">
void <code class="sig-name descname">ptrace_trap_notify</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ptrace_trap_notify" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>schedule trap to notify ptracer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*t</span></code></dt><dd><p>tracee wanting to notify tracer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function schedules sticky ptrace trap which is cleared on the next
TRAP_STOP to notify ptracer of an event.  <strong>t</strong> must have been seized by
ptracer.</p>
<p>If <strong>t</strong> is running, STOP trap will be taken.  If trapped for STOP and
ptracer is listening for events, tracee is woken up so that it can
re-trap for the new event.  If trapped otherwise, STOP trap will be
eventually taken without returning to userland after the existing traps
are finished by PTRACE_CONT.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
<dl class="c function">
<dt id="c.do_notify_parent_cldstop">
void <code class="sig-name descname">do_notify_parent_cldstop</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>tsk</em>, bool <em>for_ptracer</em>, int <em>why</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_notify_parent_cldstop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>notify parent of stopped/continued state change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>task reporting the state change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">for_ptracer</span></code></dt><dd><p>the notification is for ptracer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">why</span></code></dt><dd><p>CLD_{CONTINUED|STOPPED|TRAPPED} to report</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notify <strong>tsk</strong>’s parent that the stopped/continued state has changed.  If
<strong>for_ptracer</strong> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, <strong>tsk</strong>’s group leader notifies to its real parent.
If <code class="docutils literal notranslate"><span class="pre">true</span></code>, <strong>tsk</strong> reports to <strong>tsk-&gt;parent</strong> which should be the ptracer.</p>
<p><strong>Context</strong></p>
<p>Must be called with tasklist_lock at least read locked.</p>
<dl class="c function">
<dt id="c.do_signal_stop">
bool <code class="sig-name descname">do_signal_stop</code><span class="sig-paren">(</span>int <em>signr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_signal_stop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle group stop for SIGSTOP and other stop signals</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">signr</span></code></dt><dd><p>signr causing group stop if initiating</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_PENDING</span></code> is not set yet, initiate group stop with <strong>signr</strong>
and participate in it.  If already set, participate in the existing
group stop.  If participated in a group stop (and thus slept), <code class="docutils literal notranslate"><span class="pre">true</span></code> is
returned with siglock released.</p>
<p>If ptraced, this function doesn’t handle stop itself.  Instead,
<code class="docutils literal notranslate"><span class="pre">JOBCTL_TRAP_STOP</span></code> is scheduled and <code class="docutils literal notranslate"><span class="pre">false</span></code> is returned with siglock
untouched.  The caller must ensure that INTERRUPT trap handling takes
places afterwards.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current-&gt;sighand-&gt;siglock</strong> held, which is released
on <code class="docutils literal notranslate"><span class="pre">true</span></code> return.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if group stop is already cancelled or ptrace trap is scheduled.
<code class="docutils literal notranslate"><span class="pre">true</span></code> if participated in group stop.</p>
<dl class="c function">
<dt id="c.do_jobctl_trap">
void <code class="sig-name descname">do_jobctl_trap</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.do_jobctl_trap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>take care of ptrace jobctl traps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When PT_SEIZED, it’s used for both group stop and explicit
SEIZE/INTERRUPT traps.  Both generate PTRACE_EVENT_STOP trap with
accompanying siginfo.  If stopped, lower eight bits of exit_code contain
the stop signal; otherwise, <code class="docutils literal notranslate"><span class="pre">SIGTRAP</span></code>.</p>
<p>When !PT_SEIZED, it’s used only for group stop trap with stop signal
number as exit_code and no siginfo.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current-&gt;sighand-&gt;siglock</strong> held, which may be
released and re-acquired before returning with intervening sleep.</p>
<dl class="c function">
<dt id="c.do_freezer_trap">
void <code class="sig-name descname">do_freezer_trap</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.do_freezer_trap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle the freezer jobctl trap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Puts the task into frozen state, if only the task is not about to quit.
In this case it drops JOBCTL_TRAP_FREEZE.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current-&gt;sighand-&gt;siglock</strong> held,
which is always released before returning.</p>
<dl class="c function">
<dt id="c.signal_delivered">
void <code class="sig-name descname">signal_delivered</code><span class="sig-paren">(</span><em class="property">struct</em> ksignal *<em>ksig</em>, int <em>stepping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.signal_delivered" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ksignal</span> <span class="pre">*ksig</span></code></dt><dd><p>kernel signal struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stepping</span></code></dt><dd><p>nonzero if debugger single-step or block-step in use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called when a signal has successfully been
delivered. It updates the blocked signals accordingly (<strong>ksig-&gt;ka.sa.sa_mask</strong>
is always blocked, and the signal itself is blocked unless <code class="docutils literal notranslate"><span class="pre">SA_NODEFER</span></code>
is set in <strong>ksig-&gt;ka.sa.sa_flags</strong>.  Tracing is notified.</p>
<dl class="c function">
<dt id="c.sys_restart_syscall">
long <code class="sig-name descname">sys_restart_syscall</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.sys_restart_syscall" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>restart a system call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.set_current_blocked">
void <code class="sig-name descname">set_current_blocked</code><span class="sig-paren">(</span>sigset_t *<em>newset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_current_blocked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>change current-&gt;blocked mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">*newset</span></code></dt><dd><p>new mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is wrong to change -&gt;blocked directly, this helper should be used
to ensure the process can’t miss a shared signal we are going to block.</p>
<dl class="c function">
<dt id="c.sys_rt_sigprocmask">
long <code class="sig-name descname">sys_rt_sigprocmask</code><span class="sig-paren">(</span>int <em>how</em>, sigset_t __user *<em>nset</em>, sigset_t __user *<em>oset</em>, size_t <em>sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigprocmask" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>change the list of currently blocked signals</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">how</span></code></dt><dd><p>whether to add, remove, or set signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">nset</span></code></dt><dd><p>stores pending signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oset</span></code></dt><dd><p>previous value of signal mask if non-null</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.sys_rt_sigpending">
long <code class="sig-name descname">sys_rt_sigpending</code><span class="sig-paren">(</span>sigset_t __user *<em>uset</em>, size_t <em>sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigpending" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>examine a pending signal that has been raised while blocked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uset</span></code></dt><dd><p>stores pending signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type or larger</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.copy_siginfo_to_external32">
void <code class="sig-name descname">copy_siginfo_to_external32</code><span class="sig-paren">(</span><em class="property">struct</em> compat_siginfo *<em>to</em>, <em class="property">const</em> <em class="property">struct</em> kernel_siginfo *<em>from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_siginfo_to_external32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy a kernel siginfo into a compat user siginfo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">compat_siginfo</span> <span class="pre">*to</span></code></dt><dd><p>compat siginfo destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kernel_siginfo</span> <span class="pre">*from</span></code></dt><dd><p>kernel siginfo source</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function does not work properly for the SIGCHLD on x32, but
fortunately it doesn’t have to.  The only valid callers for this function are
copy_siginfo_to_user32, which is overriden for x32 and the coredump code.
The latter does not care because SIGCHLD will never cause a coredump.</p>
<dl class="c function">
<dt id="c.do_sigtimedwait">
int <code class="sig-name descname">do_sigtimedwait</code><span class="sig-paren">(</span><em class="property">const</em> sigset_t *<em>which</em>, kernel_siginfo_t *<em>info</em>, <em class="property">const</em> <em class="property">struct</em> timespec64 *<em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_sigtimedwait" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for queued signals specified in <strong>which</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">sigset_t</span> <span class="pre">*which</span></code></dt><dd><p>queued signals to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_siginfo_t</span> <span class="pre">*info</span></code></dt><dd><p>if non-null, the signal’s siginfo is returned here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>upper bound on process time suspension</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.sys_rt_sigtimedwait">
long <code class="sig-name descname">sys_rt_sigtimedwait</code><span class="sig-paren">(</span><em class="property">const</em> sigset_t __user *<em>uthese</em>, siginfo_t __user *<em>uinfo</em>, <em class="property">const</em> <em class="property">struct</em> __kernel_timespec __user *<em>uts</em>, size_t <em>sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigtimedwait" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>synchronously wait for queued signals specified in <strong>uthese</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uthese</span></code></dt><dd><p>queued signals to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt><dd><p>if non-null, the signal’s siginfo is returned here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">__kernel_timespec</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uts</span></code></dt><dd><p>upper bound on process time suspension</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.sys_kill">
long <code class="sig-name descname">sys_kill</code><span class="sig-paren">(</span>pid_t <em>pid</em>, int <em>sig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_kill" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>send a signal to a process</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.sys_pidfd_send_signal">
long <code class="sig-name descname">sys_pidfd_send_signal</code><span class="sig-paren">(</span>int <em>pidfd</em>, int <em>sig</em>, siginfo_t __user *<em>info</em>, unsigned int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_pidfd_send_signal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Signal a process through a pidfd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pidfd</span></code></dt><dd><p>file descriptor of the process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>signal info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>future flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The syscall currently only signals via PIDTYPE_PID which covers
kill(&lt;positive-pid&gt;, &lt;signal&gt;. It does not signal threads or process
groups.
In order to extend the syscall to threads and process groups the <strong>flags</strong>
argument should be used. In essence, the <strong>flags</strong> argument will determine
what is signaled and not the file descriptor itself. Put in other words,
grouping is a property of the flags argument not a property of the file
descriptor.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative errno on failure</p>
<dl class="c function">
<dt id="c.sys_tgkill">
long <code class="sig-name descname">sys_tgkill</code><span class="sig-paren">(</span>pid_t <em>tgid</em>, pid_t <em>pid</em>, int <em>sig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_tgkill" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>send signal to one specific thread</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">tgid</span></code></dt><dd><p>the thread group ID of the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
<p>This syscall also checks the <strong>tgid</strong> and returns -ESRCH even if the PID
exists but it’s not belonging to the target process anymore. This
method solves the problem of threads exiting and PIDs getting reused.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.sys_tkill">
long <code class="sig-name descname">sys_tkill</code><span class="sig-paren">(</span>pid_t <em>pid</em>, int <em>sig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_tkill" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>send signal to one specific task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
<p>Send a signal to only one task, even if it’s a CLONE_THREAD task.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.sys_rt_sigqueueinfo">
long <code class="sig-name descname">sys_rt_sigqueueinfo</code><span class="sig-paren">(</span>pid_t <em>pid</em>, int <em>sig</em>, siginfo_t __user *<em>uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigqueueinfo" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>send signal information to a signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt><dd><p>signal info to be sent</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.sys_sigpending">
long <code class="sig-name descname">sys_sigpending</code><span class="sig-paren">(</span>old_sigset_t __user *<em>uset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_sigpending" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>examine pending signals</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uset</span></code></dt><dd><p>where mask of pending signal is returned</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.sys_sigprocmask">
long <code class="sig-name descname">sys_sigprocmask</code><span class="sig-paren">(</span>int <em>how</em>, old_sigset_t __user *<em>nset</em>, old_sigset_t __user *<em>oset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_sigprocmask" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>examine and change blocked signals</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">how</span></code></dt><dd><p>whether to add, remove, or set signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">nset</span></code></dt><dd><p>signals to add or remove (if non-null)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oset</span></code></dt><dd><p>previous value of signal mask if non-null</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some platforms have their own version with special arguments;
others support only sys_rt_sigprocmask.</p>
<dl class="c function">
<dt id="c.sys_rt_sigaction">
long <code class="sig-name descname">sys_rt_sigaction</code><span class="sig-paren">(</span>int <em>sig</em>, <em class="property">const</em> <em class="property">struct</em> sigaction __user *<em>act</em>, <em class="property">struct</em> sigaction __user *<em>oact</em>, size_t <em>sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigaction" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>alter an action taken by a process</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sigaction</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">act</span></code></dt><dd><p>new sigaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sigaction</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oact</span></code></dt><dd><p>used to save the previous sigaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.sys_rt_sigsuspend">
long <code class="sig-name descname">sys_rt_sigsuspend</code><span class="sig-paren">(</span>sigset_t __user *<em>unewset</em>, size_t <em>sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigsuspend" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>replace the signal mask for a value with the <strong>unewset</strong> value until a signal is received</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">unewset</span></code></dt><dd><p>new signal mask value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.kthread_create">
<code class="sig-name descname">kthread_create</code><a class="headerlink" href="#c.kthread_create" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kthread_create</span> <span class="pre">(threadfn,</span> <span class="pre">data,</span> <span class="pre">namefmt,</span> <span class="pre">arg...)</span></code></p>
<blockquote>
<div><p>create a kthread on the current node</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">threadfn</span></code></dt><dd><p>the function to run in the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>data pointer for <strong>threadfn()</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">namefmt</span></code></dt><dd><p>printf-style format string for the thread name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">arg...</span></code></dt><dd><p>arguments for <strong>namefmt</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro will create a kthread on the current node, leaving it in
the stopped state.  This is just a helper for <a class="reference internal" href="#c.kthread_create_on_node" title="kthread_create_on_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create_on_node()</span></code></a>;
see the documentation there for more details.</p>
<dl class="c macro">
<dt id="c.kthread_run">
<code class="sig-name descname">kthread_run</code><a class="headerlink" href="#c.kthread_run" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kthread_run</span> <span class="pre">(threadfn,</span> <span class="pre">data,</span> <span class="pre">namefmt,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>create and wake a thread.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">threadfn</span></code></dt><dd><p>the function to run until signal_pending(current).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>data ptr for <strong>threadfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">namefmt</span></code></dt><dd><p>printf-style name for the thread.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convenient wrapper for <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a> followed by
<a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>.  Returns the kthread or ERR_PTR(-ENOMEM).</p>
<dl class="c function">
<dt id="c.kthread_should_stop">
bool <code class="sig-name descname">kthread_should_stop</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_should_stop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>should this kthread return now?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When someone calls <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a> on your kthread, it will be woken
and this will return true.  You should then return, and your return
value will be passed through to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
<dl class="c function">
<dt id="c.kthread_should_park">
bool <code class="sig-name descname">kthread_should_park</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_should_park" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>should this kthread park now?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When someone calls <a class="reference internal" href="#c.kthread_park" title="kthread_park"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_park()</span></code></a> on your kthread, it will be woken
and this will return true.  You should then do the necessary
cleanup and call kthread_parkme()</p>
<p>Similar to <a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a>, but this keeps the thread alive
and in a park position. <a class="reference internal" href="#c.kthread_unpark" title="kthread_unpark"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_unpark()</span></code></a> “restarts” the thread and
calls the thread function again.</p>
<dl class="c function">
<dt id="c.kthread_freezable_should_stop">
bool <code class="sig-name descname">kthread_freezable_should_stop</code><span class="sig-paren">(</span>bool *<em>was_frozen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_freezable_should_stop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>should this freezable kthread return now?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*was_frozen</span></code></dt><dd><p>optional out parameter, indicates whether <code class="docutils literal notranslate"><span class="pre">current</span></code> was frozen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a> for freezable kthreads, which will enter
refrigerator if necessary.  This function is safe from <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a> /
freezer deadlock and freezable kthreads should use this function instead
of calling try_to_freeze() directly.</p>
<dl class="c function">
<dt id="c.kthread_func">
void *<code class="sig-name descname">kthread_func</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_func" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the function specified on kthread creation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>kthread task in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the task is not a kthread.</p>
<dl class="c function">
<dt id="c.kthread_data">
void *<code class="sig-name descname">kthread_data</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_data" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return data value specified on kthread creation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>kthread task in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the data value specified when kthread <strong>task</strong> was created.
The caller is responsible for ensuring the validity of <strong>task</strong> when
calling this function.</p>
<dl class="c function">
<dt id="c.kthread_create_on_node">
<em class="property">struct</em> task_struct *<code class="sig-name descname">kthread_create_on_node</code><span class="sig-paren">(</span>int (*<em>threadfn</em>)<span class="sig-paren">(</span>void *data<span class="sig-paren">)</span>, void *<em>data</em>, int <em>node</em>, <em class="property">const</em> char <em>namefmt</em>[], ..., <span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_on_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a kthread.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*threadfn)(void</span> <span class="pre">*data)</span></code></dt><dd><p>the function to run until signal_pending(current).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data ptr for <strong>threadfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>task and thread structures for the thread are allocated on this node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt[]</span></code></dt><dd><p>printf-style name for the thread.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function creates and names a kernel
thread.  The thread will be stopped: use <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a> to start
it.  See also <a class="reference internal" href="#c.kthread_run" title="kthread_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_run()</span></code></a>.  The new thread has SCHED_NORMAL policy and
is affine to all CPUs.</p>
<p>If thread is going to be bound on a particular cpu, give its node
in <strong>node</strong>, to get NUMA affinity for kthread stack, or else give NUMA_NO_NODE.
When woken, the thread will run <strong>threadfn()</strong> with <strong>data</strong> as its
argument. <strong>threadfn()</strong> can either call do_exit() directly if it is a
standalone thread for which no one will call <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>, or
return when ‘<a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a>’ is true (which means
<a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a> has been called).  The return value should be zero
or a negative error number; it will be passed to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
<p>Returns a task_struct or ERR_PTR(-ENOMEM) or ERR_PTR(-EINTR).</p>
<dl class="c function">
<dt id="c.kthread_bind">
void <code class="sig-name descname">kthread_bind</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>p</em>, unsigned int <em>cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_bind" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>bind a just-created kthread to a cpu.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>cpu (might not be online, must be possible) for <strong>k</strong> to run on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is equivalent to set_cpus_allowed(),
except that <strong>cpu</strong> doesn’t need to be online, and the thread must be
stopped (i.e., just returned from <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>).</p>
<dl class="c function">
<dt id="c.kthread_unpark">
void <code class="sig-name descname">kthread_unpark</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_unpark" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unpark a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*k</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_park" title="kthread_should_park"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_park()</span></code></a> for <strong>k</strong> to return false, wakes it, and
waits for it to return. If the thread is marked percpu then its
bound to the cpu again.</p>
<dl class="c function">
<dt id="c.kthread_park">
int <code class="sig-name descname">kthread_park</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_park" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>park a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*k</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_park" title="kthread_should_park"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_park()</span></code></a> for <strong>k</strong> to return true, wakes it, and
waits for it to return. This can also be called after <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>
instead of calling <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>: the thread will park without
calling threadfn().</p>
<p>Returns 0 if the thread is parked, -ENOSYS if the thread exited.
If called by the kthread itself just the park bit is set.</p>
<dl class="c function">
<dt id="c.kthread_stop">
int <code class="sig-name descname">kthread_stop</code><span class="sig-paren">(</span><em class="property">struct</em> task_struct *<em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_stop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>stop a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*k</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a> for <strong>k</strong> to return true, wakes it, and
waits for it to exit. This can also be called after <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>
instead of calling <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>: the thread will exit without
calling threadfn().</p>
<p>If threadfn() may call do_exit() itself, the caller must ensure
task_struct can’t go away.</p>
<p>Returns the result of threadfn(), or <code class="docutils literal notranslate"><span class="pre">-EINTR</span></code> if <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>
was never called.</p>
<dl class="c function">
<dt id="c.kthread_worker_fn">
int <code class="sig-name descname">kthread_worker_fn</code><span class="sig-paren">(</span>void *<em>worker_ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_worker_fn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>kthread function to process kthread_worker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*worker_ptr</span></code></dt><dd><p>pointer to initialized kthread_worker</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements the main cycle of kthread worker. It processes
work_list until it is stopped with <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>. It sleeps when the queue
is empty.</p>
<p>The works are not allowed to keep any locks, disable preemption or interrupts
when they finish. There is defined a safe point for freezing when one work
finishes and before a new one is started.</p>
<p>Also the works must not be handled by more than one worker at the same time,
see also <a class="reference internal" href="#c.kthread_queue_work" title="kthread_queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_queue_work()</span></code></a>.</p>
<dl class="c function">
<dt id="c.kthread_create_worker">
<em class="property">struct</em> kthread_worker *<code class="sig-name descname">kthread_create_worker</code><span class="sig-paren">(</span>unsigned int <em>flags</em>, <em class="property">const</em> char <em>namefmt</em>[], ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_worker" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a kthread worker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags modifying the default behavior of the worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt[]</span></code></dt><dd><p>printf-style name for the kthread worker (task).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the allocated worker on success, ERR_PTR(-ENOMEM)
when the needed structures could not get allocated, and ERR_PTR(-EINTR)
when the worker was SIGKILLed.</p>
<dl class="c function">
<dt id="c.kthread_create_worker_on_cpu">
<em class="property">struct</em> kthread_worker *<code class="sig-name descname">kthread_create_worker_on_cpu</code><span class="sig-paren">(</span>int <em>cpu</em>, unsigned int <em>flags</em>, <em class="property">const</em> char <em>namefmt</em>[], ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_worker_on_cpu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a kthread worker and bind it to a given CPU and the associated NUMA node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>CPU number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags modifying the default behavior of the worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt[]</span></code></dt><dd><p>printf-style name for the kthread worker (task).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use a valid CPU number if you want to bind the kthread worker
to the given CPU and the associated NUMA node.</p>
<p>A good practice is to add the cpu number also into the worker name.
For example, use kthread_create_worker_on_cpu(cpu, “helper/<code class="docutils literal notranslate"><span class="pre">d</span></code>”, cpu).</p>
<p>Returns a pointer to the allocated worker on success, ERR_PTR(-ENOMEM)
when the needed structures could not get allocated, and ERR_PTR(-EINTR)
when the worker was SIGKILLed.</p>
<dl class="c function">
<dt id="c.kthread_queue_work">
bool <code class="sig-name descname">kthread_queue_work</code><span class="sig-paren">(</span><em class="property">struct</em> kthread_worker *<em>worker</em>, <em class="property">struct</em> kthread_work *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_queue_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>queue a kthread_work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>target kthread_worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*work</span></code></dt><dd><p>kthread_work to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue <strong>work</strong> to work processor <strong>task</strong> for async execution.  <strong>task</strong>
must have been created with kthread_worker_create().  Returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
if <strong>work</strong> was successfully queued, <code class="docutils literal notranslate"><span class="pre">false</span></code> if it was already pending.</p>
<p>Reinitialize the work if it needs to be used by another worker.
For example, when the worker was stopped and started again.</p>
<dl class="c function">
<dt id="c.kthread_delayed_work_timer_fn">
void <code class="sig-name descname">kthread_delayed_work_timer_fn</code><span class="sig-paren">(</span><em class="property">struct</em> timer_list *<em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_delayed_work_timer_fn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>callback that queues the associated kthread delayed work when the timer expires.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*t</span></code></dt><dd><p>pointer to the expired timer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The format of the function is defined by struct timer_list.
It should have been called from irqsafe timer with irq already off.</p>
<dl class="c function">
<dt id="c.kthread_queue_delayed_work">
bool <code class="sig-name descname">kthread_queue_delayed_work</code><span class="sig-paren">(</span><em class="property">struct</em> kthread_worker *<em>worker</em>, <em class="property">struct</em> kthread_delayed_work *<em>dwork</em>, unsigned long <em>delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_queue_delayed_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>queue the associated kthread work after a delay.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>target kthread_worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>kthread_delayed_work to queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queuing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the work has not been pending it starts a timer that will queue
the work after the given <strong>delay</strong>. If <strong>delay</strong> is zero, it queues the
work immediately.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if the <strong>work</strong> has already been pending. It means that
either the timer was running or the work was queued. It returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
otherwise.</p>
<dl class="c function">
<dt id="c.kthread_flush_work">
void <code class="sig-name descname">kthread_flush_work</code><span class="sig-paren">(</span><em class="property">struct</em> kthread_work *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_flush_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>flush a kthread_work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*work</span></code></dt><dd><p>work to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>work</strong> is queued or executing, wait for it to finish execution.</p>
<dl class="c function">
<dt id="c.kthread_mod_delayed_work">
bool <code class="sig-name descname">kthread_mod_delayed_work</code><span class="sig-paren">(</span><em class="property">struct</em> kthread_worker *<em>worker</em>, <em class="property">struct</em> kthread_delayed_work *<em>dwork</em>, unsigned long <em>delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_mod_delayed_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>modify delay of or queue a kthread delayed work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>kthread worker to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>kthread delayed work to queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queuing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>dwork</strong> is idle, equivalent to <a class="reference internal" href="#c.kthread_queue_delayed_work" title="kthread_queue_delayed_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_queue_delayed_work()</span></code></a>. Otherwise,
modify <strong>dwork</strong>’s timer so that it expires after <strong>delay</strong>. If <strong>delay</strong> is zero,
<strong>work</strong> is guaranteed to be queued immediately.</p>
<p>A special case is when the work is being canceled in parallel.
It might be caused either by the real <a class="reference internal" href="#c.kthread_cancel_delayed_work_sync" title="kthread_cancel_delayed_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_cancel_delayed_work_sync()</span></code></a>
or yet another <a class="reference internal" href="#c.kthread_mod_delayed_work" title="kthread_mod_delayed_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_mod_delayed_work()</span></code></a> call. We let the other command
win and return <code class="docutils literal notranslate"><span class="pre">false</span></code> here. The caller is supposed to synchronize these
operations a reasonable way.</p>
<p>This function is safe to call from any context including IRQ handler.
See __kthread_cancel_work() and <a class="reference internal" href="#c.kthread_delayed_work_timer_fn" title="kthread_delayed_work_timer_fn"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_delayed_work_timer_fn()</span></code></a>
for details.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>dwork</strong> was pending and its timer was modified,
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.kthread_cancel_work_sync">
bool <code class="sig-name descname">kthread_cancel_work_sync</code><span class="sig-paren">(</span><em class="property">struct</em> kthread_work *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_cancel_work_sync" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cancel a kthread work and wait for it to finish</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*work</span></code></dt><dd><p>the kthread work to cancel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cancel <strong>work</strong> and wait for its execution to finish.  This function
can be used even if the work re-queues itself. On return from this
function, <strong>work</strong> is guaranteed to be not pending or executing on any CPU.</p>
<p>kthread_cancel_work_sync(<code class="xref c c-type docutils literal notranslate"><span class="pre">delayed_work-&gt;work</span></code>) must not be used for
delayed_work’s. Use <a class="reference internal" href="#c.kthread_cancel_delayed_work_sync" title="kthread_cancel_delayed_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_cancel_delayed_work_sync()</span></code></a> instead.</p>
<p>The caller must ensure that the worker on which <strong>work</strong> was last
queued can’t be destroyed before this function returns.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>work</strong> was pending, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.kthread_cancel_delayed_work_sync">
bool <code class="sig-name descname">kthread_cancel_delayed_work_sync</code><span class="sig-paren">(</span><em class="property">struct</em> kthread_delayed_work *<em>dwork</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_cancel_delayed_work_sync" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cancel a kthread delayed work and wait for it to finish.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>the kthread delayed work to cancel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <a class="reference internal" href="#c.kthread_cancel_work_sync" title="kthread_cancel_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_cancel_work_sync()</span></code></a> for delayed works.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>dwork</strong> was pending, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.kthread_flush_worker">
void <code class="sig-name descname">kthread_flush_worker</code><span class="sig-paren">(</span><em class="property">struct</em> kthread_worker *<em>worker</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_flush_worker" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>flush all current works on a kthread_worker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until all currently executing or pending works on <strong>worker</strong> are
finished.</p>
<dl class="c function">
<dt id="c.kthread_destroy_worker">
void <code class="sig-name descname">kthread_destroy_worker</code><span class="sig-paren">(</span><em class="property">struct</em> kthread_worker *<em>worker</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_destroy_worker" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>destroy a kthread worker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker to be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush and destroy <strong>worker</strong>.  The simple flush is enough because the kthread
worker API is used only in trivial scenarios.  There are no multi-step state
machines needed.</p>
<dl class="c function">
<dt id="c.kthread_use_mm">
void <code class="sig-name descname">kthread_use_mm</code><span class="sig-paren">(</span><em class="property">struct</em> mm_struct *<em>mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_use_mm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>make the calling kthread operate on an address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>address space to operate on</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.kthread_unuse_mm">
void <code class="sig-name descname">kthread_unuse_mm</code><span class="sig-paren">(</span><em class="property">struct</em> mm_struct *<em>mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_unuse_mm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reverse the effect of <a class="reference internal" href="#c.kthread_use_mm" title="kthread_use_mm"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_use_mm()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>address space to operate on</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.kthread_associate_blkcg">
void <code class="sig-name descname">kthread_associate_blkcg</code><span class="sig-paren">(</span><em class="property">struct</em> cgroup_subsys_state *<em>css</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_associate_blkcg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>associate blkcg to current kthread</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cgroup_subsys_state</span> <span class="pre">*css</span></code></dt><dd><p>the cgroup info</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Current thread must be a kthread. The thread is running jobs on behalf of
other threads. In some cases, we expect the jobs attach cgroup info of
original threads instead of that of current thread. This function stores
original thread’s cgroup info in current kthread context for later
retrieval.</p>
<dl class="c function">
<dt id="c.kthread_blkcg">
<em class="property">struct</em> cgroup_subsys_state *<code class="sig-name descname">kthread_blkcg</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_blkcg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get associated blkcg css of current kthread</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Current thread must be a kthread.</p>
</div>
<div class="section" id="reference-counting">
<h2>Reference counting<a class="headerlink" href="#reference-counting" title="Permalink to this headline">¶</a></h2>
<dl class="c struct">
<dt id="c.refcount_struct">
<em class="property">struct </em><code class="sig-name descname">refcount_struct</code><a class="headerlink" href="#c.refcount_struct" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>variant of atomic_t specialized for reference counts</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct refcount_struct {
  atomic_t refs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refs</span></code></dt><dd><p>atomic_t counter field</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The counter saturates at REFCOUNT_SATURATED and will not move once
there. This avoids wrapping the counter and causing ‘spurious’
use-after-free bugs.</p>
<dl class="c function">
<dt id="c.refcount_set">
void <code class="sig-name descname">refcount_set</code><span class="sig-paren">(</span>refcount_t *<em>r</em>, int <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set a refcount’s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code></dt><dd><p>value to which the refcount will be set</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.refcount_read">
unsigned int <code class="sig-name descname">refcount_read</code><span class="sig-paren">(</span><em class="property">const</em> refcount_t *<em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a refcount’s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the refcount’s value</p>
<dl class="c function">
<dt id="c.refcount_add_not_zero">
bool <code class="sig-name descname">refcount_add_not_zero</code><span class="sig-paren">(</span>int <em>i</em>, refcount_t *<em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_add_not_zero" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a value to a refcount unless it is 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>the value to add to the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will saturate at REFCOUNT_SATURATED and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <a class="reference internal" href="#c.refcount_inc" title="refcount_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_inc()</span></code></a>, or one of its variants, should instead be used to
increment a reference count.</p>
<p><strong>Return</strong></p>
<p>false if the passed refcount is 0, true otherwise</p>
<dl class="c function">
<dt id="c.refcount_add">
void <code class="sig-name descname">refcount_add</code><span class="sig-paren">(</span>int <em>i</em>, refcount_t *<em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a value to a refcount</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>the value to add to the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_add(), but will saturate at REFCOUNT_SATURATED and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <a class="reference internal" href="#c.refcount_inc" title="refcount_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_inc()</span></code></a>, or one of its variants, should instead be used to
increment a reference count.</p>
<dl class="c function">
<dt id="c.refcount_inc_not_zero">
bool <code class="sig-name descname">refcount_inc_not_zero</code><span class="sig-paren">(</span>refcount_t *<em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_inc_not_zero" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increment a refcount unless it is 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount to increment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_inc_not_zero(), but will saturate at REFCOUNT_SATURATED
and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p><strong>Return</strong></p>
<p>true if the increment was successful, false otherwise</p>
<dl class="c function">
<dt id="c.refcount_inc">
void <code class="sig-name descname">refcount_inc</code><span class="sig-paren">(</span>refcount_t *<em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_inc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increment a refcount</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount to increment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_inc(), but will saturate at REFCOUNT_SATURATED and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller already has a
reference on the object.</p>
<p>Will WARN if the refcount is 0, as this represents a possible use-after-free
condition.</p>
<dl class="c function">
<dt id="c.refcount_sub_and_test">
bool <code class="sig-name descname">refcount_sub_and_test</code><span class="sig-paren">(</span>int <em>i</em>, refcount_t *<em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_sub_and_test" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>subtract from a refcount and test if it is 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>amount to subtract from the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_dec_and_test(), but it will WARN, return false and
ultimately leak on underflow and will fail to decrement when saturated
at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides an acquire ordering on success such that free()
must come after.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <a class="reference internal" href="#c.refcount_dec" title="refcount_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_dec()</span></code></a>, or one of its variants, should instead be used to
decrement a reference count.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
<dl class="c function">
<dt id="c.refcount_dec_and_test">
bool <code class="sig-name descname">refcount_dec_and_test</code><span class="sig-paren">(</span>refcount_t *<em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_test" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement a refcount and test if it is 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_dec_and_test(), it will WARN on underflow and fail to
decrement when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides an acquire ordering on success such that free()
must come after.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
<dl class="c function">
<dt id="c.refcount_dec">
void <code class="sig-name descname">refcount_dec</code><span class="sig-paren">(</span>refcount_t *<em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement a refcount</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_dec(), it will WARN on underflow and fail to decrement
when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before.</p>
<dl class="c function">
<dt id="c.refcount_dec_if_one">
bool <code class="sig-name descname">refcount_dec_if_one</code><span class="sig-paren">(</span>refcount_t *<em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_if_one" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement a refcount if it is 1</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>No atomic_t counterpart, it attempts a 1 -&gt; 0 transition and returns the
success thereof.</p>
<p>Like all decrement operations, it provides release memory order and provides
a control dependency.</p>
<p>It can be used like a try-delete operator; this explicit case is provided
and not cmpxchg in generic, because that would allow implementing unsafe
operations.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
<dl class="c function">
<dt id="c.refcount_dec_not_one">
bool <code class="sig-name descname">refcount_dec_not_one</code><span class="sig-paren">(</span>refcount_t *<em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_not_one" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement a refcount if it is not 1</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>No atomic_t counterpart, it decrements unless the value is 1, in which case
it will return false.</p>
<p>Was often done like: atomic_add_unless(<code class="xref c c-type docutils literal notranslate"><span class="pre">var</span></code>, -1, 1)</p>
<p><strong>Return</strong></p>
<p>true if the decrement operation was successful, false otherwise</p>
<dl class="c function">
<dt id="c.refcount_dec_and_mutex_lock">
bool <code class="sig-name descname">refcount_dec_and_mutex_lock</code><span class="sig-paren">(</span>refcount_t *<em>r</em>, <em class="property">struct</em> mutex *<em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_mutex_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return holding mutex if able to decrement refcount to 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be locked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="../kernel-hacking/locking.html#c.atomic_dec_and_mutex_lock" title="atomic_dec_and_mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_and_mutex_lock()</span></code></a>, it will WARN on underflow and fail
to decrement when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that free() must come after.
See the comment on top.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true and hold mutex if able to decrement refcount to 0, false</dt><dd><p>otherwise</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.refcount_dec_and_lock">
bool <code class="sig-name descname">refcount_dec_and_lock</code><span class="sig-paren">(</span>refcount_t *<em>r</em>, spinlock_t *<em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return holding spinlock if able to decrement refcount to 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>the spinlock to be locked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_dec_and_lock(), it will WARN on underflow and fail to
decrement when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that free() must come after.
See the comment on top.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true and hold spinlock if able to decrement refcount to 0, false</dt><dd><p>otherwise</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.refcount_dec_and_lock_irqsave">
bool <code class="sig-name descname">refcount_dec_and_lock_irqsave</code><span class="sig-paren">(</span>refcount_t *<em>r</em>, spinlock_t *<em>lock</em>, unsigned long *<em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_lock_irqsave" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return holding spinlock with disabled interrupts if able to decrement refcount to 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>the spinlock to be locked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*flags</span></code></dt><dd><p>saved IRQ-flags if the is acquired</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.refcount_dec_and_lock" title="refcount_dec_and_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_dec_and_lock()</span></code></a> above except that the spinlock is acquired
with disabled interupts.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true and hold spinlock if able to decrement refcount to 0, false</dt><dd><p>otherwise</p>
</dd>
</dl>
</div>
<div class="section" id="atomics">
<h2>Atomics<a class="headerlink" href="#atomics" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt id="c.arch_atomic_read">
int <code class="sig-name descname">arch_atomic_read</code><span class="sig-paren">(</span><em class="property">const</em> atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>read atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically reads the value of <strong>v</strong>.</p>
<dl class="c function">
<dt id="c.arch_atomic_set">
void <code class="sig-name descname">arch_atomic_set</code><span class="sig-paren">(</span>atomic_t *<em>v</em>, int <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>required value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets the value of <strong>v</strong> to <strong>i</strong>.</p>
<dl class="c function">
<dt id="c.arch_atomic_add">
void <code class="sig-name descname">arch_atomic_add</code><span class="sig-paren">(</span>int <em>i</em>, atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add integer to atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically adds <strong>i</strong> to <strong>v</strong>.</p>
<dl class="c function">
<dt id="c.arch_atomic_sub">
void <code class="sig-name descname">arch_atomic_sub</code><span class="sig-paren">(</span>int <em>i</em>, atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_sub" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>subtract integer from atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically subtracts <strong>i</strong> from <strong>v</strong>.</p>
<dl class="c function">
<dt id="c.arch_atomic_sub_and_test">
bool <code class="sig-name descname">arch_atomic_sub_and_test</code><span class="sig-paren">(</span>int <em>i</em>, atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_sub_and_test" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>subtract value from variable and test result</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically subtracts <strong>i</strong> from <strong>v</strong> and returns
true if the result is zero, or false for all
other cases.</p>
<dl class="c function">
<dt id="c.arch_atomic_inc">
void <code class="sig-name descname">arch_atomic_inc</code><span class="sig-paren">(</span>atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_inc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increment atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically increments <strong>v</strong> by 1.</p>
<dl class="c function">
<dt id="c.arch_atomic_dec">
void <code class="sig-name descname">arch_atomic_dec</code><span class="sig-paren">(</span>atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_dec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically decrements <strong>v</strong> by 1.</p>
<dl class="c function">
<dt id="c.arch_atomic_dec_and_test">
bool <code class="sig-name descname">arch_atomic_dec_and_test</code><span class="sig-paren">(</span>atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_dec_and_test" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement and test</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically decrements <strong>v</strong> by 1 and
returns true if the result is 0, or false for all other
cases.</p>
<dl class="c function">
<dt id="c.arch_atomic_inc_and_test">
bool <code class="sig-name descname">arch_atomic_inc_and_test</code><span class="sig-paren">(</span>atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_inc_and_test" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increment and test</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically increments <strong>v</strong> by 1
and returns true if the result is zero, or false for all
other cases.</p>
<dl class="c function">
<dt id="c.arch_atomic_add_negative">
bool <code class="sig-name descname">arch_atomic_add_negative</code><span class="sig-paren">(</span>int <em>i</em>, atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_add_negative" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add and test if negative</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically adds <strong>i</strong> to <strong>v</strong> and returns true
if the result is negative, or false when
result is greater than or equal to zero.</p>
<dl class="c function">
<dt id="c.arch_atomic_add_return">
int <code class="sig-name descname">arch_atomic_add_return</code><span class="sig-paren">(</span>int <em>i</em>, atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_add_return" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add integer and return</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically adds <strong>i</strong> to <strong>v</strong> and returns <strong>i</strong> + <strong>v</strong></p>
<dl class="c function">
<dt id="c.arch_atomic_sub_return">
int <code class="sig-name descname">arch_atomic_sub_return</code><span class="sig-paren">(</span>int <em>i</em>, atomic_t *<em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_sub_return" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>subtract integer and return</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically subtracts <strong>i</strong> from <strong>v</strong> and returns <strong>v</strong> - <strong>i</strong></p>
</div>
<div class="section" id="kernel-objects-manipulation">
<h2>Kernel objects manipulation<a class="headerlink" href="#kernel-objects-manipulation" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt id="c.kobject_get_path">
char *<code class="sig-name descname">kobject_get_path</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em>, gfp_t <em>gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_get_path" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate memory and fill in the path for <strong>kobj</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject in question, with which to build the path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>the allocation type used to allocate the path</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The newly allocated memory, caller must free with <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
<dl class="c function">
<dt id="c.kobject_set_name">
int <code class="sig-name descname">kobject_set_name</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_set_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the name of a kobject.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>struct kobject to set the name of</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format string used to build the name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This sets the name of the kobject.  If you have already added the
kobject to the system, you must call <a class="reference internal" href="#c.kobject_rename" title="kobject_rename"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_rename()</span></code></a> in order to
change the name of the kobject.</p>
<dl class="c function">
<dt id="c.kobject_init">
void <code class="sig-name descname">kobject_init</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> kobj_type *<em>ktype</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a kobject structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>pointer to the kobject to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobj_type</span> <span class="pre">*ktype</span></code></dt><dd><p>pointer to the ktype for this kobject.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will properly initialize a kobject such that it can then
be passed to the <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a> call.</p>
<p>After this function is called, the kobject MUST be cleaned up by a call
to <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a>, not by a call to kfree directly to ensure that all of
the memory is cleaned up properly.</p>
<dl class="c function">
<dt id="c.kobject_add">
int <code class="sig-name descname">kobject_add</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> kobject *<em>parent</em>, <em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The main kobject add function.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>the kobject to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to the parent of the kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format to name the kobject with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The kobject name is set and added to the kobject hierarchy in this
function.</p>
<p>If <strong>parent</strong> is set, then the parent of the <strong>kobj</strong> will be set to it.
If <strong>parent</strong> is NULL, then the parent of the <strong>kobj</strong> will be set to the
kobject associated with the kset assigned to this kobject.  If no kset
is assigned to the kobject, then the kobject will be located in the
root of the sysfs tree.</p>
<p>Note, no “add” uevent will be created with this call, the caller should set
up all of the necessary sysfs files for the object and then call
kobject_uevent() with the UEVENT_ADD parameter to ensure that
userspace is properly notified of this kobject’s creation.</p>
<p><strong>Return</strong></p>
<dl>
<dt>If this function returns an error, kobject_put() must be</dt><dd><p>called to properly clean up the memory associated with the
object.  Under no instance should the kobject that is passed
to this function be directly freed with a call to <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>,
that can leak memory.</p>
<p>If this function returns success, <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> must also be called
in order to properly clean up the memory associated with the object.</p>
<p>In short, once this function is called, <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> MUST be called
when the use of the object is finished in order to properly free
everything.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.kobject_init_and_add">
int <code class="sig-name descname">kobject_init_and_add</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> kobj_type *<em>ktype</em>, <em class="property">struct</em> kobject *<em>parent</em>, <em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_init_and_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a kobject structure and add it to the kobject hierarchy.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>pointer to the kobject to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobj_type</span> <span class="pre">*ktype</span></code></dt><dd><p>pointer to the ktype for this kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to the parent of this kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>the name of the kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function combines the call to <a class="reference internal" href="#c.kobject_init" title="kobject_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_init()</span></code></a> and <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a>.</p>
<p>If this function returns an error, <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> must be called to
properly clean up the memory associated with the object.  This is the
same type of error handling after a call to <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a> and kobject
lifetime rules are the same here.</p>
<dl class="c function">
<dt id="c.kobject_rename">
int <code class="sig-name descname">kobject_rename</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">const</em> char *<em>new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_rename" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Change the name of an object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object in question.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*new_name</span></code></dt><dd><p>object’s new name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the responsibility of the caller to provide mutual
exclusion between two different calls of kobject_rename
on the same kobject and to ensure that new_name is valid and
won’t conflict with other kobjects.</p>
<dl class="c function">
<dt id="c.kobject_move">
int <code class="sig-name descname">kobject_move</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> kobject *<em>new_parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_move" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Move object to another parent.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object in question.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*new_parent</span></code></dt><dd><p>object’s new parent (can be NULL)</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.kobject_del">
void <code class="sig-name descname">kobject_del</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_del" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unlink kobject from hierarchy.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the function that should be called to delete an object
successfully added via <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a>.</p>
<dl class="c function">
<dt id="c.kobject_get">
<em class="property">struct</em> kobject *<code class="sig-name descname">kobject_get</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Increment refcount for object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.kobject_put">
void <code class="sig-name descname">kobject_put</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Decrement refcount for object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement the refcount, and if 0, call kobject_cleanup().</p>
<dl class="c function">
<dt id="c.kobject_create_and_add">
<em class="property">struct</em> kobject *<code class="sig-name descname">kobject_create_and_add</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, <em class="property">struct</em> kobject *<em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_create_and_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a struct kobject dynamically and register it with sysfs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name for the kobject</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent</span></code></dt><dd><p>the parent kobject of this kobject, if any.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a kobject structure dynamically and registers it
with sysfs.  When you are finished with this structure, call
<a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> and the structure will be dynamically freed when
it is no longer being used.</p>
<p>If the kobject was not able to be created, NULL will be returned.</p>
<dl class="c function">
<dt id="c.kset_register">
int <code class="sig-name descname">kset_register</code><span class="sig-paren">(</span><em class="property">struct</em> kset *<em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize and add a kset.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*k</span></code></dt><dd><p>kset.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.kset_unregister">
void <code class="sig-name descname">kset_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> kset *<em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove a kset.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*k</span></code></dt><dd><p>kset.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.kset_find_obj">
<em class="property">struct</em> kobject *<code class="sig-name descname">kset_find_obj</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.kset_find_obj" title="kset">kset</a> *<em>kset</em>, <em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_find_obj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Search for object in kset.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*kset</span></code></dt><dd><p>kset we’re looking in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>object’s name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock kset via <strong>kset-&gt;subsys</strong>, and iterate over <strong>kset-&gt;list</strong>,
looking for a matching kobject. If matching object is found
take a reference and return the object.</p>
<dl class="c function">
<dt id="c.kset_create_and_add">
<em class="property">struct</em> kset *<code class="sig-name descname">kset_create_and_add</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, <em class="property">const</em> <em class="property">struct</em> kset_uevent_ops *<em>uevent_ops</em>, <em class="property">struct</em> kobject *<em>parent_kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_create_and_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a struct kset dynamically and add it to sysfs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name for the kset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kset_uevent_ops</span> <span class="pre">*uevent_ops</span></code></dt><dd><p>a struct kset_uevent_ops for the kset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent_kobj</span></code></dt><dd><p>the parent kobject of this kset, if any.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a kset structure dynamically and registers it
with sysfs.  When you are finished with this structure, call
<a class="reference internal" href="#c.kset_unregister" title="kset_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">kset_unregister()</span></code></a> and the structure will be dynamically freed when it
is no longer being used.</p>
<p>If the kset was not able to be created, NULL will be returned.</p>
</div>
<div class="section" id="kernel-utility-functions">
<h2>Kernel utility functions<a class="headerlink" href="#kernel-utility-functions" title="Permalink to this headline">¶</a></h2>
<dl class="c macro">
<dt id="c.REPEAT_BYTE">
<code class="sig-name descname">REPEAT_BYTE</code><a class="headerlink" href="#c.REPEAT_BYTE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">REPEAT_BYTE</span> <span class="pre">(x)</span></code></p>
<blockquote>
<div><p>repeat the value <strong>x</strong> multiple times as an unsigned long value</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>value to repeat</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p><strong>x</strong> is not checked for &gt; 0xff; larger values produce odd results.</p>
<dl class="c macro">
<dt id="c.ARRAY_SIZE">
<code class="sig-name descname">ARRAY_SIZE</code><a class="headerlink" href="#c.ARRAY_SIZE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">ARRAY_SIZE</span> <span class="pre">(arr)</span></code></p>
<blockquote>
<div><p>get the number of elements in array <strong>arr</strong></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">arr</span></code></dt><dd><p>array to be sized</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.round_up">
<code class="sig-name descname">round_up</code><a class="headerlink" href="#c.round_up" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">round_up</span> <span class="pre">(x,</span> <span class="pre">y)</span></code></p>
<blockquote>
<div><p>round up to next specified power of 2</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>the value to round</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code></dt><dd><p>multiple to round up to (must be a power of 2)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rounds <strong>x</strong> up to next multiple of <strong>y</strong> (which must be a power of 2).
To perform arbitrary rounding up, use <a class="reference internal" href="#c.roundup" title="roundup"><code class="xref c c-func docutils literal notranslate"><span class="pre">roundup()</span></code></a> below.</p>
<dl class="c macro">
<dt id="c.round_down">
<code class="sig-name descname">round_down</code><a class="headerlink" href="#c.round_down" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">round_down</span> <span class="pre">(x,</span> <span class="pre">y)</span></code></p>
<blockquote>
<div><p>round down to next specified power of 2</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>the value to round</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code></dt><dd><p>multiple to round down to (must be a power of 2)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rounds <strong>x</strong> down to next multiple of <strong>y</strong> (which must be a power of 2).
To perform arbitrary rounding down, use <a class="reference internal" href="#c.rounddown" title="rounddown"><code class="xref c c-func docutils literal notranslate"><span class="pre">rounddown()</span></code></a> below.</p>
<dl class="c macro">
<dt id="c.roundup">
<code class="sig-name descname">roundup</code><a class="headerlink" href="#c.roundup" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">roundup</span> <span class="pre">(x,</span> <span class="pre">y)</span></code></p>
<blockquote>
<div><p>round up to the next specified multiple</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>the value to up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code></dt><dd><p>multiple to round up to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rounds <strong>x</strong> up to next multiple of <strong>y</strong>. If <strong>y</strong> will always be a power
of 2, consider using the faster <a class="reference internal" href="#c.round_up" title="round_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_up()</span></code></a>.</p>
<dl class="c macro">
<dt id="c.rounddown">
<code class="sig-name descname">rounddown</code><a class="headerlink" href="#c.rounddown" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rounddown</span> <span class="pre">(x,</span> <span class="pre">y)</span></code></p>
<blockquote>
<div><p>round down to next specified multiple</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>the value to round</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code></dt><dd><p>multiple to round down to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rounds <strong>x</strong> down to next multiple of <strong>y</strong>. If <strong>y</strong> will always be a power
of 2, consider using the faster <a class="reference internal" href="#c.round_down" title="round_down"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_down()</span></code></a>.</p>
<dl class="c macro">
<dt id="c.upper_32_bits">
<code class="sig-name descname">upper_32_bits</code><a class="headerlink" href="#c.upper_32_bits" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">upper_32_bits</span> <span class="pre">(n)</span></code></p>
<blockquote>
<div><p>return bits 32-63 of a number</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>the number we’re accessing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress
the “right shift count &gt;= width of type” warning when that quantity is
32-bits.</p>
<dl class="c macro">
<dt id="c.lower_32_bits">
<code class="sig-name descname">lower_32_bits</code><a class="headerlink" href="#c.lower_32_bits" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">lower_32_bits</span> <span class="pre">(n)</span></code></p>
<blockquote>
<div><p>return bits 0-31 of a number</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>the number we’re accessing</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.might_sleep">
<code class="sig-name descname">might_sleep</code><a class="headerlink" href="#c.might_sleep" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">might_sleep</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>annotation for functions that can sleep</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>this macro will print a stack trace if it is executed in an atomic
context (spinlock, irq-handler, …). Additional sections where blocking is
not allowed can be annotated with <a class="reference internal" href="#c.non_block_start" title="non_block_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">non_block_start()</span></code></a> and <a class="reference internal" href="#c.non_block_end" title="non_block_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">non_block_end()</span></code></a>
pairs.</p>
<p>This is a useful debugging help to be able to catch problems early and not
be bitten later when the calling function happens to sleep when it is not
supposed to.</p>
<dl class="c macro">
<dt id="c.cant_sleep">
<code class="sig-name descname">cant_sleep</code><a class="headerlink" href="#c.cant_sleep" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">cant_sleep</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>annotation for functions that cannot sleep</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>this macro will print a stack trace if it is executed with preemption enabled</p>
<dl class="c macro">
<dt id="c.non_block_start">
<code class="sig-name descname">non_block_start</code><a class="headerlink" href="#c.non_block_start" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">non_block_start</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>annotate the start of section where sleeping is prohibited</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This is on behalf of the oom reaper, specifically when it is calling the mmu
notifiers. The problem is that if the notifier were to block on, for example,
<a class="reference internal" href="../kernel-hacking/locking.html#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a> and if the process which holds that mutex were to perform a
sleeping memory allocation, the oom reaper is now blocked on completion of
that memory allocation. Other blocking calls like <a class="reference internal" href="#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event()</span></code></a> pose similar
issues.</p>
<dl class="c macro">
<dt id="c.non_block_end">
<code class="sig-name descname">non_block_end</code><a class="headerlink" href="#c.non_block_end" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">non_block_end</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>annotate the end of section where sleeping is prohibited</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Closes a section opened by <a class="reference internal" href="#c.non_block_start" title="non_block_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">non_block_start()</span></code></a>.</p>
<dl class="c macro">
<dt id="c.abs">
<code class="sig-name descname">abs</code><a class="headerlink" href="#c.abs" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">abs</span> <span class="pre">(x)</span></code></p>
<blockquote>
<div><p>return absolute value of an argument</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>the value.  If it is unsigned type, it is converted to signed type first.
char is treated as if it was signed (regardless of whether it really is)
but the macro’s return type is preserved as char.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>an absolute value of x.</p>
<dl class="c function">
<dt id="c.reciprocal_scale">
u32 <code class="sig-name descname">reciprocal_scale</code><span class="sig-paren">(</span>u32 <em>val</em>, u32 <em>ep_ro</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reciprocal_scale" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>“scale” a value into range [0, ep_ro)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">val</span></code></dt><dd><p>value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">ep_ro</span></code></dt><dd><p>right open interval endpoint</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a “reciprocal multiplication” in order to “scale” a value into
range [0, <strong>ep_ro</strong>), where the upper interval endpoint is right-open.
This is useful, e.g. for accessing a index of an array containing
<strong>ep_ro</strong> elements, for example. Think of it as sort of modulus, only that
the result isn’t that of modulo. ;) Note that if initial input is a
small value, then result will return 0.</p>
<p><strong>Return</strong></p>
<p>a result based on <strong>val</strong> in interval [0, <strong>ep_ro</strong>).</p>
<dl class="c macro">
<dt id="c.trace_printk">
<code class="sig-name descname">trace_printk</code><a class="headerlink" href="#c.trace_printk" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">trace_printk</span> <span class="pre">(fmt,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>printf formatting in the ftrace buffer</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt><dd><p>the printf format for printing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>__trace_printk is an internal function for trace_printk() and</dt><dd><p>the <strong>ip</strong> is passed in via the <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> macro.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows a kernel developer to debug fast path sections
that printk is not appropriate for. By scattering in various
printk like tracing in the code, a developer can quickly see
where problems are occurring.</p>
<p>This is intended as a debugging tool for the developer only.
Please refrain from leaving trace_printks scattered around in
your code. (Extra memory is used for special buffers that are
allocated when <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> is used.)</p>
<p>A little optimization trick is done here. If there’s only one
argument, there’s no need to scan the string for printf formats.
The <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a> will suffice. But how can we take advantage of
using <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a> when <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> has only one argument?
By stringifying the args and checking the size we can tell
whether or not there are args. __stringify((__VA_ARGS__)) will
turn into “()0” with a size of 3 when there are no args, anything
else will be bigger. All we need to do is define a string to this,
and then take its size and compare to 3. If it’s bigger, use
do_trace_printk() otherwise, optimize it to <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a>. Then just
let gcc optimize the rest.</p>
<dl class="c macro">
<dt id="c.trace_puts">
<code class="sig-name descname">trace_puts</code><a class="headerlink" href="#c.trace_puts" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">trace_puts</span> <span class="pre">(str)</span></code></p>
<blockquote>
<div><p>write a string into the ftrace buffer</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">str</span></code></dt><dd><p>the string to record</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>__trace_bputs is an internal function for trace_puts and</dt><dd><p>the <strong>ip</strong> is passed in via the trace_puts macro.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> but is made for those really fast
paths that a developer wants the least amount of “Heisenbug” effects,
where the processing of the print format is still too much.</p>
<p>This function allows a kernel developer to debug fast path sections
that printk is not appropriate for. By scattering in various
printk like tracing in the code, a developer can quickly see
where problems are occurring.</p>
<p>This is intended as a debugging tool for the developer only.
Please refrain from leaving trace_puts scattered around in
your code. (Extra memory is used for special buffers that are
allocated when <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a> is used.)</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 if nothing was written, positive # if string was.</dt><dd><p>(1 when __trace_bputs is used, strlen(str) when __trace_puts is used)</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.container_of">
<code class="sig-name descname">container_of</code><a class="headerlink" href="#c.container_of" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">container_of</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>cast a member of a structure out to the containing structure</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the pointer to the member.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the container struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the member within the struct.</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.container_of_safe">
<code class="sig-name descname">container_of_safe</code><a class="headerlink" href="#c.container_of_safe" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">container_of_safe</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>cast a member of a structure out to the containing structure</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the pointer to the member.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the container struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the member within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.</p>
<dl class="c function">
<dt id="c.console_lock">
void <code class="sig-name descname">console_lock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lock the console system for exclusive use.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires a lock which guarantees that the caller has
exclusive access to the console system and the console_drivers list.</p>
<p>Can sleep, returns nothing.</p>
<dl class="c function">
<dt id="c.console_trylock">
int <code class="sig-name descname">console_trylock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_trylock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>try to lock the console system for exclusive use.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to acquire a lock which guarantees that the caller has exclusive
access to the console system and the console_drivers list.</p>
<p>returns 1 on success, and 0 on failure to acquire the lock.</p>
<dl class="c function">
<dt id="c.console_unlock">
void <code class="sig-name descname">console_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unlock the console system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the console_lock which the caller holds on the console system
and the console driver list.</p>
<p>While the console_lock was held, console output may have been buffered
by <a class="reference internal" href="../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a>.  If this is the case, <a class="reference internal" href="#c.console_unlock" title="console_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_unlock()</span></code></a>; emits
the output prior to releasing the lock.</p>
<p>If there is output waiting, we wake /dev/kmsg and syslog() users.</p>
<p><a class="reference internal" href="#c.console_unlock" title="console_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_unlock()</span></code></a>; may be called from any context.</p>
<dl class="c function">
<dt id="c.console_conditional_schedule">
void <code class="sig-name descname">console_conditional_schedule</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_conditional_schedule" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>yield the CPU if required</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the console code is currently allowed to sleep, and
if this CPU should yield the CPU to another task, do
so here.</p>
<p>Must be called within <a class="reference internal" href="#c.console_lock" title="console_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_lock()</span></code></a>;.</p>
<dl class="c function">
<dt id="c.printk_timed_ratelimit">
bool <code class="sig-name descname">printk_timed_ratelimit</code><span class="sig-paren">(</span>unsigned long *<em>caller_jiffies</em>, unsigned int <em>interval_msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.printk_timed_ratelimit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>caller-controlled printk ratelimiting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*caller_jiffies</span></code></dt><dd><p>pointer to caller’s state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">interval_msecs</span></code></dt><dd><p>minimum interval between prints</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.printk_timed_ratelimit" title="printk_timed_ratelimit"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk_timed_ratelimit()</span></code></a> returns true if more than <strong>interval_msecs</strong>
milliseconds have elapsed since the last time <a class="reference internal" href="#c.printk_timed_ratelimit" title="printk_timed_ratelimit"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk_timed_ratelimit()</span></code></a>
returned true.</p>
<dl class="c function">
<dt id="c.kmsg_dump_register">
int <code class="sig-name descname">kmsg_dump_register</code><span class="sig-paren">(</span><em class="property">struct</em> kmsg_dumper *<em>dumper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a kernel log dumper.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*dumper</span></code></dt><dd><p>pointer to the kmsg_dumper structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a kernel log dumper to the system. The dump callback in the
structure will be called when the kernel oopses or panics and must be
set. Returns zero on success and <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> or <code class="docutils literal notranslate"><span class="pre">-EBUSY</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.kmsg_dump_unregister">
int <code class="sig-name descname">kmsg_dump_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> kmsg_dumper *<em>dumper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a kmsg dumper.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*dumper</span></code></dt><dd><p>pointer to the kmsg_dumper structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a dump device from the system. Returns zero on success and
<code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.kmsg_dump_get_line">
bool <code class="sig-name descname">kmsg_dump_get_line</code><span class="sig-paren">(</span><em class="property">struct</em> kmsg_dumper *<em>dumper</em>, bool <em>syslog</em>, char *<em>line</em>, size_t <em>size</em>, size_t *<em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_get_line" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>retrieve one kmsg log line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*dumper</span></code></dt><dd><p>registered kmsg dumper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">syslog</span></code></dt><dd><p>include the “&lt;4&gt;” prefixes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*line</span></code></dt><dd><p>buffer to copy the line to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>maximum size of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*len</span></code></dt><dd><p>length of line placed into buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start at the beginning of the kmsg buffer, with the oldest kmsg
record, and copy one record into the provided buffer.</p>
<p>Consecutive calls will return the next available record moving
towards the end of the buffer with the youngest messages.</p>
<p>A return value of FALSE indicates that there are no more records to
read.</p>
<dl class="c function">
<dt id="c.kmsg_dump_get_buffer">
bool <code class="sig-name descname">kmsg_dump_get_buffer</code><span class="sig-paren">(</span><em class="property">struct</em> kmsg_dumper *<em>dumper</em>, bool <em>syslog</em>, char *<em>buf</em>, size_t <em>size</em>, size_t *<em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_get_buffer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy kmsg log lines</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*dumper</span></code></dt><dd><p>registered kmsg dumper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">syslog</span></code></dt><dd><p>include the “&lt;4&gt;” prefixes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to copy the line to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>maximum size of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*len</span></code></dt><dd><p>length of line placed into buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start at the end of the kmsg buffer and fill the provided buffer
with as many of the <em>youngest</em> kmsg records that fit into it.
If the buffer is large enough, all available kmsg records will be
copied with a single call.</p>
<p>Consecutive calls will fill the buffer with the next block of
available older records, not including the earlier retrieved ones.</p>
<p>A return value of FALSE indicates that there are no more records to
read.</p>
<dl class="c function">
<dt id="c.kmsg_dump_rewind">
void <code class="sig-name descname">kmsg_dump_rewind</code><span class="sig-paren">(</span><em class="property">struct</em> kmsg_dumper *<em>dumper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_rewind" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reset the iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*dumper</span></code></dt><dd><p>registered kmsg dumper</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset the dumper’s iterator so that <a class="reference internal" href="#c.kmsg_dump_get_line" title="kmsg_dump_get_line"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmsg_dump_get_line()</span></code></a> and
<a class="reference internal" href="#c.kmsg_dump_get_buffer" title="kmsg_dump_get_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmsg_dump_get_buffer()</span></code></a> can be called again and used multiple
times within the same dumper.dump() callback.</p>
<dl class="c function">
<dt id="c.panic">
void <code class="sig-name descname">panic</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.panic" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>halt the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The text string to print</p>
<p>Display a message, then perform cleanups.</p>
<p>This function never returns.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.add_taint">
void <code class="sig-name descname">add_taint</code><span class="sig-paren">(</span>unsigned <em>flag</em>, <em class="property">enum</em> <a class="reference internal" href="#c.add_taint" title="lockdep_ok">lockdep_ok</a> <em>lockdep_ok</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_taint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flag</span></code></dt><dd><p>one of the TAINT_* constants.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">lockdep_ok</span> <span class="pre">lockdep_ok</span></code></dt><dd><p>whether lock debugging is still OK.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If something bad has gone wrong, you’ll want <strong>lockdebug_ok</strong> = false, but for
some notewortht-but-not-corrupting cases, it can be set to true.</p>
<dl class="c function">
<dt id="c.array_size">
size_t <code class="sig-name descname">array_size</code><span class="sig-paren">(</span>size_t <em>a</em>, size_t <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.array_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate size of 2-dimensional array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">a</span></code></dt><dd><p>dimension one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">b</span></code></dt><dd><p>dimension two</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates size of 2-dimensional array: <strong>a</strong> * <strong>b</strong>.</p>
<p><strong>Return</strong></p>
<p>number of bytes needed to represent the array or SIZE_MAX on
overflow.</p>
<dl class="c function">
<dt id="c.array3_size">
size_t <code class="sig-name descname">array3_size</code><span class="sig-paren">(</span>size_t <em>a</em>, size_t <em>b</em>, size_t <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.array3_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate size of 3-dimensional array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">a</span></code></dt><dd><p>dimension one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">b</span></code></dt><dd><p>dimension two</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">c</span></code></dt><dd><p>dimension three</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates size of 3-dimensional array: <strong>a</strong> * <strong>b</strong> * <strong>c</strong>.</p>
<p><strong>Return</strong></p>
<p>number of bytes needed to represent the array or SIZE_MAX on
overflow.</p>
<dl class="c macro">
<dt id="c.struct_size">
<code class="sig-name descname">struct_size</code><a class="headerlink" href="#c.struct_size" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">struct_size</span> <span class="pre">(p,</span> <span class="pre">member,</span> <span class="pre">count)</span></code></p>
<blockquote>
<div><p>Calculate size of structure with trailing array.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>Pointer to the structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>Name of the array member.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates size of memory needed for structure <strong>p</strong> followed by an
array of <strong>count</strong> number of <strong>member</strong> elements.</p>
<p><strong>Return</strong></p>
<p>number of bytes needed or SIZE_MAX on overflow.</p>
<dl class="c macro">
<dt id="c.flex_array_size">
<code class="sig-name descname">flex_array_size</code><a class="headerlink" href="#c.flex_array_size" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">flex_array_size</span> <span class="pre">(p,</span> <span class="pre">member,</span> <span class="pre">count)</span></code></p>
<blockquote>
<div><p>Calculate size of a flexible array member within an enclosing structure.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>Pointer to the structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>Name of the flexible array member.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates size of a flexible array of <strong>count</strong> number of <strong>member</strong>
elements, at the end of structure <strong>p</strong>.</p>
<p><strong>Return</strong></p>
<p>number of bytes needed or SIZE_MAX on overflow.</p>
</div>
<div class="section" id="device-resource-management">
<h2>Device Resource Management<a class="headerlink" href="#device-resource-management" title="Permalink to this headline">¶</a></h2>
<dl class="c function">
<dt id="c.devres_alloc_node">
void *<code class="sig-name descname">devres_alloc_node</code><span class="sig-paren">(</span>dr_release_t <em>release</em>, size_t <em>size</em>, gfp_t <em>gfp</em>, int <em>nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_alloc_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate device resource data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Release function devres will be associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>NUMA node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate devres of <strong>size</strong> bytes.  The allocated area is zeroed, then
associated with <strong>release</strong>.  The returned pointer can be passed to
other devres_*() functions.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated devres on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.devres_for_each_res">
void <code class="sig-name descname">devres_for_each_res</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, dr_release_t <em>release</em>, dr_match_t <em>match</em>, void *<em>match_data</em>, void (*<em>fn</em>)<span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a>*, void*, void*<span class="sig-paren">)</span>, void *<em>data</em>, <span class="sig-paren">)</span><a class="headerlink" href="#c.devres_for_each_res" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to iterate resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Function to be called for each matched resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data for <strong>fn</strong>, the 3rd parameter of <strong>fn</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <strong>fn</strong> for each devres of <strong>dev</strong> which is associated with <strong>release</strong>
and for which <strong>match</strong> returns 1.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>void</p>
</div></blockquote>
<dl class="c function">
<dt id="c.devres_free">
void <code class="sig-name descname">devres_free</code><span class="sig-paren">(</span>void *<em>res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free device resource data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*res</span></code></dt><dd><p>Pointer to devres data to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free devres created with devres_alloc().</p>
<dl class="c function">
<dt id="c.devres_add">
void <code class="sig-name descname">devres_add</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void *<em>res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register device resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to add resource to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*res</span></code></dt><dd><p>Resource to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register devres <strong>res</strong> to <strong>dev</strong>.  <strong>res</strong> should have been allocated
using devres_alloc().  On driver detach, the associated release
function will be invoked and devres will be freed automatically.</p>
<dl class="c function">
<dt id="c.devres_find">
void *<code class="sig-name descname">devres_find</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, dr_release_t <em>release</em>, dr_match_t <em>match</em>, void *<em>match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_find" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find device resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to lookup resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> which is associated with <strong>release</strong>
and for which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered
to match all.</p>
<p><strong>Return</strong></p>
<p>Pointer to found devres, NULL if not found.</p>
<dl class="c function">
<dt id="c.devres_get">
void *<code class="sig-name descname">devres_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void *<em>new_res</em>, dr_match_t <em>match</em>, void *<em>match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find devres, if non-existent, add one atomically</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to lookup or add devres for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*new_res</span></code></dt><dd><p>Pointer to new initialized devres to add if not found</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> which has the same release function
as <strong>new_res</strong> and for which <strong>match</strong> return 1.  If found, <strong>new_res</strong> is
freed; otherwise, <strong>new_res</strong> is added atomically.</p>
<p><strong>Return</strong></p>
<p>Pointer to found or added devres.</p>
<dl class="c function">
<dt id="c.devres_remove">
void *<code class="sig-name descname">devres_remove</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, dr_release_t <em>release</em>, dr_match_t <em>match</em>, void *<em>match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_remove" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a device resource and remove it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered to
match all.  If found, the resource is removed atomically and
returned.</p>
<p><strong>Return</strong></p>
<p>Pointer to removed devres on success, NULL if not found.</p>
<dl class="c function">
<dt id="c.devres_destroy">
int <code class="sig-name descname">devres_destroy</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, dr_release_t <em>release</em>, dr_match_t <em>match</em>, void *<em>match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a device resource and destroy it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered to
match all.  If found, the resource is removed atomically and freed.</p>
<p>Note that the release function for the resource will not be called,
only the devres-allocated data will be freed.  The caller becomes
responsible for freeing any other data.</p>
<p><strong>Return</strong></p>
<p>0 if devres is found and freed, -ENOENT if not found.</p>
<dl class="c function">
<dt id="c.devres_release">
int <code class="sig-name descname">devres_release</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, dr_release_t <em>release</em>, dr_match_t <em>match</em>, void *<em>match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_release" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a device resource and destroy it, calling release</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered to
match all.  If found, the resource is removed atomically, the
release function called and the resource freed.</p>
<p><strong>Return</strong></p>
<p>0 if devres is found and freed, -ENOENT if not found.</p>
<dl class="c function">
<dt id="c.devres_open_group">
void *<code class="sig-name descname">devres_open_group</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void *<em>id</em>, gfp_t <em>gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_open_group" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open a new devres group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to open devres group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>Separator ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open a new devres group for <strong>dev</strong> with <strong>id</strong>.  For <strong>id</strong>, using a
pointer to an object which won’t be used for another group is
recommended.  If <strong>id</strong> is NULL, address-wise unique ID is created.</p>
<p><strong>Return</strong></p>
<p>ID of the new group, NULL on failure.</p>
<dl class="c function">
<dt id="c.devres_close_group">
void <code class="sig-name descname">devres_close_group</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void *<em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_close_group" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Close a devres group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to close devres group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>ID of target group, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Close the group identified by <strong>id</strong>.  If <strong>id</strong> is NULL, the latest open
group is selected.</p>
<dl class="c function">
<dt id="c.devres_remove_group">
void <code class="sig-name descname">devres_remove_group</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void *<em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_remove_group" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove a devres group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to remove group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>ID of target group, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove the group identified by <strong>id</strong>.  If <strong>id</strong> is NULL, the latest
open group is selected.  Note that removing a group doesn’t affect
any other resources.</p>
<dl class="c function">
<dt id="c.devres_release_group">
int <code class="sig-name descname">devres_release_group</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void *<em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_release_group" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release resources in a devres group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to release group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>ID of target group, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release all resources in the group identified by <strong>id</strong>.  If <strong>id</strong> is
NULL, the latest open group is selected.  The selected group and
groups properly nested inside the selected group are removed.</p>
<p><strong>Return</strong></p>
<p>The number of released non-group resources.</p>
<dl class="c function">
<dt id="c.devm_add_action">
int <code class="sig-name descname">devm_add_action</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void (*<em>action</em>)<span class="sig-paren">(</span>void*<span class="sig-paren">)</span>, void *<em>data</em>, <span class="sig-paren">)</span><a class="headerlink" href="#c.devm_add_action" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a custom action to list of managed resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device that owns the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*action)(void</span> <span class="pre">*)</span></code></dt><dd><p>Function that should be called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to data passed to <strong>action</strong> implementation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds a custom action to the list of managed resources so that
it gets executed as part of standard resource unwinding.</p>
<dl class="c function">
<dt id="c.devm_remove_action">
void <code class="sig-name descname">devm_remove_action</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void (*<em>action</em>)<span class="sig-paren">(</span>void*<span class="sig-paren">)</span>, void *<em>data</em>, <span class="sig-paren">)</span><a class="headerlink" href="#c.devm_remove_action" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>removes previously added custom action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device that owns the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*action)(void</span> <span class="pre">*)</span></code></dt><dd><p>Function implementing the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to data passed to <strong>action</strong> implementation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes instance of <strong>action</strong> previously added by <a class="reference internal" href="#c.devm_add_action" title="devm_add_action"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_add_action()</span></code></a>.
Both action and data should match one of the existing entries.</p>
<dl class="c function">
<dt id="c.devm_release_action">
void <code class="sig-name descname">devm_release_action</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void (*<em>action</em>)<span class="sig-paren">(</span>void*<span class="sig-paren">)</span>, void *<em>data</em>, <span class="sig-paren">)</span><a class="headerlink" href="#c.devm_release_action" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release previously added custom action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device that owns the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*action)(void</span> <span class="pre">*)</span></code></dt><dd><p>Function implementing the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to data passed to <strong>action</strong> implementation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases and removes instance of <strong>action</strong> previously added by
<a class="reference internal" href="#c.devm_add_action" title="devm_add_action"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_add_action()</span></code></a>.  Both action and data should match one of the
existing entries.</p>
<dl class="c function">
<dt id="c.devm_kmalloc">
void *<code class="sig-name descname">devm_kmalloc</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, size_t <em>size</em>, gfp_t <em>gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kmalloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed kmalloc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation gfp flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed kmalloc.  Memory allocated with this function is
automatically freed on driver detach.  Like all other devres
resources, guaranteed alignment is unsigned long long.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.devm_krealloc">
void *<code class="sig-name descname">devm_krealloc</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void *<em>ptr</em>, size_t <em>new_size</em>, gfp_t <em>gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_krealloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed <a class="reference internal" href="../core-api/mm-api.html#c.krealloc" title="krealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">krealloc()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to re-allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>Pointer to the memory chunk to re-allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">new_size</span></code></dt><dd><p>New allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation gfp flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="../core-api/mm-api.html#c.krealloc" title="krealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">krealloc()</span></code></a>. Resizes the memory chunk allocated with <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a>.
Behaves similarly to regular <a class="reference internal" href="../core-api/mm-api.html#c.krealloc" title="krealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">krealloc()</span></code></a>: if <strong>ptr</strong> is NULL or ZERO_SIZE_PTR,
it’s the equivalent of <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a>. If new_size is zero, it frees the
previously allocated memory and returns ZERO_SIZE_PTR. This function doesn’t
change the order in which the release callback for the re-alloc’ed devres
will be called (except when falling back to <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> or when freeing
resources when new_size is zero). The contents of the memory are preserved
up to the lesser of new and old sizes.</p>
<dl class="c function">
<dt id="c.devm_kstrdup">
char *<code class="sig-name descname">devm_kstrdup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, <em class="property">const</em> char *<em>s</em>, gfp_t <em>gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kstrdup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate resource managed space and copy an existing string into that.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.devm_kstrdup_const">
<em class="property">const</em> char *<code class="sig-name descname">devm_kstrdup_const</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, <em class="property">const</em> char *<em>s</em>, gfp_t <em>gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kstrdup_const" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>resource managed conditional string duplication</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for which to duplicate the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Strings allocated by devm_kstrdup_const will be automatically freed when
the associated device is detached.</p>
<p><strong>Return</strong></p>
<p>Source string if it is in .rodata section otherwise it falls back to
devm_kstrdup.</p>
<dl class="c function">
<dt id="c.devm_kvasprintf">
char *<code class="sig-name descname">devm_kvasprintf</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, gfp_t <em>gfp</em>, <em class="property">const</em> char *<em>fmt</em>, va_list <em>ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kvasprintf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate resource managed space and format a string into that.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The printf()-style format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">ap</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.devm_kasprintf">
char *<code class="sig-name descname">devm_kasprintf</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, gfp_t <em>gfp</em>, <em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kasprintf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate resource managed space and format a string into that.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The printf()-style format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.devm_kfree">
void <code class="sig-name descname">devm_kfree</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, <em class="property">const</em> void *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kfree" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed kfree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>Memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a>.</p>
<dl class="c function">
<dt id="c.devm_kmemdup">
void *<code class="sig-name descname">devm_kmemdup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, <em class="property">const</em> void *<em>src</em>, size_t <em>len</em>, gfp_t <em>gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kmemdup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed kmemdup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*src</span></code></dt><dd><p>Memory region to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>Memory region length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP mask to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Duplicate region of a memory using resource managed kmalloc</p>
<dl class="c function">
<dt id="c.devm_get_free_pages">
unsigned long <code class="sig-name descname">devm_get_free_pages</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, gfp_t <em>gfp_mask</em>, unsigned int <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_get_free_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed __get_free_pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>Allocation gfp flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Allocation size is (1 &lt;&lt; order) pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed get_free_pages.  Memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Address of allocated memory on success, 0 on failure.</p>
<dl class="c function">
<dt id="c.devm_free_pages">
void <code class="sig-name descname">devm_free_pages</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, unsigned long <em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_free_pages" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed free_pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>Memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="#c.devm_get_free_pages" title="devm_get_free_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_get_free_pages()</span></code></a>. Unlike free_pages,
there is no need to supply the <strong>order</strong>.</p>
<dl class="c function">
<dt id="c.__devm_alloc_percpu">
void __percpu *<code class="sig-name descname">__devm_alloc_percpu</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, size_t <em>size</em>, size_t <em>align</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__devm_alloc_percpu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed alloc_percpu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate per-cpu memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of per-cpu memory to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>Alignment of per-cpu memory to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed alloc_percpu. Per-cpu memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.devm_free_percpu">
void <code class="sig-name descname">devm_free_percpu</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, void __percpu *<em>pdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_free_percpu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed free_percpu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*pdata</span></code></dt><dd><p>Per-cpu memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="infrastructure.html#c.devm_alloc_percpu" title="devm_alloc_percpu"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_alloc_percpu()</span></code></a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="infrastructure.html" class="btn btn-neutral float-right" title="Device drivers infrastructure" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="driver-model/porting.html" class="btn btn-neutral float-left" title="Porting Drivers to the New Driver Model" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>