

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>drm/i915 Intel GFX Driver &mdash; The Linux Kernel 5.10.0-rc6+ documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="drm/mcde ST-Ericsson MCDE Multi-channel display engine" href="mcde.html" />
    <link rel="prev" title="drm/amd/display - Display Core (DC)" href="amdgpu-dc.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-client.html">Kernel clients</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="drivers.html">GPU Driver Documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="amdgpu.html">drm/amdgpu AMDgpu driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="amdgpu-dc.html">drm/amd/display - Display Core (DC)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">drm/i915 Intel GFX Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#core-driver-infrastructure">Core Driver Infrastructure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#display-hardware-handling">Display Hardware Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-management-and-command-submission">Memory Management and Command Submission</a></li>
<li class="toctree-l4"><a class="reference internal" href="#microcontrollers">Microcontrollers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tracing">Tracing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#perf">Perf</a></li>
<li class="toctree-l4"><a class="reference internal" href="#style">Style</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mcde.html">drm/mcde ST-Ericsson MCDE Multi-channel display engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l3"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL110 and PL111 CLCD Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="tve200.html">drm/tve200 Faraday TV Encoder 200</a></li>
<li class="toctree-l3"><a class="reference internal" href="v3d.html">drm/v3d Broadcom V3D Graphics Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="vkms.html">drm/vkms Virtual Kernel Modesetting</a></li>
<li class="toctree-l3"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="xen-front.html">drm/xen-front Xen para-virtualized frontend driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="afbc.html">Arm Framebuffer Compression (AFBC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="komeda-kms.html">drm/komeda Arm display driver</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="backlight.html">Backlight support</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Linux GPU Driver Developer’s Guide</a> &raquo;</li>
        
          <li><a href="drivers.html">GPU Driver Documentation</a> &raquo;</li>
        
      <li>drm/i915 Intel GFX Driver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/i915.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="drm-i915-intel-gfx-driver">
<h1>drm/i915 Intel GFX Driver<a class="headerlink" href="#drm-i915-intel-gfx-driver" title="Permalink to this headline">¶</a></h1>
<p>The drm/i915 driver supports all (with the exception of some very early
models) integrated GFX chipsets with both Intel display and rendering
blocks. This excludes a set of SoC platforms with an SGX rendering unit,
those have basic support through the gma500 drm driver.</p>
<div class="section" id="core-driver-infrastructure">
<h2>Core Driver Infrastructure<a class="headerlink" href="#core-driver-infrastructure" title="Permalink to this headline">¶</a></h2>
<p>This section covers core driver infrastructure used by both the display
and the GEM parts of the driver.</p>
<div class="section" id="runtime-power-management">
<h3>Runtime Power Management<a class="headerlink" href="#runtime-power-management" title="Permalink to this headline">¶</a></h3>
<p>The i915 driver supports dynamic enabling and disabling of entire hardware
blocks at runtime. This is especially important on the display side where
software is supposed to control many power gates manually on recent hardware,
since on the GT side a lot of the power management is done by the hardware.
But even there some manual control at the device level is required.</p>
<p>Since i915 supports a diverse set of platforms with a unified codebase and
hardware engineers just love to shuffle functionality around between power
domains there’s a sizeable amount of indirection required. This file provides
generic functions to the driver for grabbing and releasing references for
abstract power domains. It then maps those to the actual power wells
present for a given platform.</p>
<dl class="c function">
<dt id="c.intel_runtime_pm_get_raw">
intel_wakeref_t <code class="sig-name descname">intel_runtime_pm_get_raw</code><span class="sig-paren">(</span><em class="property">struct</em> intel_runtime_pm *<em>rpm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_get_raw" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>grab a raw runtime pm reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_runtime_pm</span> <span class="pre">*rpm</span></code></dt><dd><p>the intel_runtime_pm structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the unlocked version of intel_display_power_is_enabled() and should
only be used from error capture and recovery code where deadlocks are
possible.
This function grabs a device-level runtime pm reference (mostly used for
asynchronous PM management from display code) and ensures that it is powered
up. Raw references are not considered during wakelock assert checks.</p>
<p>Any runtime pm reference obtained by this function must have a symmetric
call to <a class="reference internal" href="#c.intel_runtime_pm_put_raw" title="intel_runtime_pm_put_raw"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_put_raw()</span></code></a> to release the reference again.</p>
<p><strong>Return</strong></p>
<p>the wakeref cookie to pass to <a class="reference internal" href="#c.intel_runtime_pm_put_raw" title="intel_runtime_pm_put_raw"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_put_raw()</span></code></a>, evaluates
as True if the wakeref was acquired, or False otherwise.</p>
<dl class="c function">
<dt id="c.intel_runtime_pm_get">
intel_wakeref_t <code class="sig-name descname">intel_runtime_pm_get</code><span class="sig-paren">(</span><em class="property">struct</em> intel_runtime_pm *<em>rpm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>grab a runtime pm reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_runtime_pm</span> <span class="pre">*rpm</span></code></dt><dd><p>the intel_runtime_pm structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function grabs a device-level runtime pm reference (mostly used for GEM
code to ensure the GTT or GT is on) and ensures that it is powered up.</p>
<p>Any runtime pm reference obtained by this function must have a symmetric
call to <a class="reference internal" href="#c.intel_runtime_pm_put" title="intel_runtime_pm_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_put()</span></code></a> to release the reference again.</p>
<p><strong>Return</strong></p>
<p>the wakeref cookie to pass to <a class="reference internal" href="#c.intel_runtime_pm_put" title="intel_runtime_pm_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_put()</span></code></a></p>
<dl class="c function">
<dt id="c.intel_runtime_pm_get_if_in_use">
intel_wakeref_t <code class="sig-name descname">intel_runtime_pm_get_if_in_use</code><span class="sig-paren">(</span><em class="property">struct</em> intel_runtime_pm *<em>rpm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_get_if_in_use" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>grab a runtime pm reference if device in use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_runtime_pm</span> <span class="pre">*rpm</span></code></dt><dd><p>the intel_runtime_pm structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function grabs a device-level runtime pm reference if the device is
already in use and ensures that it is powered up. It is illegal to try
and access the HW should <a class="reference internal" href="#c.intel_runtime_pm_get_if_in_use" title="intel_runtime_pm_get_if_in_use"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_get_if_in_use()</span></code></a> report failure.</p>
<p>Any runtime pm reference obtained by this function must have a symmetric
call to <a class="reference internal" href="#c.intel_runtime_pm_put" title="intel_runtime_pm_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_put()</span></code></a> to release the reference again.</p>
<p><strong>Return</strong></p>
<p>the wakeref cookie to pass to <a class="reference internal" href="#c.intel_runtime_pm_put" title="intel_runtime_pm_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_put()</span></code></a>, evaluates
as True if the wakeref was acquired, or False otherwise.</p>
<dl class="c function">
<dt id="c.intel_runtime_pm_get_noresume">
intel_wakeref_t <code class="sig-name descname">intel_runtime_pm_get_noresume</code><span class="sig-paren">(</span><em class="property">struct</em> intel_runtime_pm *<em>rpm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_get_noresume" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>grab a runtime pm reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_runtime_pm</span> <span class="pre">*rpm</span></code></dt><dd><p>the intel_runtime_pm structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function grabs a device-level runtime pm reference (mostly used for GEM
code to ensure the GTT or GT is on).</p>
<p>It will _not_ power up the device but instead only check that it’s powered
on.  Therefore it is only valid to call this functions from contexts where
the device is known to be powered up and where trying to power it up would
result in hilarity and deadlocks. That pretty much means only the system
suspend/resume code where this is used to grab runtime pm references for
delayed setup down in work items.</p>
<p>Any runtime pm reference obtained by this function must have a symmetric
call to <a class="reference internal" href="#c.intel_runtime_pm_put" title="intel_runtime_pm_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_put()</span></code></a> to release the reference again.</p>
<p><strong>Return</strong></p>
<p>the wakeref cookie to pass to <a class="reference internal" href="#c.intel_runtime_pm_put" title="intel_runtime_pm_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_put()</span></code></a></p>
<dl class="c function">
<dt id="c.intel_runtime_pm_put_raw">
void <code class="sig-name descname">intel_runtime_pm_put_raw</code><span class="sig-paren">(</span><em class="property">struct</em> intel_runtime_pm *<em>rpm</em>, intel_wakeref_t <em>wref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_put_raw" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a raw runtime pm reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_runtime_pm</span> <span class="pre">*rpm</span></code></dt><dd><p>the intel_runtime_pm structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">intel_wakeref_t</span> <span class="pre">wref</span></code></dt><dd><p>wakeref acquired for the reference that is being released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function drops the device-level runtime pm reference obtained by
<a class="reference internal" href="#c.intel_runtime_pm_get_raw" title="intel_runtime_pm_get_raw"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_get_raw()</span></code></a> and might power down the corresponding
hardware block right away if this is the last reference.</p>
<dl class="c function">
<dt id="c.intel_runtime_pm_put_unchecked">
void <code class="sig-name descname">intel_runtime_pm_put_unchecked</code><span class="sig-paren">(</span><em class="property">struct</em> intel_runtime_pm *<em>rpm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_put_unchecked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release an unchecked runtime pm reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_runtime_pm</span> <span class="pre">*rpm</span></code></dt><dd><p>the intel_runtime_pm structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function drops the device-level runtime pm reference obtained by
<a class="reference internal" href="#c.intel_runtime_pm_get" title="intel_runtime_pm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_get()</span></code></a> and might power down the corresponding
hardware block right away if this is the last reference.</p>
<p>This function exists only for historical reasons and should be avoided in
new code, as the correctness of its use cannot be checked. Always use
<a class="reference internal" href="#c.intel_runtime_pm_put" title="intel_runtime_pm_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_put()</span></code></a> instead.</p>
<dl class="c function">
<dt id="c.intel_runtime_pm_put">
void <code class="sig-name descname">intel_runtime_pm_put</code><span class="sig-paren">(</span><em class="property">struct</em> intel_runtime_pm *<em>rpm</em>, intel_wakeref_t <em>wref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a runtime pm reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_runtime_pm</span> <span class="pre">*rpm</span></code></dt><dd><p>the intel_runtime_pm structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">intel_wakeref_t</span> <span class="pre">wref</span></code></dt><dd><p>wakeref acquired for the reference that is being released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function drops the device-level runtime pm reference obtained by
<a class="reference internal" href="#c.intel_runtime_pm_get" title="intel_runtime_pm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_runtime_pm_get()</span></code></a> and might power down the corresponding
hardware block right away if this is the last reference.</p>
<dl class="c function">
<dt id="c.intel_runtime_pm_enable">
void <code class="sig-name descname">intel_runtime_pm_enable</code><span class="sig-paren">(</span><em class="property">struct</em> intel_runtime_pm *<em>rpm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable runtime pm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_runtime_pm</span> <span class="pre">*rpm</span></code></dt><dd><p>the intel_runtime_pm structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables runtime pm at the end of the driver load sequence.</p>
<p>Note that this function does currently not enable runtime pm for the
subordinate display power domains. That is done by
intel_power_domains_enable().</p>
<dl class="c function">
<dt id="c.intel_uncore_forcewake_get">
void <code class="sig-name descname">intel_uncore_forcewake_get</code><span class="sig-paren">(</span><em class="property">struct</em> intel_uncore *<em>uncore</em>, <em class="property">enum</em> forcewake_domains <em>fw_domains</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>grab forcewake domain references</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_uncore</span> <span class="pre">*uncore</span></code></dt><dd><p>the intel_uncore structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">forcewake_domains</span> <span class="pre">fw_domains</span></code></dt><dd><p>forcewake domains to get reference on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used get GT’s forcewake domain references.
Normal register access will handle the forcewake domains automatically.
However if some sequence requires the GT to not power down a particular
forcewake domains this function should be called at the beginning of the
sequence. And subsequently the reference should be dropped by symmetric
call to intel_unforce_forcewake_put(). Usually caller wants all the domains
to be kept awake so the <strong>fw_domains</strong> would be then FORCEWAKE_ALL.</p>
<dl class="c function">
<dt id="c.intel_uncore_forcewake_user_get">
void <code class="sig-name descname">intel_uncore_forcewake_user_get</code><span class="sig-paren">(</span><em class="property">struct</em> intel_uncore *<em>uncore</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_user_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>claim forcewake on behalf of userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_uncore</span> <span class="pre">*uncore</span></code></dt><dd><p>the intel_uncore structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a wrapper around <a class="reference internal" href="#c.intel_uncore_forcewake_get" title="intel_uncore_forcewake_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_uncore_forcewake_get()</span></code></a> to acquire
the GT powerwell and in the process disable our debugging for the
duration of userspace’s bypass.</p>
<dl class="c function">
<dt id="c.intel_uncore_forcewake_user_put">
void <code class="sig-name descname">intel_uncore_forcewake_user_put</code><span class="sig-paren">(</span><em class="property">struct</em> intel_uncore *<em>uncore</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_user_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release forcewake on behalf of userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_uncore</span> <span class="pre">*uncore</span></code></dt><dd><p>the intel_uncore structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function complements <a class="reference internal" href="#c.intel_uncore_forcewake_user_get" title="intel_uncore_forcewake_user_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_uncore_forcewake_user_get()</span></code></a> and releases
the GT powerwell taken on behalf of the userspace bypass.</p>
<dl class="c function">
<dt id="c.intel_uncore_forcewake_get__locked">
void <code class="sig-name descname">intel_uncore_forcewake_get__locked</code><span class="sig-paren">(</span><em class="property">struct</em> intel_uncore *<em>uncore</em>, <em class="property">enum</em> forcewake_domains <em>fw_domains</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_get__locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>grab forcewake domain references</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_uncore</span> <span class="pre">*uncore</span></code></dt><dd><p>the intel_uncore structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">forcewake_domains</span> <span class="pre">fw_domains</span></code></dt><dd><p>forcewake domains to get reference on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.intel_uncore_forcewake_get" title="intel_uncore_forcewake_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_uncore_forcewake_get()</span></code></a>. This variant places the onus
on the caller to explicitly handle the dev_priv-&gt;uncore.lock spinlock.</p>
<dl class="c function">
<dt id="c.intel_uncore_forcewake_put">
void <code class="sig-name descname">intel_uncore_forcewake_put</code><span class="sig-paren">(</span><em class="property">struct</em> intel_uncore *<em>uncore</em>, <em class="property">enum</em> forcewake_domains <em>fw_domains</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a forcewake domain reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_uncore</span> <span class="pre">*uncore</span></code></dt><dd><p>the intel_uncore structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">forcewake_domains</span> <span class="pre">fw_domains</span></code></dt><dd><p>forcewake domains to put references</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function drops the device-level forcewakes for specified
domains obtained by <a class="reference internal" href="#c.intel_uncore_forcewake_get" title="intel_uncore_forcewake_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_uncore_forcewake_get()</span></code></a>.</p>
<dl class="c function">
<dt id="c.intel_uncore_forcewake_flush">
void <code class="sig-name descname">intel_uncore_forcewake_flush</code><span class="sig-paren">(</span><em class="property">struct</em> intel_uncore *<em>uncore</em>, <em class="property">enum</em> forcewake_domains <em>fw_domains</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>flush the delayed release</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_uncore</span> <span class="pre">*uncore</span></code></dt><dd><p>the intel_uncore structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">forcewake_domains</span> <span class="pre">fw_domains</span></code></dt><dd><p>forcewake domains to flush</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.intel_uncore_forcewake_put__locked">
void <code class="sig-name descname">intel_uncore_forcewake_put__locked</code><span class="sig-paren">(</span><em class="property">struct</em> intel_uncore *<em>uncore</em>, <em class="property">enum</em> forcewake_domains <em>fw_domains</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_put__locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>grab forcewake domain references</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_uncore</span> <span class="pre">*uncore</span></code></dt><dd><p>the intel_uncore structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">forcewake_domains</span> <span class="pre">fw_domains</span></code></dt><dd><p>forcewake domains to get reference on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.intel_uncore_forcewake_put" title="intel_uncore_forcewake_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_uncore_forcewake_put()</span></code></a>. This variant places the onus
on the caller to explicitly handle the dev_priv-&gt;uncore.lock spinlock.</p>
<dl class="c function">
<dt id="c.__intel_wait_for_register_fw">
int <code class="sig-name descname">__intel_wait_for_register_fw</code><span class="sig-paren">(</span><em class="property">struct</em> intel_uncore *<em>uncore</em>, i915_reg_t <em>reg</em>, u32 <em>mask</em>, u32 <em>value</em>, unsigned int <em>fast_timeout_us</em>, unsigned int <em>slow_timeout_ms</em>, u32 *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__intel_wait_for_register_fw" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait until register matches expected state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_uncore</span> <span class="pre">*uncore</span></code></dt><dd><p>the struct intel_uncore</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i915_reg_t</span> <span class="pre">reg</span></code></dt><dd><p>the register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mask</span></code></dt><dd><p>mask to apply to register value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">value</span></code></dt><dd><p>expected value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fast_timeout_us</span></code></dt><dd><p>fast timeout in microsecond for atomic/tight wait</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slow_timeout_ms</span></code></dt><dd><p>slow timeout in millisecond</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*out_value</span></code></dt><dd><p>optional placeholder to hold registry value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine waits until the target register <strong>reg</strong> contains the expected
<strong>value</strong> after applying the <strong>mask</strong>, i.e. it waits until</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(I915_READ_FW(reg) &amp; mask) == value
</pre></div>
</div>
<p>Otherwise, the wait will timeout after <strong>slow_timeout_ms</strong> milliseconds.
For atomic context <strong>slow_timeout_ms</strong> must be zero and <strong>fast_timeout_us</strong>
must be not larger than 20,0000 microseconds.</p>
<p>Note that this routine assumes the caller holds forcewake asserted, it is
not suitable for very long waits. See intel_wait_for_register() if you
wish to wait without holding forcewake for the duration (i.e. you expect
the wait to be slow).</p>
<p><strong>Return</strong></p>
<p>0 if the register matches the desired condition, or -ETIMEDOUT.</p>
<dl class="c function">
<dt id="c.__intel_wait_for_register">
int <code class="sig-name descname">__intel_wait_for_register</code><span class="sig-paren">(</span><em class="property">struct</em> intel_uncore *<em>uncore</em>, i915_reg_t <em>reg</em>, u32 <em>mask</em>, u32 <em>value</em>, unsigned int <em>fast_timeout_us</em>, unsigned int <em>slow_timeout_ms</em>, u32 *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__intel_wait_for_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait until register matches expected state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_uncore</span> <span class="pre">*uncore</span></code></dt><dd><p>the struct intel_uncore</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i915_reg_t</span> <span class="pre">reg</span></code></dt><dd><p>the register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mask</span></code></dt><dd><p>mask to apply to register value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">value</span></code></dt><dd><p>expected value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fast_timeout_us</span></code></dt><dd><p>fast timeout in microsecond for atomic/tight wait</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slow_timeout_ms</span></code></dt><dd><p>slow timeout in millisecond</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*out_value</span></code></dt><dd><p>optional placeholder to hold registry value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine waits until the target register <strong>reg</strong> contains the expected
<strong>value</strong> after applying the <strong>mask</strong>, i.e. it waits until</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(I915_READ(reg) &amp; mask) == value
</pre></div>
</div>
<p>Otherwise, the wait will timeout after <strong>timeout_ms</strong> milliseconds.</p>
<p><strong>Return</strong></p>
<p>0 if the register matches the desired condition, or -ETIMEDOUT.</p>
<dl class="c function">
<dt id="c.intel_uncore_forcewake_for_reg">
<em class="property">enum</em> forcewake_domains <code class="sig-name descname">intel_uncore_forcewake_for_reg</code><span class="sig-paren">(</span><em class="property">struct</em> intel_uncore *<em>uncore</em>, i915_reg_t <em>reg</em>, unsigned int <em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_for_reg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>which forcewake domains are needed to access a register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_uncore</span> <span class="pre">*uncore</span></code></dt><dd><p>pointer to struct intel_uncore</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i915_reg_t</span> <span class="pre">reg</span></code></dt><dd><p>register in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt><dd><p>operation bitmask of FW_REG_READ and/or FW_REG_WRITE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a set of forcewake domains required to be taken with for example
intel_uncore_forcewake_get for the specified register to be accessible in the
specified mode (read, write or read/write) with raw mmio accessors.</p>
<p><strong>NOTE</strong></p>
<p>On Gen6 and Gen7 write forcewake domain (FORCEWAKE_RENDER) requires the
callers to do FIFO management on their own or risk losing writes.</p>
</div>
<div class="section" id="interrupt-handling">
<h3>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h3>
<p>These functions provide the basic support for enabling and disabling the
interrupt handling support. There’s a lot more functionality in i915_irq.c
and related files, but that will be described in separate chapters.</p>
<dl class="c function">
<dt id="c.intel_irq_init">
void <code class="sig-name descname">intel_irq_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_irq_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initializes irq support</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes all the irq support including work items, timers
and all the vtables. It does not setup the interrupt itself though.</p>
<dl class="c function">
<dt id="c.intel_runtime_pm_disable_interrupts">
void <code class="sig-name descname">intel_runtime_pm_disable_interrupts</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_disable_interrupts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>runtime interrupt disabling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to disable interrupts at runtime, both in the runtime
pm and the system suspend/resume code.</p>
<dl class="c function">
<dt id="c.intel_runtime_pm_enable_interrupts">
void <code class="sig-name descname">intel_runtime_pm_enable_interrupts</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_enable_interrupts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>runtime interrupt enabling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to enable interrupts at runtime, both in the runtime
pm and the system suspend/resume code.</p>
</div>
<div class="section" id="intel-gvt-g-guest-support-vgpu">
<h3>Intel GVT-g Guest Support(vGPU)<a class="headerlink" href="#intel-gvt-g-guest-support-vgpu" title="Permalink to this headline">¶</a></h3>
<p>Intel GVT-g is a graphics virtualization technology which shares the
GPU among multiple virtual machines on a time-sharing basis. Each
virtual machine is presented a virtual GPU (vGPU), which has equivalent
features as the underlying physical GPU (pGPU), so i915 driver can run
seamlessly in a virtual machine. This file provides vGPU specific
optimizations when running in a virtual machine, to reduce the complexity
of vGPU emulation and to improve the overall performance.</p>
<p>A primary function introduced here is so-called “address space ballooning”
technique. Intel GVT-g partitions global graphics memory among multiple VMs,
so each VM can directly access a portion of the memory without hypervisor’s
intervention, e.g. filling textures or queuing commands. However with the
partitioning an unmodified i915 driver would assume a smaller graphics
memory starting from address ZERO, then requires vGPU emulation module to
translate the graphics address between ‘guest view’ and ‘host view’, for
all registers and command opcodes which contain a graphics memory address.
To reduce the complexity, Intel GVT-g introduces “address space ballooning”,
by telling the exact partitioning knowledge to each guest i915 driver, which
then reserves and prevents non-allocated portions from allocation. Thus vGPU
emulation module only needs to scan and validate graphics addresses without
complexity of address translation.</p>
<dl class="c function">
<dt id="c.intel_vgpu_detect">
void <code class="sig-name descname">intel_vgpu_detect</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_vgpu_detect" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>detect virtual GPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device private</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the initialization stage, to detect whether
running on a vGPU.</p>
<dl class="c function">
<dt id="c.intel_vgt_deballoon">
void <code class="sig-name descname">intel_vgt_deballoon</code><span class="sig-paren">(</span><em class="property">struct</em> i915_ggtt *<em>ggtt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_vgt_deballoon" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deballoon reserved graphics address trunks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the global GGTT from which we reserved earlier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called to deallocate the ballooned-out graphic memory, when
driver is unloaded or when ballooning fails.</p>
<dl class="c function">
<dt id="c.intel_vgt_balloon">
int <code class="sig-name descname">intel_vgt_balloon</code><span class="sig-paren">(</span><em class="property">struct</em> i915_ggtt *<em>ggtt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_vgt_balloon" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>balloon out reserved graphics address trunks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the global GGTT from which to reserve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the initialization stage, to balloon out the
graphic address space allocated to other vGPUs, by marking these spaces as
reserved. The ballooning related knowledge(starting address and size of
the mappable/unmappable graphic memory) is described in the vgt_if structure
in a reserved mmio range.</p>
<p>To give an example, the drawing below depicts one typical scenario after
ballooning. Here the vGPU1 has 2 pieces of graphic address spaces ballooned
out each for the mappable and the non-mappable part. From the vGPU1 point of
view, the total size is the same as the physical one, with the start address
of its graphic space being zero. Yet there are some portions ballooned out(
the shadow part, which are marked as reserved by drm allocator). From the
host point of view, the graphic address space is partitioned by multiple
vGPUs in different VMs.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                       vGPU1 view         Host view
            0 ------&gt; +-----------+     +-----------+
              ^       |###########|     |   vGPU3   |
              |       |###########|     +-----------+
              |       |###########|     |   vGPU2   |
              |       +-----------+     +-----------+
       mappable GM    | available | ==&gt; |   vGPU1   |
              |       +-----------+     +-----------+
              |       |###########|     |           |
              v       |###########|     |   Host    |
              +=======+===========+     +===========+
              ^       |###########|     |   vGPU3   |
              |       |###########|     +-----------+
              |       |###########|     |   vGPU2   |
              |       +-----------+     +-----------+
     unmappable GM    | available | ==&gt; |   vGPU1   |
              |       +-----------+     +-----------+
              |       |###########|     |           |
              |       |###########|     |   Host    |
              v       |###########|     |           |
total GM size ------&gt; +-----------+     +-----------+
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>zero on success, non-zero if configuration invalid or ballooning failed</p>
</div>
<div class="section" id="intel-gvt-g-host-support-vgpu-device-model">
<h3>Intel GVT-g Host Support(vGPU device model)<a class="headerlink" href="#intel-gvt-g-host-support-vgpu-device-model" title="Permalink to this headline">¶</a></h3>
<p>Intel GVT-g is a graphics virtualization technology which shares the
GPU among multiple virtual machines on a time-sharing basis. Each
virtual machine is presented a virtual GPU (vGPU), which has equivalent
features as the underlying physical GPU (pGPU), so i915 driver can run
seamlessly in a virtual machine.</p>
<p>To virtualize GPU resources GVT-g driver depends on hypervisor technology
e.g KVM/VFIO/mdev, Xen, etc. to provide resource access trapping capability
and be virtualized within GVT-g device module. More architectural design
doc is available on <a class="reference external" href="https://01.org/group/2230/documentation-list">https://01.org/group/2230/documentation-list</a>.</p>
<dl class="c function">
<dt id="c.intel_gvt_sanitize_options">
void <code class="sig-name descname">intel_gvt_sanitize_options</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_gvt_sanitize_options" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sanitize GVT related options</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>drm i915 private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the i915 options sanitize stage.</p>
<dl class="c function">
<dt id="c.intel_gvt_init">
int <code class="sig-name descname">intel_gvt_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_gvt_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize GVT components</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>drm i915 private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the initialization stage to create a GVT device.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code if failed.</p>
<dl class="c function">
<dt id="c.intel_gvt_driver_remove">
void <code class="sig-name descname">intel_gvt_driver_remove</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_gvt_driver_remove" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cleanup GVT components when i915 driver is unbinding</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>drm i915 private *</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the i915 driver unloading stage, to shutdown
GVT components and release the related resources.</p>
</div>
<div class="section" id="workarounds">
<h3>Workarounds<a class="headerlink" href="#workarounds" title="Permalink to this headline">¶</a></h3>
<p>This file is intended as a central place to implement most <a class="footnote-reference brackets" href="#id3" id="id1">1</a> of the
required workarounds for hardware to work as originally intended. They fall
in five basic categories depending on how/when they are applied:</p>
<ul class="simple">
<li><p>Workarounds that touch registers that are saved/restored to/from the HW
context image. The list is emitted (via Load Register Immediate commands)
everytime a new context is created.</p></li>
<li><p>GT workarounds. The list of these WAs is applied whenever these registers
revert to default values (on GPU reset, suspend/resume <a class="footnote-reference brackets" href="#id4" id="id2">2</a>, etc..).</p></li>
<li><p>Display workarounds. The list is applied during display clock-gating
initialization.</p></li>
<li><p>Workarounds that whitelist a privileged register, so that UMDs can manage
them directly. This is just a special case of a MMMIO workaround (as we
write the list of these to/be-whitelisted registers to some special HW
registers).</p></li>
<li><p>Workaround batchbuffers, that get executed automatically by the hardware
on every HW context restore.</p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Please notice that there are other WAs that, due to their nature,
cannot be applied from a central place. Those are peppered around the rest
of the code, as needed.</p>
</dd>
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Technically, some registers are powercontext saved &amp; restored, so they
survive a suspend/resume. In practice, writing them again is not too
costly and simplifies things. We can revisit this in the future.</p>
</dd>
</dl>
<div class="section" id="layout">
<h4>Layout<a class="headerlink" href="#layout" title="Permalink to this headline">¶</a></h4>
<p>Keep things in this file ordered by WA type, as per the above (context, GT,
display, register whitelist, batchbuffer). Then, inside each type, keep the
following order:</p>
<ul class="simple">
<li><p>Infrastructure functions and macros</p></li>
<li><p>WAs per platform in standard gen/chrono order</p></li>
<li><p>Public functions to init or apply the given workaround type.</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="display-hardware-handling">
<h2>Display Hardware Handling<a class="headerlink" href="#display-hardware-handling" title="Permalink to this headline">¶</a></h2>
<p>This section covers everything related to the display hardware including
the mode setting infrastructure, plane, sprite and cursor handling and
display, output probing and related topics.</p>
<div class="section" id="mode-setting-infrastructure">
<h3>Mode Setting Infrastructure<a class="headerlink" href="#mode-setting-infrastructure" title="Permalink to this headline">¶</a></h3>
<p>The i915 driver is thus far the only DRM driver which doesn’t use the
common DRM helper code to implement mode setting sequences. Thus it has
its own tailor-made infrastructure for executing a display configuration
change.</p>
</div>
<div class="section" id="frontbuffer-tracking">
<h3>Frontbuffer Tracking<a class="headerlink" href="#frontbuffer-tracking" title="Permalink to this headline">¶</a></h3>
<p>Many features require us to track changes to the currently active
frontbuffer, especially rendering targeted at the frontbuffer.</p>
<p>To be able to do so we track frontbuffers using a bitmask for all possible
frontbuffer slots through <a class="reference internal" href="#c.intel_frontbuffer_track" title="intel_frontbuffer_track"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_frontbuffer_track()</span></code></a>. The functions in this
file are then called when the contents of the frontbuffer are invalidated,
when frontbuffer rendering has stopped again to flush out all the changes
and when the frontbuffer is exchanged with a flip. Subsystems interested in
frontbuffer changes (e.g. PSR, FBC, DRRS) should directly put their callbacks
into the relevant places and filter for the frontbuffer slots that they are
interested int.</p>
<p>On a high level there are two types of powersaving features. The first one
work like a special cache (FBC and PSR) and are interested when they should
stop caching and when to restart caching. This is done by placing callbacks
into the invalidate and the flush functions: At invalidate the caching must
be stopped and at flush time it can be restarted. And maybe they need to know
when the frontbuffer changes (e.g. when the hw doesn’t initiate an invalidate
and flush on its own) which can be achieved with placing callbacks into the
flip functions.</p>
<p>The other type of display power saving feature only cares about busyness
(e.g. DRRS). In that case all three (invalidate, flush and flip) indicate
busyness. There is no direct way to detect idleness. Instead an idle timer
work delayed work should be started from the flush and flip functions and
cancelled as soon as busyness is detected.</p>
<dl class="c function">
<dt id="c.intel_frontbuffer_invalidate">
bool <code class="sig-name descname">intel_frontbuffer_invalidate</code><span class="sig-paren">(</span><em class="property">struct</em> intel_frontbuffer *<em>front</em>, <em class="property">enum</em> fb_op_origin <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_frontbuffer_invalidate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>invalidate frontbuffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_frontbuffer</span> <span class="pre">*front</span></code></dt><dd><p>GEM object to invalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fb_op_origin</span> <span class="pre">origin</span></code></dt><dd><p>which operation caused the invalidation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called every time rendering on the given object starts and
frontbuffer caching (fbc, low refresh rate for DRRS, panel self refresh) must
be invalidated. For ORIGIN_CS any subsequent invalidation will be delayed
until the rendering completes or a flip on this frontbuffer plane is
scheduled.</p>
<dl class="c function">
<dt id="c.intel_frontbuffer_flush">
void <code class="sig-name descname">intel_frontbuffer_flush</code><span class="sig-paren">(</span><em class="property">struct</em> intel_frontbuffer *<em>front</em>, <em class="property">enum</em> fb_op_origin <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_frontbuffer_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>flush frontbuffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_frontbuffer</span> <span class="pre">*front</span></code></dt><dd><p>GEM object to flush</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fb_op_origin</span> <span class="pre">origin</span></code></dt><dd><p>which operation caused the flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called every time rendering on the given object has
completed and frontbuffer caching can be started again.</p>
<dl class="c function">
<dt id="c.frontbuffer_flush">
void <code class="sig-name descname">frontbuffer_flush</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em>, unsigned int <em>frontbuffer_bits</em>, <em class="property">enum</em> fb_op_origin <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.frontbuffer_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>flush frontbuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">frontbuffer_bits</span></code></dt><dd><p>frontbuffer plane tracking bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fb_op_origin</span> <span class="pre">origin</span></code></dt><dd><p>which operation caused the flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called every time rendering on the given planes has
completed and frontbuffer caching can be started again. Flushes will get
delayed if they’re blocked by some outstanding asynchronous rendering.</p>
<p>Can be called without any locks held.</p>
<dl class="c function">
<dt id="c.intel_frontbuffer_flip_prepare">
void <code class="sig-name descname">intel_frontbuffer_flip_prepare</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em>, unsigned <em>frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_frontbuffer_flip_prepare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>prepare asynchronous frontbuffer flip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt><dd><p>frontbuffer plane tracking bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called after scheduling a flip on <strong>obj</strong>. The actual
frontbuffer flushing will be delayed until completion is signalled with
intel_frontbuffer_flip_complete. If an invalidate happens in between this
flush will be cancelled.</p>
<p>Can be called without any locks held.</p>
<dl class="c function">
<dt id="c.intel_frontbuffer_flip_complete">
void <code class="sig-name descname">intel_frontbuffer_flip_complete</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em>, unsigned <em>frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_frontbuffer_flip_complete" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>complete asynchronous frontbuffer flip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt><dd><p>frontbuffer plane tracking bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called after the flip has been latched and will complete
on the next vblank. It will execute the flush if it hasn’t been cancelled yet.</p>
<p>Can be called without any locks held.</p>
<dl class="c function">
<dt id="c.intel_frontbuffer_flip">
void <code class="sig-name descname">intel_frontbuffer_flip</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em>, unsigned <em>frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_frontbuffer_flip" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>synchronous frontbuffer flip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt><dd><p>frontbuffer plane tracking bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called after scheduling a flip on <strong>obj</strong>. This is for
synchronous plane updates which will happen on the next vblank and which will
not get delayed by pending gpu rendering.</p>
<p>Can be called without any locks held.</p>
<dl class="c function">
<dt id="c.intel_frontbuffer_track">
void <code class="sig-name descname">intel_frontbuffer_track</code><span class="sig-paren">(</span><em class="property">struct</em> intel_frontbuffer *<em>old</em>, <em class="property">struct</em> intel_frontbuffer *<em>new</em>, unsigned int <em>frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_frontbuffer_track" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update frontbuffer tracking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_frontbuffer</span> <span class="pre">*old</span></code></dt><dd><p>current buffer for the frontbuffer slots</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_frontbuffer</span> <span class="pre">*new</span></code></dt><dd><p>new buffer for the frontbuffer slots</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">frontbuffer_bits</span></code></dt><dd><p>bitmask of frontbuffer slots</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This updates the frontbuffer tracking bits <strong>frontbuffer_bits</strong> by clearing them
from <strong>old</strong> and setting them in <strong>new</strong>. Both <strong>old</strong> and <strong>new</strong> can be NULL.</p>
</div>
<div class="section" id="display-fifo-underrun-reporting">
<h3>Display FIFO Underrun Reporting<a class="headerlink" href="#display-fifo-underrun-reporting" title="Permalink to this headline">¶</a></h3>
<p>The i915 driver checks for display fifo underruns using the interrupt signals
provided by the hardware. This is enabled by default and fairly useful to
debug display issues, especially watermark settings.</p>
<p>If an underrun is detected this is logged into dmesg. To avoid flooding logs
and occupying the cpu underrun interrupts are disabled after the first
occurrence until the next modeset on a given pipe.</p>
<p>Note that underrun detection on gmch platforms is a bit more ugly since there
is no interrupt (despite that the signalling bit is in the PIPESTAT pipe
interrupt register). Also on some other platforms underrun interrupts are
shared, which means that if we detect an underrun we need to disable underrun
reporting on all pipes.</p>
<p>The code also supports underrun detection on the PCH transcoder.</p>
<dl class="c function">
<dt id="c.intel_set_cpu_fifo_underrun_reporting">
bool <code class="sig-name descname">intel_set_cpu_fifo_underrun_reporting</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_set_cpu_fifo_underrun_reporting" title="pipe">pipe</a> <em>pipe</em>, bool <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_set_cpu_fifo_underrun_reporting" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set cpu fifo underrrun reporting state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pipe</span> <span class="pre">pipe</span></code></dt><dd><p>(CPU) pipe to set state for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>whether underruns should be reported or not</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets the fifo underrun state for <strong>pipe</strong>. It is used in the
modeset code to avoid false positives since on many platforms underruns are
expected when disabling or enabling the pipe.</p>
<p>Notice that on some platforms disabling underrun reports for one pipe
disables for all due to shared interrupts. Actual reporting is still per-pipe
though.</p>
<p>Returns the previous state of underrun reporting.</p>
<dl class="c function">
<dt id="c.intel_set_pch_fifo_underrun_reporting">
bool <code class="sig-name descname">intel_set_pch_fifo_underrun_reporting</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> pipe <em>pch_transcoder</em>, bool <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_set_pch_fifo_underrun_reporting" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set PCH fifo underrun reporting state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pipe</span> <span class="pre">pch_transcoder</span></code></dt><dd><p>the PCH transcoder (same as pipe on IVB and older)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>whether underruns should be reported or not</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function makes us disable or enable PCH fifo underruns for a specific
PCH transcoder. Notice that on some PCHs (e.g. CPT/PPT), disabling FIFO
underrun reporting for one transcoder may also disable all the other PCH
error interruts for the other transcoders, due to the fact that there’s just
one interrupt mask/enable bit for all the transcoders.</p>
<p>Returns the previous state of underrun reporting.</p>
<dl class="c function">
<dt id="c.intel_cpu_fifo_underrun_irq_handler">
void <code class="sig-name descname">intel_cpu_fifo_underrun_irq_handler</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_cpu_fifo_underrun_irq_handler" title="pipe">pipe</a> <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_cpu_fifo_underrun_irq_handler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle CPU fifo underrun interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pipe</span> <span class="pre">pipe</span></code></dt><dd><p>(CPU) pipe to set state for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This handles a CPU fifo underrun interrupt, generating an underrun warning
into dmesg if underrun reporting is enabled and then disables the underrun
interrupt to avoid an irq storm.</p>
<dl class="c function">
<dt id="c.intel_pch_fifo_underrun_irq_handler">
void <code class="sig-name descname">intel_pch_fifo_underrun_irq_handler</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> pipe <em>pch_transcoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_pch_fifo_underrun_irq_handler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle PCH fifo underrun interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pipe</span> <span class="pre">pch_transcoder</span></code></dt><dd><p>the PCH transcoder (same as pipe on IVB and older)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This handles a PCH fifo underrun interrupt, generating an underrun warning
into dmesg if underrun reporting is enabled and then disables the underrun
interrupt to avoid an irq storm.</p>
<dl class="c function">
<dt id="c.intel_check_cpu_fifo_underruns">
void <code class="sig-name descname">intel_check_cpu_fifo_underruns</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_check_cpu_fifo_underruns" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check for CPU fifo underruns immediately</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for CPU fifo underruns immediately. Useful on IVB/HSW where the shared
error interrupt may have been disabled, and so CPU fifo underruns won’t
necessarily raise an interrupt, and on GMCH platforms where underruns never
raise an interrupt.</p>
<dl class="c function">
<dt id="c.intel_check_pch_fifo_underruns">
void <code class="sig-name descname">intel_check_pch_fifo_underruns</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_check_pch_fifo_underruns" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check for PCH fifo underruns immediately</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for PCH fifo underruns immediately. Useful on CPT/PPT where the shared
error interrupt may have been disabled, and so PCH fifo underruns won’t
necessarily raise an interrupt.</p>
</div>
<div class="section" id="plane-configuration">
<h3>Plane Configuration<a class="headerlink" href="#plane-configuration" title="Permalink to this headline">¶</a></h3>
<p>This section covers plane configuration and composition with the primary
plane, sprites, cursors and overlays. This includes the infrastructure
to do atomic vsync’ed updates of all this state and also tightly coupled
topics like watermark setup and computation, framebuffer compression and
panel self refresh.</p>
</div>
<div class="section" id="atomic-plane-helpers">
<h3>Atomic Plane Helpers<a class="headerlink" href="#atomic-plane-helpers" title="Permalink to this headline">¶</a></h3>
<p>The functions here are used by the atomic plane helper functions to
implement legacy plane updates (i.e., drm_plane-&gt;update_plane() and
drm_plane-&gt;disable_plane()).  This allows plane updates to use the
atomic state infrastructure and perform plane updates as separate
prepare/check/commit/cleanup steps.</p>
<dl class="c function">
<dt id="c.intel_plane_duplicate_state">
<em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<code class="sig-name descname">intel_plane_duplicate_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_plane_duplicate_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>duplicate plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and returns a copy of the plane state (both common and
Intel-specific) for the specified plane.</p>
<p><strong>Return</strong></p>
<p>The newly allocated plane state, or NULL on failure.</p>
<dl class="c function">
<dt id="c.intel_plane_destroy_state">
void <code class="sig-name descname">intel_plane_destroy_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em>, <em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_plane_destroy_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>destroy plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>state object to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroys the plane state (both common and Intel-specific) for the
specified plane.</p>
</div>
<div class="section" id="output-probing">
<h3>Output Probing<a class="headerlink" href="#output-probing" title="Permalink to this headline">¶</a></h3>
<p>This section covers output probing and related infrastructure like the
hotplug interrupt storm detection and mitigation code. Note that the
i915 driver still uses most of the common DRM helper code for output
probing, so those sections fully apply.</p>
</div>
<div class="section" id="hotplug">
<h3>Hotplug<a class="headerlink" href="#hotplug" title="Permalink to this headline">¶</a></h3>
<p>Simply put, hotplug occurs when a display is connected to or disconnected
from the system. However, there may be adapters and docking stations and
Display Port short pulses and MST devices involved, complicating matters.</p>
<p>Hotplug in i915 is handled in many different levels of abstraction.</p>
<p>The platform dependent interrupt handling code in i915_irq.c enables,
disables, and does preliminary handling of the interrupts. The interrupt
handlers gather the hotplug detect (HPD) information from relevant registers
into a platform independent mask of hotplug pins that have fired.</p>
<p>The platform independent interrupt handler <a class="reference internal" href="#c.intel_hpd_irq_handler" title="intel_hpd_irq_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_hpd_irq_handler()</span></code></a> in
intel_hotplug.c does hotplug irq storm detection and mitigation, and passes
further processing to appropriate bottom halves (Display Port specific and
regular hotplug).</p>
<p>The Display Port work function i915_digport_work_func() calls into
intel_dp_hpd_pulse() via hooks, which handles DP short pulses and DP MST long
pulses, with failures and non-MST long pulses triggering regular hotplug
processing on the connector.</p>
<p>The regular hotplug work function i915_hotplug_work_func() calls connector
detect hooks, and, if connector status changes, triggers sending of hotplug
uevent to userspace via <a class="reference internal" href="drm-kms-helpers.html#c.drm_kms_helper_hotplug_event" title="drm_kms_helper_hotplug_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_hotplug_event()</span></code></a>.</p>
<p>Finally, the userspace is responsible for triggering a modeset upon receiving
the hotplug uevent, disabling or enabling the crtc as needed.</p>
<p>The hotplug interrupt storm detection and mitigation code keeps track of the
number of interrupts per hotplug pin per a period of time, and if the number
of interrupts exceeds a certain threshold, the interrupt is disabled for a
while before being re-enabled. The intention is to mitigate issues raising
from broken hardware triggering massive amounts of interrupts and grinding
the system to a halt.</p>
<p>Current implementation expects that hotplug interrupt storm will not be
seen when display port sink is connected, hence on platforms whose DP
callback is handled by i915_digport_work_func reenabling of hpd is not
performed (it was never expected to be disabled in the first place ;) )
this is specific to DP sinks handled by this routine and any other display
such as HDMI or DVI enabled on the same port will have proper logic since
it will use i915_hotplug_work_func where this logic is handled.</p>
<dl class="c function">
<dt id="c.intel_hpd_pin_default">
<em class="property">enum</em> hpd_pin <code class="sig-name descname">intel_hpd_pin_default</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_hpd_pin_default" title="port">port</a> <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_hpd_pin_default" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return default pin associated with certain port.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>private driver data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">port</span></code></dt><dd><p>the hpd port to get associated pin</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is only valid and used by digital port encoder.</p>
<p>Return pin that is associatade with <strong>port</strong>.</p>
<dl class="c function">
<dt id="c.intel_hpd_irq_storm_detect">
bool <code class="sig-name descname">intel_hpd_irq_storm_detect</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> hpd_pin <em>pin</em>, bool <em>long_hpd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_hpd_irq_storm_detect" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>gather stats and detect HPD IRQ storm on a pin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>private driver data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hpd_pin</span> <span class="pre">pin</span></code></dt><dd><p>the pin to gather stats on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">long_hpd</span></code></dt><dd><p>whether the HPD IRQ was long or short</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gather stats about HPD IRQs from the specified <strong>pin</strong>, and detect IRQ
storms. Only the pin specific stats and state are changed, the caller is
responsible for further action.</p>
<p>The number of IRQs that are allowed within <strong>HPD_STORM_DETECT_PERIOD</strong> is
stored in <strong>dev_priv-&gt;hotplug.hpd_storm_threshold</strong> which defaults to
<strong>HPD_STORM_DEFAULT_THRESHOLD</strong>. Long IRQs count as +10 to this threshold, and
short IRQs count as +1. If this threshold is exceeded, it’s considered an
IRQ storm and the IRQ state is set to <strong>HPD_MARK_DISABLED</strong>.</p>
<p>By default, most systems will only count long IRQs towards
<code class="xref c c-type docutils literal notranslate"><span class="pre">dev_priv-&gt;hotplug</span></code>.hpd_storm_threshold. However, some older systems also
suffer from short IRQ storms and must also track these. Because short IRQ
storms are naturally caused by sideband interactions with DP MST devices,
short IRQ detection is only enabled for systems without DP MST support.
Systems which are new enough to support DP MST are far less likely to
suffer from IRQ storms at all, so this is fine.</p>
<p>The HPD threshold can be controlled through i915_hpd_storm_ctl in debugfs,
and should only be adjusted for automated hotplug testing.</p>
<p>Return true if an IRQ storm was detected on <strong>pin</strong>.</p>
<dl class="c function">
<dt id="c.intel_hpd_trigger_irq">
void <code class="sig-name descname">intel_hpd_trigger_irq</code><span class="sig-paren">(</span><em class="property">struct</em> intel_digital_port *<em>dig_port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_hpd_trigger_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>trigger an hpd irq event for a port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_digital_port</span> <span class="pre">*dig_port</span></code></dt><dd><p>digital port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trigger an HPD interrupt event for the given port, emulating a short pulse
generated by the sink, and schedule the dig port work to handle it.</p>
<dl class="c function">
<dt id="c.intel_hpd_irq_handler">
void <code class="sig-name descname">intel_hpd_irq_handler</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, u32 <em>pin_mask</em>, u32 <em>long_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_hpd_irq_handler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>main hotplug irq handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>drm_i915_private</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">pin_mask</span></code></dt><dd><p>a mask of hpd pins that have triggered the irq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">long_mask</span></code></dt><dd><p>a mask of hpd pins that may be long hpd pulses</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the main hotplug irq handler for all platforms. The platform specific
irq handlers call the platform specific hotplug irq handlers, which read and
decode the appropriate registers into bitmasks about hpd pins that have
triggered (<strong>pin_mask</strong>), and which of those pins may be long pulses
(<strong>long_mask</strong>). The <strong>long_mask</strong> is ignored if the port corresponding to the pin
is not a digital port.</p>
<p>Here, we do hotplug irq storm detection and mitigation, and pass further
processing to appropriate bottom halves.</p>
<dl class="c function">
<dt id="c.intel_hpd_init">
void <code class="sig-name descname">intel_hpd_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_hpd_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initializes and enables hpd support</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables the hotplug support. It requires that interrupts have
already been enabled with intel_irq_init_hw(). From this point on hotplug and
poll request can run concurrently to other code, so locking rules must be
obeyed.</p>
<p>This is a separate step from interrupt enabling to simplify the locking rules
in the driver load and resume code.</p>
<p>Also see: <a class="reference internal" href="#c.intel_hpd_poll_init" title="intel_hpd_poll_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_hpd_poll_init()</span></code></a>, which enables connector polling</p>
<dl class="c function">
<dt id="c.intel_hpd_poll_init">
void <code class="sig-name descname">intel_hpd_poll_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_hpd_poll_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enables/disables polling for connectors with hpd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables polling for all connectors, regardless of whether or
not they support hotplug detection. Under certain conditions HPD may not be
functional. On most Intel GPUs, this happens when we enter runtime suspend.
On Valleyview and Cherryview systems, this also happens when we shut off all
of the powerwells.</p>
<p>Since this function can get called in contexts where we’re already holding
dev-&gt;mode_config.mutex, we do the actual hotplug enabling in a seperate
worker.</p>
<p>Also see: <a class="reference internal" href="#c.intel_hpd_init" title="intel_hpd_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_hpd_init()</span></code></a>, which restores hpd handling.</p>
</div>
<div class="section" id="high-definition-audio">
<h3>High Definition Audio<a class="headerlink" href="#high-definition-audio" title="Permalink to this headline">¶</a></h3>
<p>The graphics and audio drivers together support High Definition Audio over
HDMI and Display Port. The audio programming sequences are divided into audio
codec and controller enable and disable sequences. The graphics driver
handles the audio codec sequences, while the audio driver handles the audio
controller sequences.</p>
<p>The disable sequences must be performed before disabling the transcoder or
port. The enable sequences may only be performed after enabling the
transcoder and port, and after completed link training. Therefore the audio
enable/disable sequences are part of the modeset sequence.</p>
<p>The codec and controller sequences could be done either parallel or serial,
but generally the ELDV/PD change in the codec sequence indicates to the audio
driver that the controller sequence should start. Indeed, most of the
co-operation between the graphics and audio drivers is handled via audio
related registers. (The notable exception is the power management, not
covered here.)</p>
<p>The struct <a class="reference internal" href="#c.i915_audio_component" title="i915_audio_component"><code class="xref c c-type docutils literal notranslate"><span class="pre">i915_audio_component</span></code></a> is used to interact between the graphics
and audio drivers. The struct <code class="xref c c-type docutils literal notranslate"><span class="pre">i915_audio_component_ops</span></code> <strong>ops</strong> in it is
defined in graphics driver and called in audio driver. The
struct <code class="xref c c-type docutils literal notranslate"><span class="pre">i915_audio_component_audio_ops</span></code> <strong>audio_ops</strong> is called from i915 driver.</p>
<dl class="c function">
<dt id="c.intel_audio_codec_enable">
void <code class="sig-name descname">intel_audio_codec_enable</code><span class="sig-paren">(</span><em class="property">struct</em> intel_encoder *<em>encoder</em>, <em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_audio_codec_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enable the audio codec for HD audio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder on which to enable audio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>pointer to the current crtc state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>pointer to the current connector state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The enable sequences may only be performed after enabling the transcoder and
port, and after completed link training.</p>
<dl class="c function">
<dt id="c.intel_audio_codec_disable">
void <code class="sig-name descname">intel_audio_codec_disable</code><span class="sig-paren">(</span><em class="property">struct</em> intel_encoder *<em>encoder</em>, <em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>old_crtc_state</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>old_conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_audio_codec_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disable the audio codec for HD audio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder on which to disable audio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*old_crtc_state</span></code></dt><dd><p>pointer to the old crtc state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*old_conn_state</span></code></dt><dd><p>pointer to the old connector state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The disable sequences must be performed before disabling the transcoder or
port.</p>
<dl class="c function">
<dt id="c.intel_init_audio_hooks">
void <code class="sig-name descname">intel_init_audio_hooks</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_init_audio_hooks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set up chip specific audio hooks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>device private</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.i915_audio_component_init">
void <code class="sig-name descname">i915_audio_component_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_audio_component_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize and register the audio component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will register with the component framework a child component which
will bind dynamically to the snd_hda_intel driver’s corresponding master
component when the latter is registered. During binding the child
initializes an instance of <a class="reference internal" href="#c.i915_audio_component" title="i915_audio_component"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_audio_component</span></code></a> which it receives
from the master. The master can then start to use the interface defined by
this struct. Each side can break the binding at any point by deregistering
its own component after which each side’s component unbind callback is
called.</p>
<p>We ignore any error during registration and continue with reduced
functionality (i.e. without HDMI audio).</p>
<dl class="c function">
<dt id="c.i915_audio_component_cleanup">
void <code class="sig-name descname">i915_audio_component_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_audio_component_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deregister the audio component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deregisters the audio component, breaking any existing binding to the
corresponding snd_hda_intel driver’s master component.</p>
<dl class="c function">
<dt id="c.intel_audio_init">
void <code class="sig-name descname">intel_audio_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_audio_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize the audio driver either using component framework or using lpe audio bridge</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>the i915 drm device private data</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.intel_audio_deinit">
void <code class="sig-name descname">intel_audio_deinit</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_audio_deinit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deinitialize the audio driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>the i915 drm device private data</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.i915_audio_component">
<em class="property">struct </em><code class="sig-name descname">i915_audio_component</code><a class="headerlink" href="#c.i915_audio_component" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Used for direct communication between i915 and hda drivers</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_audio_component {
  struct drm_audio_component      base;
  int aud_sample_rate[MAX_PORTS];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>the drm_audio_component base class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aud_sample_rate</span></code></dt><dd><p>the array of audio sample rate per port</p>
</dd>
</dl>
</div>
<div class="section" id="intel-hdmi-lpe-audio-support">
<h3>Intel HDMI LPE Audio Support<a class="headerlink" href="#intel-hdmi-lpe-audio-support" title="Permalink to this headline">¶</a></h3>
<p>Motivation:
Atom platforms (e.g. valleyview and cherryTrail) integrates a DMA-based
interface as an alternative to the traditional HDaudio path. While this
mode is unrelated to the LPE aka SST audio engine, the documentation refers
to this mode as LPE so we keep this notation for the sake of consistency.</p>
<p>The interface is handled by a separate standalone driver maintained in the
ALSA subsystem for simplicity. To minimize the interaction between the two
subsystems, a bridge is setup between the hdmi-lpe-audio and i915:
1. Create a platform device to share MMIO/IRQ resources
2. Make the platform device child of i915 device for runtime PM.
3. Create IRQ chip to forward the LPE audio irqs.
the hdmi-lpe-audio driver probes the lpe audio device and creates a new
sound card</p>
<p>Threats:
Due to the restriction in Linux platform device model, user need manually
uninstall the hdmi-lpe-audio driver before uninstalling i915 module,
otherwise we might run into use-after-free issues after i915 removes the
platform device: even though hdmi-lpe-audio driver is released, the modules
is still in “installed” status.</p>
<p>Implementation:
The MMIO/REG platform resources are created according to the registers
specification.
When forwarding LPE audio irqs, the flow control handler selection depends
on the platform, for example on valleyview handle_simple_irq is enough.</p>
<dl class="c function">
<dt id="c.intel_lpe_audio_irq_handler">
void <code class="sig-name descname">intel_lpe_audio_irq_handler</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_lpe_audio_irq_handler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>forwards the LPE audio irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>the i915 drm device private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>the LPE Audio irq is forwarded to the irq handler registered by LPE audio
driver.</p>
<dl class="c function">
<dt id="c.intel_lpe_audio_init">
int <code class="sig-name descname">intel_lpe_audio_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_lpe_audio_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>detect and setup the bridge between HDMI LPE Audio driver and i915</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>the i915 drm device private data</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if successful. non-zero if detection or
llocation/initialization fails</p>
<dl class="c function">
<dt id="c.intel_lpe_audio_teardown">
void <code class="sig-name descname">intel_lpe_audio_teardown</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_lpe_audio_teardown" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>destroy the bridge between HDMI LPE audio driver and i915</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>the i915 drm device private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>release all the resources for LPE audio &lt;-&gt; i915 bridge.</p>
<dl class="c function">
<dt id="c.intel_lpe_audio_notify">
void <code class="sig-name descname">intel_lpe_audio_notify</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_lpe_audio_notify" title="pipe">pipe</a> <em>pipe</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_lpe_audio_notify" title="port">port</a> <em>port</em>, <em class="property">const</em> void *<em>eld</em>, int <em>ls_clock</em>, bool <em>dp_output</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_lpe_audio_notify" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>notify lpe audio event audio driver and i915</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>the i915 drm device private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pipe</span> <span class="pre">pipe</span></code></dt><dd><p>pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">port</span></code></dt><dd><p>port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*eld</span></code></dt><dd><p>ELD data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ls_clock</span></code></dt><dd><p>Link symbol clock in kHz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">dp_output</span></code></dt><dd><p>Driving a DP output?</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notify lpe audio driver of eld change.</p>
</div>
<div class="section" id="panel-self-refresh-psr-psr-srd">
<h3>Panel Self Refresh PSR (PSR/SRD)<a class="headerlink" href="#panel-self-refresh-psr-psr-srd" title="Permalink to this headline">¶</a></h3>
<p>Since Haswell Display controller supports Panel Self-Refresh on display
panels witch have a remote frame buffer (RFB) implemented according to PSR
spec in eDP1.3. PSR feature allows the display to go to lower standby states
when system is idle but display is on as it eliminates display refresh
request to DDR memory completely as long as the frame buffer for that
display is unchanged.</p>
<p>Panel Self Refresh must be supported by both Hardware (source) and
Panel (sink).</p>
<p>PSR saves power by caching the framebuffer in the panel RFB, which allows us
to power down the link and memory controller. For DSI panels the same idea
is called “manual mode”.</p>
<p>The implementation uses the hardware-based PSR support which automatically
enters/exits self-refresh mode. The hardware takes care of sending the
required DP aux message and could even retrain the link (that part isn’t
enabled yet though). The hardware also keeps track of any frontbuffer
changes to know when to exit self-refresh mode again. Unfortunately that
part doesn’t work too well, hence why the i915 PSR support uses the
software frontbuffer tracking to make sure it doesn’t miss a screen
update. For this integration <a class="reference internal" href="#c.intel_psr_invalidate" title="intel_psr_invalidate"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_psr_invalidate()</span></code></a> and <a class="reference internal" href="#c.intel_psr_flush" title="intel_psr_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_psr_flush()</span></code></a>
get called by the frontbuffer tracking code. Note that because of locking
issues the self-refresh re-enable code is done from a work queue, which
must be correctly synchronized/cancelled when shutting down the pipe.”</p>
<p>DC3CO (DC3 clock off)</p>
<p>On top of PSR2, GEN12 adds a intermediate power savings state that turns
clock off automatically during PSR2 idle state.
The smaller overhead of DC3co entry/exit vs. the overhead of PSR2 deep sleep
entry/exit allows the HW to enter a low-power state even when page flipping
periodically (for instance a 30fps video playback scenario).</p>
<p>Every time a flips occurs PSR2 will get out of deep sleep state(if it was),
so DC3CO is enabled and tgl_dc3co_disable_work is schedule to run after 6
frames, if no other flip occurs and the function above is executed, DC3CO is
disabled and PSR2 is configured to enter deep sleep, resetting again in case
of another flip.
Front buffer modifications do not trigger DC3CO activation on purpose as it
would bring a lot of complexity and most of the moderns systems will only
use page flips.</p>
<dl class="c function">
<dt id="c.intel_psr_enable">
void <code class="sig-name descname">intel_psr_enable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.intel_psr_enable" title="intel_dp">intel_dp</a> *<em>intel_dp</em>, <em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enable PSR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_dp</span> <span class="pre">*intel_dp</span></code></dt><dd><p>Intel DP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>new CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>new CONNECTOR state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can only be called after the pipe is fully trained and enabled.</p>
<dl class="c function">
<dt id="c.intel_psr_disable">
void <code class="sig-name descname">intel_psr_disable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.intel_psr_disable" title="intel_dp">intel_dp</a> *<em>intel_dp</em>, <em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>old_crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disable PSR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_dp</span> <span class="pre">*intel_dp</span></code></dt><dd><p>Intel DP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*old_crtc_state</span></code></dt><dd><p>old CRTC state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function needs to be called before disabling pipe.</p>
<dl class="c function">
<dt id="c.intel_psr_update">
void <code class="sig-name descname">intel_psr_update</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.intel_psr_update" title="intel_dp">intel_dp</a> *<em>intel_dp</em>, <em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_update" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update PSR state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_dp</span> <span class="pre">*intel_dp</span></code></dt><dd><p>Intel DP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>new CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>new CONNECTOR state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions will update PSR states, disabling, enabling or switching PSR
version when executing fastsets. For full modeset, <a class="reference internal" href="#c.intel_psr_disable" title="intel_psr_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_psr_disable()</span></code></a> and
<a class="reference internal" href="#c.intel_psr_enable" title="intel_psr_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_psr_enable()</span></code></a> should be called instead.</p>
<dl class="c function">
<dt id="c.intel_psr_wait_for_idle">
int <code class="sig-name descname">intel_psr_wait_for_idle</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>new_crtc_state</em>, u32 *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_wait_for_idle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for PSR1 to idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*new_crtc_state</span></code></dt><dd><p>new CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*out_value</span></code></dt><dd><p>PSR status in case of failure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is expected to be called from pipe_update_start() where it is
not expected to race with PSR enable or disable.</p>
<p><strong>Return</strong></p>
<p>0 on success or -ETIMEOUT if PSR status does not idle.</p>
<dl class="c function">
<dt id="c.intel_psr_invalidate">
void <code class="sig-name descname">intel_psr_invalidate</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, unsigned <em>frontbuffer_bits</em>, <em class="property">enum</em> fb_op_origin <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_invalidate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invalidade PSR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt><dd><p>frontbuffer plane tracking bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fb_op_origin</span> <span class="pre">origin</span></code></dt><dd><p>which operation caused the invalidate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Since the hardware frontbuffer tracking has gaps we need to integrate
with the software frontbuffer tracking. This function gets called every
time frontbuffer rendering starts and a buffer gets dirtied. PSR must be
disabled if the frontbuffer mask contains a buffer relevant to PSR.</p>
<p>Dirty frontbuffers relevant to PSR are tracked in busy_frontbuffer_bits.”</p>
<dl class="c function">
<dt id="c.intel_psr_flush">
void <code class="sig-name descname">intel_psr_flush</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, unsigned <em>frontbuffer_bits</em>, <em class="property">enum</em> fb_op_origin <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flush PSR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt><dd><p>frontbuffer plane tracking bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fb_op_origin</span> <span class="pre">origin</span></code></dt><dd><p>which operation caused the flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Since the hardware frontbuffer tracking has gaps we need to integrate
with the software frontbuffer tracking. This function gets called every
time frontbuffer rendering has completed and flushed out to memory. PSR
can be enabled again if no other frontbuffer relevant to PSR is dirty.</p>
<p>Dirty frontbuffers relevant to PSR are tracked in busy_frontbuffer_bits.</p>
<dl class="c function">
<dt id="c.intel_psr_init">
void <code class="sig-name descname">intel_psr_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Init basic PSR work and mutex.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device private</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is  called only once at driver load to initialize basic
PSR stuff.</p>
</div>
<div class="section" id="frame-buffer-compression-fbc">
<h3>Frame Buffer Compression (FBC)<a class="headerlink" href="#frame-buffer-compression-fbc" title="Permalink to this headline">¶</a></h3>
<p>FBC tries to save memory bandwidth (and so power consumption) by
compressing the amount of memory used by the display. It is total
transparent to user space and completely handled in the kernel.</p>
<p>The benefits of FBC are mostly visible with solid backgrounds and
variation-less patterns. It comes from keeping the memory footprint small
and having fewer memory pages opened and accessed for refreshing the display.</p>
<p>i915 is responsible to reserve stolen memory for FBC and configure its
offset on proper registers. The hardware takes care of all
compress/decompress. However there are many known cases where we have to
forcibly disable it to allow proper screen updates.</p>
<dl class="c function">
<dt id="c.intel_fbc_is_active">
bool <code class="sig-name descname">intel_fbc_is_active</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_is_active" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Is FBC active?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to verify the current state of FBC.</p>
<p>FIXME: This should be tracked in the plane config eventually
instead of queried at runtime for most callers.</p>
<dl class="c function">
<dt id="c.__intel_fbc_disable">
void <code class="sig-name descname">__intel_fbc_disable</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__intel_fbc_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>disable FBC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the low level function that actually disables FBC. Callers should
grab the FBC lock.</p>
<dl class="c function">
<dt id="c.intel_fbc_choose_crtc">
void <code class="sig-name descname">intel_fbc_choose_crtc</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">struct</em> intel_atomic_state *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_choose_crtc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>select a CRTC to enable FBC on</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the atomic state structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks at the proposed state for CRTCs and planes, then chooses
which pipe is going to have FBC by setting intel_crtc_state-&gt;enable_fbc to
true.</p>
<p>Later, intel_fbc_enable is going to look for state-&gt;enable_fbc and then maybe
enable FBC for the chosen CRTC. If it does, it will set dev_priv-&gt;fbc.crtc.</p>
<dl class="c function">
<dt id="c.intel_fbc_enable">
void <code class="sig-name descname">intel_fbc_enable</code><span class="sig-paren">(</span><em class="property">struct</em> intel_atomic_state *<em>state</em>, <em class="property">struct</em> intel_crtc *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>corresponding <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state</span></code></a> for <strong>crtc</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>the CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks if the given CRTC was chosen for FBC, then enables it if
possible. Notice that it doesn’t activate FBC. It is valid to call
intel_fbc_enable multiple times for the same pipe without an
intel_fbc_disable in the middle, as long as it is deactivated.</p>
<dl class="c function">
<dt id="c.intel_fbc_disable">
void <code class="sig-name descname">intel_fbc_disable</code><span class="sig-paren">(</span><em class="property">struct</em> intel_crtc *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>disable FBC if it’s associated with crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>the CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables FBC if it’s associated with the provided CRTC.</p>
<dl class="c function">
<dt id="c.intel_fbc_global_disable">
void <code class="sig-name descname">intel_fbc_global_disable</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_global_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>globally disable FBC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables FBC regardless of which CRTC is associated with it.</p>
<dl class="c function">
<dt id="c.intel_fbc_handle_fifo_underrun_irq">
void <code class="sig-name descname">intel_fbc_handle_fifo_underrun_irq</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_handle_fifo_underrun_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>disable FBC when we get a FIFO underrun</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Without FBC, most underruns are harmless and don’t really cause too many
problems, except for an annoying message on dmesg. With FBC, underruns can
become black screens or even worse, especially when paired with bad
watermarks. So in order for us to be on the safe side, completely disable FBC
in case we ever detect a FIFO underrun on any pipe. An underrun on any pipe
already suggests that watermarks may be bad, so try to be as safe as
possible.</p>
<p>This function is called from the IRQ handler.</p>
<dl class="c function">
<dt id="c.intel_fbc_init">
void <code class="sig-name descname">intel_fbc_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize FBC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>the i915 device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function might be called during PM init process.</p>
</div>
<div class="section" id="display-refresh-rate-switching-drrs">
<h3>Display Refresh Rate Switching (DRRS)<a class="headerlink" href="#display-refresh-rate-switching-drrs" title="Permalink to this headline">¶</a></h3>
<p>Display Refresh Rate Switching (DRRS) is a power conservation feature
which enables swtching between low and high refresh rates,
dynamically, based on the usage scenario. This feature is applicable
for internal panels.</p>
<p>Indication that the panel supports DRRS is given by the panel EDID, which
would list multiple refresh rates for one resolution.</p>
<p>DRRS is of 2 types - static and seamless.
Static DRRS involves changing refresh rate (RR) by doing a full modeset
(may appear as a blink on screen) and is used in dock-undock scenario.
Seamless DRRS involves changing RR without any visual effect to the user
and can be used during normal system usage. This is done by programming
certain registers.</p>
<p>Support for static/seamless DRRS may be indicated in the VBT based on
inputs from the panel spec.</p>
<p>DRRS saves power by switching to low RR based on usage scenarios.</p>
<p>The implementation is based on frontbuffer tracking implementation.  When
there is a disturbance on the screen triggered by user activity or a periodic
system activity, DRRS is disabled (RR is changed to high RR).  When there is
no movement on screen, after a timeout of 1 second, a switch to low RR is
made.</p>
<p>For integration with frontbuffer tracking code, <a class="reference internal" href="#c.intel_edp_drrs_invalidate" title="intel_edp_drrs_invalidate"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_edp_drrs_invalidate()</span></code></a>
and <a class="reference internal" href="#c.intel_edp_drrs_flush" title="intel_edp_drrs_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_edp_drrs_flush()</span></code></a> are called.</p>
<p>DRRS can be further extended to support other internal panels and also
the scenario of video playback wherein RR is set based on the rate
requested by userspace.</p>
<dl class="c function">
<dt id="c.intel_dp_set_drrs_state">
void <code class="sig-name descname">intel_dp_set_drrs_state</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em>, int <em>refresh_rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dp_set_drrs_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>program registers for RR switch to take effect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>a pointer to the active intel_crtc_state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">refresh_rate</span></code></dt><dd><p>RR to be programmed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called when refresh rate (RR) has to be changed from
one frequency to another. Switches can be between high and low RR
supported by the panel or to any other RR based on media playback (in
this case, RR value needs to be passed from user space).</p>
<p>The caller of this function needs to take a lock on dev_priv-&gt;drrs.</p>
<dl class="c function">
<dt id="c.intel_edp_drrs_enable">
void <code class="sig-name descname">intel_edp_drrs_enable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.intel_edp_drrs_enable" title="intel_dp">intel_dp</a> *<em>intel_dp</em>, <em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_edp_drrs_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>init drrs struct if supported</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_dp</span> <span class="pre">*intel_dp</span></code></dt><dd><p>DP struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>A pointer to the active crtc state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes frontbuffer_bits and drrs.dp</p>
<dl class="c function">
<dt id="c.intel_edp_drrs_disable">
void <code class="sig-name descname">intel_edp_drrs_disable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.intel_edp_drrs_disable" title="intel_dp">intel_dp</a> *<em>intel_dp</em>, <em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>old_crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_edp_drrs_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disable DRRS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_dp</span> <span class="pre">*intel_dp</span></code></dt><dd><p>DP struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*old_crtc_state</span></code></dt><dd><p>Pointer to old crtc_state.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.intel_edp_drrs_invalidate">
void <code class="sig-name descname">intel_edp_drrs_invalidate</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, unsigned int <em>frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_edp_drrs_invalidate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disable Idleness DRRS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">frontbuffer_bits</span></code></dt><dd><p>frontbuffer plane tracking bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called everytime rendering on the given planes start.
Hence DRRS needs to be Upclocked, i.e. (LOW_RR -&gt; HIGH_RR).</p>
<p>Dirty frontbuffers relevant to DRRS are tracked in busy_frontbuffer_bits.</p>
<dl class="c function">
<dt id="c.intel_edp_drrs_flush">
void <code class="sig-name descname">intel_edp_drrs_flush</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, unsigned int <em>frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_edp_drrs_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Restart Idleness DRRS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">frontbuffer_bits</span></code></dt><dd><p>frontbuffer plane tracking bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called every time rendering on the given planes has
completed or flip on a crtc is completed. So DRRS should be upclocked
(LOW_RR -&gt; HIGH_RR). And also Idleness detection should be started again,
if no other planes are dirty.</p>
<p>Dirty frontbuffers relevant to DRRS are tracked in busy_frontbuffer_bits.</p>
<dl class="c function">
<dt id="c.intel_dp_drrs_init">
<em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<code class="sig-name descname">intel_dp_drrs_init</code><span class="sig-paren">(</span><em class="property">struct</em> intel_connector *<em>connector</em>, <em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>fixed_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dp_drrs_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Init basic DRRS work and mutex.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_connector</span> <span class="pre">*connector</span></code></dt><dd><p>eDP connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*fixed_mode</span></code></dt><dd><p>preferred mode of panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is  called only once at driver load to initialize basic
DRRS stuff.</p>
<p><strong>Return</strong></p>
<p>Downclock mode if panel supports it, else return NULL.
DRRS support is determined by the presence of downclock mode (apart
from VBT setting).</p>
</div>
<div class="section" id="dpio">
<h3>DPIO<a class="headerlink" href="#dpio" title="Permalink to this headline">¶</a></h3>
<p>VLV, CHV and BXT have slightly peculiar display PHYs for driving DP/HDMI
ports. DPIO is the name given to such a display PHY. These PHYs
don’t follow the standard programming model using direct MMIO
registers, and instead their registers must be accessed trough IOSF
sideband. VLV has one such PHY for driving ports B and C, and CHV
adds another PHY for driving port D. Each PHY responds to specific
IOSF-SB port.</p>
<p>Each display PHY is made up of one or two channels. Each channel
houses a common lane part which contains the PLL and other common
logic. CH0 common lane also contains the IOSF-SB logic for the
Common Register Interface (CRI) ie. the DPIO registers. CRI clock
must be running when any DPIO registers are accessed.</p>
<p>In addition to having their own registers, the PHYs are also
controlled through some dedicated signals from the display
controller. These include PLL reference clock enable, PLL enable,
and CRI clock selection, for example.</p>
<p>Eeach channel also has two splines (also called data lanes), and
each spline is made up of one Physical Access Coding Sub-Layer
(PCS) block and two TX lanes. So each channel has two PCS blocks
and four TX lanes. The TX lanes are used as DP lanes or TMDS
data/clock pairs depending on the output type.</p>
<p>Additionally the PHY also contains an AUX lane with AUX blocks
for each channel. This is used for DP AUX communication, but
this fact isn’t really relevant for the driver since AUX is
controlled from the display controller side. No DPIO registers
need to be accessed during AUX communication,</p>
<p>Generally on VLV/CHV the common lane corresponds to the pipe and
the spline (PCS/TX) corresponds to the port.</p>
<p>For dual channel PHY (VLV/CHV):</p>
<blockquote>
<div><p>pipe A == CMN/PLL/REF CH0</p>
<p>pipe B == CMN/PLL/REF CH1</p>
<p>port B == PCS/TX CH0</p>
<p>port C == PCS/TX CH1</p>
</div></blockquote>
<p>This is especially important when we cross the streams
ie. drive port B with pipe B, or port C with pipe A.</p>
<p>For single channel PHY (CHV):</p>
<blockquote>
<div><p>pipe C == CMN/PLL/REF CH0</p>
<p>port D == PCS/TX CH0</p>
</div></blockquote>
<p>On BXT the entire PHY channel corresponds to the port. That means
the PLL is also now associated with the port rather than the pipe,
and so the clock needs to be routed to the appropriate transcoder.
Port A PLL is directly connected to transcoder EDP and port B/C
PLLs can be routed to any transcoder A/B/C.</p>
<p>Note: DDI0 is digital port B, DD1 is digital port C, and DDI2 is
digital port D (CHV) or port A (BXT).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Dual channel PHY (VLV/CHV/BXT)
---------------------------------
|      CH0      |      CH1      |
|  CMN/PLL/REF  |  CMN/PLL/REF  |
|---------------|---------------| Display PHY
| PCS01 | PCS23 | PCS01 | PCS23 |
|-------|-------|-------|-------|
|TX0|TX1|TX2|TX3|TX0|TX1|TX2|TX3|
---------------------------------
|     DDI0      |     DDI1      | DP/HDMI ports
---------------------------------

Single channel PHY (CHV/BXT)
-----------------
|      CH0      |
|  CMN/PLL/REF  |
|---------------| Display PHY
| PCS01 | PCS23 |
|-------|-------|
|TX0|TX1|TX2|TX3|
-----------------
|     DDI2      | DP/HDMI port
-----------------
</pre></div>
</div>
</div>
<div class="section" id="csr-firmware-support-for-dmc">
<h3>CSR firmware support for DMC<a class="headerlink" href="#csr-firmware-support-for-dmc" title="Permalink to this headline">¶</a></h3>
<p>Display Context Save and Restore (CSR) firmware support added from gen9
onwards to drive newly added DMC (Display microcontroller) in display
engine to save and restore the state of display engine when it enter into
low-power state and comes back to normal.</p>
<dl class="c function">
<dt id="c.intel_csr_load_program">
void <code class="sig-name descname">intel_csr_load_program</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_csr_load_program" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>write the firmware from memory to register.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 drm device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>CSR firmware is read from a .bin file and kept in internal memory one time.
Everytime display comes back from low power state this function is called to
copy the firmware from internal memory to registers.</p>
<dl class="c function">
<dt id="c.intel_csr_ucode_init">
void <code class="sig-name descname">intel_csr_ucode_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_csr_ucode_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize the firmware loading.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 drm device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the time of loading the display driver to read
firmware from a .bin file and copied into a internal memory.</p>
<dl class="c function">
<dt id="c.intel_csr_ucode_suspend">
void <code class="sig-name descname">intel_csr_ucode_suspend</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_csr_ucode_suspend" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>prepare CSR firmware before system suspend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 drm device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepare the DMC firmware before entering system suspend. This includes
flushing pending work items and releasing any resources acquired during
init.</p>
<dl class="c function">
<dt id="c.intel_csr_ucode_resume">
void <code class="sig-name descname">intel_csr_ucode_resume</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_csr_ucode_resume" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>init CSR firmware during system resume</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 drm device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reinitialize the DMC firmware during system resume, reacquiring any
resources released in <a class="reference internal" href="#c.intel_csr_ucode_suspend" title="intel_csr_ucode_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_csr_ucode_suspend()</span></code></a>.</p>
<dl class="c function">
<dt id="c.intel_csr_ucode_fini">
void <code class="sig-name descname">intel_csr_ucode_fini</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_csr_ucode_fini" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unload the CSR firmware.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 drm device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Firmmware unloading includes freeing the internal memory and reset the
firmware loading status.</p>
</div>
<div class="section" id="video-bios-table-vbt">
<h3>Video BIOS Table (VBT)<a class="headerlink" href="#video-bios-table-vbt" title="Permalink to this headline">¶</a></h3>
<p>The Video BIOS Table, or VBT, provides platform and board specific
configuration information to the driver that is not discoverable or available
through other means. The configuration is mostly related to display
hardware. The VBT is available via the ACPI OpRegion or, on older systems, in
the PCI ROM.</p>
<p>The VBT consists of a VBT Header (defined as <a class="reference internal" href="#c.vbt_header" title="vbt_header"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vbt_header</span></code></a>), a BDB
Header (<a class="reference internal" href="#c.bdb_header" title="bdb_header"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bdb_header</span></code></a>), and a number of BIOS Data Blocks (BDB) that
contain the actual configuration information. The VBT Header, and thus the
VBT, begins with “$VBT” signature. The VBT Header contains the offset of the
BDB Header. The data blocks are concatenated after the BDB Header. The data
blocks have a 1-byte Block ID, 2-byte Block Size, and Block Size bytes of
data. (Block 53, the MIPI Sequence Block is an exception.)</p>
<p>The driver parses the VBT during load. The relevant information is stored in
driver private data for ease of use, and the actual VBT is not read after
that.</p>
<dl class="c function">
<dt id="c.intel_bios_is_valid_vbt">
bool <code class="sig-name descname">intel_bios_is_valid_vbt</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>buf</em>, size_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_valid_vbt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>does the given buffer contain a valid VBT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to a buffer to validate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true on valid VBT.</p>
<dl class="c function">
<dt id="c.intel_bios_init">
void <code class="sig-name descname">intel_bios_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find VBT and initialize settings from the BIOS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse and initialize settings from the Video BIOS Tables (VBT). If the VBT
was not found in ACPI OpRegion, try to find it in PCI ROM first. Also
initialize some defaults if the VBT is not present at all.</p>
<dl class="c function">
<dt id="c.intel_bios_driver_remove">
void <code class="sig-name descname">intel_bios_driver_remove</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_driver_remove" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free any resources allocated by <a class="reference internal" href="#c.intel_bios_init" title="intel_bios_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_bios_init()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.intel_bios_is_tv_present">
bool <code class="sig-name descname">intel_bios_is_tv_present</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_tv_present" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is integrated TV present in VBT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if TV is present. If no child devices were parsed from VBT,
assume TV is present.</p>
<dl class="c function">
<dt id="c.intel_bios_is_lvds_present">
bool <code class="sig-name descname">intel_bios_is_lvds_present</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, u8 *<em>i2c_pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_lvds_present" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is LVDS present in VBT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*i2c_pin</span></code></dt><dd><p>i2c pin for LVDS if present</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if LVDS is present. If no child devices were parsed from VBT,
assume LVDS is present.</p>
<dl class="c function">
<dt id="c.intel_bios_is_port_present">
bool <code class="sig-name descname">intel_bios_is_port_present</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_bios_is_port_present" title="port">port</a> <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_port_present" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is the specified digital port present</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">port</span></code></dt><dd><p>port to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the device in <code class="docutils literal notranslate"><span class="pre">port</span></code> is present.</p>
<dl class="c function">
<dt id="c.intel_bios_is_port_edp">
bool <code class="sig-name descname">intel_bios_is_port_edp</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_bios_is_port_edp" title="port">port</a> <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_port_edp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is the device in given port eDP</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">port</span></code></dt><dd><p>port to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the device in <code class="docutils literal notranslate"><span class="pre">port</span></code> is eDP.</p>
<dl class="c function">
<dt id="c.intel_bios_is_dsi_present">
bool <code class="sig-name descname">intel_bios_is_dsi_present</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_bios_is_dsi_present" title="port">port</a> *<em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_dsi_present" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is DSI present in VBT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">*port</span></code></dt><dd><p>port for DSI if present</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if DSI is present, and return the port in <code class="docutils literal notranslate"><span class="pre">port</span></code>.</p>
<dl class="c function">
<dt id="c.intel_bios_is_port_hpd_inverted">
bool <code class="sig-name descname">intel_bios_is_port_hpd_inverted</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> drm_i915_private *<em>i915</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_bios_is_port_hpd_inverted" title="port">port</a> <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_port_hpd_inverted" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is HPD inverted for <code class="docutils literal notranslate"><span class="pre">port</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">port</span></code></dt><dd><p>port to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if HPD should be inverted for <code class="docutils literal notranslate"><span class="pre">port</span></code>.</p>
<dl class="c function">
<dt id="c.intel_bios_is_lspcon_present">
bool <code class="sig-name descname">intel_bios_is_lspcon_present</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> drm_i915_private *<em>i915</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_bios_is_lspcon_present" title="port">port</a> <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_lspcon_present" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>if LSPCON is attached on <code class="docutils literal notranslate"><span class="pre">port</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">port</span></code></dt><dd><p>port to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if LSPCON is present on this port</p>
<dl class="c struct">
<dt id="c.vbt_header">
<em class="property">struct </em><code class="sig-name descname">vbt_header</code><a class="headerlink" href="#c.vbt_header" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>VBT Header structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vbt_header {
  u8 signature[20];
  u16 version;
  u16 header_size;
  u16 vbt_size;
  u8 vbt_checksum;
  u8 reserved0;
  u32 bdb_offset;
  u32 aim_offset[4];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">signature</span></code></dt><dd><p>VBT signature, always starts with “$VBT”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt><dd><p>Version of this structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header_size</span></code></dt><dd><p>Size of this structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vbt_size</span></code></dt><dd><p>Size of VBT (VBT Header, BDB Header and data blocks)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vbt_checksum</span></code></dt><dd><p>Checksum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved0</span></code></dt><dd><p>Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bdb_offset</span></code></dt><dd><p>Offset of <a class="reference internal" href="#c.bdb_header" title="bdb_header"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bdb_header</span></code></a> from beginning of VBT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aim_offset</span></code></dt><dd><p>Offsets of add-in data blocks from beginning of VBT</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.bdb_header">
<em class="property">struct </em><code class="sig-name descname">bdb_header</code><a class="headerlink" href="#c.bdb_header" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>BDB Header structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct bdb_header {
  u8 signature[16];
  u16 version;
  u16 header_size;
  u16 bdb_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">signature</span></code></dt><dd><p>BDB signature “BIOS_DATA_BLOCK”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt><dd><p>Version of the data block definitions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header_size</span></code></dt><dd><p>Size of this structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bdb_size</span></code></dt><dd><p>Size of BDB (BDB Header and data blocks)</p>
</dd>
</dl>
</div>
<div class="section" id="display-clocks">
<h3>Display clocks<a class="headerlink" href="#display-clocks" title="Permalink to this headline">¶</a></h3>
<p>The display engine uses several different clocks to do its work. There
are two main clocks involved that aren’t directly related to the actual
pixel clock or any symbol/bit clock of the actual output port. These
are the core display clock (CDCLK) and RAWCLK.</p>
<p>CDCLK clocks most of the display pipe logic, and thus its frequency
must be high enough to support the rate at which pixels are flowing
through the pipes. Downscaling must also be accounted as that increases
the effective pixel rate.</p>
<p>On several platforms the CDCLK frequency can be changed dynamically
to minimize power consumption for a given display configuration.
Typically changes to the CDCLK frequency require all the display pipes
to be shut down while the frequency is being changed.</p>
<p>On SKL+ the DMC will toggle the CDCLK off/on during DC5/6 entry/exit.
DMC will not change the active CDCLK frequency however, so that part
will still be performed by the driver directly.</p>
<p>RAWCLK is a fixed frequency clock, often used by various auxiliary
blocks such as AUX CH or backlight PWM. Hence the only thing we
really need to know about RAWCLK is its frequency so that various
dividers can be programmed correctly.</p>
<dl class="c function">
<dt id="c.intel_cdclk_init_hw">
void <code class="sig-name descname">intel_cdclk_init_hw</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_cdclk_init_hw" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize CDCLK hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize CDCLK. This consists mainly of initializing dev_priv-&gt;cdclk.hw and
sanitizing the state of the hardware if needed. This is generally done only
during the display core initialization sequence, after which the DMC will
take care of turning CDCLK off/on as needed.</p>
<dl class="c function">
<dt id="c.intel_cdclk_uninit_hw">
void <code class="sig-name descname">intel_cdclk_uninit_hw</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_cdclk_uninit_hw" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Uninitialize CDCLK hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uninitialize CDCLK. This is done only during the display core
uninitialization sequence.</p>
<dl class="c function">
<dt id="c.intel_cdclk_needs_modeset">
bool <code class="sig-name descname">intel_cdclk_needs_modeset</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> intel_cdclk_config *<em>a</em>, <em class="property">const</em> <em class="property">struct</em> intel_cdclk_config *<em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_cdclk_needs_modeset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if changong between the CDCLK configurations requires a modeset on all pipes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_cdclk_config</span> <span class="pre">*a</span></code></dt><dd><p>first CDCLK configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_cdclk_config</span> <span class="pre">*b</span></code></dt><dd><p>second CDCLK configuration</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if changing between the two CDCLK configurations
requires all pipes to be off, false if not.</p>
<dl class="c function">
<dt id="c.intel_cdclk_can_cd2x_update">
bool <code class="sig-name descname">intel_cdclk_can_cd2x_update</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">const</em> <em class="property">struct</em> intel_cdclk_config *<em>a</em>, <em class="property">const</em> <em class="property">struct</em> intel_cdclk_config *<em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_cdclk_can_cd2x_update" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if changing between the two CDCLK configurations requires only a cd2x divider update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_cdclk_config</span> <span class="pre">*a</span></code></dt><dd><p>first CDCLK configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_cdclk_config</span> <span class="pre">*b</span></code></dt><dd><p>second CDCLK configuration</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if changing between the two CDCLK configurations
can be done with just a cd2x divider update, false if not.</p>
<dl class="c function">
<dt id="c.intel_cdclk_changed">
bool <code class="sig-name descname">intel_cdclk_changed</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> intel_cdclk_config *<em>a</em>, <em class="property">const</em> <em class="property">struct</em> intel_cdclk_config *<em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_cdclk_changed" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if two CDCLK configurations are different</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_cdclk_config</span> <span class="pre">*a</span></code></dt><dd><p>first CDCLK configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_cdclk_config</span> <span class="pre">*b</span></code></dt><dd><p>second CDCLK configuration</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the CDCLK configurations don’t match, false if they do.</p>
<dl class="c function">
<dt id="c.intel_set_cdclk">
void <code class="sig-name descname">intel_set_cdclk</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">const</em> <em class="property">struct</em> intel_cdclk_config *<em>cdclk_config</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_set_cdclk" title="pipe">pipe</a> <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_set_cdclk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Push the CDCLK configuration to the hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_cdclk_config</span> <span class="pre">*cdclk_config</span></code></dt><dd><p>new CDCLK configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pipe</span> <span class="pre">pipe</span></code></dt><dd><p>pipe with which to synchronize the update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Program the hardware based on the passed in CDCLK state,
if necessary.</p>
<dl class="c function">
<dt id="c.intel_set_cdclk_pre_plane_update">
void <code class="sig-name descname">intel_set_cdclk_pre_plane_update</code><span class="sig-paren">(</span><em class="property">struct</em> intel_atomic_state *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_set_cdclk_pre_plane_update" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Push the CDCLK state to the hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>intel atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Program the hardware before updating the HW plane state based on the
new CDCLK state, if necessary.</p>
<dl class="c function">
<dt id="c.intel_set_cdclk_post_plane_update">
void <code class="sig-name descname">intel_set_cdclk_post_plane_update</code><span class="sig-paren">(</span><em class="property">struct</em> intel_atomic_state *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_set_cdclk_post_plane_update" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Push the CDCLK state to the hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>intel atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Program the hardware after updating the HW plane state based on the
new CDCLK state, if necessary.</p>
<dl class="c function">
<dt id="c.intel_update_max_cdclk">
void <code class="sig-name descname">intel_update_max_cdclk</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_update_max_cdclk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine the maximum support CDCLK frequency</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the maximum CDCLK frequency the platform supports, and also
derive the maximum dot clock frequency the maximum CDCLK frequency
allows.</p>
<dl class="c function">
<dt id="c.intel_update_cdclk">
void <code class="sig-name descname">intel_update_cdclk</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_update_cdclk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine the current CDCLK frequency</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the current CDCLK frequency.</p>
<dl class="c function">
<dt id="c.intel_read_rawclk">
u32 <code class="sig-name descname">intel_read_rawclk</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_read_rawclk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine the current RAWCLK frequency</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the current RAWCLK frequency. RAWCLK is a fixed
frequency clock so this needs to done only once.</p>
<dl class="c function">
<dt id="c.intel_init_cdclk_hooks">
void <code class="sig-name descname">intel_init_cdclk_hooks</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_init_cdclk_hooks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize CDCLK related modesetting hooks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device</p>
</dd>
</dl>
</div>
<div class="section" id="display-plls">
<h3>Display PLLs<a class="headerlink" href="#display-plls" title="Permalink to this headline">¶</a></h3>
<p>Display PLLs used for driving outputs vary by platform. While some have
per-pipe or per-encoder dedicated PLLs, others allow the use of any PLL
from a pool. In the latter scenario, it is possible that multiple pipes
share a PLL if their configurations match.</p>
<p>This file provides an abstraction over display PLLs. The function
<a class="reference internal" href="#c.intel_shared_dpll_init" title="intel_shared_dpll_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_shared_dpll_init()</span></code></a> initializes the PLLs for the given platform.  The
users of a PLL are tracked and that tracking is integrated with the atomic
modset interface. During an atomic operation, required PLLs can be reserved
for a given CRTC and encoder configuration by calling
<a class="reference internal" href="#c.intel_reserve_shared_dplls" title="intel_reserve_shared_dplls"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_reserve_shared_dplls()</span></code></a> and previously reserved PLLs can be released
with <a class="reference internal" href="#c.intel_release_shared_dplls" title="intel_release_shared_dplls"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_release_shared_dplls()</span></code></a>.
Changes to the users are first staged in the atomic state, and then made
effective by calling <a class="reference internal" href="#c.intel_shared_dpll_swap_state" title="intel_shared_dpll_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_shared_dpll_swap_state()</span></code></a> during the atomic
commit phase.</p>
<dl class="c function">
<dt id="c.intel_get_shared_dpll_by_id">
<em class="property">struct</em> <a class="reference internal" href="#c.intel_shared_dpll" title="intel_shared_dpll">intel_shared_dpll</a> *<code class="sig-name descname">intel_get_shared_dpll_by_id</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">enum</em> <a class="reference internal" href="#c.intel_dpll_id" title="intel_dpll_id">intel_dpll_id</a> <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_get_shared_dpll_by_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a DPLL given its id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">intel_dpll_id</span> <span class="pre">id</span></code></dt><dd><p>pll id</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the DPLL with <strong>id</strong></p>
<dl class="c function">
<dt id="c.intel_get_shared_dpll_id">
<em class="property">enum</em> <a class="reference internal" href="#c.intel_dpll_id" title="intel_dpll_id">intel_dpll_id</a> <code class="sig-name descname">intel_get_shared_dpll_id</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">struct</em> <a class="reference internal" href="#c.intel_shared_dpll" title="intel_shared_dpll">intel_shared_dpll</a> *<em>pll</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_get_shared_dpll_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the id of a DPLL</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_shared_dpll</span> <span class="pre">*pll</span></code></dt><dd><p>the DPLL</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The id of <strong>pll</strong></p>
<dl class="c function">
<dt id="c.intel_prepare_shared_dpll">
void <code class="sig-name descname">intel_prepare_shared_dpll</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_prepare_shared_dpll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>call a dpll’s prepare hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>CRTC, and its state, which has a shared dpll</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This calls the PLL’s prepare hook if it has one and if the PLL is not
already enabled. The prepare hook is platform specific.</p>
<dl class="c function">
<dt id="c.intel_enable_shared_dpll">
void <code class="sig-name descname">intel_enable_shared_dpll</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_enable_shared_dpll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable a CRTC’s shared DPLL</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>CRTC, and its state, which has a shared DPLL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable the shared DPLL used by <strong>crtc</strong>.</p>
<dl class="c function">
<dt id="c.intel_disable_shared_dpll">
void <code class="sig-name descname">intel_disable_shared_dpll</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_disable_shared_dpll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>disable a CRTC’s shared DPLL</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>CRTC, and its state, which has a shared DPLL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable the shared DPLL used by <strong>crtc</strong>.</p>
<dl class="c function">
<dt id="c.intel_shared_dpll_swap_state">
void <code class="sig-name descname">intel_shared_dpll_swap_state</code><span class="sig-paren">(</span><em class="property">struct</em> intel_atomic_state *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_shared_dpll_swap_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>make atomic DPLL configuration effective</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the dpll version of <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a> since the
helper does not handle driver-specific global state.</p>
<p>For consistency with atomic helpers this function does a complete swap,
i.e. it also puts the current state into <strong>state</strong>, even though there is no
need for that at this moment.</p>
<dl class="c function">
<dt id="c.icl_set_active_port_dpll">
void <code class="sig-name descname">icl_set_active_port_dpll</code><span class="sig-paren">(</span><em class="property">struct</em> intel_crtc_state *<em>crtc_state</em>, <em class="property">enum</em> icl_port_dpll_id <em>port_dpll_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.icl_set_active_port_dpll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>select the active port DPLL for a given CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>state for the CRTC to select the DPLL for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">icl_port_dpll_id</span> <span class="pre">port_dpll_id</span></code></dt><dd><p>the active <strong>port_dpll_id</strong> to select</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Select the given <strong>port_dpll_id</strong> instance from the DPLLs reserved for the
CRTC.</p>
<dl class="c function">
<dt id="c.intel_shared_dpll_init">
void <code class="sig-name descname">intel_shared_dpll_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_shared_dpll_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize shared DPLLs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize shared DPLLs for <strong>dev</strong>.</p>
<dl class="c function">
<dt id="c.intel_reserve_shared_dplls">
bool <code class="sig-name descname">intel_reserve_shared_dplls</code><span class="sig-paren">(</span><em class="property">struct</em> intel_atomic_state *<em>state</em>, <em class="property">struct</em> intel_crtc *<em>crtc</em>, <em class="property">struct</em> intel_encoder *<em>encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_reserve_shared_dplls" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reserve DPLLs for CRTC and encoder combination</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to reserve DPLLs for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function reserves all required DPLLs for the given CRTC and encoder
combination in the current atomic commit <strong>state</strong> and the new <strong>crtc</strong> atomic
state.</p>
<p>The new configuration in the atomic commit <strong>state</strong> is made effective by
calling <a class="reference internal" href="#c.intel_shared_dpll_swap_state" title="intel_shared_dpll_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_shared_dpll_swap_state()</span></code></a>.</p>
<p>The reserved DPLLs should be released by calling
<a class="reference internal" href="#c.intel_release_shared_dplls" title="intel_release_shared_dplls"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_release_shared_dplls()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>True if all required DPLLs were successfully reserved.</p>
<dl class="c function">
<dt id="c.intel_release_shared_dplls">
void <code class="sig-name descname">intel_release_shared_dplls</code><span class="sig-paren">(</span><em class="property">struct</em> intel_atomic_state *<em>state</em>, <em class="property">struct</em> intel_crtc *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_release_shared_dplls" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>end use of DPLLs by CRTC in atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>crtc from which the DPLLs are to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function releases all DPLLs reserved by <a class="reference internal" href="#c.intel_reserve_shared_dplls" title="intel_reserve_shared_dplls"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_reserve_shared_dplls()</span></code></a>
from the current atomic commit <strong>state</strong> and the old <strong>crtc</strong> atomic state.</p>
<p>The new configuration in the atomic commit <strong>state</strong> is made effective by
calling <a class="reference internal" href="#c.intel_shared_dpll_swap_state" title="intel_shared_dpll_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_shared_dpll_swap_state()</span></code></a>.</p>
<dl class="c function">
<dt id="c.intel_update_active_dpll">
void <code class="sig-name descname">intel_update_active_dpll</code><span class="sig-paren">(</span><em class="property">struct</em> intel_atomic_state *<em>state</em>, <em class="property">struct</em> intel_crtc *<em>crtc</em>, <em class="property">struct</em> intel_encoder *<em>encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_update_active_dpll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update the active DPLL for a CRTC/encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>the CRTC for which to update the active DPLL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder determining the type of port DPLL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the active DPLL for the given <strong>crtc</strong>/<strong>encoder</strong> in <strong>crtc</strong>’s atomic state,
from the port DPLLs reserved previously by <a class="reference internal" href="#c.intel_reserve_shared_dplls" title="intel_reserve_shared_dplls"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_reserve_shared_dplls()</span></code></a>. The
DPLL selected will be based on the current mode of the encoder’s port.</p>
<dl class="c function">
<dt id="c.intel_dpll_get_freq">
int <code class="sig-name descname">intel_dpll_get_freq</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.intel_shared_dpll" title="intel_shared_dpll">intel_shared_dpll</a> *<em>pll</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dpll_get_freq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>calculate the DPLL’s output frequency</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_shared_dpll</span> <span class="pre">*pll</span></code></dt><dd><p>DPLL for which to calculate the output frequency</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the output frequency corresponding to <strong>pll</strong>’s current state.</p>
<dl class="c function">
<dt id="c.intel_dpll_dump_hw_state">
void <code class="sig-name descname">intel_dpll_dump_hw_state</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em>, <em class="property">const</em> <em class="property">struct</em> intel_dpll_hw_state *<em>hw_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dpll_dump_hw_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>write hw_state to dmesg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_dpll_hw_state</span> <span class="pre">*hw_state</span></code></dt><dd><p>hw state to be written to the log</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write the relevant values in <strong>hw_state</strong> to dmesg using drm_dbg_kms.</p>
<dl class="c enum">
<dt id="c.intel_dpll_id">
<em class="property">enum </em><code class="sig-name descname">intel_dpll_id</code><a class="headerlink" href="#c.intel_dpll_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>possible DPLL ids</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_PRIVATE</span></code></dt><dd><p>non-shared dpll in use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_PCH_PLL_A</span></code></dt><dd><p>DPLL A in ILK, SNB and IVB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_PCH_PLL_B</span></code></dt><dd><p>DPLL B in ILK, SNB and IVB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_WRPLL1</span></code></dt><dd><p>HSW and BDW WRPLL1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_WRPLL2</span></code></dt><dd><p>HSW and BDW WRPLL2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_SPLL</span></code></dt><dd><p>HSW and BDW SPLL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_LCPLL_810</span></code></dt><dd><p>HSW and BDW 0.81 GHz LCPLL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_LCPLL_1350</span></code></dt><dd><p>HSW and BDW 1.35 GHz LCPLL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_LCPLL_2700</span></code></dt><dd><p>HSW and BDW 2.7 GHz LCPLL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_SKL_DPLL0</span></code></dt><dd><p>SKL and later DPLL0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_SKL_DPLL1</span></code></dt><dd><p>SKL and later DPLL1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_SKL_DPLL2</span></code></dt><dd><p>SKL and later DPLL2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_SKL_DPLL3</span></code></dt><dd><p>SKL and later DPLL3</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_ICL_DPLL0</span></code></dt><dd><p>ICL/TGL combo PHY DPLL0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_ICL_DPLL1</span></code></dt><dd><p>ICL/TGL combo PHY DPLL1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_EHL_DPLL4</span></code></dt><dd><p>EHL combo PHY DPLL4</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_ICL_TBTPLL</span></code></dt><dd><p>ICL/TGL TBT PLL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_ICL_MGPLL1</span></code></dt><dd><dl class="simple">
<dt>ICL MG PLL 1 port 1 (C),</dt><dd><p>TGL TC PLL 1 port 1 (TC1)</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_ICL_MGPLL2</span></code></dt><dd><dl class="simple">
<dt>ICL MG PLL 1 port 2 (D)</dt><dd><p>TGL TC PLL 1 port 2 (TC2)</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_ICL_MGPLL3</span></code></dt><dd><dl class="simple">
<dt>ICL MG PLL 1 port 3 (E)</dt><dd><p>TGL TC PLL 1 port 3 (TC3)</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_ICL_MGPLL4</span></code></dt><dd><dl class="simple">
<dt>ICL MG PLL 1 port 4 (F)</dt><dd><p>TGL TC PLL 1 port 4 (TC4)</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_TGL_MGPLL5</span></code></dt><dd><p>TGL TC PLL port 5 (TC5)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPLL_ID_TGL_MGPLL6</span></code></dt><dd><p>TGL TC PLL port 6 (TC6)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enumeration of possible IDs for a DPLL. Real shared dpll ids must be &gt;= 0.</p>
<dl class="c struct">
<dt id="c.intel_shared_dpll_state">
<em class="property">struct </em><code class="sig-name descname">intel_shared_dpll_state</code><a class="headerlink" href="#c.intel_shared_dpll_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>hold the DPLL atomic state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct intel_shared_dpll_state {
  unsigned crtc_mask;
  struct intel_dpll_hw_state hw_state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">crtc_mask</span></code></dt><dd><p>mask of CRTC using this DPLL, active or not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_state</span></code></dt><dd><p>hardware configuration for the DPLL stored in
struct <code class="xref c c-type docutils literal notranslate"><span class="pre">intel_dpll_hw_state</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure holds an atomic state for the DPLL, that can represent
either its current state (in struct <a class="reference internal" href="#c.intel_shared_dpll" title="intel_shared_dpll"><code class="xref c c-type docutils literal notranslate"><span class="pre">intel_shared_dpll</span></code></a>) or a desired
future state which would be applied by an atomic mode set (stored in
a struct <code class="xref c c-type docutils literal notranslate"><span class="pre">intel_atomic_state</span></code>).</p>
<p>See also <a class="reference internal" href="#c.intel_reserve_shared_dplls" title="intel_reserve_shared_dplls"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_reserve_shared_dplls()</span></code></a> and <a class="reference internal" href="#c.intel_release_shared_dplls" title="intel_release_shared_dplls"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_release_shared_dplls()</span></code></a>.</p>
<dl class="c struct">
<dt id="c.intel_shared_dpll_funcs">
<em class="property">struct </em><code class="sig-name descname">intel_shared_dpll_funcs</code><a class="headerlink" href="#c.intel_shared_dpll_funcs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>platform specific hooks for managing DPLLs</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct intel_shared_dpll_funcs {
  void (*prepare)(struct drm_i915_private *dev_priv, struct intel_shared_dpll *pll);
  void (*enable)(struct drm_i915_private *dev_priv, struct intel_shared_dpll *pll);
  void (*disable)(struct drm_i915_private *dev_priv, struct intel_shared_dpll *pll);
  bool (*get_hw_state)(struct drm_i915_private *dev_priv,struct intel_shared_dpll *pll, struct intel_dpll_hw_state *hw_state);
  int (*get_freq)(struct drm_i915_private *i915, const struct intel_shared_dpll *pll);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt><dd><p>Optional hook to perform operations prior to enabling the PLL.
Called from <a class="reference internal" href="#c.intel_prepare_shared_dpll" title="intel_prepare_shared_dpll"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_prepare_shared_dpll()</span></code></a> function unless the PLL
is already enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>Hook for enabling the pll, called from <a class="reference internal" href="#c.intel_enable_shared_dpll" title="intel_enable_shared_dpll"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_enable_shared_dpll()</span></code></a>
if the pll is not already enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>Hook for disabling the pll, called from <a class="reference internal" href="#c.intel_disable_shared_dpll" title="intel_disable_shared_dpll"><code class="xref c c-func docutils literal notranslate"><span class="pre">intel_disable_shared_dpll()</span></code></a>
only when it is safe to disable the pll, i.e., there are no more
tracked users for it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_hw_state</span></code></dt><dd><p>Hook for reading the values currently programmed to the DPLL
registers. This is used for initial hw state readout and state
verification after a mode set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_freq</span></code></dt><dd><p>Hook for calculating the pll’s output frequency based on its
current state.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.dpll_info">
<em class="property">struct </em><code class="sig-name descname">dpll_info</code><a class="headerlink" href="#c.dpll_info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>display PLL platform specific info</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dpll_info {
  const char *name;
  const struct intel_shared_dpll_funcs *funcs;
  enum intel_dpll_id id;
#define INTEL_DPLL_ALWAYS_ON    (1 &lt;&lt; 0);
  u32 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>DPLL name; used for logging</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>platform specific hooks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>unique indentifier for this DPLL; should match the index in the
dev_priv-&gt;shared_dplls array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><dl class="simple">
<dt>INTEL_DPLL_ALWAYS_ON</dt><dd><p>Inform the state checker that the DPLL is kept enabled even if
not in use by any CRTC.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="c struct">
<dt id="c.intel_shared_dpll">
<em class="property">struct </em><code class="sig-name descname">intel_shared_dpll</code><a class="headerlink" href="#c.intel_shared_dpll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>display PLL with tracked state and users</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct intel_shared_dpll {
  struct intel_shared_dpll_state state;
  unsigned active_mask;
  bool on;
  const struct dpll_info *info;
  intel_wakeref_t wakeref;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>Store the state for the pll, including its hw state
and CRTCs using it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_mask</span></code></dt><dd><p>mask of active CRTCs (i.e. DPMS on) using this DPLL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">on</span></code></dt><dd><p>is the PLL actually active? Disabled during modeset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>platform specific info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wakeref</span></code></dt><dd><p>In some platforms a device-level runtime pm reference may
need to be grabbed to disable DC states while this DPLL is enabled</p>
</dd>
</dl>
</div>
<div class="section" id="display-state-buffer">
<h3>Display State Buffer<a class="headerlink" href="#display-state-buffer" title="Permalink to this headline">¶</a></h3>
<p>A DSB (Display State Buffer) is a queue of MMIO instructions in the memory
which can be offloaded to DSB HW in Display Controller. DSB HW is a DMA
engine that can be programmed to download the DSB from memory.
It allows driver to batch submit display HW programming. This helps to
reduce loading time and CPU activity, thereby making the context switch
faster. DSB Support added from Gen12 Intel graphics based platform.</p>
<p>DSB’s can access only the pipe, plane, and transcoder Data Island Packet
registers.</p>
<p>DSB HW can support only register writes (both indexed and direct MMIO
writes). There are no registers reads possible with DSB HW engine.</p>
<dl class="c function">
<dt id="c.intel_dsb_indexed_reg_write">
void <code class="sig-name descname">intel_dsb_indexed_reg_write</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em>, i915_reg_t <em>reg</em>, u32 <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dsb_indexed_reg_write" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write to the DSB context for auto increment register.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>intel_crtc_state structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i915_reg_t</span> <span class="pre">reg</span></code></dt><dd><p>register address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">val</span></code></dt><dd><p>value.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used for writing register-value pair in command
buffer of DSB for auto-increment register. During command buffer overflow,
a warning is thrown and rest all erroneous condition register programming
is done through mmio write.</p>
<dl class="c function">
<dt id="c.intel_dsb_reg_write">
void <code class="sig-name descname">intel_dsb_reg_write</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em>, i915_reg_t <em>reg</em>, u32 <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dsb_reg_write" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write to the DSB context for normal register.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>intel_crtc_state structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i915_reg_t</span> <span class="pre">reg</span></code></dt><dd><p>register address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">val</span></code></dt><dd><p>value.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used for writing register-value pair in command
buffer of DSB. During command buffer overflow, a warning  is thrown
and rest all erroneous condition register programming is done
through mmio write.</p>
<dl class="c function">
<dt id="c.intel_dsb_commit">
void <code class="sig-name descname">intel_dsb_commit</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> intel_crtc_state *<em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dsb_commit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trigger workload execution of DSB.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>intel_crtc_state structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to do actual write to hardware using DSB.
On errors, fall back to MMIO. Also this function help to reset the context.</p>
<dl class="c function">
<dt id="c.intel_dsb_prepare">
void <code class="sig-name descname">intel_dsb_prepare</code><span class="sig-paren">(</span><em class="property">struct</em> intel_crtc_state *<em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dsb_prepare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate, pin and map the DSB command buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>intel_crtc_state structure to prepare associated dsb instance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prepare the command buffer which is used to store dsb
instructions with data.</p>
<dl class="c function">
<dt id="c.intel_dsb_cleanup">
void <code class="sig-name descname">intel_dsb_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> intel_crtc_state *<em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dsb_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>To cleanup DSB context.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>intel_crtc_state structure to cleanup associated dsb instance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleanup the DSB context by unpinning and releasing
the VMA object associated with it.</p>
</div>
</div>
<div class="section" id="memory-management-and-command-submission">
<h2>Memory Management and Command Submission<a class="headerlink" href="#memory-management-and-command-submission" title="Permalink to this headline">¶</a></h2>
<p>This sections covers all things related to the GEM implementation in the
i915 driver.</p>
<div class="section" id="intel-gpu-basics">
<h3>Intel GPU Basics<a class="headerlink" href="#intel-gpu-basics" title="Permalink to this headline">¶</a></h3>
<p>An Intel GPU has multiple engines. There are several engine types.</p>
<ul class="simple">
<li><p>RCS engine is for rendering 3D and performing compute, this is named
<cite>I915_EXEC_RENDER</cite> in user space.</p></li>
<li><p>BCS is a blitting (copy) engine, this is named <cite>I915_EXEC_BLT</cite> in user
space.</p></li>
<li><p>VCS is a video encode and decode engine, this is named <cite>I915_EXEC_BSD</cite>
in user space</p></li>
<li><p>VECS is video enhancement engine, this is named <cite>I915_EXEC_VEBOX</cite> in user
space.</p></li>
<li><p>The enumeration <cite>I915_EXEC_DEFAULT</cite> does not refer to specific engine;
instead it is to be used by user space to specify a default rendering
engine (for 3D) that may or may not be the same as RCS.</p></li>
</ul>
<p>The Intel GPU family is a family of integrated GPU’s using Unified
Memory Access. For having the GPU “do work”, user space will feed the
GPU batch buffers via one of the ioctls <cite>DRM_IOCTL_I915_GEM_EXECBUFFER2</cite>
or <cite>DRM_IOCTL_I915_GEM_EXECBUFFER2_WR</cite>. Most such batchbuffers will
instruct the GPU to perform work (for example rendering) and that work
needs memory from which to read and memory to which to write. All memory
is encapsulated within GEM buffer objects (usually created with the ioctl
<cite>DRM_IOCTL_I915_GEM_CREATE</cite>). An ioctl providing a batchbuffer for the GPU
to create will also list all GEM buffer objects that the batchbuffer reads
and/or writes. For implementation details of memory management see
<a class="reference internal" href="#gem-bo-management-implementation-details">GEM BO Management Implementation Details</a>.</p>
<p>The i915 driver allows user space to create a context via the ioctl
<cite>DRM_IOCTL_I915_GEM_CONTEXT_CREATE</cite> which is identified by a 32-bit
integer. Such a context should be viewed by user-space as -loosely-
analogous to the idea of a CPU process of an operating system. The i915
driver guarantees that commands issued to a fixed context are to be
executed so that writes of a previously issued command are seen by
reads of following commands. Actions issued between different contexts
(even if from the same file descriptor) are NOT given that guarantee
and the only way to synchronize across contexts (even from the same
file descriptor) is through the use of fences. At least as far back as
Gen4, also have that a context carries with it a GPU HW context;
the HW context is essentially (most of atleast) the state of a GPU.
In addition to the ordering guarantees, the kernel will restore GPU
state via HW context when commands are issued to a context, this saves
user space the need to restore (most of atleast) the GPU state at the
start of each batchbuffer. The non-deprecated ioctls to submit batchbuffer
work can pass that ID (in the lower bits of drm_i915_gem_execbuffer2::rsvd1)
to identify what context to use with the command.</p>
<p>The GPU has its own memory management and address space. The kernel
driver maintains the memory translation table for the GPU. For older
GPUs (i.e. those before Gen8), there is a single global such translation
table, a global Graphics Translation Table (GTT). For newer generation
GPUs each context has its own translation table, called Per-Process
Graphics Translation Table (PPGTT). Of important note, is that although
PPGTT is named per-process it is actually per context. When user space
submits a batchbuffer, the kernel walks the list of GEM buffer objects
used by the batchbuffer and guarantees that not only is the memory of
each such GEM buffer object resident but it is also present in the
(PP)GTT. If the GEM buffer object is not yet placed in the (PP)GTT,
then it is given an address. Two consequences of this are: the kernel
needs to edit the batchbuffer submitted to write the correct value of
the GPU address when a GEM BO is assigned a GPU address and the kernel
might evict a different GEM BO from the (PP)GTT to make address room
for another GEM BO. Consequently, the ioctls submitting a batchbuffer
for execution also include a list of all locations within buffers that
refer to GPU-addresses so that the kernel can edit the buffer correctly.
This process is dubbed relocation.</p>
</div>
<div class="section" id="locking-guidelines">
<h3>Locking Guidelines<a class="headerlink" href="#locking-guidelines" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a description of how the locking should be after
refactoring is done. Does not necessarily reflect what the locking
looks like while WIP.</p>
</div>
<ol class="arabic">
<li><p>All locking rules and interface contracts with cross-driver interfaces
(dma-buf, dma_fence) need to be followed.</p></li>
<li><p>No struct_mutex anywhere in the code</p></li>
<li><p>dma_resv will be the outermost lock (when needed) and ww_acquire_ctx
is to be hoisted at highest level and passed down within i915_gem_ctx
in the call chain</p></li>
<li><p>While holding lru/memory manager (buddy, drm_mm, whatever) locks
system memory allocations are not allowed</p>
<blockquote>
<div><ul class="simple">
<li><p>Enforce this by priming lockdep (with fs_reclaim). If we
allocate memory while holding these looks we get a rehash
of the shrinker vs. struct_mutex saga, and that would be
real bad.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Do not nest different lru/memory manager locks within each other.
Take them in turn to update memory allocations, relying on the object’s
dma_resv ww_mutex to serialize against other operations.</p></li>
<li><p>The suggestion for lru/memory managers locks is that they are small
enough to be spinlocks.</p></li>
<li><p>All features need to come with exhaustive kernel selftests and/or
IGT tests when appropriate</p></li>
<li><p>All LMEM uAPI paths need to be fully restartable (_interruptible()
for all locks/waits/sleeps)</p>
<blockquote>
<div><ul class="simple">
<li><p>Error handling validation through signal injection.
Still the best strategy we have for validating GEM uAPI
corner cases.
Must be excessively used in the IGT, and we need to check
that we really have full path coverage of all error cases.</p></li>
<li><p>-EDEADLK handling with ww_mutex</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="gem-bo-management-implementation-details">
<h3>GEM BO Management Implementation Details<a class="headerlink" href="#gem-bo-management-implementation-details" title="Permalink to this headline">¶</a></h3>
<p>A VMA represents a GEM BO that is bound into an address space. Therefore, a
VMA’s presence cannot be guaranteed before binding, or after unbinding the
object into/from the address space.</p>
<p>To make things as simple as possible (ie. no refcounting), a VMA’s lifetime
will always be &lt;= an objects lifetime. So object refcounting should cover us.</p>
</div>
<div class="section" id="buffer-object-eviction">
<h3>Buffer Object Eviction<a class="headerlink" href="#buffer-object-eviction" title="Permalink to this headline">¶</a></h3>
<p>This section documents the interface functions for evicting buffer
objects to make space available in the virtual gpu address spaces. Note
that this is mostly orthogonal to shrinking buffer objects caches, which
has the goal to make main memory (shared with the gpu through the
unified memory architecture) available.</p>
<dl class="c function">
<dt id="c.i915_gem_evict_something">
int <code class="sig-name descname">i915_gem_evict_something</code><span class="sig-paren">(</span><em class="property">struct</em> i915_address_space *<em>vm</em>, u64 <em>min_size</em>, u64 <em>alignment</em>, unsigned long <em>color</em>, u64 <em>start</em>, u64 <em>end</em>, unsigned <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_evict_something" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evict vmas to make room for binding a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_address_space</span> <span class="pre">*vm</span></code></dt><dd><p>address space to evict from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">min_size</span></code></dt><dd><p>size of the desired free space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt><dd><p>alignment constraint of the desired free space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt><dd><p>color for the desired space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>start (inclusive) of the range from which to evict objects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">end</span></code></dt><dd><p>end (exclusive) of the range from which to evict objects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt><dd><p>additional flags to control the eviction algorithm</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will try to evict vmas until a free space satisfying the
requirements is found. Callers must check first whether any such hole exists
already before calling this function.</p>
<p>This function is used by the object/vma binding code.</p>
<p>Since this function is only used to free up virtual address space it only
ignores pinned vmas, and not object where the backing storage itself is
pinned. Hence obj-&gt;pages_pin_count does not protect against eviction.</p>
<p>To clarify: This is for freeing up virtual address space, not for freeing
memory in e.g. the shrinker.</p>
<dl class="c function">
<dt id="c.i915_gem_evict_for_node">
int <code class="sig-name descname">i915_gem_evict_for_node</code><span class="sig-paren">(</span><em class="property">struct</em> i915_address_space *<em>vm</em>, <em class="property">struct</em> <a class="reference internal" href="drm-mm.html#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>target</em>, unsigned int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_evict_for_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evict vmas to make room for binding a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_address_space</span> <span class="pre">*vm</span></code></dt><dd><p>address space to evict from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*target</span></code></dt><dd><p>range (and color) to evict for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>additional flags to control the eviction algorithm</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will try to evict vmas that overlap the target node.</p>
<p>To clarify: This is for freeing up virtual address space, not for freeing
memory in e.g. the shrinker.</p>
<dl class="c function">
<dt id="c.i915_gem_evict_vm">
int <code class="sig-name descname">i915_gem_evict_vm</code><span class="sig-paren">(</span><em class="property">struct</em> i915_address_space *<em>vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_evict_vm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evict all idle vmas from a vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_address_space</span> <span class="pre">*vm</span></code></dt><dd><p>Address space to cleanse</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function evicts all vmas from a vm.</p>
<p>This is used by the execbuf code as a last-ditch effort to defragment the
address space.</p>
<p>To clarify: This is for freeing up virtual address space, not for freeing
memory in e.g. the shrinker.</p>
</div>
<div class="section" id="buffer-object-memory-shrinking">
<h3>Buffer Object Memory Shrinking<a class="headerlink" href="#buffer-object-memory-shrinking" title="Permalink to this headline">¶</a></h3>
<p>This section documents the interface function for shrinking memory usage
of buffer object caches. Shrinking is used to make main memory
available. Note that this is mostly orthogonal to evicting buffer
objects, which has the goal to make space in gpu virtual address spaces.</p>
<dl class="c function">
<dt id="c.i915_gem_shrink">
unsigned long <code class="sig-name descname">i915_gem_shrink</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em>, unsigned long <em>target</em>, unsigned long *<em>nr_scanned</em>, unsigned int <em>shrink</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_shrink" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Shrink buffer object caches</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">target</span></code></dt><dd><p>amount of memory to make available, in pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*nr_scanned</span></code></dt><dd><p>optional output for number of pages scanned (incremental)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">shrink</span></code></dt><dd><p>control flags for selecting cache types</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is the main interface to the shrinker. It will try to release
up to <strong>target</strong> pages of main memory backing storage from buffer objects.
Selection of the specific caches can be done with <strong>flags</strong>. This is e.g. useful
when purgeable objects should be removed from caches preferentially.</p>
<p>Note that it’s not guaranteed that released amount is actually available as
free system memory - the pages might still be in-used to due to other reasons
(like cpu mmaps) or the mm core has reused them before we could grab them.
Therefore code that needs to explicitly shrink buffer objects caches (e.g. to
avoid deadlocks in memory reclaim) must fall back to <a class="reference internal" href="#c.i915_gem_shrink_all" title="i915_gem_shrink_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_gem_shrink_all()</span></code></a>.</p>
<p>Also note that any kind of pinning (both per-vma address space pins and
backing storage pins at the buffer object level) result in the shrinker code
having to skip the object.</p>
<p><strong>Return</strong></p>
<p>The number of pages of backing storage actually released.</p>
<dl class="c function">
<dt id="c.i915_gem_shrink_all">
unsigned long <code class="sig-name descname">i915_gem_shrink_all</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_shrink_all" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Shrink buffer object caches completely</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simple wraper around <a class="reference internal" href="#c.i915_gem_shrink" title="i915_gem_shrink"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_gem_shrink()</span></code></a> to aggressively shrink all
caches completely. It also first waits for and retires all outstanding
requests to also be able to release backing storage for active objects.</p>
<p>This should only be used in code to intentionally quiescent the gpu or as a
last-ditch effort when memory seems to have run out.</p>
<p><strong>Return</strong></p>
<p>The number of pages of backing storage actually released.</p>
</div>
<div class="section" id="batchbuffer-parsing">
<h3>Batchbuffer Parsing<a class="headerlink" href="#batchbuffer-parsing" title="Permalink to this headline">¶</a></h3>
<p>Motivation:
Certain OpenGL features (e.g. transform feedback, performance monitoring)
require userspace code to submit batches containing commands such as
MI_LOAD_REGISTER_IMM to access various registers. Unfortunately, some
generations of the hardware will noop these commands in “unsecure” batches
(which includes all userspace batches submitted via i915) even though the
commands may be safe and represent the intended programming model of the
device.</p>
<p>The software command parser is similar in operation to the command parsing
done in hardware for unsecure batches. However, the software parser allows
some operations that would be noop’d by hardware, if the parser determines
the operation is safe, and submits the batch as “secure” to prevent hardware
parsing.</p>
<p>Threats:
At a high level, the hardware (and software) checks attempt to prevent
granting userspace undue privileges. There are three categories of privilege.</p>
<p>First, commands which are explicitly defined as privileged or which should
only be used by the kernel driver. The parser rejects such commands</p>
<p>Second, commands which access registers. To support correct/enhanced
userspace functionality, particularly certain OpenGL extensions, the parser
provides a whitelist of registers which userspace may safely access</p>
<p>Third, commands which access privileged memory (i.e. GGTT, HWS page, etc).
The parser always rejects such commands.</p>
<p>The majority of the problematic commands fall in the MI_* range, with only a
few specific commands on each engine (e.g. PIPE_CONTROL and MI_FLUSH_DW).</p>
<p>Implementation:
Each engine maintains tables of commands and registers which the parser
uses in scanning batch buffers submitted to that engine.</p>
<p>Since the set of commands that the parser must check for is significantly
smaller than the number of commands supported, the parser tables contain only
those commands required by the parser. This generally works because command
opcode ranges have standard command length encodings. So for commands that
the parser does not need to check, it can easily skip them. This is
implemented via a per-engine length decoding vfunc.</p>
<p>Unfortunately, there are a number of commands that do not follow the standard
length encoding for their opcode range, primarily amongst the MI_* commands.
To handle this, the parser provides a way to define explicit “skip” entries
in the per-engine command tables.</p>
<p>Other command table entries map fairly directly to high level categories
mentioned above: rejected, register whitelist. The parser implements a number
of checks, including the privileged memory checks, via a general bitmasking
mechanism.</p>
<dl class="c function">
<dt id="c.intel_engine_init_cmd_parser">
void <code class="sig-name descname">intel_engine_init_cmd_parser</code><span class="sig-paren">(</span><em class="property">struct</em> intel_engine_cs *<em>engine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_engine_init_cmd_parser" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set cmd parser related fields for an engine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*engine</span></code></dt><dd><p>the engine to initialize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Optionally initializes fields related to batch buffer command parsing in the
struct intel_engine_cs based on whether the platform requires software
command parsing.</p>
<dl class="c function">
<dt id="c.intel_engine_cleanup_cmd_parser">
void <code class="sig-name descname">intel_engine_cleanup_cmd_parser</code><span class="sig-paren">(</span><em class="property">struct</em> intel_engine_cs *<em>engine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_engine_cleanup_cmd_parser" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clean up cmd parser related fields</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*engine</span></code></dt><dd><p>the engine to clean up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases any resources related to command parsing that may have been
initialized for the specified engine.</p>
<dl class="c function">
<dt id="c.intel_engine_cmd_parser">
int <code class="sig-name descname">intel_engine_cmd_parser</code><span class="sig-paren">(</span><em class="property">struct</em> intel_engine_cs *<em>engine</em>, <em class="property">struct</em> i915_vma *<em>batch</em>, unsigned long <em>batch_offset</em>, unsigned long <em>batch_length</em>, <em class="property">struct</em> i915_vma *<em>shadow</em>, bool <em>trampoline</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_engine_cmd_parser" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>parse a batch buffer for privilege violations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*engine</span></code></dt><dd><p>the engine on which the batch is to execute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_vma</span> <span class="pre">*batch</span></code></dt><dd><p>the batch buffer in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">batch_offset</span></code></dt><dd><p>byte offset in the batch at which execution starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">batch_length</span></code></dt><dd><p>length of the commands in batch_obj</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_vma</span> <span class="pre">*shadow</span></code></dt><dd><p>validated copy of the batch buffer in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">trampoline</span></code></dt><dd><p>whether to emit a conditional trampoline at the end of the batch</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parses the specified batch buffer looking for privilege violations as
described in the overview.</p>
<p><strong>Return</strong></p>
<p>non-zero if the parser finds violations or otherwise fails; -EACCES
if the batch appears legal but should use hardware parsing</p>
<dl class="c function">
<dt id="c.i915_cmd_parser_get_version">
int <code class="sig-name descname">i915_cmd_parser_get_version</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_cmd_parser_get_version" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the cmd parser version number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*dev_priv</span></code></dt><dd><p>i915 device private</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The cmd parser maintains a simple increasing integer version number suitable
for passing to userspace clients to determine what operations are permitted.</p>
<p><strong>Return</strong></p>
<p>the current version number of the cmd parser</p>
</div>
<div class="section" id="user-batchbuffer-execution">
<h3>User Batchbuffer Execution<a class="headerlink" href="#user-batchbuffer-execution" title="Permalink to this headline">¶</a></h3>
<p>Userspace submits commands to be executed on the GPU as an instruction
stream within a GEM object we call a batchbuffer. This instructions may
refer to other GEM objects containing auxiliary state such as kernels,
samplers, render targets and even secondary batchbuffers. Userspace does
not know where in the GPU memory these objects reside and so before the
batchbuffer is passed to the GPU for execution, those addresses in the
batchbuffer and auxiliary objects are updated. This is known as relocation,
or patching. To try and avoid having to relocate each object on the next
execution, userspace is told the location of those objects in this pass,
but this remains just a hint as the kernel may choose a new location for
any object in the future.</p>
<p>At the level of talking to the hardware, submitting a batchbuffer for the
GPU to execute is to add content to a buffer from which the HW
command streamer is reading.</p>
<ol class="arabic simple">
<li><p>Add a command to load the HW context. For Logical Ring Contexts, i.e.
Execlists, this command is not placed on the same buffer as the
remaining items.</p></li>
<li><p>Add a command to invalidate caches to the buffer.</p></li>
<li><p>Add a batchbuffer start command to the buffer; the start command is
essentially a token together with the GPU address of the batchbuffer
to be executed.</p></li>
<li><p>Add a pipeline flush to the buffer.</p></li>
<li><p>Add a memory write command to the buffer to record when the GPU
is done executing the batchbuffer. The memory write writes the
global sequence number of the request, <code class="docutils literal notranslate"><span class="pre">i915_request::global_seqno</span></code>;
the i915 driver uses the current value in the register to determine
if the GPU has completed the batchbuffer.</p></li>
<li><p>Add a user interrupt command to the buffer. This command instructs
the GPU to issue an interrupt when the command, pipeline flush and
memory write are completed.</p></li>
<li><p>Inform the hardware of the additional commands added to the buffer
(by updating the tail pointer).</p></li>
</ol>
<p>Processing an execbuf ioctl is conceptually split up into a few phases.</p>
<ol class="arabic simple">
<li><p>Validation - Ensure all the pointers, handles and flags are valid.</p></li>
<li><p>Reservation - Assign GPU address space for every object</p></li>
<li><p>Relocation - Update any addresses to point to the final locations</p></li>
<li><p>Serialisation - Order the request with respect to its dependencies</p></li>
<li><p>Construction - Construct a request to execute the batchbuffer</p></li>
<li><p>Submission (at some point in the future execution)</p></li>
</ol>
<p>Reserving resources for the execbuf is the most complicated phase. We
neither want to have to migrate the object in the address space, nor do
we want to have to update any relocations pointing to this object. Ideally,
we want to leave the object where it is and for all the existing relocations
to match. If the object is given a new address, or if userspace thinks the
object is elsewhere, we have to parse all the relocation entries and update
the addresses. Userspace can set the I915_EXEC_NORELOC flag to hint that
all the target addresses in all of its objects match the value in the
relocation entries and that they all match the presumed offsets given by the
list of execbuffer objects. Using this knowledge, we know that if we haven’t
moved any buffers, all the relocation entries are valid and we can skip
the update. (If userspace is wrong, the likely outcome is an impromptu GPU
hang.) The requirement for using I915_EXEC_NO_RELOC are:</p>
<blockquote>
<div><p>The addresses written in the objects must match the corresponding
reloc.presumed_offset which in turn must match the corresponding
execobject.offset.</p>
<p>Any render targets written to in the batch must be flagged with
EXEC_OBJECT_WRITE.</p>
<p>To avoid stalling, execobject.offset should match the current
address of that object within the active context.</p>
</div></blockquote>
<p>The reservation is done is multiple phases. First we try and keep any
object already bound in its current location - so as long as meets the
constraints imposed by the new execbuffer. Any object left unbound after the
first pass is then fitted into any available idle space. If an object does
not fit, all objects are removed from the reservation and the process rerun
after sorting the objects into a priority order (more difficult to fit
objects are tried first). Failing that, the entire VM is cleared and we try
to fit the execbuf once last time before concluding that it simply will not
fit.</p>
<p>A small complication to all of this is that we allow userspace not only to
specify an alignment and a size for the object in the address space, but
we also allow userspace to specify the exact offset. This objects are
simpler to place (the location is known a priori) all we have to do is make
sure the space is available.</p>
<p>Once all the objects are in place, patching up the buried pointers to point
to the final locations is a fairly simple job of walking over the relocation
entry arrays, looking up the right address and rewriting the value into
the object. Simple! … The relocation entries are stored in user memory
and so to access them we have to copy them into a local buffer. That copy
has to avoid taking any pagefaults as they may lead back to a GEM object
requiring the struct_mutex (i.e. recursive deadlock). So once again we split
the relocation into multiple passes. First we try to do everything within an
atomic context (avoid the pagefaults) which requires that we never wait. If
we detect that we may wait, or if we need to fault, then we have to fallback
to a slower path. The slowpath has to drop the mutex. (Can you hear alarm
bells yet?) Dropping the mutex means that we lose all the state we have
built up so far for the execbuf and we must reset any global data. However,
we do leave the objects pinned in their final locations - which is a
potential issue for concurrent execbufs. Once we have left the mutex, we can
allocate and copy all the relocation entries into a large array at our
leisure, reacquire the mutex, reclaim all the objects and other state and
then proceed to update any incorrect addresses with the objects.</p>
<p>As we process the relocation entries, we maintain a record of whether the
object is being written to. Using NORELOC, we expect userspace to provide
this information instead. We also check whether we can skip the relocation
by comparing the expected value inside the relocation entry with the target’s
final address. If they differ, we have to map the current object and rewrite
the 4 or 8 byte pointer within.</p>
<p>Serialising an execbuf is quite simple according to the rules of the GEM
ABI. Execution within each context is ordered by the order of submission.
Writes to any GEM object are in order of submission and are exclusive. Reads
from a GEM object are unordered with respect to other reads, but ordered by
writes. A write submitted after a read cannot occur before the read, and
similarly any read submitted after a write cannot occur before the write.
Writes are ordered between engines such that only one write occurs at any
time (completing any reads beforehand) - using semaphores where available
and CPU serialisation otherwise. Other GEM access obey the same rules, any
write (either via mmaps using set-domain, or via pwrite) must flush all GPU
reads before starting, and any read (either using set-domain or pread) must
flush all GPU writes before starting. (Note we only employ a barrier before,
we currently rely on userspace not concurrently starting a new execution
whilst reading or writing to an object. This may be an advantage or not
depending on how much you trust userspace not to shoot themselves in the
foot.) Serialisation may just result in the request being inserted into
a DAG awaiting its turn, but most simple is to wait on the CPU until
all dependencies are resolved.</p>
<p>After all of that, is just a matter of closing the request and handing it to
the hardware (well, leaving it in a queue to be executed). However, we also
offer the ability for batchbuffers to be run with elevated privileges so
that they access otherwise hidden registers. (Used to adjust L3 cache etc.)
Before any batch is given extra privileges we first must check that it
contains no nefarious instructions, we check that each instruction is from
our whitelist and all registers are also from an allowed list. We first
copy the user’s batchbuffer to a shadow (so that the user doesn’t have
access to it, either by the CPU or GPU as we scan it) and then parse each
instruction. If everything is ok, we set a flag telling the hardware to run
the batchbuffer in trusted mode, otherwise the ioctl is rejected.</p>
</div>
<div class="section" id="logical-rings-logical-ring-contexts-and-execlists">
<h3>Logical Rings, Logical Ring Contexts and Execlists<a class="headerlink" href="#logical-rings-logical-ring-contexts-and-execlists" title="Permalink to this headline">¶</a></h3>
<p>Motivation:
GEN8 brings an expansion of the HW contexts: “Logical Ring Contexts”.
These expanded contexts enable a number of new abilities, especially
“Execlists” (also implemented in this file).</p>
<p>One of the main differences with the legacy HW contexts is that logical
ring contexts incorporate many more things to the context’s state, like
PDPs or ringbuffer control registers:</p>
<p>The reason why PDPs are included in the context is straightforward: as
PPGTTs (per-process GTTs) are actually per-context, having the PDPs
contained there mean you don’t need to do a ppgtt-&gt;switch_mm yourself,
instead, the GPU will do it for you on the context switch.</p>
<p>But, what about the ringbuffer control registers (head, tail, etc..)?
shouldn’t we just need a set of those per engine command streamer? This is
where the name “Logical Rings” starts to make sense: by virtualizing the
rings, the engine cs shifts to a new “ring buffer” with every context
switch. When you want to submit a workload to the GPU you: A) choose your
context, B) find its appropriate virtualized ring, C) write commands to it
and then, finally, D) tell the GPU to switch to that context.</p>
<p>Instead of the legacy MI_SET_CONTEXT, the way you tell the GPU to switch
to a contexts is via a context execution list, ergo “Execlists”.</p>
<p>LRC implementation:
Regarding the creation of contexts, we have:</p>
<ul class="simple">
<li><p>One global default context.</p></li>
<li><p>One local default context for each opened fd.</p></li>
<li><p>One local extra context for each context create ioctl call.</p></li>
</ul>
<p>Now that ringbuffers belong per-context (and not per-engine, like before)
and that contexts are uniquely tied to a given engine (and not reusable,
like before) we need:</p>
<ul class="simple">
<li><p>One ringbuffer per-engine inside each context.</p></li>
<li><p>One backing object per-engine inside each context.</p></li>
</ul>
<p>The global default context starts its life with these new objects fully
allocated and populated. The local default context for each opened fd is
more complex, because we don’t know at creation time which engine is going
to use them. To handle this, we have implemented a deferred creation of LR
contexts:</p>
<p>The local context starts its life as a hollow or blank holder, that only
gets populated for a given engine once we receive an execbuffer. If later
on we receive another execbuffer ioctl for the same context but a different
engine, we allocate/populate a new ringbuffer and context backing object and
so on.</p>
<p>Finally, regarding local contexts created using the ioctl call: as they are
only allowed with the render ring, we can allocate &amp; populate them right
away (no need to defer anything, at least for now).</p>
<p>Execlists implementation:
Execlists are the new method by which, on gen8+ hardware, workloads are
submitted for execution (as opposed to the legacy, ringbuffer-based, method).
This method works as follows:</p>
<p>When a request is committed, its commands (the BB start and any leading or
trailing commands, like the seqno breadcrumbs) are placed in the ringbuffer
for the appropriate context. The tail pointer in the hardware context is not
updated at this time, but instead, kept by the driver in the ringbuffer
structure. A structure representing this request is added to a request queue
for the appropriate engine: this structure contains a copy of the context’s
tail after the request was written to the ring buffer and a pointer to the
context itself.</p>
<p>If the engine’s request queue was empty before the request was added, the
queue is processed immediately. Otherwise the queue will be processed during
a context switch interrupt. In any case, elements on the queue will get sent
(in pairs) to the GPU’s ExecLists Submit Port (ELSP, for short) with a
globally unique 20-bits submission ID.</p>
<p>When execution of a request completes, the GPU updates the context status
buffer with a context complete event and generates a context switch interrupt.
During the interrupt handling, the driver examines the events in the buffer:
for each context complete event, if the announced ID matches that on the head
of the request queue, then that request is retired and removed from the queue.</p>
<p>After processing, if any requests were retired and the queue is not empty
then a new execution list can be submitted. The two requests at the front of
the queue are next to be submitted but since a context may not occur twice in
an execution list, if subsequent requests have the same ID as the first then
the two requests must be combined. This is done simply by discarding requests
at the head of the queue until either only one requests is left (in which case
we use a NULL second context) or the first two requests have unique IDs.</p>
<p>By always executing the first two requests in the queue the driver ensures
that the GPU is kept as busy as possible. In the case where a single context
completes but a second context is still executing, the request for this second
context will be at the head of the queue when we remove the first one. This
request will then be resubmitted along with a new request for a different context,
which will cause the hardware to continue executing the second request and queue
the new request (the GPU detects the condition of a context getting preempted
with the same context and optimizes the context switch flow by not doing
preemption, but just sampling the new tail pointer).</p>
</div>
<div class="section" id="global-gtt-views">
<h3>Global GTT views<a class="headerlink" href="#global-gtt-views" title="Permalink to this headline">¶</a></h3>
<p>Background and previous state</p>
<p>Historically objects could exists (be bound) in global GTT space only as
singular instances with a view representing all of the object’s backing pages
in a linear fashion. This view will be called a normal view.</p>
<p>To support multiple views of the same object, where the number of mapped
pages is not equal to the backing store, or where the layout of the pages
is not linear, concept of a GGTT view was added.</p>
<p>One example of an alternative view is a stereo display driven by a single
image. In this case we would have a framebuffer looking like this
(2x2 pages):</p>
<blockquote>
<div><p>12
34</p>
</div></blockquote>
<p>Above would represent a normal GGTT view as normally mapped for GPU or CPU
rendering. In contrast, fed to the display engine would be an alternative
view which could look something like this:</p>
<blockquote>
<div><p>1212
3434</p>
</div></blockquote>
<p>In this example both the size and layout of pages in the alternative view is
different from the normal view.</p>
<p>Implementation and usage</p>
<p>GGTT views are implemented using VMAs and are distinguished via enum
i915_ggtt_view_type and struct i915_ggtt_view.</p>
<p>A new flavour of core GEM functions which work with GGTT bound objects were
added with the _ggtt_ infix, and sometimes with _view postfix to avoid
renaming  in large amounts of code. They take the struct i915_ggtt_view
parameter encapsulating all metadata required to implement a view.</p>
<p>As a helper for callers which are only interested in the normal view,
globally const i915_ggtt_view_normal singleton instance exists. All old core
GEM API functions, the ones not taking the view parameter, are operating on,
or with the normal GGTT view.</p>
<p>Code wanting to add or use a new GGTT view needs to:</p>
<ol class="arabic simple">
<li><p>Add a new enum with a suitable name.</p></li>
<li><p>Extend the metadata in the i915_ggtt_view structure if required.</p></li>
<li><p>Add support to i915_get_vma_pages().</p></li>
</ol>
<p>New views are required to build a scatter-gather table from within the
i915_get_vma_pages function. This table is stored in the vma.ggtt_view and
exists for the lifetime of an VMA.</p>
<p>Core API is designed to have copy semantics which means that passed in
struct i915_ggtt_view does not need to be persistent (left around after
calling the core API functions).</p>
<dl class="c function">
<dt id="c.i915_gem_gtt_reserve">
int <code class="sig-name descname">i915_gem_gtt_reserve</code><span class="sig-paren">(</span><em class="property">struct</em> i915_address_space *<em>vm</em>, <em class="property">struct</em> <a class="reference internal" href="drm-mm.html#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>node</em>, u64 <em>size</em>, u64 <em>offset</em>, unsigned long <em>color</em>, unsigned int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_gtt_reserve" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reserve a node in an address_space (GTT)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_address_space</span> <span class="pre">*vm</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_address_space</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*node</span></code></dt><dd><p>the <a class="reference internal" href="drm-mm.html#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span></code></a> (typically i915_vma.mode)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>how much space to allocate inside the GTT,
must be #I915_GTT_PAGE_SIZE aligned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">offset</span></code></dt><dd><p>where to insert inside the GTT,
must be #I915_GTT_MIN_ALIGNMENT aligned, and the node
(<strong>offset</strong> + <strong>size</strong>) must fit within the address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt><dd><p>color to apply to node, if this node is not from a VMA,
color must be #I915_COLOR_UNEVICTABLE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>control search and eviction behaviour</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.i915_gem_gtt_reserve" title="i915_gem_gtt_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_gem_gtt_reserve()</span></code></a> tries to insert the <strong>node</strong> at the exact <strong>offset</strong> inside
the address space (using <strong>size</strong> and <strong>color</strong>). If the <strong>node</strong> does not fit, it
tries to evict any overlapping nodes from the GTT, including any
neighbouring nodes if the colors do not match (to ensure guard pages between
differing domains). See <a class="reference internal" href="#c.i915_gem_evict_for_node" title="i915_gem_evict_for_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_gem_evict_for_node()</span></code></a> for the gory details
on the eviction algorithm. #PIN_NONBLOCK may used to prevent waiting on
evicting active overlapping objects, and any overlapping node that is pinned
or marked as unevictable will also result in failure.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOSPC if no suitable hole is found, -EINTR if
asked to wait for eviction and interrupted.</p>
<dl class="c function">
<dt id="c.i915_gem_gtt_insert">
int <code class="sig-name descname">i915_gem_gtt_insert</code><span class="sig-paren">(</span><em class="property">struct</em> i915_address_space *<em>vm</em>, <em class="property">struct</em> <a class="reference internal" href="drm-mm.html#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>node</em>, u64 <em>size</em>, u64 <em>alignment</em>, unsigned long <em>color</em>, u64 <em>start</em>, u64 <em>end</em>, unsigned int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_gtt_insert" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>insert a node into an address_space (GTT)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_address_space</span> <span class="pre">*vm</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_address_space</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*node</span></code></dt><dd><p>the <a class="reference internal" href="drm-mm.html#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span></code></a> (typically i915_vma.node)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>how much space to allocate inside the GTT,
must be #I915_GTT_PAGE_SIZE aligned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt><dd><p>required alignment of starting offset, may be 0 but
if specified, this must be a power-of-two and at least
#I915_GTT_MIN_ALIGNMENT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt><dd><p>color to apply to node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>start of any range restriction inside GTT (0 for all),
must be #I915_GTT_PAGE_SIZE aligned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">end</span></code></dt><dd><p>end of any range restriction inside GTT (U64_MAX for all),
must be #I915_GTT_PAGE_SIZE aligned if not U64_MAX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>control search and eviction behaviour</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.i915_gem_gtt_insert" title="i915_gem_gtt_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_gem_gtt_insert()</span></code></a> first searches for an available hole into which
is can insert the node. The hole address is aligned to <strong>alignment</strong> and
its <strong>size</strong> must then fit entirely within the [<strong>start</strong>, <strong>end</strong>] bounds. The
nodes on either side of the hole must match <strong>color</strong>, or else a guard page
will be inserted between the two nodes (or the node evicted). If no
suitable hole is found, first a victim is randomly selected and tested
for eviction, otherwise then the LRU list of objects within the GTT
is scanned to find the first set of replacement nodes to create the hole.
Those old overlapping nodes are evicted from the GTT (and so must be
rebound before any future use). Any node that is currently pinned cannot
be evicted (see i915_vma_pin()). Similar if the node’s VMA is currently
active and #PIN_NONBLOCK is specified, that node is also skipped when
searching for an eviction candidate. See <a class="reference internal" href="#c.i915_gem_evict_something" title="i915_gem_evict_something"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_gem_evict_something()</span></code></a> for
the gory details on the eviction algorithm.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOSPC if no suitable hole is found, -EINTR if
asked to wait for eviction and interrupted.</p>
</div>
<div class="section" id="gtt-fences-and-swizzling">
<h3>GTT Fences and Swizzling<a class="headerlink" href="#gtt-fences-and-swizzling" title="Permalink to this headline">¶</a></h3>
<dl class="c function">
<dt id="c.i915_vma_revoke_fence">
void <code class="sig-name descname">i915_vma_revoke_fence</code><span class="sig-paren">(</span><em class="property">struct</em> i915_vma *<em>vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_vma_revoke_fence" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>force-remove fence for a VMA</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_vma</span> <span class="pre">*vma</span></code></dt><dd><p>vma to map linearly (not through a fence reg)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function force-removes any fence from the given object, which is useful
if the kernel wants to do untiled GTT access.</p>
<dl class="c function">
<dt id="c.i915_vma_pin_fence">
int <code class="sig-name descname">i915_vma_pin_fence</code><span class="sig-paren">(</span><em class="property">struct</em> i915_vma *<em>vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_vma_pin_fence" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set up fencing for a vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_vma</span> <span class="pre">*vma</span></code></dt><dd><p>vma to map through a fence reg</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When mapping objects through the GTT, userspace wants to be able to write
to them without having to worry about swizzling if the object is tiled.
This function walks the fence regs looking for a free one for <strong>obj</strong>,
stealing one if it can’t find any.</p>
<p>It then sets up the reg based on the object’s properties: address, pitch
and tiling format.</p>
<p>For an untiled surface, this removes any existing fence.</p>
<p>0 on success, negative error code on failure.</p>
<p><strong>Return</strong></p>
<dl class="c function">
<dt id="c.i915_reserve_fence">
<em class="property">struct</em> i915_fence_reg *<code class="sig-name descname">i915_reserve_fence</code><span class="sig-paren">(</span><em class="property">struct</em> i915_ggtt *<em>ggtt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_reserve_fence" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reserve a fence for vGPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>Global GTT</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks the fence regs looking for a free one and remove
it from the fence_list. It is used to reserve fence for vGPU to use.</p>
<dl class="c function">
<dt id="c.i915_unreserve_fence">
void <code class="sig-name descname">i915_unreserve_fence</code><span class="sig-paren">(</span><em class="property">struct</em> i915_fence_reg *<em>fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_unreserve_fence" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reclaim a reserved fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_fence_reg</span> <span class="pre">*fence</span></code></dt><dd><p>the fence reg</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function add a reserved fence register from vGPU to the fence_list.</p>
<dl class="c function">
<dt id="c.intel_ggtt_restore_fences">
void <code class="sig-name descname">intel_ggtt_restore_fences</code><span class="sig-paren">(</span><em class="property">struct</em> i915_ggtt *<em>ggtt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_ggtt_restore_fences" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>restore fence state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>Global GTT</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restore the hw fence state to match the software tracking again, to be called
after a gpu reset and on resume. Note that on runtime suspend we only cancel
the fences, to be reacquired by the user later.</p>
<dl class="c function">
<dt id="c.detect_bit_6_swizzle">
void <code class="sig-name descname">detect_bit_6_swizzle</code><span class="sig-paren">(</span><em class="property">struct</em> i915_ggtt *<em>ggtt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.detect_bit_6_swizzle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>detect bit 6 swizzling pattern</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>Global GGTT</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Detects bit 6 swizzling of address lookup between IGD access and CPU
access through main memory.</p>
<dl class="c function">
<dt id="c.i915_gem_object_do_bit_17_swizzle">
void <code class="sig-name descname">i915_gem_object_do_bit_17_swizzle</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_gem_object *<em>obj</em>, <em class="property">struct</em> sg_table *<em>pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_object_do_bit_17_swizzle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fixup bit 17 swizzling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>i915 GEM buffer object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*pages</span></code></dt><dd><p>the scattergather list of physical pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function fixes up the swizzling in case any page frame number for this
object has changed in bit 17 since that state has been saved with
<a class="reference internal" href="#c.i915_gem_object_save_bit_17_swizzle" title="i915_gem_object_save_bit_17_swizzle"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_gem_object_save_bit_17_swizzle()</span></code></a>.</p>
<p>This is called when pinning backing storage again, since the kernel is free
to move unpinned backing storage around (either by directly moving pages or
by swapping them out and back in again).</p>
<dl class="c function">
<dt id="c.i915_gem_object_save_bit_17_swizzle">
void <code class="sig-name descname">i915_gem_object_save_bit_17_swizzle</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_gem_object *<em>obj</em>, <em class="property">struct</em> sg_table *<em>pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_object_save_bit_17_swizzle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>save bit 17 swizzling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>i915 GEM buffer object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*pages</span></code></dt><dd><p>the scattergather list of physical pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function saves the bit 17 of each page frame number so that swizzling
can be fixed up later on with <a class="reference internal" href="#c.i915_gem_object_do_bit_17_swizzle" title="i915_gem_object_do_bit_17_swizzle"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_gem_object_do_bit_17_swizzle()</span></code></a>. This must
be called before the backing storage can be unpinned.</p>
<div class="section" id="global-gtt-fence-handling">
<h4>Global GTT Fence Handling<a class="headerlink" href="#global-gtt-fence-handling" title="Permalink to this headline">¶</a></h4>
<p>Important to avoid confusions: “fences” in the i915 driver are not execution
fences used to track command completion but hardware detiler objects which
wrap a given range of the global GTT. Each platform has only a fairly limited
set of these objects.</p>
<p>Fences are used to detile GTT memory mappings. They’re also connected to the
hardware frontbuffer render tracking and hence interact with frontbuffer
compression. Furthermore on older platforms fences are required for tiled
objects used by the display engine. They can also be used by the render
engine - they’re required for blitter commands and are optional for render
commands. But on gen4+ both display (with the exception of fbc) and rendering
have their own tiling state bits and don’t need fences.</p>
<p>Also note that fences only support X and Y tiling and hence can’t be used for
the fancier new tiling formats like W, Ys and Yf.</p>
<p>Finally note that because fences are such a restricted resource they’re
dynamically associated with objects. Furthermore fence state is committed to
the hardware lazily to avoid unnecessary stalls on gen2/3. Therefore code must
explicitly call i915_gem_object_get_fence() to synchronize fencing status
for cpu access. Also note that some code wants an unfenced view, for those
cases the fence can be removed forcefully with i915_gem_object_put_fence().</p>
<p>Internally these functions will synchronize with userspace access by removing
CPU ptes into GTT mmaps (not the GTT ptes themselves) as needed.</p>
</div>
<div class="section" id="hardware-tiling-and-swizzling-details">
<h4>Hardware Tiling and Swizzling Details<a class="headerlink" href="#hardware-tiling-and-swizzling-details" title="Permalink to this headline">¶</a></h4>
<p>The idea behind tiling is to increase cache hit rates by rearranging
pixel data so that a group of pixel accesses are in the same cacheline.
Performance improvement from doing this on the back/depth buffer are on
the order of 30%.</p>
<p>Intel architectures make this somewhat more complicated, though, by
adjustments made to addressing of data when the memory is in interleaved
mode (matched pairs of DIMMS) to improve memory bandwidth.
For interleaved memory, the CPU sends every sequential 64 bytes
to an alternate memory channel so it can get the bandwidth from both.</p>
<p>The GPU also rearranges its accesses for increased bandwidth to interleaved
memory, and it matches what the CPU does for non-tiled.  However, when tiled
it does it a little differently, since one walks addresses not just in the
X direction but also Y.  So, along with alternating channels when bit
6 of the address flips, it also alternates when other bits flip –  Bits 9
(every 512 bytes, an X tile scanline) and 10 (every two X tile scanlines)
are common to both the 915 and 965-class hardware.</p>
<p>The CPU also sometimes XORs in higher bits as well, to improve
bandwidth doing strided access like we do so frequently in graphics.  This
is called “Channel XOR Randomization” in the MCH documentation.  The result
is that the CPU is XORing in either bit 11 or bit 17 to bit 6 of its address
decode.</p>
<p>All of this bit 6 XORing has an effect on our memory management,
as we need to make sure that the 3d driver can correctly address object
contents.</p>
<p>If we don’t have interleaved memory, all tiling is safe and no swizzling is
required.</p>
<p>When bit 17 is XORed in, we simply refuse to tile at all.  Bit
17 is not just a page offset, so as we page an object out and back in,
individual pages in it will have different bit 17 addresses, resulting in
each 64 bytes being swapped with its neighbor!</p>
<p>Otherwise, if interleaved, we have to tell the 3d driver what the address
swizzling it needs to do is, since it’s writing with the CPU to the pages
(bit 6 and potentially bit 11 XORed in), and the GPU is reading from the
pages (bit 6, 9, and 10 XORed in), resulting in a cumulative bit swizzling
required by the CPU of XORing in bit 6, 9, 10, and potentially 11, in order
to match what the GPU expects.</p>
</div>
</div>
<div class="section" id="object-tiling-ioctls">
<h3>Object Tiling IOCTLs<a class="headerlink" href="#object-tiling-ioctls" title="Permalink to this headline">¶</a></h3>
<dl class="c function">
<dt id="c.i915_gem_fence_size">
u32 <code class="sig-name descname">i915_gem_fence_size</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em>, u32 <em>size</em>, unsigned int <em>tiling</em>, unsigned int <em>stride</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_fence_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>required global GTT size for a fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">size</span></code></dt><dd><p>object size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tiling</span></code></dt><dd><p>tiling mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">stride</span></code></dt><dd><p>tiling stride</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the required global GTT size for a fence (view of a tiled object),
taking into account potential fence register mapping.</p>
<dl class="c function">
<dt id="c.i915_gem_fence_alignment">
u32 <code class="sig-name descname">i915_gem_fence_alignment</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em>, u32 <em>size</em>, unsigned int <em>tiling</em>, unsigned int <em>stride</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_fence_alignment" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>required global GTT alignment for a fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">size</span></code></dt><dd><p>object size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tiling</span></code></dt><dd><p>tiling mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">stride</span></code></dt><dd><p>tiling stride</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the required global GTT alignment for a fence (a view of a tiled
object), taking into account potential fence register mapping.</p>
<dl class="c function">
<dt id="c.i915_gem_set_tiling_ioctl">
int <code class="sig-name descname">i915_gem_set_tiling_ioctl</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, void *<em>data</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_set_tiling_ioctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>IOCTL handler to set tiling mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data pointer for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>DRM file for the ioctl call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the tiling mode of an object, returning the required swizzling of
bit 6 of addresses in the object.</p>
<p>Called by the user via ioctl.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.i915_gem_get_tiling_ioctl">
int <code class="sig-name descname">i915_gem_get_tiling_ioctl</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, void *<em>data</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_get_tiling_ioctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>IOCTL handler to get tiling mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data pointer for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>DRM file for the ioctl call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the current tiling mode and required bit 6 swizzling for the object.</p>
<p>Called by the user via ioctl.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<p><a class="reference internal" href="#c.i915_gem_set_tiling_ioctl" title="i915_gem_set_tiling_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_gem_set_tiling_ioctl()</span></code></a> and <a class="reference internal" href="#c.i915_gem_get_tiling_ioctl" title="i915_gem_get_tiling_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_gem_get_tiling_ioctl()</span></code></a> is the userspace
interface to declare fence register requirements.</p>
<p>In principle GEM doesn’t care at all about the internal data layout of an
object, and hence it also doesn’t care about tiling or swizzling. There’s two
exceptions:</p>
<ul class="simple">
<li><p>For X and Y tiling the hardware provides detilers for CPU access, so called
fences. Since there’s only a limited amount of them the kernel must manage
these, and therefore userspace must tell the kernel the object tiling if it
wants to use fences for detiling.</p></li>
<li><p>On gen3 and gen4 platforms have a swizzling pattern for tiled objects which
depends upon the physical page frame number. When swapping such objects the
page frame number might change and the kernel must be able to fix this up
and hence now the tiling. Note that on a subset of platforms with
asymmetric memory channel population the swizzling pattern changes in an
unknown way, and for those the kernel simply forbids swapping completely.</p></li>
</ul>
<p>Since neither of this applies for new tiling layouts on modern platforms like
W, Ys and Yf tiling GEM only allows object tiling to be set to X or Y tiled.
Anything else can be handled in userspace entirely without the kernel’s
invovlement.</p>
</div>
</div>
<div class="section" id="microcontrollers">
<h2>Microcontrollers<a class="headerlink" href="#microcontrollers" title="Permalink to this headline">¶</a></h2>
<p>Starting from gen9, three microcontrollers are available on the HW: the
graphics microcontroller (GuC), the HEVC/H.265 microcontroller (HuC) and the
display microcontroller (DMC). The driver is responsible for loading the
firmwares on the microcontrollers; the GuC and HuC firmwares are transferred
to WOPCM using the DMA engine, while the DMC firmware is written through MMIO.</p>
<div class="section" id="wopcm">
<h3>WOPCM<a class="headerlink" href="#wopcm" title="Permalink to this headline">¶</a></h3>
<div class="section" id="wopcm-layout">
<h4>WOPCM Layout<a class="headerlink" href="#wopcm-layout" title="Permalink to this headline">¶</a></h4>
<p>The layout of the WOPCM will be fixed after writing to GuC WOPCM size and
offset registers whose values are calculated and determined by HuC/GuC
firmware size and set of hardware requirements/restrictions as shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  +=========&gt; +====================+ &lt;== WOPCM Top
  ^           |  HW contexts RSVD  |
  |     +===&gt; +====================+ &lt;== GuC WOPCM Top
  |     ^     |                    |
  |     |     |                    |
  |     |     |                    |
  |    GuC    |                    |
  |   WOPCM   |                    |
  |    Size   +--------------------+
WOPCM   |     |    GuC FW RSVD     |
  |     |     +--------------------+
  |     |     |   GuC Stack RSVD   |
  |     |     +------------------- +
  |     v     |   GuC WOPCM RSVD   |
  |     +===&gt; +====================+ &lt;== GuC WOPCM base
  |           |     WOPCM RSVD     |
  |           +------------------- + &lt;== HuC Firmware Top
  v           |      HuC FW        |
  +=========&gt; +====================+ &lt;== WOPCM Base
</pre></div>
</div>
<p>GuC accessible WOPCM starts at GuC WOPCM base and ends at GuC WOPCM top.
The top part of the WOPCM is reserved for hardware contexts (e.g. RC6
context).</p>
</div>
</div>
<div class="section" id="guc">
<h3>GuC<a class="headerlink" href="#guc" title="Permalink to this headline">¶</a></h3>
<p>The GuC is a microcontroller inside the GT HW, introduced in gen9. The GuC is
designed to offload some of the functionality usually performed by the host
driver; currently the main operations it can take care of are:</p>
<ul class="simple">
<li><p>Authentication of the HuC, which is required to fully enable HuC usage.</p></li>
<li><p>Low latency graphics context scheduling (a.k.a. GuC submission).</p></li>
<li><p>GT Power management.</p></li>
</ul>
<p>The enable_guc module parameter can be used to select which of those
operations to enable within GuC. Note that not all the operations are
supported on all gen9+ platforms.</p>
<p>Enabling the GuC is not mandatory and therefore the firmware is only loaded
if at least one of the operations is selected. However, not loading the GuC
might result in the loss of some features that do require the GuC (currently
just the HuC, but more are expected to land in the future).</p>
<div class="section" id="guc-firmware-layout">
<h4>GuC Firmware Layout<a class="headerlink" href="#guc-firmware-layout" title="Permalink to this headline">¶</a></h4>
<p>The GuC/HuC firmware layout looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+======================================================================+
|  Firmware blob                                                       |
+===============+===============+============+============+============+
|  CSS header   |     uCode     |  RSA key   |  modulus   |  exponent  |
+===============+===============+============+============+============+
 &lt;-header size-&gt;                 &lt;---header size continued -----------&gt;
 &lt;--- size -----------------------------------------------------------&gt;
                                 &lt;-key size-&gt;
                                              &lt;-mod size-&gt;
                                                           &lt;-exp size-&gt;
</pre></div>
</div>
<p>The firmware may or may not have modulus key and exponent data. The header,
uCode and RSA signature are must-have components that will be used by driver.
Length of each components, which is all in dwords, can be found in header.
In the case that modulus and exponent are not present in fw, a.k.a truncated
image, the length value still appears in header.</p>
<p>Driver will do some basic fw size validation based on the following rules:</p>
<ol class="arabic simple">
<li><p>Header, uCode and RSA are must-have components.</p></li>
<li><p>All firmware components, if they present, are in the sequence illustrated
in the layout table above.</p></li>
<li><p>Length info of each component can be found in header, in dwords.</p></li>
<li><p>Modulus and exponent key are not required by driver. They may not appear
in fw. So driver will load a truncated firmware in this case.</p></li>
</ol>
</div>
<div class="section" id="guc-memory-management">
<h4>GuC Memory Management<a class="headerlink" href="#guc-memory-management" title="Permalink to this headline">¶</a></h4>
<p>GuC can’t allocate any memory for its own usage, so all the allocations must
be handled by the host driver. GuC accesses the memory via the GGTT, with the
exception of the top and bottom parts of the 4GB address space, which are
instead re-mapped by the GuC HW to memory location of the FW itself (WOPCM)
or other parts of the HW. The driver must take care not to place objects that
the GuC is going to access in these reserved ranges. The layout of the GuC
address space is shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   +===========&gt; +====================+ &lt;== FFFF_FFFF
   ^             |      Reserved      |
   |             +====================+ &lt;== GUC_GGTT_TOP
   |             |                    |
   |             |        DRAM        |
  GuC            |                    |
Address    +===&gt; +====================+ &lt;== GuC ggtt_pin_bias
 Space     ^     |                    |
   |       |     |                    |
   |      GuC    |        GuC         |
   |     WOPCM   |       WOPCM        |
   |      Size   |                    |
   |       |     |                    |
   v       v     |                    |
   +=======+===&gt; +====================+ &lt;== 0000_0000
</pre></div>
</div>
<p>The lower part of GuC Address Space [0, ggtt_pin_bias) is mapped to GuC WOPCM
while upper part of GuC Address Space [ggtt_pin_bias, GUC_GGTT_TOP) is mapped
to DRAM. The value of the GuC ggtt_pin_bias is the GuC WOPCM size.</p>
<dl class="c function">
<dt id="c.intel_guc_allocate_vma">
<em class="property">struct</em> i915_vma *<code class="sig-name descname">intel_guc_allocate_vma</code><span class="sig-paren">(</span><em class="property">struct</em> intel_guc *<em>guc</em>, u32 <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_guc_allocate_vma" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a GGTT VMA for GuC usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_guc</span> <span class="pre">*guc</span></code></dt><dd><p>the guc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">size</span></code></dt><dd><p>size of area to allocate (both virtual space and memory)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a wrapper to create an object for use with the GuC. In order to
use it inside the GuC, an object needs to be pinned lifetime, so we allocate
both some backing storage and a range inside the Global GTT. We must pin
it in the GGTT somewhere other than than [0, GUC ggtt_pin_bias) because that
range is reserved inside GuC.</p>
<p><strong>Return</strong></p>
<p>A i915_vma if successful, otherwise an ERR_PTR.</p>
</div>
<div class="section" id="guc-specific-firmware-loader">
<h4>GuC-specific firmware loader<a class="headerlink" href="#guc-specific-firmware-loader" title="Permalink to this headline">¶</a></h4>
<dl class="c function">
<dt id="c.intel_guc_fw_upload">
int <code class="sig-name descname">intel_guc_fw_upload</code><span class="sig-paren">(</span><em class="property">struct</em> intel_guc *<em>guc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_guc_fw_upload" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>load GuC uCode to device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_guc</span> <span class="pre">*guc</span></code></dt><dd><p>intel_guc structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from intel_uc_init_hw() during driver load, resume from sleep and
after a GPU reset.</p>
<p>The firmware image should have already been fetched into memory, so only
check that fetch succeeded, and then transfer the image to the h/w.</p>
<p><strong>Return</strong></p>
<p>non-zero code on error</p>
</div>
<div class="section" id="guc-based-command-submission">
<h4>GuC-based command submission<a class="headerlink" href="#guc-based-command-submission" title="Permalink to this headline">¶</a></h4>
<p>IMPORTANT NOTE: GuC submission is currently not supported in i915. The GuC
firmware is moving to an updated submission interface and we plan to
turn submission back on when that lands. The below documentation (and related
code) matches the old submission model and will be updated as part of the
upgrade to the new flow.</p>
<p>GuC stage descriptor:
During initialization, the driver allocates a static pool of 1024 such
descriptors, and shares them with the GuC. Currently, we only use one
descriptor. This stage descriptor lets the GuC know about the workqueue and
process descriptor. Theoretically, it also lets the GuC know about our HW
contexts (context ID, etc…), but we actually employ a kind of submission
where the GuC uses the LRCA sent via the work item instead. This is called
a “proxy” submission.</p>
<p>The Scratch registers:
There are 16 MMIO-based registers start from 0xC180. The kernel driver writes
a value to the action register (SOFT_SCRATCH_0) along with any data. It then
triggers an interrupt on the GuC via another register write (0xC4C8).
Firmware writes a success/fail code back to the action register after
processes the request. The kernel driver polls waiting for this update and
then proceeds.</p>
<p>Work Items:
There are several types of work items that the host may place into a
workqueue, each with its own requirements and limitations. Currently only
WQ_TYPE_INORDER is needed to support legacy submission via GuC, which
represents in-order queue. The kernel driver packs ring tail pointer and an
ELSP context descriptor dword into Work Item.
See guc_add_request()</p>
</div>
</div>
<div class="section" id="huc">
<h3>HuC<a class="headerlink" href="#huc" title="Permalink to this headline">¶</a></h3>
<p>The HuC is a dedicated microcontroller for usage in media HEVC (High
Efficiency Video Coding) operations. Userspace can directly use the firmware
capabilities by adding HuC specific commands to batch buffers.</p>
<p>The kernel driver is only responsible for loading the HuC firmware and
triggering its security authentication, which is performed by the GuC. For
The GuC to correctly perform the authentication, the HuC binary must be
loaded before the GuC one. Loading the HuC is optional; however, not using
the HuC might negatively impact power usage and/or performance of media
workloads, depending on the use-cases.</p>
<p>See <a class="reference external" href="https://github.com/intel/media-driver">https://github.com/intel/media-driver</a> for the latest details on HuC
functionality.</p>
<dl class="c function">
<dt id="c.intel_huc_auth">
int <code class="sig-name descname">intel_huc_auth</code><span class="sig-paren">(</span><em class="property">struct</em> intel_huc *<em>huc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_huc_auth" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Authenticate HuC uCode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intel_huc</span> <span class="pre">*huc</span></code></dt><dd><p>intel_huc structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called after HuC and GuC firmware loading during intel_uc_init_hw().</p>
<p>This function invokes the GuC action to authenticate the HuC firmware,
passing the offset of the RSA signature to intel_guc_auth_huc(). It then
waits for up to 50ms for firmware verification ACK.</p>
<div class="section" id="huc-memory-management">
<h4>HuC Memory Management<a class="headerlink" href="#huc-memory-management" title="Permalink to this headline">¶</a></h4>
<p>Similarly to the GuC, the HuC can’t do any memory allocations on its own,
with the difference being that the allocations for HuC usage are handled by
the userspace driver instead of the kernel one. The HuC accesses the memory
via the PPGTT belonging to the context loaded on the VCS executing the
HuC-specific commands.</p>
</div>
<div class="section" id="huc-firmware-layout">
<h4>HuC Firmware Layout<a class="headerlink" href="#huc-firmware-layout" title="Permalink to this headline">¶</a></h4>
<p>The HuC FW layout is the same as the GuC one, see <a class="reference internal" href="#guc-firmware-layout">GuC Firmware Layout</a></p>
</div>
</div>
<div class="section" id="dmc">
<h3>DMC<a class="headerlink" href="#dmc" title="Permalink to this headline">¶</a></h3>
<p>See <a class="reference internal" href="#csr-firmware-support-for-dmc">CSR firmware support for DMC</a></p>
</div>
</div>
<div class="section" id="tracing">
<h2>Tracing<a class="headerlink" href="#tracing" title="Permalink to this headline">¶</a></h2>
<p>This sections covers all things related to the tracepoints implemented
in the i915 driver.</p>
<div class="section" id="i915-ppgtt-create-and-i915-ppgtt-release">
<h3>i915_ppgtt_create and i915_ppgtt_release<a class="headerlink" href="#i915-ppgtt-create-and-i915-ppgtt-release" title="Permalink to this headline">¶</a></h3>
<p>With full ppgtt enabled each process using drm will allocate at least one
translation table. With these traces it is possible to keep track of the
allocation and of the lifetime of the tables; this can be used during
testing/debug to verify that we are not leaking ppgtts.
These traces identify the ppgtt through the vm pointer, which is also printed
by the i915_vma_bind and i915_vma_unbind tracepoints.</p>
</div>
<div class="section" id="i915-context-create-and-i915-context-free">
<h3>i915_context_create and i915_context_free<a class="headerlink" href="#i915-context-create-and-i915-context-free" title="Permalink to this headline">¶</a></h3>
<p>These tracepoints are used to track creation and deletion of contexts.
If full ppgtt is enabled, they also print the address of the vm assigned to
the context.</p>
</div>
</div>
<div class="section" id="perf">
<h2>Perf<a class="headerlink" href="#perf" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>Gen graphics supports a large number of performance counters that can help
driver and application developers understand and optimize their use of the
GPU.</p>
<p>This i915 perf interface enables userspace to configure and open a file
descriptor representing a stream of GPU metrics which can then be read() as
a stream of sample records.</p>
<p>The interface is particularly suited to exposing buffered metrics that are
captured by DMA from the GPU, unsynchronized with and unrelated to the CPU.</p>
<p>Streams representing a single context are accessible to applications with a
corresponding drm file descriptor, such that OpenGL can use the interface
without special privileges. Access to system-wide metrics requires root
privileges by default, unless changed via the dev.i915.perf_event_paranoid
sysctl option.</p>
</div>
<div class="section" id="comparison-with-core-perf">
<h3>Comparison with Core Perf<a class="headerlink" href="#comparison-with-core-perf" title="Permalink to this headline">¶</a></h3>
<p>The interface was initially inspired by the core Perf infrastructure but
some notable differences are:</p>
<p>i915 perf file descriptors represent a “stream” instead of an “event”; where
a perf event primarily corresponds to a single 64bit value, while a stream
might sample sets of tightly-coupled counters, depending on the
configuration.  For example the Gen OA unit isn’t designed to support
orthogonal configurations of individual counters; it’s configured for a set
of related counters. Samples for an i915 perf stream capturing OA metrics
will include a set of counter values packed in a compact HW specific format.
The OA unit supports a number of different packing formats which can be
selected by the user opening the stream. Perf has support for grouping
events, but each event in the group is configured, validated and
authenticated individually with separate system calls.</p>
<p>i915 perf stream configurations are provided as an array of u64 (key,value)
pairs, instead of a fixed struct with multiple miscellaneous config members,
interleaved with event-type specific members.</p>
<p>i915 perf doesn’t support exposing metrics via an mmap’d circular buffer.
The supported metrics are being written to memory by the GPU unsynchronized
with the CPU, using HW specific packing formats for counter sets. Sometimes
the constraints on HW configuration require reports to be filtered before it
would be acceptable to expose them to unprivileged applications - to hide
the metrics of other processes/contexts. For these use cases a read() based
interface is a good fit, and provides an opportunity to filter data as it
gets copied from the GPU mapped buffers to userspace buffers.</p>
<div class="section" id="issues-hit-with-first-prototype-based-on-core-perf">
<h4>Issues hit with first prototype based on Core Perf<a class="headerlink" href="#issues-hit-with-first-prototype-based-on-core-perf" title="Permalink to this headline">¶</a></h4>
<p>The first prototype of this driver was based on the core perf
infrastructure, and while we did make that mostly work, with some changes to
perf, we found we were breaking or working around too many assumptions baked
into perf’s currently cpu centric design.</p>
<p>In the end we didn’t see a clear benefit to making perf’s implementation and
interface more complex by changing design assumptions while we knew we still
wouldn’t be able to use any existing perf based userspace tools.</p>
<p>Also considering the Gen specific nature of the Observability hardware and
how userspace will sometimes need to combine i915 perf OA metrics with
side-band OA data captured via MI_REPORT_PERF_COUNT commands; we’re
expecting the interface to be used by a platform specific userspace such as
OpenGL or tools. This is to say; we aren’t inherently missing out on having
a standard vendor/architecture agnostic interface by not using perf.</p>
<p>For posterity, in case we might re-visit trying to adapt core perf to be
better suited to exposing i915 metrics these were the main pain points we
hit:</p>
<ul>
<li><p>The perf based OA PMU driver broke some significant design assumptions:</p>
<p>Existing perf pmus are used for profiling work on a cpu and we were
introducing the idea of _IS_DEVICE pmus with different security
implications, the need to fake cpu-related data (such as user/kernel
registers) to fit with perf’s current design, and adding _DEVICE records
as a way to forward device-specific status records.</p>
<p>The OA unit writes reports of counters into a circular buffer, without
involvement from the CPU, making our PMU driver the first of a kind.</p>
<p>Given the way we were periodically forward data from the GPU-mapped, OA
buffer to perf’s buffer, those bursts of sample writes looked to perf like
we were sampling too fast and so we had to subvert its throttling checks.</p>
<p>Perf supports groups of counters and allows those to be read via
transactions internally but transactions currently seem designed to be
explicitly initiated from the cpu (say in response to a userspace read())
and while we could pull a report out of the OA buffer we can’t
trigger a report from the cpu on demand.</p>
<p>Related to being report based; the OA counters are configured in HW as a
set while perf generally expects counter configurations to be orthogonal.
Although counters can be associated with a group leader as they are
opened, there’s no clear precedent for being able to provide group-wide
configuration attributes (for example we want to let userspace choose the
OA unit report format used to capture all counters in a set, or specify a
GPU context to filter metrics on). We avoided using perf’s grouping
feature and forwarded OA reports to userspace via perf’s ‘raw’ sample
field. This suited our userspace well considering how coupled the counters
are when dealing with normalizing. It would be inconvenient to split
counters up into separate events, only to require userspace to recombine
them. For Mesa it’s also convenient to be forwarded raw, periodic reports
for combining with the side-band raw reports it captures using
MI_REPORT_PERF_COUNT commands.</p>
<ul>
<li><p>As a side note on perf’s grouping feature; there was also some concern
that using PERF_FORMAT_GROUP as a way to pack together counter values
would quite drastically inflate our sample sizes, which would likely
lower the effective sampling resolutions we could use when the available
memory bandwidth is limited.</p>
<p>With the OA unit’s report formats, counters are packed together as 32
or 40bit values, with the largest report size being 256 bytes.</p>
<p>PERF_FORMAT_GROUP values are 64bit, but there doesn’t appear to be a
documented ordering to the values, implying PERF_FORMAT_ID must also be
used to add a 64bit ID before each value; giving 16 bytes per counter.</p>
</li>
</ul>
<p>Related to counter orthogonality; we can’t time share the OA unit, while
event scheduling is a central design idea within perf for allowing
userspace to open + enable more events than can be configured in HW at any
one time.  The OA unit is not designed to allow re-configuration while in
use. We can’t reconfigure the OA unit without losing internal OA unit
state which we can’t access explicitly to save and restore. Reconfiguring
the OA unit is also relatively slow, involving ~100 register writes. From
userspace Mesa also depends on a stable OA configuration when emitting
MI_REPORT_PERF_COUNT commands and importantly the OA unit can’t be
disabled while there are outstanding MI_RPC commands lest we hang the
command streamer.</p>
<p>The contents of sample records aren’t extensible by device drivers (i.e.
the sample_type bits). As an example; Sourab Gupta had been looking to
attach GPU timestamps to our OA samples. We were shoehorning OA reports
into sample records by using the ‘raw’ field, but it’s tricky to pack more
than one thing into this field because events/core.c currently only lets a
pmu give a single raw data pointer plus len which will be copied into the
ring buffer. To include more than the OA report we’d have to copy the
report into an intermediate larger buffer. I’d been considering allowing a
vector of data+len values to be specified for copying the raw data, but
it felt like a kludge to being using the raw field for this purpose.</p>
</li>
<li><p>It felt like our perf based PMU was making some technical compromises
just for the sake of using perf:</p>
<p>perf_event_open() requires events to either relate to a pid or a specific
cpu core, while our device pmu related to neither.  Events opened with a
pid will be automatically enabled/disabled according to the scheduling of
that process - so not appropriate for us. When an event is related to a
cpu id, perf ensures pmu methods will be invoked via an inter process
interrupt on that core. To avoid invasive changes our userspace opened OA
perf events for a specific cpu. This was workable but it meant the
majority of the OA driver ran in atomic context, including all OA report
forwarding, which wasn’t really necessary in our case and seems to make
our locking requirements somewhat complex as we handled the interaction
with the rest of the i915 driver.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="i915-driver-entry-points">
<h3>i915 Driver Entry Points<a class="headerlink" href="#i915-driver-entry-points" title="Permalink to this headline">¶</a></h3>
<p>This section covers the entrypoints exported outside of i915_perf.c to
integrate with drm/i915 and to handle the <cite>DRM_I915_PERF_OPEN</cite> ioctl.</p>
<dl class="c function">
<dt id="c.i915_perf_init">
void <code class="sig-name descname">i915_perf_init</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize i915-perf state on module bind</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes i915-perf state without exposing anything to userspace.</p>
<p><strong>Note</strong></p>
<p>i915-perf initialization is split into an ‘init’ and ‘register’
phase with the <a class="reference internal" href="#c.i915_perf_register" title="i915_perf_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_perf_register()</span></code></a> exposing state to userspace.</p>
<dl class="c function">
<dt id="c.i915_perf_fini">
void <code class="sig-name descname">i915_perf_fini</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_fini" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter part to <a class="reference internal" href="#c.i915_perf_init" title="i915_perf_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_perf_init()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.i915_perf_register">
void <code class="sig-name descname">i915_perf_register</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>exposes i915-perf to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In particular OA metric sets are advertised under a sysfs metrics/
directory allowing userspace to enumerate valid IDs that can be
used to open an i915-perf stream.</p>
<dl class="c function">
<dt id="c.i915_perf_unregister">
void <code class="sig-name descname">i915_perf_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> drm_i915_private *<em>i915</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>hide i915-perf from userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*i915</span></code></dt><dd><p>i915 device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>i915-perf state cleanup is split up into an ‘unregister’ and
‘deinit’ phase where the interface is first hidden from
userspace by <a class="reference internal" href="#c.i915_perf_unregister" title="i915_perf_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_perf_unregister()</span></code></a> before cleaning up
remaining state in <a class="reference internal" href="#c.i915_perf_fini" title="i915_perf_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_perf_fini()</span></code></a>.</p>
<dl class="c function">
<dt id="c.i915_perf_open_ioctl">
int <code class="sig-name descname">i915_perf_open_ioctl</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, void *<em>data</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_open_ioctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM ioctl() for userspace to open a stream FD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>ioctl data copied from userspace (unvalidated)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>drm file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates the stream open parameters given by userspace including flags
and an array of u64 key, value pair properties.</p>
<p>Very little is assumed up front about the nature of the stream being
opened (for instance we don’t assume it’s for periodic OA unit metrics). An
i915-perf stream is expected to be a suitable interface for other forms of
buffered data written by the GPU besides periodic OA metrics.</p>
<p>Note we copy the properties from userspace outside of the i915 perf
mutex to avoid an awkward lockdep with mmap_lock.</p>
<p>Most of the implementation details are handled by
<a class="reference internal" href="#c.i915_perf_open_ioctl_locked" title="i915_perf_open_ioctl_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_perf_open_ioctl_locked()</span></code></a> after taking the <code class="xref c c-type docutils literal notranslate"><span class="pre">perf-&gt;lock</span></code>
mutex for serializing with any non-file-operation driver hooks.</p>
<p><strong>Return</strong></p>
<p>A newly opened i915 Perf stream file descriptor or negative
error code on failure.</p>
<dl class="c function">
<dt id="c.i915_perf_release">
int <code class="sig-name descname">i915_perf_release</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_release" title="inode">inode</a> *<em>inode</em>, <em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_release" title="file">file</a> *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_release" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handles userspace close() of a stream file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>anonymous inode associated with file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>An i915 perf stream file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleans up any resources associated with an open i915 perf stream file.</p>
<p>NB: close() can’t really fail from the userspace point of view.</p>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code.</p>
<dl class="c function">
<dt id="c.i915_perf_add_config_ioctl">
int <code class="sig-name descname">i915_perf_add_config_ioctl</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, void *<em>data</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_add_config_ioctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM ioctl() for userspace to add a new OA config</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>ioctl data (pointer to struct drm_i915_perf_oa_config) copied from
userspace (unvalidated)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>drm file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates the submitted OA register to be saved into a new OA config that
can then be used for programming the OA unit and its NOA network.</p>
<p><strong>Return</strong></p>
<p>A new allocated config number to be used with the perf open ioctl
or a negative error code on failure.</p>
<dl class="c function">
<dt id="c.i915_perf_remove_config_ioctl">
int <code class="sig-name descname">i915_perf_remove_config_ioctl</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, void *<em>data</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_remove_config_ioctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM ioctl() for userspace to remove an OA config</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>ioctl data (pointer to u64 integer) copied from userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>drm file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configs can be removed while being used, the will stop appearing in sysfs
and their content will be freed when the stream using the config is closed.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<div class="section" id="i915-perf-stream">
<h3>i915 Perf Stream<a class="headerlink" href="#i915-perf-stream" title="Permalink to this headline">¶</a></h3>
<p>This section covers the stream-semantics-agnostic structures and functions
for representing an i915 perf stream FD and associated file operations.</p>
<dl class="c struct">
<dt id="c.i915_perf_stream">
<em class="property">struct </em><code class="sig-name descname">i915_perf_stream</code><a class="headerlink" href="#c.i915_perf_stream" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>state for a single open stream FD</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_perf_stream {
  struct i915_perf *perf;
  struct intel_uncore *uncore;
  struct intel_engine_cs *engine;
  u32 sample_flags;
  int sample_size;
  struct i915_gem_context *ctx;
  bool enabled;
  bool hold_preemption;
  const struct i915_perf_stream_ops *ops;
  struct i915_oa_config *oa_config;
  struct llist_head oa_config_bos;
  struct intel_context *pinned_ctx;
  u32 specific_ctx_id;
  u32 specific_ctx_id_mask;
  struct hrtimer poll_check_timer;
  wait_queue_head_t poll_wq;
  bool pollin;
  bool periodic;
  int period_exponent;
  struct {
    struct i915_vma *vma;
    u8 *vaddr;
    u32 last_ctx_id;
    int format;
    int format_size;
    int size_exponent;
    spinlock_t ptr_lock;
    u32 aging_tail;
    u64 aging_timestamp;
    u32 head;
    u32 tail;
  } oa_buffer;
  struct i915_vma *noa_wait;
  u64 poll_oa_period;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">perf</span></code></dt><dd><p>i915_perf backpointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uncore</span></code></dt><dd><p>mmio access path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engine</span></code></dt><dd><p>Engine associated with this performance stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sample_flags</span></code></dt><dd><p>Flags representing the <cite>DRM_I915_PERF_PROP_SAMPLE_*</cite>
properties given when opening a stream, representing the contents
of a single sample as read() by userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sample_size</span></code></dt><dd><p>Considering the configured contents of a sample
combined with the required header size, this is the total size
of a single sample record.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> if measuring system-wide across all contexts or a
specific context that is being monitored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled</span></code></dt><dd><p>Whether the stream is currently enabled, considering
whether the stream was opened in a disabled state and based
on <cite>I915_PERF_IOCTL_ENABLE</cite> and <cite>I915_PERF_IOCTL_DISABLE</cite> calls.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hold_preemption</span></code></dt><dd><p>Whether preemption is put on hold for command
submissions done on the <strong>ctx</strong>. This is useful for some drivers that
cannot easily post process the OA buffer context to subtract delta
of performance counters not associated with <strong>ctx</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>The callbacks providing the implementation of this specific
type of configured stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_config</span></code></dt><dd><p>The OA configuration used by the stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_config_bos</span></code></dt><dd><p>A list of struct i915_oa_config_bo allocated lazily
each time <strong>oa_config</strong> changes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pinned_ctx</span></code></dt><dd><p>The OA context specific information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">specific_ctx_id</span></code></dt><dd><p>The id of the specific context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">specific_ctx_id_mask</span></code></dt><dd><p>The mask used to masking specific_ctx_id bits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_check_timer</span></code></dt><dd><p>High resolution timer that will periodically
check for data in the circular OA buffer for notifying userspace
(e.g. during a read() or poll()).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_wq</span></code></dt><dd><p>The wait queue that hrtimer callback wakes when it
sees data ready to read in the circular OA buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pollin</span></code></dt><dd><p>Whether there is data available to read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">periodic</span></code></dt><dd><p>Whether periodic sampling is currently enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">period_exponent</span></code></dt><dd><p>The OA unit sampling frequency is derived from this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_buffer</span></code></dt><dd><p>State of the OA buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">noa_wait</span></code></dt><dd><p>A batch buffer doing a wait on the GPU for the NOA logic to be
reprogrammed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_oa_period</span></code></dt><dd><p>The period in nanoseconds at which the OA
buffer should be checked for available data.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.i915_perf_stream_ops">
<em class="property">struct </em><code class="sig-name descname">i915_perf_stream_ops</code><a class="headerlink" href="#c.i915_perf_stream_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>the OPs to support a specific stream type</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_perf_stream_ops {
  void (*enable)(struct i915_perf_stream *stream);
  void (*disable)(struct i915_perf_stream *stream);
  void (*poll_wait)(struct i915_perf_stream *stream,struct file *file, poll_table *wait);
  int (*wait_unlocked)(struct i915_perf_stream *stream);
  int (*read)(struct i915_perf_stream *stream,char __user *buf,size_t count, size_t *offset);
  void (*destroy)(struct i915_perf_stream *stream);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>Enables the collection of HW samples, either in response to
<cite>I915_PERF_IOCTL_ENABLE</cite> or implicitly called when stream is opened
without <cite>I915_PERF_FLAG_DISABLED</cite>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>Disables the collection of HW samples, either in response
to <cite>I915_PERF_IOCTL_DISABLE</cite> or implicitly called before destroying
the stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_wait</span></code></dt><dd><p>Call poll_wait, passing a wait queue that will be woken
once there is something ready to read() for the stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_unlocked</span></code></dt><dd><p>For handling a blocking read, wait until there is
something to ready to read() for the stream. E.g. wait on the same
wait queue that would be passed to poll_wait().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>Copy buffered metrics as records to userspace
<strong>buf</strong>: the userspace, destination buffer
<strong>count</strong>: the number of bytes to copy, requested by userspace
<strong>offset</strong>: zero at the start of the read, updated as the read
proceeds, it represents how many bytes have been copied so far and
the buffer offset for copying the next record.</p>
<p>Copy as many buffered i915 perf samples and records for this stream
to userspace as will fit in the given buffer.</p>
<p>Only write complete records; returning -<code class="docutils literal notranslate"><span class="pre">ENOSPC</span></code> if there isn’t room
for a complete record.</p>
<p>Return any error condition that results in a short read such as
-<code class="docutils literal notranslate"><span class="pre">ENOSPC</span></code> or -<code class="docutils literal notranslate"><span class="pre">EFAULT</span></code>, even though these may be squashed before
returning to userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy</span></code></dt><dd><p>Cleanup any stream specific resources.</p>
<p>The stream will always be disabled before this is called.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.read_properties_unlocked">
int <code class="sig-name descname">read_properties_unlocked</code><span class="sig-paren">(</span><em class="property">struct</em> i915_perf *<em>perf</em>, u64 __user *<em>uprops</em>, u32 <em>n_props</em>, <em class="property">struct</em> <a class="reference internal" href="#c.perf_open_properties" title="perf_open_properties">perf_open_properties</a> *<em>props</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_properties_unlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>validate + copy userspace stream open properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf</span> <span class="pre">*perf</span></code></dt><dd><p>i915 perf instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">__user</span> <span class="pre">*uprops</span></code></dt><dd><p>The array of u64 key value pairs given by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">n_props</span></code></dt><dd><p>The number of key value pairs expected in <strong>uprops</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">perf_open_properties</span> <span class="pre">*props</span></code></dt><dd><p>The stream configuration built up while validating properties</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note this function only validates properties in isolation it doesn’t
validate that the combination of properties makes sense or that all
properties necessary for a particular kind of stream have been set.</p>
<p>Note that there currently aren’t any ordering requirements for properties so
we shouldn’t validate or assume anything about ordering here. This doesn’t
rule out defining new properties with ordering requirements in the future.</p>
<dl class="c function">
<dt id="c.i915_perf_open_ioctl_locked">
int <code class="sig-name descname">i915_perf_open_ioctl_locked</code><span class="sig-paren">(</span><em class="property">struct</em> i915_perf *<em>perf</em>, <em class="property">struct</em> drm_i915_perf_open_param *<em>param</em>, <em class="property">struct</em> <a class="reference internal" href="#c.perf_open_properties" title="perf_open_properties">perf_open_properties</a> *<em>props</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_open_ioctl_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM ioctl() for userspace to open a stream FD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf</span> <span class="pre">*perf</span></code></dt><dd><p>i915 perf instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_perf_open_param</span> <span class="pre">*param</span></code></dt><dd><p>The open parameters passed to ‘DRM_I915_PERF_OPEN`</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">perf_open_properties</span> <span class="pre">*props</span></code></dt><dd><p>individually validated u64 property value pairs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>drm file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See i915_perf_ioctl_open() for interface details.</p>
<p>Implements further stream config validation and stream initialization on
behalf of <a class="reference internal" href="#c.i915_perf_open_ioctl" title="i915_perf_open_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_perf_open_ioctl()</span></code></a> with the <code class="xref c c-type docutils literal notranslate"><span class="pre">perf-&gt;lock</span></code> mutex
taken to serialize with any non-file-operation driver hooks.</p>
<p>In the case where userspace is interested in OA unit metrics then further
config validation and stream initialization details will be handled by
<a class="reference internal" href="#c.i915_oa_stream_init" title="i915_oa_stream_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_oa_stream_init()</span></code></a>. The code here should only validate config state that
will be relevant to all stream types / backends.</p>
<p><strong>Note</strong></p>
<p>at this point the <strong>props</strong> have only been validated in isolation and
it’s still necessary to validate that the combination of properties makes
sense.</p>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code.</p>
<dl class="c function">
<dt id="c.i915_perf_destroy_locked">
void <code class="sig-name descname">i915_perf_destroy_locked</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_destroy_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>destroy an i915 perf stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915 perf stream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees all resources associated with the given i915 perf <strong>stream</strong>, disabling
any associated data capture in the process.</p>
<p><strong>Note</strong></p>
<p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">perf-&gt;lock</span></code> mutex has been taken to serialize
with any non-file-operation driver hooks.</p>
<dl class="c function">
<dt id="c.i915_perf_read">
ssize_t <code class="sig-name descname">i915_perf_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_read" title="file">file</a> *<em>file</em>, char __user *<em>buf</em>, size_t <em>count</em>, loff_t *<em>ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handles read() FOP for i915 perf stream FDs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>An i915 perf stream file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>destination buffer given by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the number of bytes userspace wants to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>(inout) file seek position (unused)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The entry point for handling a read() on a stream file descriptor from
userspace. Most of the work is left to the i915_perf_read_locked() and
<a class="reference internal" href="#c.i915_perf_stream_ops" title="i915_perf_stream_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">i915_perf_stream_ops-&gt;read</span></code></a> but to save having stream implementations (of
which we might have multiple later) we handle blocking read here.</p>
<p>We can also consistently treat trying to read from a disabled stream
as an IO error so implementations can assume the stream is enabled
while reading.</p>
<p><strong>Return</strong></p>
<p>The number of bytes copied or a negative error code on failure.</p>
<dl class="c function">
<dt id="c.i915_perf_ioctl">
long <code class="sig-name descname">i915_perf_ioctl</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_ioctl" title="file">file</a> *<em>file</em>, unsigned int <em>cmd</em>, unsigned long <em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_ioctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>support ioctl() usage with i915 perf stream FDs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>An i915 perf stream file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>the ioctl request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>the ioctl data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implementation deferred to <a class="reference internal" href="#c.i915_perf_ioctl_locked" title="i915_perf_ioctl_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_perf_ioctl_locked()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code. Returns -EINVAL for
an unknown ioctl request.</p>
<dl class="c function">
<dt id="c.i915_perf_enable_locked">
void <code class="sig-name descname">i915_perf_enable_locked</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_enable_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle <cite>I915_PERF_IOCTL_ENABLE</cite> ioctl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>A disabled i915 perf stream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>[Re]enables the associated capture of data for this stream.</p>
<p>If a stream was previously enabled then there’s currently no intention
to provide userspace any guarantee about the preservation of previously
buffered data.</p>
<dl class="c function">
<dt id="c.i915_perf_disable_locked">
void <code class="sig-name descname">i915_perf_disable_locked</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_disable_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle <cite>I915_PERF_IOCTL_DISABLE</cite> ioctl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An enabled i915 perf stream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables the associated capture of data for this stream.</p>
<p>The intention is that disabling an re-enabling a stream will ideally be
cheaper than destroying and re-opening a stream with the same configuration,
though there are no formal guarantees about what state or buffered data
must be retained between disabling and re-enabling a stream.</p>
<p><strong>Note</strong></p>
<p>while a stream is disabled it’s considered an error for userspace
to attempt to read from the stream (-EIO).</p>
<dl class="c function">
<dt id="c.i915_perf_poll">
__poll_t <code class="sig-name descname">i915_perf_poll</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_poll" title="file">file</a> *<em>file</em>, poll_table *<em>wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_poll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>call poll_wait() with a suitable wait queue for stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>An i915 perf stream file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*wait</span></code></dt><dd><p>poll() state table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For handling userspace polling on an i915 perf stream, this ensures
poll_wait() gets called with a wait queue that will be woken for new stream
data.</p>
<p><strong>Note</strong></p>
<p>Implementation deferred to <a class="reference internal" href="#c.i915_perf_poll_locked" title="i915_perf_poll_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">i915_perf_poll_locked()</span></code></a></p>
<p><strong>Return</strong></p>
<p>any poll events that are ready without sleeping</p>
<dl class="c function">
<dt id="c.i915_perf_poll_locked">
__poll_t <code class="sig-name descname">i915_perf_poll_locked</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, <em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_poll_locked" title="file">file</a> *<em>file</em>, poll_table *<em>wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_poll_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>poll_wait() with a suitable wait queue for stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915 perf stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>An i915 perf stream file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*wait</span></code></dt><dd><p>poll() state table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For handling userspace polling on an i915 perf stream, this calls through to
<a class="reference internal" href="#c.i915_perf_stream_ops" title="i915_perf_stream_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">i915_perf_stream_ops-&gt;poll_wait</span></code></a> to call poll_wait() with a wait queue that
will be woken for new stream data.</p>
<p><strong>Note</strong></p>
<p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">perf-&gt;lock</span></code> mutex has been taken to serialize
with any non-file-operation driver hooks.</p>
<p><strong>Return</strong></p>
<p>any poll events that are ready without sleeping</p>
</div>
<div class="section" id="i915-perf-observation-architecture-stream">
<h3>i915 Perf Observation Architecture Stream<a class="headerlink" href="#i915-perf-observation-architecture-stream" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.i915_oa_ops">
<em class="property">struct </em><code class="sig-name descname">i915_oa_ops</code><a class="headerlink" href="#c.i915_oa_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gen specific implementation of an OA unit stream</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_oa_ops {
  bool (*is_valid_b_counter_reg)(struct i915_perf *perf, u32 addr);
  bool (*is_valid_mux_reg)(struct i915_perf *perf, u32 addr);
  bool (*is_valid_flex_reg)(struct i915_perf *perf, u32 addr);
  int (*enable_metric_set)(struct i915_perf_stream *stream, struct i915_active *active);
  void (*disable_metric_set)(struct i915_perf_stream *stream);
  void (*oa_enable)(struct i915_perf_stream *stream);
  void (*oa_disable)(struct i915_perf_stream *stream);
  int (*read)(struct i915_perf_stream *stream,char __user *buf,size_t count, size_t *offset);
  u32 (*oa_hw_tail_read)(struct i915_perf_stream *stream);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">is_valid_b_counter_reg</span></code></dt><dd><p>Validates register’s address for
programming boolean counters for a particular platform.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_valid_mux_reg</span></code></dt><dd><p>Validates register’s address for programming mux
for a particular platform.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_valid_flex_reg</span></code></dt><dd><p>Validates register’s address for programming
flex EU filtering for a particular platform.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_metric_set</span></code></dt><dd><p>Selects and applies any MUX configuration to set
up the Boolean and Custom (B/C) counters that are part of the
counter reports being sampled. May apply system constraints such as
disabling EU clock gating as required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_metric_set</span></code></dt><dd><p>Remove system constraints associated with using
the OA unit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_enable</span></code></dt><dd><p>Enable periodic sampling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_disable</span></code></dt><dd><p>Disable periodic sampling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>Copy data from the circular OA buffer into a given userspace
buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_hw_tail_read</span></code></dt><dd><p>read the OA tail pointer register</p>
<p>In particular this enables us to share all the fiddly code for
handling the OA unit tail pointer race that affects multiple
generations.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.i915_oa_stream_init">
int <code class="sig-name descname">i915_oa_stream_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, <em class="property">struct</em> drm_i915_perf_open_param *<em>param</em>, <em class="property">struct</em> <a class="reference internal" href="#c.perf_open_properties" title="perf_open_properties">perf_open_properties</a> *<em>props</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_oa_stream_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>validate combined props for OA stream and init</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915 perf stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_perf_open_param</span> <span class="pre">*param</span></code></dt><dd><p>The open parameters passed to <cite>DRM_I915_PERF_OPEN</cite></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">perf_open_properties</span> <span class="pre">*props</span></code></dt><dd><p>The property state that configures stream (individually validated)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>While <a class="reference internal" href="#c.read_properties_unlocked" title="read_properties_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">read_properties_unlocked()</span></code></a> validates properties in isolation it
doesn’t ensure that the combination necessarily makes sense.</p>
<p>At this point it has been determined that userspace wants a stream of
OA metrics, but still we need to further validate the combined
properties are OK.</p>
<p>If the configuration makes sense then we can allocate memory for
a circular OA buffer and apply the requested metric set configuration.</p>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code.</p>
<dl class="c function">
<dt id="c.i915_oa_read">
int <code class="sig-name descname">i915_oa_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, char __user *<em>buf</em>, size_t <em>count</em>, size_t *<em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_oa_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>just calls through to <a class="reference internal" href="#c.i915_oa_ops" title="i915_oa_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">i915_oa_ops-&gt;read</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>destination buffer given by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the number of bytes userspace wants to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*offset</span></code></dt><dd><p>(inout): the current position for writing into <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates <strong>offset</strong> according to the number of bytes successfully copied into
the userspace buffer.</p>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code</p>
<dl class="c function">
<dt id="c.i915_oa_stream_enable">
void <code class="sig-name descname">i915_oa_stream_enable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_oa_stream_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle <cite>I915_PERF_IOCTL_ENABLE</cite> for OA stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915 perf stream opened for OA metrics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>[Re]enables hardware periodic sampling according to the period configured
when opening the stream. This also starts a hrtimer that will periodically
check for data in the circular OA buffer for notifying userspace (e.g.
during a read() or poll()).</p>
<dl class="c function">
<dt id="c.i915_oa_stream_disable">
void <code class="sig-name descname">i915_oa_stream_disable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_oa_stream_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle <cite>I915_PERF_IOCTL_DISABLE</cite> for OA stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915 perf stream opened for OA metrics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops the OA unit from periodically writing counter reports into the
circular OA buffer. This also stops the hrtimer that periodically checks for
data in the circular OA buffer, for notifying userspace.</p>
<dl class="c function">
<dt id="c.i915_oa_wait_unlocked">
int <code class="sig-name descname">i915_oa_wait_unlocked</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_oa_wait_unlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handles blocking IO until OA data available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when userspace tries to read() from a blocking stream FD opened
for OA metrics. It waits until the hrtimer callback finds a non-empty
OA buffer and wakes us.</p>
<p><strong>Note</strong></p>
<p>it’s acceptable to have this return with some false positives
since any subsequent read handling will return -EAGAIN if there isn’t
really data ready for userspace yet.</p>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code</p>
<dl class="c function">
<dt id="c.i915_oa_poll_wait">
void <code class="sig-name descname">i915_oa_poll_wait</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, <em class="property">struct</em> <a class="reference internal" href="#c.i915_oa_poll_wait" title="file">file</a> *<em>file</em>, poll_table *<em>wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_oa_poll_wait" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>call poll_wait() for an OA stream poll()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>An i915 perf stream file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*wait</span></code></dt><dd><p>poll() state table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For handling userspace polling on an i915 perf stream opened for OA metrics,
this starts a poll_wait with the wait queue that our hrtimer callback wakes
when it sees data ready to read in the circular OA buffer.</p>
</div>
<div class="section" id="other-i915-perf-internals">
<h3>Other i915 Perf Internals<a class="headerlink" href="#other-i915-perf-internals" title="Permalink to this headline">¶</a></h3>
<p>This section simply includes all other currently documented i915 perf internals,
in no particular order, but may include some more minor utilities or platform
specific details than found in the more high-level sections.</p>
<dl class="c struct">
<dt id="c.perf_open_properties">
<em class="property">struct </em><code class="sig-name descname">perf_open_properties</code><a class="headerlink" href="#c.perf_open_properties" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>for validated properties given to open a stream</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct perf_open_properties {
  u32 sample_flags;
  u64 single_context:1;
  u64 hold_preemption:1;
  u64 ctx_handle;
  int metrics_set;
  int oa_format;
  bool oa_periodic;
  int oa_period_exponent;
  struct intel_engine_cs *engine;
  bool has_sseu;
  struct intel_sseu sseu;
  u64 poll_oa_period;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sample_flags</span></code></dt><dd><p><cite>DRM_I915_PERF_PROP_SAMPLE_*</cite> properties are tracked as flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">single_context</span></code></dt><dd><p>Whether a single or all gpu contexts should be monitored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hold_preemption</span></code></dt><dd><p>Whether the preemption is disabled for the filtered
context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx_handle</span></code></dt><dd><p>A gem ctx handle for use with <strong>single_context</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">metrics_set</span></code></dt><dd><p>An ID for an OA unit metric set advertised via sysfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_format</span></code></dt><dd><p>An OA unit HW report format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_periodic</span></code></dt><dd><p>Whether to enable periodic OA unit sampling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_period_exponent</span></code></dt><dd><p>The OA unit sampling period is derived from this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engine</span></code></dt><dd><p>The engine (typically rcs0) being monitored by the OA unit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">has_sseu</span></code></dt><dd><p>Whether <strong>sseu</strong> was specified by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sseu</span></code></dt><dd><p>internal SSEU configuration computed either from the userspace
specified configuration in the opening parameters or a default value
(see get_default_sseu_config())</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_oa_period</span></code></dt><dd><p>The period in nanoseconds at which the CPU will check for OA
data availability</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>As <a class="reference internal" href="#c.read_properties_unlocked" title="read_properties_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">read_properties_unlocked()</span></code></a> enumerates and validates the properties given
to open a stream of metrics the configuration is built up in the structure
which starts out zero initialized.</p>
<dl class="c function">
<dt id="c.oa_buffer_check_unlocked">
bool <code class="sig-name descname">oa_buffer_check_unlocked</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.oa_buffer_check_unlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check for data and update tail ptr state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>i915 stream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is either called via fops (for blocking reads in user ctx) or the poll
check hrtimer (atomic ctx) to check the OA buffer tail pointer and check
if there is data available for userspace to read.</p>
<p>This function is central to providing a workaround for the OA unit tail
pointer having a race with respect to what data is visible to the CPU.
It is responsible for reading tail pointers from the hardware and giving
the pointers time to ‘age’ before they are made available for reading.
(See description of OA_TAIL_MARGIN_NSEC above for further details.)</p>
<p>Besides returning true when there is data available to read() this function
also updates the tail, aging_tail and aging_timestamp in the oa_buffer
object.</p>
<p><strong>Note</strong></p>
<p>It’s safe to read OA config state here unlocked, assuming that this is
only called while the stream is enabled, while the global OA configuration
can’t be modified.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the OA buffer contains data, else <code class="docutils literal notranslate"><span class="pre">false</span></code></p>
<dl class="c function">
<dt id="c.append_oa_status">
int <code class="sig-name descname">append_oa_status</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, char __user *<em>buf</em>, size_t <em>count</em>, size_t *<em>offset</em>, <em class="property">enum</em> drm_i915_perf_record_type <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.append_oa_status" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Appends a status record to a userspace read() buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>destination buffer given by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the number of bytes userspace wants to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*offset</span></code></dt><dd><p>(inout): the current position for writing into <strong>buf</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_i915_perf_record_type</span> <span class="pre">type</span></code></dt><dd><p>The kind of status to report to userspace</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a status record (such as <cite>DRM_I915_PERF_RECORD_OA_REPORT_LOST</cite>)
into the userspace read() buffer.</p>
<p>The <strong>buf</strong> <strong>offset</strong> will only be updated on success.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="c function">
<dt id="c.append_oa_sample">
int <code class="sig-name descname">append_oa_sample</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, char __user *<em>buf</em>, size_t <em>count</em>, size_t *<em>offset</em>, <em class="property">const</em> u8 *<em>report</em><span class="sig-paren">)</span><a class="headerlink" href="#c.append_oa_sample" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies single OA report into userspace read() buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>destination buffer given by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the number of bytes userspace wants to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*offset</span></code></dt><dd><p>(inout): the current position for writing into <strong>buf</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*report</span></code></dt><dd><p>A single OA report to (optionally) include as part of the sample</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The contents of a sample are configured through <cite>DRM_I915_PERF_PROP_SAMPLE_*</cite>
properties when opening a stream, tracked as <cite>stream-&gt;sample_flags</cite>. This
function copies the requested components of a single sample to the given
read() <strong>buf</strong>.</p>
<p>The <strong>buf</strong> <strong>offset</strong> will only be updated on success.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="c function">
<dt id="c.gen8_append_oa_reports">
int <code class="sig-name descname">gen8_append_oa_reports</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, char __user *<em>buf</em>, size_t <em>count</em>, size_t *<em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen8_append_oa_reports" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>destination buffer given by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the number of bytes userspace wants to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*offset</span></code></dt><dd><p>(inout): the current position for writing into <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notably any error condition resulting in a short read (-<code class="docutils literal notranslate"><span class="pre">ENOSPC</span></code> or
-<code class="docutils literal notranslate"><span class="pre">EFAULT</span></code>) will be returned even though one or more records may
have been successfully copied. In this case it’s up to the caller
to decide if the error should be squashed before returning to
userspace.</p>
<p><strong>Note</strong></p>
<p>reports are consumed from the head, and appended to the
tail, so the tail chases the head?… If you think that’s mad
and back-to-front you’re not alone, but this follows the
Gen PRM naming convention.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="c function">
<dt id="c.gen8_oa_read">
int <code class="sig-name descname">gen8_oa_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, char __user *<em>buf</em>, size_t <em>count</em>, size_t *<em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen8_oa_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy status records then buffered OA reports</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>destination buffer given by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the number of bytes userspace wants to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*offset</span></code></dt><dd><p>(inout): the current position for writing into <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks OA unit status registers and if necessary appends corresponding
status records for userspace (such as for a buffer full condition) and then
initiate appending any buffered OA reports.</p>
<p>Updates <strong>offset</strong> according to the number of bytes successfully copied into
the userspace buffer.</p>
<p>NB: some data may be successfully copied to the userspace buffer
even if an error is returned, and this is reflected in the
updated <strong>offset</strong>.</p>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code</p>
<dl class="c function">
<dt id="c.gen7_append_oa_reports">
int <code class="sig-name descname">gen7_append_oa_reports</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, char __user *<em>buf</em>, size_t <em>count</em>, size_t *<em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen7_append_oa_reports" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>destination buffer given by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the number of bytes userspace wants to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*offset</span></code></dt><dd><p>(inout): the current position for writing into <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notably any error condition resulting in a short read (-<code class="docutils literal notranslate"><span class="pre">ENOSPC</span></code> or
-<code class="docutils literal notranslate"><span class="pre">EFAULT</span></code>) will be returned even though one or more records may
have been successfully copied. In this case it’s up to the caller
to decide if the error should be squashed before returning to
userspace.</p>
<p><strong>Note</strong></p>
<p>reports are consumed from the head, and appended to the
tail, so the tail chases the head?… If you think that’s mad
and back-to-front you’re not alone, but this follows the
Gen PRM naming convention.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="c function">
<dt id="c.gen7_oa_read">
int <code class="sig-name descname">gen7_oa_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, char __user *<em>buf</em>, size_t <em>count</em>, size_t *<em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen7_oa_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy status records then buffered OA reports</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>destination buffer given by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the number of bytes userspace wants to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*offset</span></code></dt><dd><p>(inout): the current position for writing into <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks Gen 7 specific OA unit status registers and if necessary appends
corresponding status records for userspace (such as for a buffer full
condition) and then initiate appending any buffered OA reports.</p>
<p>Updates <strong>offset</strong> according to the number of bytes successfully copied into
the userspace buffer.</p>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code</p>
<dl class="c function">
<dt id="c.oa_get_render_ctx_id">
int <code class="sig-name descname">oa_get_render_ctx_id</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.oa_get_render_ctx_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>determine and hold ctx hw id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the render context hw id, and ensure it remains fixed for the
lifetime of the stream. This ensures that we don’t have to worry about
updating the context ID in OACONTROL on the fly.</p>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code</p>
<dl class="c function">
<dt id="c.oa_put_render_ctx_id">
void <code class="sig-name descname">oa_put_render_ctx_id</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.oa_put_render_ctx_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>counterpart to oa_get_render_ctx_id releases hold</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915-perf stream opened for OA metrics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In case anything needed doing to ensure the context HW ID would remain valid
for the lifetime of the stream, then that can be undone here.</p>
<dl class="c function">
<dt id="c.i915_perf_ioctl_locked">
long <code class="sig-name descname">i915_perf_ioctl_locked</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.i915_perf_stream" title="i915_perf_stream">i915_perf_stream</a> *<em>stream</em>, unsigned int <em>cmd</em>, unsigned long <em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_ioctl_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>support ioctl() usage with i915 perf stream FDs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_perf_stream</span> <span class="pre">*stream</span></code></dt><dd><p>An i915 perf stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>the ioctl request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>the ioctl data</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">perf-&gt;lock</span></code> mutex has been taken to serialize
with any non-file-operation driver hooks.</p>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code. Returns -EINVAL for
an unknown ioctl request.</p>
<dl class="c function">
<dt id="c.i915_perf_ioctl_version">
int <code class="sig-name descname">i915_perf_ioctl_version</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.i915_perf_ioctl_version" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Version of the i915-perf subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This version number is used by userspace to detect available features.</p>
</div>
</div>
<div class="section" id="style">
<h2>Style<a class="headerlink" href="#style" title="Permalink to this headline">¶</a></h2>
<p>The drm/i915 driver codebase has some style rules in addition to (and, in some
cases, deviating from) the kernel coding style.</p>
<div class="section" id="register-macro-definition-style">
<h3>Register macro definition style<a class="headerlink" href="#register-macro-definition-style" title="Permalink to this headline">¶</a></h3>
<p>The style guide for <code class="docutils literal notranslate"><span class="pre">i915_reg.h</span></code>.</p>
<p>Follow the style described here for new macros, and while changing existing
macros. Do <strong>not</strong> mass change existing definitions just to update the style.</p>
<div class="section" id="file-layout">
<h4>File Layout<a class="headerlink" href="#file-layout" title="Permalink to this headline">¶</a></h4>
<p>Keep helper macros near the top. For example, _PIPE() and friends.</p>
<p>Prefix macros that generally should not be used outside of this file with
underscore ‘_’. For example, _PIPE() and friends, single instances of
registers that are defined solely for the use by function-like macros.</p>
<p>Avoid using the underscore prefixed macros outside of this file. There are
exceptions, but keep them to a minimum.</p>
<p>There are two basic types of register definitions: Single registers and
register groups. Register groups are registers which have two or more
instances, for example one per pipe, port, transcoder, etc. Register groups
should be defined using function-like macros.</p>
<p>For single registers, define the register offset first, followed by register
contents.</p>
<p>For register groups, define the register instance offsets first, prefixed
with underscore, followed by a function-like macro choosing the right
instance based on the parameter, followed by register contents.</p>
<p>Define the register contents (i.e. bit and bit field macros) from most
significant to least significant bit. Indent the register content macros
using two extra spaces between <code class="docutils literal notranslate"><span class="pre">#define</span></code> and the macro name.</p>
<p>Define bit fields using <code class="docutils literal notranslate"><span class="pre">REG_GENMASK(h,</span> <span class="pre">l)</span></code>. Define bit field contents
using <code class="docutils literal notranslate"><span class="pre">REG_FIELD_PREP(mask,</span> <span class="pre">value)</span></code>. This will define the values already
shifted in place, so they can be directly OR’d together. For convenience,
function-like macros may be used to define bit fields, but do note that the
macros may be needed to read as well as write the register contents.</p>
<p>Define bits using <code class="docutils literal notranslate"><span class="pre">REG_BIT(N)</span></code>. Do <strong>not</strong> add <code class="docutils literal notranslate"><span class="pre">_BIT</span></code> suffix to the name.</p>
<p>Group the register and its contents together without blank lines, separate
from other registers and their contents with one blank line.</p>
<p>Indent macro values from macro names using TABs. Align values vertically. Use
braces in macro values as needed to avoid unintended precedence after macro
substitution. Use spaces in macro values according to kernel coding
style. Use lower case in hexadecimal values.</p>
</div>
<div class="section" id="naming">
<h4>Naming<a class="headerlink" href="#naming" title="Permalink to this headline">¶</a></h4>
<p>Try to name registers according to the specs. If the register name changes in
the specs from platform to another, stick to the original name.</p>
<p>Try to re-use existing register macro definitions. Only add new macros for
new register offsets, or when the register contents have changed enough to
warrant a full redefinition.</p>
<p>When a register macro changes for a new platform, prefix the new macro using
the platform acronym or generation. For example, <code class="docutils literal notranslate"><span class="pre">SKL_</span></code> or <code class="docutils literal notranslate"><span class="pre">GEN8_</span></code>. The
prefix signifies the start platform/generation using the register.</p>
<p>When a bit (field) macro changes or gets added for a new platform, while
retaining the existing register macro, add a platform acronym or generation
suffix to the name. For example, <code class="docutils literal notranslate"><span class="pre">_SKL</span></code> or <code class="docutils literal notranslate"><span class="pre">_GEN8</span></code>.</p>
</div>
<div class="section" id="examples">
<h4>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h4>
<p>(Note that the values in the example are indented using spaces instead of
TABs to avoid misalignment in generated documentation. Use TABs in the
definitions.):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define _FOO_A                      0xf000
#define _FOO_B                      0xf001
#define FOO(pipe)                   _MMIO_PIPE(pipe, _FOO_A, _FOO_B)
#define   FOO_ENABLE                REG_BIT(31)
#define   FOO_MODE_MASK             REG_GENMASK(19, 16)
#define   FOO_MODE_BAR              REG_FIELD_PREP(FOO_MODE_MASK, 0)
#define   FOO_MODE_BAZ              REG_FIELD_PREP(FOO_MODE_MASK, 1)
#define   FOO_MODE_QUX_SNB          REG_FIELD_PREP(FOO_MODE_MASK, 2)

#define BAR                         _MMIO(0xb000)
#define GEN8_BAR                    _MMIO(0xb888)
</pre></div>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mcde.html" class="btn btn-neutral float-right" title="drm/mcde ST-Ericsson MCDE Multi-channel display engine" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="amdgpu-dc.html" class="btn btn-neutral float-left" title="drm/amd/display - Display Core (DC)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>