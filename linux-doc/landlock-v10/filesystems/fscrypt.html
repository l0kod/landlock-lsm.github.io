

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Filesystem-level encryption (fscrypt) &mdash; The Linux Kernel 5.2.0+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux Memory Management Documentation" href="../vm/index.html" />
    <link rel="prev" title="The Linux Journalling API" href="journalling.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Filesystems in the Linux kernel</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-vfs-documentation">Core VFS documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#filesystem-support-layers">Filesystem support layers</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="journalling.html">The Linux Journalling API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Filesystem-level encryption (fscrypt)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#threat-model">Threat model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#key-hierarchy">Key hierarchy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encryption-modes-and-usage">Encryption modes and usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-api">User API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-semantics">Access semantics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encryption-policy-enforcement">Encryption policy enforcement</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation-details">Implementation details</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tests">Tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Filesystems in the Linux kernel</a> &raquo;</li>
        
      <li>Filesystem-level encryption (fscrypt)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/fscrypt.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="filesystem-level-encryption-fscrypt">
<h1>Filesystem-level encryption (fscrypt)<a class="headerlink" href="#filesystem-level-encryption-fscrypt" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>fscrypt is a library which filesystems can hook into to support
transparent encryption of files and directories.</p>
<p>Note: “fscrypt” in this document refers to the kernel-level portion,
implemented in <code class="docutils literal notranslate"><span class="pre">fs/crypto/</span></code>, as opposed to the userspace tool
<a class="reference external" href="https://github.com/google/fscrypt">fscrypt</a>.  This document only
covers the kernel-level portion.  For command-line examples of how to
use encryption, see the documentation for the userspace tool <a class="reference external" href="https://github.com/google/fscrypt">fscrypt</a>.  Also, it is recommended to use
the fscrypt userspace tool, or other existing userspace tools such as
<a class="reference external" href="https://github.com/google/fscryptctl">fscryptctl</a> or <a class="reference external" href="https://source.android.com/security/encryption/file-based">Android’s key
management system</a>, over
using the kernel’s API directly.  Using existing tools reduces the
chance of introducing your own security bugs.  (Nevertheless, for
completeness this documentation covers the kernel’s API anyway.)</p>
<p>Unlike dm-crypt, fscrypt operates at the filesystem level rather than
at the block device level.  This allows it to encrypt different files
with different keys and to have unencrypted files on the same
filesystem.  This is useful for multi-user systems where each user’s
data-at-rest needs to be cryptographically isolated from the others.
However, except for filenames, fscrypt does not encrypt filesystem
metadata.</p>
<p>Unlike eCryptfs, which is a stacked filesystem, fscrypt is integrated
directly into supported filesystems — currently ext4, F2FS, and
UBIFS.  This allows encrypted files to be read and written without
caching both the decrypted and encrypted pages in the pagecache,
thereby nearly halving the memory used and bringing it in line with
unencrypted files.  Similarly, half as many dentries and inodes are
needed.  eCryptfs also limits encrypted filenames to 143 bytes,
causing application compatibility issues; fscrypt allows the full 255
bytes (NAME_MAX).  Finally, unlike eCryptfs, the fscrypt API can be
used by unprivileged users, with no need to mount anything.</p>
<p>fscrypt does not support encrypting files in-place.  Instead, it
supports marking an empty directory as encrypted.  Then, after
userspace provides the key, all regular files, directories, and
symbolic links created in that directory tree are transparently
encrypted.</p>
</div>
<div class="section" id="threat-model">
<h2>Threat model<a class="headerlink" href="#threat-model" title="Permalink to this headline">¶</a></h2>
<div class="section" id="offline-attacks">
<h3>Offline attacks<a class="headerlink" href="#offline-attacks" title="Permalink to this headline">¶</a></h3>
<p>Provided that userspace chooses a strong encryption key, fscrypt
protects the confidentiality of file contents and filenames in the
event of a single point-in-time permanent offline compromise of the
block device content.  fscrypt does not protect the confidentiality of
non-filename metadata, e.g. file sizes, file permissions, file
timestamps, and extended attributes.  Also, the existence and location
of holes (unallocated blocks which logically contain all zeroes) in
files is not protected.</p>
<p>fscrypt is not guaranteed to protect confidentiality or authenticity
if an attacker is able to manipulate the filesystem offline prior to
an authorized user later accessing the filesystem.</p>
</div>
<div class="section" id="online-attacks">
<h3>Online attacks<a class="headerlink" href="#online-attacks" title="Permalink to this headline">¶</a></h3>
<p>fscrypt (and storage encryption in general) can only provide limited
protection, if any at all, against online attacks.  In detail:</p>
<p>fscrypt is only resistant to side-channel attacks, such as timing or
electromagnetic attacks, to the extent that the underlying Linux
Cryptographic API algorithms are.  If a vulnerable algorithm is used,
such as a table-based implementation of AES, it may be possible for an
attacker to mount a side channel attack against the online system.
Side channel attacks may also be mounted against applications
consuming decrypted data.</p>
<p>After an encryption key has been provided, fscrypt is not designed to
hide the plaintext file contents or filenames from other users on the
same system, regardless of the visibility of the keyring key.
Instead, existing access control mechanisms such as file mode bits,
POSIX ACLs, LSMs, or mount namespaces should be used for this purpose.
Also note that as long as the encryption keys are <em>anywhere</em> in
memory, an online attacker can necessarily compromise them by mounting
a physical attack or by exploiting any kernel security vulnerability
which provides an arbitrary memory read primitive.</p>
<p>While it is ostensibly possible to “evict” keys from the system,
recently accessed encrypted files will remain accessible at least
until the filesystem is unmounted or the VFS caches are dropped, e.g.
using <code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">2</span> <span class="pre">&gt;</span> <span class="pre">/proc/sys/vm/drop_caches</span></code>.  Even after that, if the
RAM is compromised before being powered off, it will likely still be
possible to recover portions of the plaintext file contents, if not
some of the encryption keys as well.  (Since Linux v4.12, all
in-kernel keys related to fscrypt are sanitized before being freed.
However, userspace would need to do its part as well.)</p>
<p>Currently, fscrypt does not prevent a user from maliciously providing
an incorrect key for another user’s existing encrypted files.  A
protection against this is planned.</p>
</div>
</div>
<div class="section" id="key-hierarchy">
<h2>Key hierarchy<a class="headerlink" href="#key-hierarchy" title="Permalink to this headline">¶</a></h2>
<div class="section" id="master-keys">
<h3>Master Keys<a class="headerlink" href="#master-keys" title="Permalink to this headline">¶</a></h3>
<p>Each encrypted directory tree is protected by a <em>master key</em>.  Master
keys can be up to 64 bytes long, and must be at least as long as the
greater of the key length needed by the contents and filenames
encryption modes being used.  For example, if AES-256-XTS is used for
contents encryption, the master key must be 64 bytes (512 bits).  Note
that the XTS mode is defined to require a key twice as long as that
required by the underlying block cipher.</p>
<p>To “unlock” an encrypted directory tree, userspace must provide the
appropriate master key.  There can be any number of master keys, each
of which protects any number of directory trees on any number of
filesystems.</p>
<p>Userspace should generate master keys either using a cryptographically
secure random number generator, or by using a KDF (Key Derivation
Function).  Note that whenever a KDF is used to “stretch” a
lower-entropy secret such as a passphrase, it is critical that a KDF
designed for this purpose be used, such as scrypt, PBKDF2, or Argon2.</p>
</div>
<div class="section" id="per-file-keys">
<h3>Per-file keys<a class="headerlink" href="#per-file-keys" title="Permalink to this headline">¶</a></h3>
<p>Since each master key can protect many files, it is necessary to
“tweak” the encryption of each file so that the same plaintext in two
files doesn’t map to the same ciphertext, or vice versa.  In most
cases, fscrypt does this by deriving per-file keys.  When a new
encrypted inode (regular file, directory, or symlink) is created,
fscrypt randomly generates a 16-byte nonce and stores it in the
inode’s encryption xattr.  Then, it uses a KDF (Key Derivation
Function) to derive the file’s key from the master key and nonce.</p>
<p>The Adiantum encryption mode (see <a class="reference internal" href="#encryption-modes-and-usage">Encryption modes and usage</a>) is
special, since it accepts longer IVs and is suitable for both contents
and filenames encryption.  For it, a “direct key” option is offered
where the file’s nonce is included in the IVs and the master key is
used for encryption directly.  This improves performance; however,
users must not use the same master key for any other encryption mode.</p>
<p>Below, the KDF and design considerations are described in more detail.</p>
<p>The current KDF works by encrypting the master key with AES-128-ECB,
using the file’s nonce as the AES key.  The output is used as the
derived key.  If the output is longer than needed, then it is
truncated to the needed length.</p>
<p>Note: this KDF meets the primary security requirement, which is to
produce unique derived keys that preserve the entropy of the master
key, assuming that the master key is already a good pseudorandom key.
However, it is nonstandard and has some problems such as being
reversible, so it is generally considered to be a mistake!  It may be
replaced with HKDF or another more standard KDF in the future.</p>
<p>Key derivation was chosen over key wrapping because wrapped keys would
require larger xattrs which would be less likely to fit in-line in the
filesystem’s inode table, and there didn’t appear to be any
significant advantages to key wrapping.  In particular, currently
there is no requirement to support unlocking a file with multiple
alternative master keys or to support rotating master keys.  Instead,
the master keys may be wrapped in userspace, e.g. as is done by the
<a class="reference external" href="https://github.com/google/fscrypt">fscrypt</a> tool.</p>
<p>Including the inode number in the IVs was considered.  However, it was
rejected as it would have prevented ext4 filesystems from being
resized, and by itself still wouldn’t have been sufficient to prevent
the same key from being directly reused for both XTS and CTS-CBC.</p>
</div>
</div>
<div class="section" id="encryption-modes-and-usage">
<h2>Encryption modes and usage<a class="headerlink" href="#encryption-modes-and-usage" title="Permalink to this headline">¶</a></h2>
<p>fscrypt allows one encryption mode to be specified for file contents
and one encryption mode to be specified for filenames.  Different
directory trees are permitted to use different encryption modes.
Currently, the following pairs of encryption modes are supported:</p>
<ul class="simple">
<li>AES-256-XTS for contents and AES-256-CTS-CBC for filenames</li>
<li>AES-128-CBC for contents and AES-128-CTS-CBC for filenames</li>
<li>Adiantum for both contents and filenames</li>
</ul>
<p>If unsure, you should use the (AES-256-XTS, AES-256-CTS-CBC) pair.</p>
<p>AES-128-CBC was added only for low-powered embedded devices with
crypto accelerators such as CAAM or CESA that do not support XTS.  To
use AES-128-CBC, CONFIG_CRYPTO_SHA256 (or another SHA-256
implementation) must be enabled so that ESSIV can be used.</p>
<p>Adiantum is a (primarily) stream cipher-based mode that is fast even
on CPUs without dedicated crypto instructions.  It’s also a true
wide-block mode, unlike XTS.  It can also eliminate the need to derive
per-file keys.  However, it depends on the security of two primitives,
XChaCha12 and AES-256, rather than just one.  See the paper
“Adiantum: length-preserving encryption for entry-level processors”
(<a class="reference external" href="https://eprint.iacr.org/2018/720.pdf">https://eprint.iacr.org/2018/720.pdf</a>) for more details.  To use
Adiantum, CONFIG_CRYPTO_ADIANTUM must be enabled.  Also, fast
implementations of ChaCha and NHPoly1305 should be enabled, e.g.
CONFIG_CRYPTO_CHACHA20_NEON and CONFIG_CRYPTO_NHPOLY1305_NEON for ARM.</p>
<p>New encryption modes can be added relatively easily, without changes
to individual filesystems.  However, authenticated encryption (AE)
modes are not currently supported because of the difficulty of dealing
with ciphertext expansion.</p>
<div class="section" id="contents-encryption">
<h3>Contents encryption<a class="headerlink" href="#contents-encryption" title="Permalink to this headline">¶</a></h3>
<p>For file contents, each filesystem block is encrypted independently.
Currently, only the case where the filesystem block size is equal to
the system’s page size (usually 4096 bytes) is supported.</p>
<p>Each block’s IV is set to the logical block number within the file as
a little endian number, except that:</p>
<ul class="simple">
<li>With CBC mode encryption, ESSIV is also used.  Specifically, each IV
is encrypted with AES-256 where the AES-256 key is the SHA-256 hash
of the file’s data encryption key.</li>
<li>In the “direct key” configuration (FS_POLICY_FLAG_DIRECT_KEY set in
the fscrypt_policy), the file’s nonce is also appended to the IV.
Currently this is only allowed with the Adiantum encryption mode.</li>
</ul>
</div>
<div class="section" id="filenames-encryption">
<h3>Filenames encryption<a class="headerlink" href="#filenames-encryption" title="Permalink to this headline">¶</a></h3>
<p>For filenames, each full filename is encrypted at once.  Because of
the requirements to retain support for efficient directory lookups and
filenames of up to 255 bytes, the same IV is used for every filename
in a directory.</p>
<p>However, each encrypted directory still uses a unique key; or
alternatively (for the “direct key” configuration) has the file’s
nonce included in the IVs.  Thus, IV reuse is limited to within a
single directory.</p>
<p>With CTS-CBC, the IV reuse means that when the plaintext filenames
share a common prefix at least as long as the cipher block size (16
bytes for AES), the corresponding encrypted filenames will also share
a common prefix.  This is undesirable.  Adiantum does not have this
weakness, as it is a wide-block encryption mode.</p>
<p>All supported filenames encryption modes accept any plaintext length
&gt;= 16 bytes; cipher block alignment is not required.  However,
filenames shorter than 16 bytes are NUL-padded to 16 bytes before
being encrypted.  In addition, to reduce leakage of filename lengths
via their ciphertexts, all filenames are NUL-padded to the next 4, 8,
16, or 32-byte boundary (configurable).  32 is recommended since this
provides the best confidentiality, at the cost of making directory
entries consume slightly more space.  Note that since NUL (<code class="docutils literal notranslate"><span class="pre">\0</span></code>) is
not otherwise a valid character in filenames, the padding will never
produce duplicate plaintexts.</p>
<p>Symbolic link targets are considered a type of filename and are
encrypted in the same way as filenames in directory entries, except
that IV reuse is not a problem as each symlink has its own inode.</p>
</div>
</div>
<div class="section" id="user-api">
<h2>User API<a class="headerlink" href="#user-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="setting-an-encryption-policy">
<h3>Setting an encryption policy<a class="headerlink" href="#setting-an-encryption-policy" title="Permalink to this headline">¶</a></h3>
<p>The FS_IOC_SET_ENCRYPTION_POLICY ioctl sets an encryption policy on an
empty directory or verifies that a directory or regular file already
has the specified encryption policy.  It takes in a pointer to a
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscrypt_policy</span></code>, defined as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define FS_KEY_DESCRIPTOR_SIZE  8

struct fscrypt_policy {
        __u8 version;
        __u8 contents_encryption_mode;
        __u8 filenames_encryption_mode;
        __u8 flags;
        __u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
};
</pre></div>
</div>
<p>This structure must be initialized as follows:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">version</span></code> must be 0.</li>
<li><code class="docutils literal notranslate"><span class="pre">contents_encryption_mode</span></code> and <code class="docutils literal notranslate"><span class="pre">filenames_encryption_mode</span></code> must
be set to constants from <code class="docutils literal notranslate"><span class="pre">&lt;linux/fs.h&gt;</span></code> which identify the
encryption modes to use.  If unsure, use
FS_ENCRYPTION_MODE_AES_256_XTS (1) for <code class="docutils literal notranslate"><span class="pre">contents_encryption_mode</span></code>
and FS_ENCRYPTION_MODE_AES_256_CTS (4) for
<code class="docutils literal notranslate"><span class="pre">filenames_encryption_mode</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">flags</span></code> must contain a value from <code class="docutils literal notranslate"><span class="pre">&lt;linux/fs.h&gt;</span></code> which
identifies the amount of NUL-padding to use when encrypting
filenames.  If unsure, use FS_POLICY_FLAGS_PAD_32 (0x3).
In addition, if the chosen encryption modes are both
FS_ENCRYPTION_MODE_ADIANTUM, this can contain
FS_POLICY_FLAG_DIRECT_KEY to specify that the master key should be
used directly, without key derivation.</li>
<li><code class="docutils literal notranslate"><span class="pre">master_key_descriptor</span></code> specifies how to find the master key in
the keyring; see <a class="reference internal" href="#adding-keys">Adding keys</a>.  It is up to userspace to choose a
unique <code class="docutils literal notranslate"><span class="pre">master_key_descriptor</span></code> for each master key.  The e4crypt
and fscrypt tools use the first 8 bytes of
<code class="docutils literal notranslate"><span class="pre">SHA-512(SHA-512(master_key))</span></code>, but this particular scheme is not
required.  Also, the master key need not be in the keyring yet when
FS_IOC_SET_ENCRYPTION_POLICY is executed.  However, it must be added
before any files can be created in the encrypted directory.</li>
</ul>
<p>If the file is not yet encrypted, then FS_IOC_SET_ENCRYPTION_POLICY
verifies that the file is an empty directory.  If so, the specified
encryption policy is assigned to the directory, turning it into an
encrypted directory.  After that, and after providing the
corresponding master key as described in <a class="reference internal" href="#adding-keys">Adding keys</a>, all regular
files, directories (recursively), and symlinks created in the
directory will be encrypted, inheriting the same encryption policy.
The filenames in the directory’s entries will be encrypted as well.</p>
<p>Alternatively, if the file is already encrypted, then
FS_IOC_SET_ENCRYPTION_POLICY validates that the specified encryption
policy exactly matches the actual one.  If they match, then the ioctl
returns 0.  Otherwise, it fails with EEXIST.  This works on both
regular files and directories, including nonempty directories.</p>
<p>Note that the ext4 filesystem does not allow the root directory to be
encrypted, even if it is empty.  Users who want to encrypt an entire
filesystem with one key should consider using dm-crypt instead.</p>
<p>FS_IOC_SET_ENCRYPTION_POLICY can fail with the following errors:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">EACCES</span></code>: the file is not owned by the process’s uid, nor does the
process have the CAP_FOWNER capability in a namespace with the file
owner’s uid mapped</li>
<li><code class="docutils literal notranslate"><span class="pre">EEXIST</span></code>: the file is already encrypted with an encryption policy
different from the one specified</li>
<li><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: an invalid encryption policy was specified (invalid
version, mode(s), or flags)</li>
<li><code class="docutils literal notranslate"><span class="pre">ENOTDIR</span></code>: the file is unencrypted and is a regular file, not a
directory</li>
<li><code class="docutils literal notranslate"><span class="pre">ENOTEMPTY</span></code>: the file is unencrypted and is a nonempty directory</li>
<li><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement encryption</li>
<li><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with encryption
support for filesystems, or the filesystem superblock has not
had encryption enabled on it.  (For example, to use encryption on an
ext4 filesystem, CONFIG_FS_ENCRYPTION must be enabled in the
kernel config, and the superblock must have had the “encrypt”
feature flag enabled using <code class="docutils literal notranslate"><span class="pre">tune2fs</span> <span class="pre">-O</span> <span class="pre">encrypt</span></code> or <code class="docutils literal notranslate"><span class="pre">mkfs.ext4</span> <span class="pre">-O</span>
<span class="pre">encrypt</span></code>.)</li>
<li><code class="docutils literal notranslate"><span class="pre">EPERM</span></code>: this directory may not be encrypted, e.g. because it is
the root directory of an ext4 filesystem</li>
<li><code class="docutils literal notranslate"><span class="pre">EROFS</span></code>: the filesystem is readonly</li>
</ul>
</div>
<div class="section" id="getting-an-encryption-policy">
<h3>Getting an encryption policy<a class="headerlink" href="#getting-an-encryption-policy" title="Permalink to this headline">¶</a></h3>
<p>The FS_IOC_GET_ENCRYPTION_POLICY ioctl retrieves the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">fscrypt_policy</span></code>, if any, for a directory or regular file.  See above
for the struct definition.  No additional permissions are required
beyond the ability to open the file.</p>
<p>FS_IOC_GET_ENCRYPTION_POLICY can fail with the following errors:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: the file is encrypted, but it uses an unrecognized
encryption context format</li>
<li><code class="docutils literal notranslate"><span class="pre">ENODATA</span></code>: the file is not encrypted</li>
<li><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement encryption</li>
<li><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with encryption
support for this filesystem</li>
</ul>
<p>Note: if you only need to know whether a file is encrypted or not, on
most filesystems it is also possible to use the FS_IOC_GETFLAGS ioctl
and check for FS_ENCRYPT_FL, or to use the statx() system call and
check for STATX_ATTR_ENCRYPTED in stx_attributes.</p>
</div>
<div class="section" id="getting-the-per-filesystem-salt">
<h3>Getting the per-filesystem salt<a class="headerlink" href="#getting-the-per-filesystem-salt" title="Permalink to this headline">¶</a></h3>
<p>Some filesystems, such as ext4 and F2FS, also support the deprecated
ioctl FS_IOC_GET_ENCRYPTION_PWSALT.  This ioctl retrieves a randomly
generated 16-byte value stored in the filesystem superblock.  This
value is intended to used as a salt when deriving an encryption key
from a passphrase or other low-entropy user credential.</p>
<p>FS_IOC_GET_ENCRYPTION_PWSALT is deprecated.  Instead, prefer to
generate and manage any needed salt(s) in userspace.</p>
</div>
<div class="section" id="adding-keys">
<h3>Adding keys<a class="headerlink" href="#adding-keys" title="Permalink to this headline">¶</a></h3>
<p>To provide a master key, userspace must add it to an appropriate
keyring using the add_key() system call (see:
<code class="docutils literal notranslate"><span class="pre">Documentation/security/keys/core.rst</span></code>).  The key type must be
“logon”; keys of this type are kept in kernel memory and cannot be
read back by userspace.  The key description must be “fscrypt:”
followed by the 16-character lower case hex representation of the
<code class="docutils literal notranslate"><span class="pre">master_key_descriptor</span></code> that was set in the encryption policy.  The
key payload must conform to the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define FS_MAX_KEY_SIZE 64

struct fscrypt_key {
        u32 mode;
        u8 raw[FS_MAX_KEY_SIZE];
        u32 size;
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mode</span></code> is ignored; just set it to 0.  The actual key is provided in
<code class="docutils literal notranslate"><span class="pre">raw</span></code> with <code class="docutils literal notranslate"><span class="pre">size</span></code> indicating its size in bytes.  That is, the
bytes <code class="docutils literal notranslate"><span class="pre">raw[0..size-1]</span></code> (inclusive) are the actual key.</p>
<p>The key description prefix “fscrypt:” may alternatively be replaced
with a filesystem-specific prefix such as “ext4:”.  However, the
filesystem-specific prefixes are deprecated and should not be used in
new programs.</p>
<p>There are several different types of keyrings in which encryption keys
may be placed, such as a session keyring, a user session keyring, or a
user keyring.  Each key must be placed in a keyring that is “attached”
to all processes that might need to access files encrypted with it, in
the sense that request_key() will find the key.  Generally, if only
processes belonging to a specific user need to access a given
encrypted directory and no session keyring has been installed, then
that directory’s key should be placed in that user’s user session
keyring or user keyring.  Otherwise, a session keyring should be
installed if needed, and the key should be linked into that session
keyring, or in a keyring linked into that session keyring.</p>
<p>Note: introducing the complex visibility semantics of keyrings here
was arguably a mistake — especially given that by design, after any
process successfully opens an encrypted file (thereby setting up the
per-file key), possessing the keyring key is not actually required for
any process to read/write the file until its in-memory inode is
evicted.  In the future there probably should be a way to provide keys
directly to the filesystem instead, which would make the intended
semantics clearer.</p>
</div>
</div>
<div class="section" id="access-semantics">
<h2>Access semantics<a class="headerlink" href="#access-semantics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="with-the-key">
<h3>With the key<a class="headerlink" href="#with-the-key" title="Permalink to this headline">¶</a></h3>
<p>With the encryption key, encrypted regular files, directories, and
symlinks behave very similarly to their unencrypted counterparts —
after all, the encryption is intended to be transparent.  However,
astute users may notice some differences in behavior:</p>
<ul>
<li><p class="first">Unencrypted files, or files encrypted with a different encryption
policy (i.e. different key, modes, or flags), cannot be renamed or
linked into an encrypted directory; see <a class="reference internal" href="#encryption-policy-enforcement">Encryption policy
enforcement</a>.  Attempts to do so will fail with EXDEV.  However,
encrypted files can be renamed within an encrypted directory, or
into an unencrypted directory.</p>
<p>Note: “moving” an unencrypted file into an encrypted directory, e.g.
with the <cite>mv</cite> program, is implemented in userspace by a copy
followed by a delete.  Be aware that the original unencrypted data
may remain recoverable from free space on the disk; prefer to keep
all files encrypted from the very beginning.  The <cite>shred</cite> program
may be used to overwrite the source files but isn’t guaranteed to be
effective on all filesystems and storage devices.</p>
</li>
<li><p class="first">Direct I/O is not supported on encrypted files.  Attempts to use
direct I/O on such files will fall back to buffered I/O.</p>
</li>
<li><p class="first">The fallocate operations FALLOC_FL_COLLAPSE_RANGE,
FALLOC_FL_INSERT_RANGE, and FALLOC_FL_ZERO_RANGE are not supported
on encrypted files and will fail with EOPNOTSUPP.</p>
</li>
<li><p class="first">Online defragmentation of encrypted files is not supported.  The
EXT4_IOC_MOVE_EXT and F2FS_IOC_MOVE_RANGE ioctls will fail with
EOPNOTSUPP.</p>
</li>
<li><p class="first">The ext4 filesystem does not support data journaling with encrypted
regular files.  It will fall back to ordered data mode instead.</p>
</li>
<li><p class="first">DAX (Direct Access) is not supported on encrypted files.</p>
</li>
<li><p class="first">The st_size of an encrypted symlink will not necessarily give the
length of the symlink target as required by POSIX.  It will actually
give the length of the ciphertext, which will be slightly longer
than the plaintext due to NUL-padding and an extra 2-byte overhead.</p>
</li>
<li><p class="first">The maximum length of an encrypted symlink is 2 bytes shorter than
the maximum length of an unencrypted symlink.  For example, on an
EXT4 filesystem with a 4K block size, unencrypted symlinks can be up
to 4095 bytes long, while encrypted symlinks can only be up to 4093
bytes long (both lengths excluding the terminating null).</p>
</li>
</ul>
<p>Note that mmap <em>is</em> supported.  This is possible because the pagecache
for an encrypted file contains the plaintext, not the ciphertext.</p>
</div>
<div class="section" id="without-the-key">
<h3>Without the key<a class="headerlink" href="#without-the-key" title="Permalink to this headline">¶</a></h3>
<p>Some filesystem operations may be performed on encrypted regular
files, directories, and symlinks even before their encryption key has
been provided:</p>
<ul>
<li><p class="first">File metadata may be read, e.g. using stat().</p>
</li>
<li><p class="first">Directories may be listed, in which case the filenames will be
listed in an encoded form derived from their ciphertext.  The
current encoding algorithm is described in <a class="reference internal" href="#filename-hashing-and-encoding">Filename hashing and
encoding</a>.  The algorithm is subject to change, but it is
guaranteed that the presented filenames will be no longer than
NAME_MAX bytes, will not contain the <code class="docutils literal notranslate"><span class="pre">/</span></code> or <code class="docutils literal notranslate"><span class="pre">\0</span></code> characters, and
will uniquely identify directory entries.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.</span></code> and <code class="docutils literal notranslate"><span class="pre">..</span></code> directory entries are special.  They are always
present and are not encrypted or encoded.</p>
</li>
<li><p class="first">Files may be deleted.  That is, nondirectory files may be deleted
with unlink() as usual, and empty directories may be deleted with
rmdir() as usual.  Therefore, <code class="docutils literal notranslate"><span class="pre">rm</span></code> and <code class="docutils literal notranslate"><span class="pre">rm</span> <span class="pre">-r</span></code> will work as
expected.</p>
</li>
<li><p class="first">Symlink targets may be read and followed, but they will be presented
in encrypted form, similar to filenames in directories.  Hence, they
are unlikely to point to anywhere useful.</p>
</li>
</ul>
<p>Without the key, regular files cannot be opened or truncated.
Attempts to do so will fail with ENOKEY.  This implies that any
regular file operations that require a file descriptor, such as
read(), write(), mmap(), fallocate(), and ioctl(), are also forbidden.</p>
<p>Also without the key, files of any type (including directories) cannot
be created or linked into an encrypted directory, nor can a name in an
encrypted directory be the source or target of a rename, nor can an
O_TMPFILE temporary file be created in an encrypted directory.  All
such operations will fail with ENOKEY.</p>
<p>It is not currently possible to backup and restore encrypted files
without the encryption key.  This would require special APIs which
have not yet been implemented.</p>
</div>
</div>
<div class="section" id="encryption-policy-enforcement">
<h2>Encryption policy enforcement<a class="headerlink" href="#encryption-policy-enforcement" title="Permalink to this headline">¶</a></h2>
<p>After an encryption policy has been set on a directory, all regular
files, directories, and symbolic links created in that directory
(recursively) will inherit that encryption policy.  Special files —
that is, named pipes, device nodes, and UNIX domain sockets — will
not be encrypted.</p>
<p>Except for those special files, it is forbidden to have unencrypted
files, or files encrypted with a different encryption policy, in an
encrypted directory tree.  Attempts to link or rename such a file into
an encrypted directory will fail with EXDEV.  This is also enforced
during -&gt;lookup() to provide limited protection against offline
attacks that try to disable or downgrade encryption in known locations
where applications may later write sensitive data.  It is recommended
that systems implementing a form of “verified boot” take advantage of
this by validating all top-level encryption policies prior to access.</p>
</div>
<div class="section" id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="encryption-context">
<h3>Encryption context<a class="headerlink" href="#encryption-context" title="Permalink to this headline">¶</a></h3>
<p>An encryption policy is represented on-disk by a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">fscrypt_context</span></code>.  It is up to individual filesystems to decide where
to store it, but normally it would be stored in a hidden extended
attribute.  It should <em>not</em> be exposed by the xattr-related system
calls such as getxattr() and setxattr() because of the special
semantics of the encryption xattr.  (In particular, there would be
much confusion if an encryption policy were to be added to or removed
from anything other than an empty directory.)  The struct is defined
as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define FS_KEY_DESCRIPTOR_SIZE  8
#define FS_KEY_DERIVATION_NONCE_SIZE 16

struct fscrypt_context {
        u8 format;
        u8 contents_encryption_mode;
        u8 filenames_encryption_mode;
        u8 flags;
        u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
        u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];
};
</pre></div>
</div>
<p>Note that <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscrypt_context</span></code> contains the same
information as <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscrypt_policy</span></code> (see <a class="reference internal" href="#setting-an-encryption-policy">Setting an
encryption policy</a>), except that <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fscrypt_context</span></code>
also contains a nonce.  The nonce is randomly generated by the kernel
and is used to derive the inode’s encryption key as described in
<a class="reference internal" href="#per-file-keys">Per-file keys</a>.</p>
</div>
<div class="section" id="data-path-changes">
<h3>Data path changes<a class="headerlink" href="#data-path-changes" title="Permalink to this headline">¶</a></h3>
<p>For the read path (-&gt;readpage()) of regular files, filesystems can
read the ciphertext into the page cache and decrypt it in-place.  The
page lock must be held until decryption has finished, to prevent the
page from becoming visible to userspace prematurely.</p>
<p>For the write path (-&gt;writepage()) of regular files, filesystems
cannot encrypt data in-place in the page cache, since the cached
plaintext must be preserved.  Instead, filesystems must encrypt into a
temporary buffer or “bounce page”, then write out the temporary
buffer.  Some filesystems, such as UBIFS, already use temporary
buffers regardless of encryption.  Other filesystems, such as ext4 and
F2FS, have to allocate bounce pages specially for encryption.</p>
</div>
<div class="section" id="filename-hashing-and-encoding">
<h3>Filename hashing and encoding<a class="headerlink" href="#filename-hashing-and-encoding" title="Permalink to this headline">¶</a></h3>
<p>Modern filesystems accelerate directory lookups by using indexed
directories.  An indexed directory is organized as a tree keyed by
filename hashes.  When a -&gt;lookup() is requested, the filesystem
normally hashes the filename being looked up so that it can quickly
find the corresponding directory entry, if any.</p>
<p>With encryption, lookups must be supported and efficient both with and
without the encryption key.  Clearly, it would not work to hash the
plaintext filenames, since the plaintext filenames are unavailable
without the key.  (Hashing the plaintext filenames would also make it
impossible for the filesystem’s fsck tool to optimize encrypted
directories.)  Instead, filesystems hash the ciphertext filenames,
i.e. the bytes actually stored on-disk in the directory entries.  When
asked to do a -&gt;lookup() with the key, the filesystem just encrypts
the user-supplied name to get the ciphertext.</p>
<p>Lookups without the key are more complicated.  The raw ciphertext may
contain the <code class="docutils literal notranslate"><span class="pre">\0</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code> characters, which are illegal in
filenames.  Therefore, readdir() must base64-encode the ciphertext for
presentation.  For most filenames, this works fine; on -&gt;lookup(), the
filesystem just base64-decodes the user-supplied name to get back to
the raw ciphertext.</p>
<p>However, for very long filenames, base64 encoding would cause the
filename length to exceed NAME_MAX.  To prevent this, readdir()
actually presents long filenames in an abbreviated form which encodes
a strong “hash” of the ciphertext filename, along with the optional
filesystem-specific hash(es) needed for directory lookups.  This
allows the filesystem to still, with a high degree of confidence, map
the filename given in -&gt;lookup() back to a particular directory entry
that was previously listed by readdir().  See <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">fscrypt_digested_name</span></code> in the source for more details.</p>
<p>Note that the precise way that filenames are presented to userspace
without the key is subject to change in the future.  It is only meant
as a way to temporarily present valid filenames so that commands like
<code class="docutils literal notranslate"><span class="pre">rm</span> <span class="pre">-r</span></code> work as expected on encrypted directories.</p>
</div>
</div>
<div class="section" id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<p>To test fscrypt, use xfstests, which is Linux’s de facto standard
filesystem test suite.  First, run all the tests in the “encrypt”
group on the relevant filesystem(s).  For example, to test ext4 and
f2fs encryption using <a class="reference external" href="https://github.com/tytso/xfstests-bld/blob/master/Documentation/kvm-quickstart.md">kvm-xfstests</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kvm-xfstests -c ext4,f2fs -g encrypt
</pre></div>
</div>
<p>UBIFS encryption can also be tested this way, but it should be done in
a separate command, and it takes some time for kvm-xfstests to set up
emulated UBI volumes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kvm-xfstests -c ubifs -g encrypt
</pre></div>
</div>
<p>No tests should fail.  However, tests that use non-default encryption
modes (e.g. generic/549 and generic/550) will be skipped if the needed
algorithms were not built into the kernel’s crypto API.  Also, tests
that access the raw block device (e.g. generic/399, generic/548,
generic/549, generic/550) will be skipped on UBIFS.</p>
<p>Besides running the “encrypt” group tests, for ext4 and f2fs it’s also
possible to run most xfstests with the “test_dummy_encryption” mount
option.  This option causes all new files to be automatically
encrypted with a dummy key, without having to make any API calls.
This tests the encrypted I/O paths more thoroughly.  To do this with
kvm-xfstests, use the “encrypt” filesystem configuration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kvm-xfstests -c ext4/encrypt,f2fs/encrypt -g auto
</pre></div>
</div>
<p>Because this runs many more tests than “-g encrypt” does, it takes
much longer to run; so also consider using <a class="reference external" href="https://github.com/tytso/xfstests-bld/blob/master/Documentation/gce-xfstests.md">gce-xfstests</a>
instead of kvm-xfstests:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gce-xfstests -c ext4/encrypt,f2fs/encrypt -g auto
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../vm/index.html" class="btn btn-neutral float-right" title="Linux Memory Management Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="journalling.html" class="btn btn-neutral float-left" title="The Linux Journalling API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>