

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux UWB + Wireless USB + WiNET &mdash; The Linux Kernel 5.2.0+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="USB references" href="usb-help.html" />
    <link rel="prev" title="USB serial" href="usb-serial.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">USB support</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="acm.html">Linux ACM driver v0.16</a></li>
<li class="toctree-l2"><a class="reference internal" href="authorization.html">Authorizing (or not) your USB devices to connect to the system</a></li>
<li class="toctree-l2"><a class="reference internal" href="chipidea.html">ChipIdea Highspeed Dual Role Controller Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="dwc3.html">DWC3 driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="ehci.html">EHCI driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="functionfs.html">How FunctionFS works</a></li>
<li class="toctree-l2"><a class="reference internal" href="gadget_configfs.html">Linux USB gadget configured through configfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="gadget_hid.html">Linux USB HID gadget driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="gadget_multi.html">Multifunction Composite Gadget</a></li>
<li class="toctree-l2"><a class="reference internal" href="gadget_printer.html">Linux USB Printer Gadget Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="gadget_serial.html">Linux Gadget Serial Driver v2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="gadget-testing.html">Gadget Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="iuu_phoenix.html">Infinity Usb Unlimited Readme</a></li>
<li class="toctree-l2"><a class="reference internal" href="mass-storage.html">Mass Storage Gadget (MSG)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_usbsevseg.html">USB 7-Segment Numeric Display</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtouchusb.html">mtouchusb driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="ohci.html">OHCI</a></li>
<li class="toctree-l2"><a class="reference internal" href="rio.html">Diamonds Rio</a></li>
<li class="toctree-l2"><a class="reference internal" href="usbip_protocol.html">USB/IP protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="usbmon.html">usbmon</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb-serial.html">USB serial</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Linux UWB + Wireless USB + WiNET</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hwa-host-wire-adapters-your-wireless-usb-dongle">HWA: Host Wire adapters, your Wireless USB dongle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dwa-device-wired-adaptor-a-wireless-usb-hub-for-wired-devices">DWA: Device Wired Adaptor, a Wireless USB hub for wired devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#whci-wireless-host-controller-interface-the-pci-wusb-host-adapter">WHCI: Wireless Host Controller Interface, the PCI WUSB host adapter</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-uwb-stack">The UWB stack</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#devices-and-hosts-the-basic-structure">Devices and hosts: the basic structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#host-controller-life-cycle">Host Controller life cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#on-the-air-beacons-and-enumerating-the-radio-neighborhood">On the air: beacons and enumerating the radio neighborhood</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-lists">Device lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bandwidth-allocation">Bandwidth allocation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#wireless-usb-host-controller-drivers">Wireless USB Host Controller drivers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#new-device-connection">New device connection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-life-cycle-and-keep-alives">Device life cycle and keep alives</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sending-and-receiving-data">Sending and receiving data</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#glossary">Glossary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="usb-help.html">USB references</a></li>
<li class="toctree-l2"><a class="reference internal" href="text_files.html">Linux CDC ACM inf</a></li>
<li class="toctree-l2"><a class="reference internal" href="text_files.html#linux-inf">Linux inf</a></li>
<li class="toctree-l2"><a class="reference internal" href="text_files.html#usb-devfs-drop-permissions-source">USB devfs drop permissions source</a></li>
<li class="toctree-l2"><a class="reference internal" href="text_files.html#wusb-command-line-script-to-manipulate-auth-credentials">WUSB command line script to manipulate auth credentials</a></li>
<li class="toctree-l2"><a class="reference internal" href="text_files.html#credits">Credits</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">USB support</a> &raquo;</li>
        
      <li>Linux UWB + Wireless USB + WiNET</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/usb/wusb-design-overview.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-uwb-wireless-usb-winet">
<h1>Linux UWB + Wireless USB + WiNET<a class="headerlink" href="#linux-uwb-wireless-usb-winet" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Copyright (C) 2005-2006 Intel Corporation</p>
<p>Inaky Perez-Gonzalez &lt;<a class="reference external" href="mailto:inaky&#46;perez-gonzalez&#37;&#52;&#48;intel&#46;com">inaky<span>&#46;</span>perez-gonzalez<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</p>
<p>This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License version
2 as published by the Free Software Foundation.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.</p>
</div></blockquote>
<p>Please visit <a class="reference external" href="http://bughost.org/thewiki/Design-overview.txt-1.8">http://bughost.org/thewiki/Design-overview.txt-1.8</a> for
updated content.</p>
<blockquote>
<div><ul class="simple">
<li>Design-overview.txt-1.8</li>
</ul>
</div></blockquote>
<p>This code implements a Ultra Wide Band stack for Linux, as well as
drivers for the USB based UWB radio controllers defined in the
Wireless USB 1.0 specification (including Wireless USB host controller
and an Intel WiNET controller).</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>UWB is a wide-band communication protocol that is to serve also as the
low-level protocol for others (much like TCP sits on IP). Currently
these others are Wireless USB and TCP/IP, but seems Bluetooth and
Firewire/1394 are coming along.</p>
<p>UWB uses a band from roughly 3 to 10 GHz, transmitting at a max of
~-41dB (or 0.074 uW/MHz–geography specific data is still being
negotiated w/ regulators, so watch for changes). That band is divided in
a bunch of ~1.5 GHz wide channels (or band groups) composed of three
subbands/subchannels (528 MHz each). Each channel is independent of each
other, so you could consider them different “busses”. Initially this
driver considers them all a single one.</p>
<p>Radio time is divided in 65536 us long /superframes/, each one divided
in 256 256us long /MASs/ (Media Allocation Slots), which are the basic
time/media allocation units for transferring data. At the beginning of
each superframe there is a Beacon Period (BP), where every device
transmit its beacon on a single MAS. The length of the BP depends on how
many devices are present and the length of their beacons.</p>
<p>Devices have a MAC (fixed, 48 bit address) and a device (changeable, 16
bit address) and send periodic beacons to advertise themselves and pass
info on what they are and do. They advertise their capabilities and a
bunch of other stuff.</p>
<p>The different logical parts of this driver are:</p>
<blockquote>
<div><ul class="simple">
<li><em>UWB</em>: the Ultra-Wide-Band stack – manages the radio and
associated spectrum to allow for devices sharing it. Allows to
control bandwidth assignment, beaconing, scanning, etc</li>
<li><em>WUSB</em>: the layer that sits on top of UWB to provide Wireless USB.
The Wireless USB spec defines means to control a UWB radio and to
do the actual WUSB.</li>
</ul>
</div></blockquote>
<div class="section" id="hwa-host-wire-adapters-your-wireless-usb-dongle">
<h3>HWA: Host Wire adapters, your Wireless USB dongle<a class="headerlink" href="#hwa-host-wire-adapters-your-wireless-usb-dongle" title="Permalink to this headline">¶</a></h3>
<p>WUSB also defines a device called a Host Wire Adaptor (HWA), which in
mere terms is a USB dongle that enables your PC to have UWB and Wireless
USB. The Wireless USB Host Controller in a HWA looks to the host like a
[Wireless] USB controller connected via USB (!)</p>
<p>The HWA itself is broken in two or three main interfaces:</p>
<blockquote>
<div><ul class="simple">
<li><em>RC</em>: Radio control – this implements an interface to the
Ultra-Wide-Band radio controller. The driver for this implements a
USB-based UWB Radio Controller to the UWB stack.</li>
<li><em>HC</em>: the wireless USB host controller. It looks like a USB host
whose root port is the radio and the WUSB devices connect to it.
To the system it looks like a separate USB host. The driver (will)
implement a USB host controller (similar to UHCI, OHCI or EHCI)
for which the root hub is the radio…To reiterate: it is a USB
controller that is connected via USB instead of PCI.</li>
<li><em>WINET</em>: some HW provide a WiNET interface (IP over UWB). This
package provides a driver for it (it looks like a network
interface, winetX). The driver detects when there is a link up for
their type and kick into gear.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="dwa-device-wired-adaptor-a-wireless-usb-hub-for-wired-devices">
<h3>DWA: Device Wired Adaptor, a Wireless USB hub for wired devices<a class="headerlink" href="#dwa-device-wired-adaptor-a-wireless-usb-hub-for-wired-devices" title="Permalink to this headline">¶</a></h3>
<p>These are the complement to HWAs. They are a USB host for connecting
wired devices, but it is connected to your PC connected via Wireless
USB. To the system it looks like yet another USB host. To the untrained
eye, it looks like a hub that connects upstream wirelessly.</p>
<p>We still offer no support for this; however, it should share a lot of
code with the HWA-RC driver; there is a bunch of factorization work that
has been done to support that in upcoming releases.</p>
</div>
<div class="section" id="whci-wireless-host-controller-interface-the-pci-wusb-host-adapter">
<h3>WHCI: Wireless Host Controller Interface, the PCI WUSB host adapter<a class="headerlink" href="#whci-wireless-host-controller-interface-the-pci-wusb-host-adapter" title="Permalink to this headline">¶</a></h3>
<p>This is your usual PCI device that implements WHCI. Similar in concept
to EHCI, it allows your wireless USB devices (including DWAs) to connect
to your host via a PCI interface. As in the case of the HWA, it has a
Radio Control interface and the WUSB Host Controller interface per se.</p>
<p>There is still no driver support for this, but will be in upcoming
releases.</p>
</div>
</div>
<div class="section" id="the-uwb-stack">
<h2>The UWB stack<a class="headerlink" href="#the-uwb-stack" title="Permalink to this headline">¶</a></h2>
<p>The main mission of the UWB stack is to keep a tally of which devices
are in radio proximity to allow drivers to connect to them. As well, it
provides an API for controlling the local radio controllers (RCs from
now on), such as to start/stop beaconing, scan, allocate bandwidth, etc.</p>
<div class="section" id="devices-and-hosts-the-basic-structure">
<h3>Devices and hosts: the basic structure<a class="headerlink" href="#devices-and-hosts-the-basic-structure" title="Permalink to this headline">¶</a></h3>
<p>The main building block here is the UWB device (struct uwb_dev). For
each device that pops up in radio presence (ie: the UWB host receives a
beacon from it) you get a struct uwb_dev that will show up in
/sys/bus/uwb/devices.</p>
<p>For each RC that is detected, a new struct uwb_rc and struct uwb_dev are
created. An entry is also created in /sys/class/uwb_rc for each RC.</p>
<p>Each RC driver is implemented by a separate driver that plugs into the
interface that the UWB stack provides through a struct uwb_rc_ops. The
spec creators have been nice enough to make the message format the same
for HWA and WHCI RCs, so the driver is really a very thin transport that
moves the requests from the UWB API to the device [/uwb_rc_ops-&gt;cmd()/]
and sends the replies and notifications back to the API
[/uwb_rc_neh_grok()/]. Notifications are handled to the UWB daemon, that
is chartered, among other things, to keep the tab of how the UWB radio
neighborhood looks, creating and destroying devices as they show up or
disappear.</p>
<p>Command execution is very simple: a command block is sent and a event
block or reply is expected back. For sending/receiving command/events, a
handle called /neh/ (Notification/Event Handle) is opened with
/uwb_rc_neh_open()/.</p>
<p>The HWA-RC (USB dongle) driver (drivers/uwb/hwa-rc.c) does this job for
the USB connected HWA. Eventually, drivers/whci-rc.c will do the same
for the PCI connected WHCI controller.</p>
</div>
<div class="section" id="host-controller-life-cycle">
<h3>Host Controller life cycle<a class="headerlink" href="#host-controller-life-cycle" title="Permalink to this headline">¶</a></h3>
<p>So let’s say we connect a dongle to the system: it is detected and
firmware uploaded if needed [for Intel’s i1480
/drivers/uwb/ptc/usb.c:ptc_usb_probe()/] and then it is reenumerated.
Now we have a real HWA device connected and
/drivers/uwb/hwa-rc.c:hwarc_probe()/ picks it up, that will set up the
Wire-Adaptor environment and then suck it into the UWB stack’s vision of
the world [/drivers/uwb/lc-rc.c:uwb_rc_add()/].</p>
<blockquote>
<div><ul class="simple">
<li>[*] The stack should put a new RC to scan for devices
[/uwb_rc_scan()/] so it finds what’s available around and tries to
connect to them, but this is policy stuff and should be driven
from user space. As of now, the operator is expected to do it
manually; see the release notes for documentation on the procedure.</li>
</ul>
</div></blockquote>
<p>When a dongle is disconnected, /drivers/uwb/hwa-rc.c:hwarc_disconnect()/
takes time of tearing everything down safely (or not…).</p>
</div>
<div class="section" id="on-the-air-beacons-and-enumerating-the-radio-neighborhood">
<h3>On the air: beacons and enumerating the radio neighborhood<a class="headerlink" href="#on-the-air-beacons-and-enumerating-the-radio-neighborhood" title="Permalink to this headline">¶</a></h3>
<p>So assuming we have devices and we have agreed for a channel to connect
on (let’s say 9), we put the new RC to beacon:</p>
<blockquote>
<div><ul class="simple">
<li>$ echo 9 0 &gt; /sys/class/uwb_rc/uwb0/beacon</li>
</ul>
</div></blockquote>
<p>Now it is visible. If there were other devices in the same radio channel
and beacon group (that’s what the zero is for), the dongle’s radio
control interface will send beacon notifications on its
notification/event endpoint (NEEP). The beacon notifications are part of
the event stream that is funneled into the API with
/drivers/uwb/neh.c:uwb_rc_neh_grok()/ and delivered to the UWBD, the UWB
daemon through a notification list.</p>
<p>UWBD wakes up and scans the event list; finds a beacon and adds it to
the BEACON CACHE (/uwb_beca/). If he receives a number of beacons from
the same device, he considers it to be ‘onair’ and creates a new device
[/drivers/uwb/lc-dev.c:uwbd_dev_onair()/]. Similarly, when no beacons
are received in some time, the device is considered gone and wiped out
[uwbd calls periodically /uwb/beacon.c:uwb_beca_purge()/ that will purge
the beacon cache of dead devices].</p>
</div>
<div class="section" id="device-lists">
<h3>Device lists<a class="headerlink" href="#device-lists" title="Permalink to this headline">¶</a></h3>
<p>All UWB devices are kept in the list of the struct bus_type uwb_bus_type.</p>
</div>
<div class="section" id="bandwidth-allocation">
<h3>Bandwidth allocation<a class="headerlink" href="#bandwidth-allocation" title="Permalink to this headline">¶</a></h3>
<p>The UWB stack maintains a local copy of DRP availability through
processing of incoming <em>DRP Availability Change</em> notifications. This
local copy is currently used to present the current bandwidth
availability to the user through the sysfs file
/sys/class/uwb_rc/uwbx/bw_avail. In the future the bandwidth
availability information will be used by the bandwidth reservation
routines.</p>
<p>The bandwidth reservation routines are in progress and are thus not
present in the current release. When completed they will enable a user
to initiate DRP reservation requests through interaction with sysfs. DRP
reservation requests from remote UWB devices will also be handled. The
bandwidth management done by the UWB stack will include callbacks to the
higher layers will enable the higher layers to use the reservations upon
completion. [Note: The bandwidth reservation work is in progress and
subject to change.]</p>
</div>
</div>
<div class="section" id="wireless-usb-host-controller-drivers">
<h2>Wireless USB Host Controller drivers<a class="headerlink" href="#wireless-usb-host-controller-drivers" title="Permalink to this headline">¶</a></h2>
<p><em>WARNING</em> This section needs a lot of work!</p>
<p>As explained above, there are three different types of HCs in the WUSB
world: HWA-HC, DWA-HC and WHCI-HC.</p>
<p>HWA-HC and DWA-HC share that they are Wire-Adapters (USB or WUSB
connected controllers), and their transfer management system is almost
identical. So is their notification delivery system.</p>
<p>HWA-HC and WHCI-HC share that they are both WUSB host controllers, so
they have to deal with WUSB device life cycle and maintenance, wireless
root-hub</p>
<p>HWA exposes a Host Controller interface (HWA-HC 0xe0/02/02). This has
three endpoints (Notifications, Data Transfer In and Data Transfer
Out–known as NEP, DTI and DTO in the code).</p>
<p>We reserve UWB bandwidth for our Wireless USB Cluster, create a Cluster
ID and tell the HC to use all that. Then we start it. This means the HC
starts sending MMCs.</p>
<blockquote>
<div><ul class="simple">
<li>The MMCs are blocks of data defined somewhere in the WUSB1.0 spec
that define a stream in the UWB channel time allocated for sending
WUSB IEs (host to device commands/notifications) and Device
Notifications (device initiated to host). Each host defines a
unique Wireless USB cluster through MMCs. Devices can connect to a
single cluster at the time. The IEs are Information Elements, and
among them are the bandwidth allocations that tell each device
when can they transmit or receive.</li>
</ul>
</div></blockquote>
<p>Now it all depends on external stimuli.</p>
<div class="section" id="new-device-connection">
<h3>New device connection<a class="headerlink" href="#new-device-connection" title="Permalink to this headline">¶</a></h3>
<p>A new device pops up, it scans the radio looking for MMCs that give out
the existence of Wireless USB channels. Once one (or more) are found,
selects which one to connect to. Sends a /DN_Connect/ (device
notification connect) during the DNTS (Device Notification Time
Slot–announced in the MMCs</p>
<p>HC picks the /DN_Connect/ out (nep module sends to notif.c for delivery
into /devconnect/). This process starts the authentication process for
the device. First we allocate a /fake port/ and assign an
unauthenticated address (128 to 255–what we really do is
0x80 | fake_port_idx). We fiddle with the fake port status and /hub_wq/
sees a new connection, so he moves on to enable the fake port with a reset.</p>
<p>So now we are in the reset path – we know we have a non-yet enumerated
device with an unauthorized address; we ask user space to authenticate
(FIXME: not yet done, similar to bluetooth pairing), then we do the key
exchange (FIXME: not yet done) and issue a /set address 0/ to bring the
device to the default state. Device is authenticated.</p>
<p>From here, the USB stack takes control through the usb_hcd ops. hub_wq
has seen the port status changes, as we have been toggling them. It will
start enumerating and doing transfers through usb_hcd-&gt;urb_enqueue() to
read descriptors and move our data.</p>
</div>
<div class="section" id="device-life-cycle-and-keep-alives">
<h3>Device life cycle and keep alives<a class="headerlink" href="#device-life-cycle-and-keep-alives" title="Permalink to this headline">¶</a></h3>
<p>Every time there is a successful transfer to/from a device, we update a
per-device activity timestamp. If not, every now and then we check and
if the activity timestamp gets old, we ping the device by sending it a
Keep Alive IE; it responds with a /DN_Alive/ pong during the DNTS (this
arrives to us as a notification through
devconnect.c:wusb_handle_dn_alive(). If a device times out, we
disconnect it from the system (cleaning up internal information and
toggling the bits in the fake hub port, which kicks hub_wq into removing
the rest of the stuff).</p>
<p>This is done through devconnect:__wusb_check_devs(), which will scan the
device list looking for whom needs refreshing.</p>
<p>If the device wants to disconnect, it will either die (ugly) or send a
/DN_Disconnect/ that will prompt a disconnection from the system.</p>
</div>
<div class="section" id="sending-and-receiving-data">
<h3>Sending and receiving data<a class="headerlink" href="#sending-and-receiving-data" title="Permalink to this headline">¶</a></h3>
<p>Data is sent and received through /Remote Pipes/ (rpipes). An rpipe is
/aimed/ at an endpoint in a WUSB device. This is the same for HWAs and
DWAs.</p>
<p>Each HC has a number of rpipes and buffers that can be assigned to them;
when doing a data transfer (xfer), first the rpipe has to be aimed and
prepared (buffers assigned), then we can start queueing requests for
data in or out.</p>
<p>Data buffers have to be segmented out before sending–so we send first a
header (segment request) and then if there is any data, a data buffer
immediately after to the DTI interface (yep, even the request). If our
buffer is bigger than the max segment size, then we just do multiple
requests.</p>
<p>[This sucks, because doing USB scatter gatter in Linux is resource
intensive, if any…not that the current approach is not. It just has to
be cleaned up a lot :)].</p>
<p>If reading, we don’t send data buffers, just the segment headers saying
we want to read segments.</p>
<p>When the xfer is executed, we receive a notification that says data is
ready in the DTI endpoint (handled through
xfer.c:wa_handle_notif_xfer()). In there we read from the DTI endpoint a
descriptor that gives us the status of the transfer, its identification
(given when we issued it) and the segment number. If it was a data read,
we issue another URB to read into the destination buffer the chunk of
data coming out of the remote endpoint. Done, wait for the next guy. The
callbacks for the URBs issued from here are the ones that will declare
the xfer complete at some point and call its callback.</p>
<p>Seems simple, but the implementation is not trivial.</p>
<blockquote>
<div><ul class="simple">
<li><em>WARNING</em> Old!!</li>
</ul>
</div></blockquote>
<p>The main xfer descriptor, wa_xfer (equivalent to a URB) contains an
array of segments, tallys on segments and buffers and callback
information. Buried in there is a lot of URBs for executing the segments
and buffer transfers.</p>
<p>For OUT xfers, there is an array of segments, one URB for each, another
one of buffer URB. When submitting, we submit URBs for segment request
1, buffer 1, segment 2, buffer 2…etc. Then we wait on the DTI for xfer
result data; when all the segments are complete, we call the callback to
finalize the transfer.</p>
<p>For IN xfers, we only issue URBs for the segments we want to read and
then wait for the xfer result data.</p>
<div class="section" id="urb-mapping-into-xfers">
<h4>URB mapping into xfers<a class="headerlink" href="#urb-mapping-into-xfers" title="Permalink to this headline">¶</a></h4>
<p>This is done by hwahc_op_urb_[en|de]queue(). In enqueue() we aim an
rpipe to the endpoint where we have to transmit, create a transfer
context (wa_xfer) and submit it. When the xfer is done, our callback is
called and we assign the status bits and release the xfer resources.</p>
<p>In dequeue() we are basically cancelling/aborting the transfer. We issue
a xfer abort request to the HC, cancel all the URBs we had submitted
and not yet done and when all that is done, the xfer callback will be
called–this will call the URB callback.</p>
</div>
</div>
</div>
<div class="section" id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<p><em>DWA</em> – Device Wire Adapter</p>
<p>USB host, wired for downstream devices, upstream connects wirelessly
with Wireless USB.</p>
<p><em>EVENT</em> – Response to a command on the NEEP</p>
<p><em>HWA</em> – Host Wire Adapter / USB dongle for UWB and Wireless USB</p>
<p><em>NEH</em> – Notification/Event Handle</p>
<p>Handle/file descriptor for receiving notifications or events. The WA
code requires you to get one of this to listen for notifications or
events on the NEEP.</p>
<p><em>NEEP</em> – Notification/Event EndPoint</p>
<p>Stuff related to the management of the first endpoint of a HWA USB
dongle that is used to deliver an stream of events and notifications to
the host.</p>
<p><em>NOTIFICATION</em> – Message coming in the NEEP as response to something.</p>
<p><em>RC</em> – Radio Control</p>
<p>Design-overview.txt-1.8 (last edited 2006-11-04 12:22:24 by
InakyPerezGonzalez)</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="usb-help.html" class="btn btn-neutral float-right" title="USB references" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="usb-serial.html" class="btn btn-neutral float-left" title="USB serial" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>