

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Error Detection And Correction (EDAC) Devices &mdash; The Linux Kernel 5.8.0-rc4+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SCSI Interfaces Guide" href="scsi.html" />
    <link rel="prev" title="High Speed Synchronous Serial Interface (HSI)" href="hsi.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0-rc4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Error Detection And Correction (EDAC) Devices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#main-concepts-used-at-the-edac-subsystem">Main Concepts used at the EDAC subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-controllers">Memory Controllers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pci-controllers">PCI Controllers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edac-blocks">EDAC Blocks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Error Detection And Correction (EDAC) Devices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/edac.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="error-detection-and-correction-edac-devices">
<h1>Error Detection And Correction (EDAC) Devices<a class="headerlink" href="#error-detection-and-correction-edac-devices" title="Permalink to this headline">¶</a></h1>
<div class="section" id="main-concepts-used-at-the-edac-subsystem">
<h2>Main Concepts used at the EDAC subsystem<a class="headerlink" href="#main-concepts-used-at-the-edac-subsystem" title="Permalink to this headline">¶</a></h2>
<p>There are several things to be aware of that aren’t at all obvious, like
<em>sockets, *socket sets</em>, <em>banks</em>, <em>rows</em>, <em>chip-select rows</em>, <em>channels</em>,
etc…</p>
<p>These are some of the many terms that are thrown about that don’t always
mean what people think they mean (Inconceivable!).  In the interest of
creating a common ground for discussion, terms and their definitions
will be established.</p>
<ul class="simple">
<li><p>Memory devices</p></li>
</ul>
<p>The individual DRAM chips on a memory stick.  These devices commonly
output 4 and 8 bits each (x4, x8). Grouping several of these in parallel
provides the number of bits that the memory controller expects:
typically 72 bits, in order to provide 64 bits + 8 bits of ECC data.</p>
<ul class="simple">
<li><p>Memory Stick</p></li>
</ul>
<p>A printed circuit board that aggregates multiple memory devices in
parallel.  In general, this is the Field Replaceable Unit (FRU) which
gets replaced, in the case of excessive errors. Most often it is also
called DIMM (Dual Inline Memory Module).</p>
<ul class="simple">
<li><p>Memory Socket</p></li>
</ul>
<p>A physical connector on the motherboard that accepts a single memory
stick. Also called as “slot” on several datasheets.</p>
<ul class="simple">
<li><p>Channel</p></li>
</ul>
<p>A memory controller channel, responsible to communicate with a group of
DIMMs. Each channel has its own independent control (command) and data
bus, and can be used independently or grouped with other channels.</p>
<ul class="simple">
<li><p>Branch</p></li>
</ul>
<p>It is typically the highest hierarchy on a Fully-Buffered DIMM memory
controller. Typically, it contains two channels. Two channels at the
same branch can be used in single mode or in lockstep mode. When
lockstep is enabled, the cacheline is doubled, but it generally brings
some performance penalty. Also, it is generally not possible to point to
just one memory stick when an error occurs, as the error correction code
is calculated using two DIMMs instead of one. Due to that, it is capable
of correcting more errors than on single mode.</p>
<ul class="simple">
<li><p>Single-channel</p></li>
</ul>
<p>The data accessed by the memory controller is contained into one dimm
only. E. g. if the data is 64 bits-wide, the data flows to the CPU using
one 64 bits parallel access. Typically used with SDR, DDR, DDR2 and DDR3
memories. FB-DIMM and RAMBUS use a different concept for channel, so
this concept doesn’t apply there.</p>
<ul class="simple">
<li><p>Double-channel</p></li>
</ul>
<p>The data size accessed by the memory controller is interlaced into two
dimms, accessed at the same time. E. g. if the DIMM is 64 bits-wide (72
bits with ECC), the data flows to the CPU using a 128 bits parallel
access.</p>
<ul class="simple">
<li><p>Chip-select row</p></li>
</ul>
<p>This is the name of the DRAM signal used to select the DRAM ranks to be
accessed. Common chip-select rows for single channel are 64 bits, for
dual channel 128 bits. It may not be visible by the memory controller,
as some DIMM types have a memory buffer that can hide direct access to
it from the Memory Controller.</p>
<ul class="simple">
<li><p>Single-Ranked stick</p></li>
</ul>
<p>A Single-ranked stick has 1 chip-select row of memory. Motherboards
commonly drive two chip-select pins to a memory stick. A single-ranked
stick, will occupy only one of those rows. The other will be unused.</p>
<ul class="simple" id="doubleranked">
<li><p>Double-Ranked stick</p></li>
</ul>
<p>A double-ranked stick has two chip-select rows which access different
sets of memory devices.  The two rows cannot be accessed concurrently.</p>
<ul class="simple">
<li><p>Double-sided stick</p></li>
</ul>
<p><strong>DEPRECATED TERM</strong>, see <a class="reference internal" href="#doubleranked"><span class="std std-ref">Double-Ranked stick</span></a>.</p>
<p>A double-sided stick has two chip-select rows which access different sets
of memory devices. The two rows cannot be accessed concurrently.
“Double-sided” is irrespective of the memory devices being mounted on
both sides of the memory stick.</p>
<ul class="simple">
<li><p>Socket set</p></li>
</ul>
<p>All of the memory sticks that are required for a single memory access or
all of the memory sticks spanned by a chip-select row.  A single socket
set has two chip-select rows and if double-sided sticks are used these
will occupy those chip-select rows.</p>
<ul class="simple">
<li><p>Bank</p></li>
</ul>
<p>This term is avoided because it is unclear when needing to distinguish
between chip-select rows and socket sets.</p>
</div>
<div class="section" id="memory-controllers">
<h2>Memory Controllers<a class="headerlink" href="#memory-controllers" title="Permalink to this headline">¶</a></h2>
<p>Most of the EDAC core is focused on doing Memory Controller error detection.
The <a class="reference internal" href="#c.edac_mc_alloc" title="edac_mc_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_mc_alloc()</span></code></a>. It uses internally the struct <code class="docutils literal notranslate"><span class="pre">mem_ctl_info</span></code>
to describe the memory controllers, with is an opaque struct for the EDAC
drivers. Only the EDAC core is allowed to touch it.</p>
<dl class="type">
<dt id="c.dev_type">
enum <code class="sig-name descname">dev_type</code><a class="headerlink" href="#c.dev_type" title="Permalink to this definition">¶</a></dt>
<dd><p>describe the type of memory DRAM chips used at the stick</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEV_UNKNOWN</span></code></dt><dd><p>Can’t be determined, or MC doesn’t support detect it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X1</span></code></dt><dd><p>1 bit for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X2</span></code></dt><dd><p>2 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X4</span></code></dt><dd><p>4 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X8</span></code></dt><dd><p>8 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X16</span></code></dt><dd><p>16 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X32</span></code></dt><dd><p>32 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X64</span></code></dt><dd><p>64 bits for data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Typical values are x4 and x8.</p>
<dl class="type">
<dt id="c.hw_event_mc_err_type">
enum <code class="sig-name descname">hw_event_mc_err_type</code><a class="headerlink" href="#c.hw_event_mc_err_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of the detected error</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_CORRECTED</span></code></dt><dd><p>Corrected Error - Indicates that an ECC
corrected error was detected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_UNCORRECTED</span></code></dt><dd><p>Uncorrected Error - Indicates an error that
can’t be corrected by ECC, but it is not
fatal (maybe it is on an unused memory area,
or the memory controller could recover from
it for example, by re-trying the operation).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_DEFERRED</span></code></dt><dd><p>Deferred Error - Indicates an uncorrectable
error whose handling is not urgent. This could
be due to hardware data poisoning where the
system can continue operation until the poisoned
data is consumed. Preemptive measures may also
be taken, e.g. offlining pages, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_FATAL</span></code></dt><dd><p>Fatal Error - Uncorrected error that could not
be recovered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_INFO</span></code></dt><dd><p>Informational - The CPER spec defines a forth
type of error: informational logs.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.mem_type">
enum <code class="sig-name descname">mem_type</code><a class="headerlink" href="#c.mem_type" title="Permalink to this definition">¶</a></dt>
<dd><p>memory types. For a more detailed reference, please see <a class="reference external" href="http://en.wikipedia.org/wiki/DRAM">http://en.wikipedia.org/wiki/DRAM</a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MEM_EMPTY</span></code></dt><dd><p>Empty csrow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RESERVED</span></code></dt><dd><p>Reserved csrow type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_UNKNOWN</span></code></dt><dd><p>Unknown csrow type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_FPM</span></code></dt><dd><p>FPM - Fast Page Mode, used on systems up to 1995.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_EDO</span></code></dt><dd><p>EDO - Extended data out, used on systems up to 1998.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_BEDO</span></code></dt><dd><p>BEDO - Burst Extended data out, an EDO variant.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_SDR</span></code></dt><dd><p>SDR - Single data rate SDRAM
<a class="reference external" href="http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory</a>
They use 3 pins for chip select: Pins 0 and 2 are
for rank 0; pins 1 and 3 are for rank 1, if the memory
is dual-rank.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDR</span></code></dt><dd><p>Registered SDR SDRAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR</span></code></dt><dd><p>Double data rate SDRAM
<a class="reference external" href="http://en.wikipedia.org/wiki/DDR_SDRAM">http://en.wikipedia.org/wiki/DDR_SDRAM</a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR</span></code></dt><dd><p>Registered Double data rate SDRAM
This is a variant of the DDR memories.
A registered memory has a buffer inside it, hiding
part of the memory details to the memory controller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RMBS</span></code></dt><dd><p>Rambus DRAM, used on a few Pentium III/IV controllers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR2</span></code></dt><dd><p>DDR2 RAM, as described at JEDEC JESD79-2F.
Those memories are labeled as “PC2-” instead of “PC” to
differentiate from DDR.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_FB_DDR2</span></code></dt><dd><p>Fully-Buffered DDR2, as described at JEDEC Std No. 205
and JESD206.
Those memories are accessed per DIMM slot, and not by
a chip select signal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR2</span></code></dt><dd><p>Registered DDR2 RAM
This is a variant of the DDR2 memories.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_XDR</span></code></dt><dd><p>Rambus XDR
It is an evolution of the original RAMBUS memories,
created to compete with DDR2. Weren’t used on any
x86 arch, but cell_edac PPC memory controller uses it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR3</span></code></dt><dd><p>DDR3 RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR3</span></code></dt><dd><p>Registered DDR3 RAM
This is a variant of the DDR3 memories.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LRDDR3</span></code></dt><dd><p>Load-Reduced DDR3 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR4</span></code></dt><dd><p>Unbuffered DDR4 RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR4</span></code></dt><dd><p>Registered DDR4 RAM
This is a variant of the DDR4 memories.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LRDDR4</span></code></dt><dd><p>Load-Reduced DDR4 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_NVDIMM</span></code></dt><dd><p>Non-volatile RAM</p>
</dd>
</dl>
<dl class="type">
<dt id="c.edac_type">
enum <code class="sig-name descname">edac_type</code><a class="headerlink" href="#c.edac_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type - Error Detection and Correction capabilities and mode</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_UNKNOWN</span></code></dt><dd><p>Unknown if ECC is available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_NONE</span></code></dt><dd><p>Doesn’t support ECC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_RESERVED</span></code></dt><dd><p>Reserved ECC type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_PARITY</span></code></dt><dd><p>Detects parity errors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_EC</span></code></dt><dd><p>Error Checking - no correction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_SECDED</span></code></dt><dd><p>Single bit error correction, Double detection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S2ECD2ED</span></code></dt><dd><p>Chipkill x2 devices - do these exist?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S4ECD4ED</span></code></dt><dd><p>Chipkill x4 devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S8ECD8ED</span></code></dt><dd><p>Chipkill x8 devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S16ECD16ED</span></code></dt><dd><p>Chipkill x16 devices</p>
</dd>
</dl>
<dl class="type">
<dt id="c.scrub_type">
enum <code class="sig-name descname">scrub_type</code><a class="headerlink" href="#c.scrub_type" title="Permalink to this definition">¶</a></dt>
<dd><p>scrubbing capabilities</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_UNKNOWN</span></code></dt><dd><p>Unknown if scrubber is available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_NONE</span></code></dt><dd><p>No scrubber</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_PROG</span></code></dt><dd><p>SW progressive (sequential) scrubbing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_SRC</span></code></dt><dd><p>Software scrub only errors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_PROG_SRC</span></code></dt><dd><p>Progressive software scrub from an error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_TUNABLE</span></code></dt><dd><p>Software scrub frequency is tunable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_PROG</span></code></dt><dd><p>HW progressive (sequential) scrubbing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_SRC</span></code></dt><dd><p>Hardware scrub only errors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_PROG_SRC</span></code></dt><dd><p>Progressive hardware scrub from an error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_TUNABLE</span></code></dt><dd><p>Hardware scrub frequency is tunable</p>
</dd>
</dl>
<dl class="type">
<dt id="c.edac_mc_layer_type">
enum <code class="sig-name descname">edac_mc_layer_type</code><a class="headerlink" href="#c.edac_mc_layer_type" title="Permalink to this definition">¶</a></dt>
<dd><p>memory controller hierarchy layer</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_BRANCH</span></code></dt><dd><p>memory layer is named “branch”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_CHANNEL</span></code></dt><dd><p>memory layer is named “channel”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_SLOT</span></code></dt><dd><p>memory layer is named “slot”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_CHIP_SELECT</span></code></dt><dd><p>memory layer is named “chip select”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_ALL_MEM</span></code></dt><dd><p>memory layout is unknown. All memory is mapped
as a single memory area. This is used when
retrieving errors from a firmware driven driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used by the drivers to tell edac_mc_sysfs what name should
be used when describing a memory stick location.</p>
<dl class="type">
<dt id="c.edac_mc_layer">
struct <code class="sig-name descname">edac_mc_layer</code><a class="headerlink" href="#c.edac_mc_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>describes the memory controller hierarchy</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct edac_mc_layer {
  enum edac_mc_layer_type type;
  unsigned size;
  bool is_virt_csrow;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>layer type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>number of components per layer. For example,
if the channel layer has two channels, size = 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_virt_csrow</span></code></dt><dd><p>This layer is part of the “csrow” when old API
compatibility mode is enabled. Otherwise, it is
a channel</p>
</dd>
</dl>
<dl class="type">
<dt id="c.rank_info">
struct <code class="sig-name descname">rank_info</code><a class="headerlink" href="#c.rank_info" title="Permalink to this definition">¶</a></dt>
<dd><p>contains the information for one DIMM rank</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rank_info {
  int chan_idx;
  struct csrow_info *csrow;
  struct dimm_info *dimm;
  u32 ce_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chan_idx</span></code></dt><dd><p>channel number where the rank is (typically, 0 or 1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csrow</span></code></dt><dd><p>A pointer to the chip select row structure (the parent
structure). The location of the rank is given by
the (csrow-&gt;csrow_idx, chan_idx) vector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dimm</span></code></dt><dd><p>A pointer to the DIMM structure, where the DIMM label
information is stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ce_count</span></code></dt><dd><p>number of correctable errors for this rank</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>FIXME: Currently, the EDAC core model will assume one DIMM per rank.</dt><dd><p>This is a bad assumption, but it makes this patch easier. Later
patches in this series will fix this issue.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.edac_raw_error_desc">
struct <code class="sig-name descname">edac_raw_error_desc</code><a class="headerlink" href="#c.edac_raw_error_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Raw error report structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct edac_raw_error_desc {
  char location[LOCATION_SIZE];
  char label[(EDAC_MC_LABEL_LEN + 1 + sizeof(OTHER_LABEL)) * EDAC_MAX_LABELS];
  long grain;
  u16 error_count;
  enum hw_event_mc_err_type type;
  int top_layer;
  int mid_layer;
  int low_layer;
  unsigned long page_frame_number;
  unsigned long offset_in_page;
  unsigned long syndrome;
  const char *msg;
  const char *other_detail;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">location</span></code></dt><dd><p>location of the error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code></dt><dd><p>label of the affected DIMM(s)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">grain</span></code></dt><dd><p>minimum granularity for an error report, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error_count</span></code></dt><dd><p>number of errors of the same type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>severity of the error (CE/UE/Fatal)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">top_layer</span></code></dt><dd><p>top layer of the error (layer[0])</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mid_layer</span></code></dt><dd><p>middle layer of the error (layer[1])</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">low_layer</span></code></dt><dd><p>low layer of the error (layer[2])</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_frame_number</span></code></dt><dd><p>page where the error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset_in_page</span></code></dt><dd><p>page offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">syndrome</span></code></dt><dd><p>syndrome of the error (or 0 if unknown or if
the syndrome is not applicable)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg</span></code></dt><dd><p>error message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">other_detail</span></code></dt><dd><p>other driver-specific detail about the error</p>
</dd>
</dl>
<dl class="function">
<dt id="c.edac_get_dimm_by_index">
struct dimm_info * <code class="sig-name descname">edac_get_dimm_by_index</code><span class="sig-paren">(</span>struct mem_ctl_info *<em> mci</em>, int<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_get_dimm_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Get DIMM info at <strong>index</strong> from a memory controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*</span> <span class="pre">mci</span></code></dt><dd><p>MC descriptor struct mem_ctl_info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index in the memory controller’s DIMM array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct dimm_info * or NULL on failure.</p>
<dl class="function">
<dt id="c.edac_get_dimm">
struct dimm_info * <code class="sig-name descname">edac_get_dimm</code><span class="sig-paren">(</span>struct mem_ctl_info *<em> mci</em>, int<em> layer0</em>, int<em> layer1</em>, int<em> layer2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_get_dimm" title="Permalink to this definition">¶</a></dt>
<dd><p>Get DIMM info from a memory controller given by [layer0,layer1,layer2] position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*</span> <span class="pre">mci</span></code></dt><dd><p>MC descriptor struct mem_ctl_info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">layer0</span></code></dt><dd><p>layer0 position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">layer1</span></code></dt><dd><p>layer1 position. Unused if n_layers &lt; 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">layer2</span></code></dt><dd><p>layer2 position. Unused if n_layers &lt; 3</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For 1 layer, this function returns “dimms[layer0]”;</p>
<p>For 2 layers, this function is similar to allocating a two-dimensional
array and returning “dimms[layer0][layer1]”;</p>
<p>For 3 layers, this function is similar to allocating a tri-dimensional
array and returning “dimms[layer0][layer1][layer2]”;</p>
<dl class="function">
<dt id="c.edac_mc_alloc">
struct mem_ctl_info * <code class="sig-name descname">edac_mc_alloc</code><span class="sig-paren">(</span>unsigned int<em> mc_num</em>, unsigned int<em> n_layers</em>, struct <a class="reference internal" href="#c.edac_mc_layer" title="edac_mc_layer">edac_mc_layer</a> *<em> layers</em>, unsigned int<em> sz_pvt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and partially fill a struct <code class="xref c c-type docutils literal notranslate"><span class="pre">mem_ctl_info</span></code>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mc_num</span></code></dt><dd><p>Memory controller number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n_layers</span></code></dt><dd><p>Number of MC hierarchy layers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_mc_layer</span> <span class="pre">*</span> <span class="pre">layers</span></code></dt><dd><p>Describes each layer as seen by the Memory Controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz_pvt</span></code></dt><dd><p>size of private storage needed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Everything is kmalloc’ed as one big chunk - more efficient.
Only can be used if all structures have the same lifetime - otherwise
you have to allocate and initialize your own structures.</p>
<p>Use <a class="reference internal" href="#c.edac_mc_free" title="edac_mc_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_mc_free()</span></code></a> to free mc structures allocated by this function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>drivers handle multi-rank memories in different ways: in some
drivers, one multi-rank memory stick is mapped as one entry, while, in
others, a single multi-rank memory stick would be mapped into several
entries. Currently, this function will allocate multiple struct dimm_info
on such scenarios, as grouping the multiple ranks require drivers change.</p>
</div>
<p><strong>Return</strong></p>
<blockquote>
<div><p>On success, return a pointer to struct mem_ctl_info pointer;
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise</p>
</div></blockquote>
<dl class="function">
<dt id="c.edac_get_owner">
const char * <code class="sig-name descname">edac_get_owner</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_get_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the owner’s mod_name of EDAC MC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to mod_name string when EDAC MC is owned. NULL otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.edac_mc_free">
void <code class="sig-name descname">edac_mc_free</code><span class="sig-paren">(</span>struct mem_ctl_info *<em> mci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees a previously allocated <strong>mci</strong> structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*</span> <span class="pre">mci</span></code></dt><dd><p>pointer to a struct mem_ctl_info structure</p>
</dd>
</dl>
<dl class="function">
<dt id="c.edac_has_mcs">
bool <code class="sig-name descname">edac_has_mcs</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_has_mcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if any MCs have been allocated.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>True if MC instances have been registered successfully.
False otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.edac_mc_find">
struct mem_ctl_info * <code class="sig-name descname">edac_mc_find</code><span class="sig-paren">(</span>int<em> idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_find" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for a mem_ctl_info structure whose index is <strong>idx</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>index to be seek</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If found, return a pointer to the structure.
Else return NULL.</p>
<dl class="function">
<dt id="c.find_mci_by_dev">
struct mem_ctl_info * <code class="sig-name descname">find_mci_by_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_mci_by_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan list of controllers looking for the one that manages the <strong>dev</strong> device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>pointer to a struct device related with the MCI</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>on success, returns a pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">mem_ctl_info</span></code>;
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.edac_mc_del_mc">
struct mem_ctl_info * <code class="sig-name descname">edac_mc_del_mc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_del_mc" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove sysfs entries for mci structure associated with <strong>dev</strong> and remove mci structure from global list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a> representing mci structure to remove.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>pointer to removed mci structure, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if device not found.</p>
<dl class="function">
<dt id="c.edac_mc_find_csrow_by_page">
int <code class="sig-name descname">edac_mc_find_csrow_by_page</code><span class="sig-paren">(</span>struct mem_ctl_info *<em> mci</em>, unsigned long<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_find_csrow_by_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Ancillary routine to identify what csrow contains a memory page.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*</span> <span class="pre">mci</span></code></dt><dd><p>pointer to a struct mem_ctl_info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page</span></code></dt><dd><p>memory page to find</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>on success, returns the csrow. -1 if not found.</p>
<dl class="function">
<dt id="c.edac_raw_mc_handle_error">
void <code class="sig-name descname">edac_raw_mc_handle_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.edac_raw_error_desc" title="edac_raw_error_desc">edac_raw_error_desc</a> *<em> e</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_raw_mc_handle_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports a memory event to userspace without doing anything to discover the error location.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_raw_error_desc</span> <span class="pre">*</span> <span class="pre">e</span></code></dt><dd><p>error description</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This raw function is used internally by <a class="reference internal" href="#c.edac_mc_handle_error" title="edac_mc_handle_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_mc_handle_error()</span></code></a>. It should
only be called directly when the hardware error come directly from BIOS,
like in the case of APEI GHES driver.</p>
<dl class="function">
<dt id="c.edac_mc_handle_error">
void <code class="sig-name descname">edac_mc_handle_error</code><span class="sig-paren">(</span>const enum <a class="reference internal" href="#c.hw_event_mc_err_type" title="hw_event_mc_err_type">hw_event_mc_err_type</a><em> type</em>, struct mem_ctl_info *<em> mci</em>, const u16<em> error_count</em>, const unsigned long<em> page_frame_number</em>, const unsigned long<em> offset_in_page</em>, const unsigned long<em> syndrome</em>, const int<em> top_layer</em>, const int<em> mid_layer</em>, const int<em> low_layer</em>, const char *<em> msg</em>, const char *<em> other_detail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_handle_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports a memory event to userspace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hw_event_mc_err_type</span> <span class="pre">type</span></code></dt><dd><p>severity of the error (CE/UE/Fatal)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*</span> <span class="pre">mci</span></code></dt><dd><p>a struct mem_ctl_info pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">error_count</span></code></dt><dd><p>Number of errors of the same type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_frame_number</span></code></dt><dd><p>mem page where the error occurred</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">offset_in_page</span></code></dt><dd><p>offset of the error inside the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">syndrome</span></code></dt><dd><p>ECC syndrome</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">top_layer</span></code></dt><dd><p>Memory layer[0] position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">mid_layer</span></code></dt><dd><p>Memory layer[1] position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">low_layer</span></code></dt><dd><p>Memory layer[2] position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>Message meaningful to the end users that
explains the event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">other_detail</span></code></dt><dd><p>Technical details about the event that
may help hardware manufacturers and
EDAC developers to analyse the event</p>
</dd>
</dl>
</div>
<div class="section" id="pci-controllers">
<h2>PCI Controllers<a class="headerlink" href="#pci-controllers" title="Permalink to this headline">¶</a></h2>
<p>The EDAC subsystem provides a mechanism to handle PCI controllers by calling
the <a class="reference internal" href="#c.edac_pci_alloc_ctl_info" title="edac_pci_alloc_ctl_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_pci_alloc_ctl_info()</span></code></a>. It will use the struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code> to describe the PCI controllers.</p>
<dl class="function">
<dt id="c.edac_pci_alloc_ctl_info">
struct edac_pci_ctl_info * <code class="sig-name descname">edac_pci_alloc_ctl_info</code><span class="sig-paren">(</span>unsigned int<em> sz_pvt</em>, const char *<em> edac_pci_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_alloc_ctl_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz_pvt</span></code></dt><dd><p>size of the private info at struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">edac_pci_name</span></code></dt><dd><p>name of the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The alloc() function for the ‘edac_pci’ control info
structure.</p>
</div></blockquote>
<p>The chip driver will allocate one of these for each
edac_pci it is going to control/register with the EDAC CORE.</p>
<p><strong>Return</strong></p>
<p>a pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code> on success; <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.edac_pci_free_ctl_info">
void <code class="sig-name descname">edac_pci_free_ctl_info</code><span class="sig-paren">(</span>struct edac_pci_ctl_info *<em> pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_free_ctl_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*</span> <span class="pre">pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Last action on the pci control structure.</p>
</div></blockquote>
<p>Calls the remove sysfs information, which will unregister
this control struct’s kobj. When that kobj’s ref count
goes to zero, its release function will be call and then
<a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> the memory.</p>
<dl class="function">
<dt id="c.edac_pci_alloc_index">
int <code class="sig-name descname">edac_pci_alloc_index</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_alloc_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>allocated index number</p>
</div></blockquote>
<dl class="function">
<dt id="c.edac_pci_add_device">
int <code class="sig-name descname">edac_pci_add_device</code><span class="sig-paren">(</span>struct edac_pci_ctl_info *<em> pci</em>, int<em> edac_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_add_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*</span> <span class="pre">pci</span></code></dt><dd><p>pointer to the edac_device structure to be added to the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">edac_idx</span></code></dt><dd><p>A unique numeric identifier to be assigned to the
‘edac_pci’ structure.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>edac_pci global list and create sysfs entries associated with
edac_pci structure.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on Success, or an error code on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.edac_pci_del_device">
struct edac_pci_ctl_info * <code class="sig-name descname">edac_pci_del_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_del_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Pointer to ‘struct device’ representing edac_pci structure
to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove sysfs entries for specified edac_pci structure and
then remove edac_pci structure from global list</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to removed edac_pci structure,
or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if device not found</p>
</div></blockquote>
<dl class="function">
<dt id="c.edac_pci_create_generic_ctl">
struct edac_pci_ctl_info * <code class="sig-name descname">edac_pci_create_generic_ctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_create_generic_ctl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a>;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">mod_name</span></code></dt><dd><p>name of the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>A generic constructor for a PCI parity polling device
Some systems have more than one domain of PCI busses.
For systems with one domain, then this API will
provide for a generic poller.</p>
</div></blockquote>
<p>This routine calls the <a class="reference internal" href="#c.edac_pci_alloc_ctl_info" title="edac_pci_alloc_ctl_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_pci_alloc_ctl_info()</span></code></a> for
the generic device, with default values</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code> on success, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on</dt><dd><p>failure.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.edac_pci_release_generic_ctl">
void <code class="sig-name descname">edac_pci_release_generic_ctl</code><span class="sig-paren">(</span>struct edac_pci_ctl_info *<em> pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_release_generic_ctl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*</span> <span class="pre">pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The release function of a generic EDAC PCI polling device</p>
</div></blockquote>
<dl class="function">
<dt id="c.edac_pci_create_sysfs">
int <code class="sig-name descname">edac_pci_create_sysfs</code><span class="sig-paren">(</span>struct edac_pci_ctl_info *<em> pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_create_sysfs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*</span> <span class="pre">pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Create the controls/attributes for the specified EDAC PCI device</p>
</div></blockquote>
<dl class="function">
<dt id="c.edac_pci_remove_sysfs">
void <code class="sig-name descname">edac_pci_remove_sysfs</code><span class="sig-paren">(</span>struct edac_pci_ctl_info *<em> pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_remove_sysfs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*</span> <span class="pre">pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>remove the controls and attributes for this EDAC PCI device</p>
</div></blockquote>
</div>
<div class="section" id="edac-blocks">
<h2>EDAC Blocks<a class="headerlink" href="#edac-blocks" title="Permalink to this headline">¶</a></h2>
<p>The EDAC subsystem also provides a generic mechanism to report errors on
other parts of the hardware via <code class="xref c c-func docutils literal notranslate"><span class="pre">edac_device_alloc_ctl_info()</span></code> function.</p>
<p>The structures <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_dev_sysfs_block_attribute</span></code>,
<code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_block</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_instance</span></code> and
<code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code> provide a generic or abstract ‘edac_device’
representation at sysfs.</p>
<p>This set of structures and the code that implements the APIs for the same, provide for registering EDAC type devices which are NOT standard memory or
PCI, like:</p>
<ul class="simple">
<li><p>CPU caches (L1 and L2)</p></li>
<li><p>DMA engines</p></li>
<li><p>Core CPU switches</p></li>
<li><p>Fabric switch units</p></li>
<li><p>PCIe interface controllers</p></li>
<li><p>other EDAC/ECC type devices that can be monitored for
errors, etc.</p></li>
</ul>
<p>It allows for a 2 level set of hierarchy.</p>
<p>For example, a cache could be composed of L1, L2 and L3 levels of cache.
Each CPU core would have its own L1 cache, while sharing L2 and maybe L3
caches. On such case, those can be represented via the following sysfs
nodes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/edac/..

pci/            &lt;existing pci directory (if available)&gt;
mc/             &lt;existing memory device directory&gt;
cpu/cpu0/..     &lt;L1 and L2 block directory&gt;
        /L1-cache/ce_count
                 /ue_count
        /L2-cache/ce_count
                 /ue_count
cpu/cpu1/..     &lt;L1 and L2 block directory&gt;
        /L1-cache/ce_count
                 /ue_count
        /L2-cache/ce_count
                 /ue_count
...

the L1 and L2 directories would be &quot;edac_device_block&#39;s&quot;
</pre></div>
</div>
<dl class="function">
<dt id="c.edac_device_add_device">
int <code class="sig-name descname">edac_device_add_device</code><span class="sig-paren">(</span>struct edac_device_ctl_info *<em> edac_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_add_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*</span> <span class="pre">edac_dev</span></code></dt><dd><p>pointer to edac_device structure to be added to the list
‘edac_device’ structure.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>edac_device global list and create sysfs entries associated with
edac_device structure.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on Success, or an error code on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.edac_device_del_device">
struct edac_device_ctl_info * <code class="sig-name descname">edac_device_del_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_del_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a> representing the edac device
structure to remove.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove sysfs entries for specified edac_device structure and
then remove edac_device structure from global list</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to removed edac_device structure,
or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if device not found.</p>
</div></blockquote>
<dl class="function">
<dt id="c.edac_device_handle_ce_count">
void <code class="sig-name descname">edac_device_handle_ce_count</code><span class="sig-paren">(</span>struct edac_device_ctl_info *<em> edac_dev</em>, unsigned int<em> count</em>, int<em> inst_nr</em>, int<em> block_nr</em>, const char *<em> msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ce_count" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*</span> <span class="pre">edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of errors to log.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
<dl class="function">
<dt id="c.edac_device_handle_ue_count">
void <code class="sig-name descname">edac_device_handle_ue_count</code><span class="sig-paren">(</span>struct edac_device_ctl_info *<em> edac_dev</em>, unsigned int<em> count</em>, int<em> inst_nr</em>, int<em> block_nr</em>, const char *<em> msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ue_count" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*</span> <span class="pre">edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of errors to log.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
<dl class="function">
<dt id="c.edac_device_handle_ce">
void <code class="sig-name descname">edac_device_handle_ce</code><span class="sig-paren">(</span>struct edac_device_ctl_info *<em> edac_dev</em>, int<em> inst_nr</em>, int<em> block_nr</em>, const char *<em> msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*</span> <span class="pre">edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
<dl class="function">
<dt id="c.edac_device_handle_ue">
void <code class="sig-name descname">edac_device_handle_ue</code><span class="sig-paren">(</span>struct edac_device_ctl_info *<em> edac_dev</em>, int<em> inst_nr</em>, int<em> block_nr</em>, const char *<em> msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*</span> <span class="pre">edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the UE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the UE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
<dl class="function">
<dt id="c.edac_device_alloc_index">
int <code class="sig-name descname">edac_device_alloc_index</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_alloc_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>allocated index number</p>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="scsi.html" class="btn btn-neutral float-right" title="SCSI Interfaces Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="hsi.html" class="btn btn-neutral float-left" title="High Speed Synchronous Serial Interface (HSI)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>