

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>VME Device Drivers &mdash; The Linux Kernel 4.10.0-rc8+ documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 4.10.0-rc8+ documentation" href="../index.html"/>
        <link rel="up" title="The Linux driver implementer’s API guide" href="index.html"/>
        <link rel="next" title="Linux 802.11 Driver Developer’s Guide" href="80211/index.html"/>
        <link rel="prev" title="Parallel Port Devices" href="miscellaneous.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.10.0-rc8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb.html">The Linux-USB Host Side API</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">VME Device Drivers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#driver-registration">Driver registration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resource-management">Resource management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#master-windows">Master windows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#master-window-configuration">Master window configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#master-window-access">Master window access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#slave-windows">Slave windows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#slave-window-configuration">Slave window configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slave-window-buffer-allocation">Slave window buffer allocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slave-window-access">Slave window access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dma-channels">DMA channels</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#list-management">List Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-population">List Population</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transfer-attributes">Transfer Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-execution">List Execution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interrupts">Interrupts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#attaching-interrupt-handlers">Attaching Interrupt Handlers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-generation">Interrupt Generation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#location-monitors">Location monitors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#location-monitor-management">Location Monitor Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#location-monitor-configuration">Location Monitor Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#location-monitor-use">Location Monitor Use</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#slot-detection">Slot Detection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bus-detection">Bus Detection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer&#8217;s Guide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
      
    <li>VME Device Drivers</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/driver-api/vme.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="vme-device-drivers">
<h1>VME Device Drivers<a class="headerlink" href="#vme-device-drivers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="driver-registration">
<h2>Driver registration<a class="headerlink" href="#driver-registration" title="Permalink to this headline">¶</a></h2>
<p>As with other subsystems within the Linux kernel, VME device drivers register
with the VME subsystem, typically called from the devices init routine.  This is
achieved via a call to the following function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_register_driver</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vme_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndevs</span><span class="p">);</span>
</pre></div>
</div>
<p>If driver registration is successful this function returns zero, if an error
occurred a negative error code will be returned.</p>
<p>A pointer to a structure of type &#8216;vme_driver&#8217; must be provided to the
registration function. Along with ndevs, which is the number of devices your
driver is able to support. The structure is as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">vme_driver</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">device_driver</span> <span class="n">driver</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">devices</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndev</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>At the minimum, the &#8216;.name&#8217;, &#8216;.match&#8217; and &#8216;.probe&#8217; elements of this structure
should be correctly set. The &#8216;.name&#8217; element is a pointer to a string holding
the device driver&#8217;s name.</p>
<p>The &#8216;.match&#8217; function allows control over which VME devices should be registered
with the driver. The match function should return 1 if a device should be
probed and 0 otherwise. This example match function (from vme_user.c) limits
the number of devices probed to one:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define USER_BUS_MAX    1</span>
<span class="p">...</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vme_user_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">USER_BUS_MAX</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The &#8216;.probe&#8217; element should contain a pointer to the probe routine. The
probe routine is passed a &#8216;struct vme_dev&#8217; pointer as an argument. The
&#8216;struct vme_dev&#8217; structure looks like the following:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">vme_bridge</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">drv_list</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">bridge_list</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here, the &#8216;num&#8217; field refers to the sequential device ID for this specific
driver. The bridge number (or bus number) can be accessed using
dev-&gt;bridge-&gt;num.</p>
<p>A function is also provided to unregister the driver from the VME core and is
usually called from the device driver&#8217;s exit routine:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">vme_unregister_driver</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vme_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="resource-management">
<h2>Resource management<a class="headerlink" href="#resource-management" title="Permalink to this headline">¶</a></h2>
<p>Once a driver has registered with the VME core the provided match routine will
be called the number of times specified during the registration. If a match
succeeds, a non-zero value should be returned. A zero return value indicates
failure. For all successful matches, the probe routine of the corresponding
driver is called. The probe routine is passed a pointer to the devices
device structure. This pointer should be saved, it will be required for
requesting VME resources.</p>
<p>The driver can request ownership of one or more master windows, slave windows
and/or dma channels. Rather than allowing the device driver to request a
specific window or DMA channel (which may be used by a different driver) this
driver allows a resource to be assigned based on the required attributes of the
driver in question:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span> <span class="nf">vme_master_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
        <span class="n">u32</span> <span class="n">aspace</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">width</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span> <span class="nf">vme_slave_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">aspace</span><span class="p">,</span>
        <span class="n">u32</span> <span class="n">cycle</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="nf">vme_dma_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">route</span><span class="p">);</span>
</pre></div>
</div>
<p>For slave windows these attributes are split into the VME address spaces that
need to be accessed in &#8216;aspace&#8217; and VME bus cycle types required in &#8216;cycle&#8217;.
Master windows add a further set of attributes in &#8216;width&#8217; specifying the
required data transfer widths. These attributes are defined as bitmasks and as
such any combination of the attributes can be requested for a single window,
the core will assign a window that meets the requirements, returning a pointer
of type vme_resource that should be used to identify the allocated resource
when it is used. For DMA controllers, the request function requires the
potential direction of any transfers to be provided in the route attributes.
This is typically VME-to-MEM and/or MEM-to-VME, though some hardware can
support VME-to-VME and MEM-to-MEM transfers as well as test pattern generation.
If an unallocated window fitting the requirements can not be found a NULL
pointer will be returned.</p>
<p>Functions are also provided to free window allocations once they are no longer
required. These functions should be passed the pointer to the resource provided
during resource allocation:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">vme_master_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vme_slave_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vme_dma_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="master-windows">
<h2>Master windows<a class="headerlink" href="#master-windows" title="Permalink to this headline">¶</a></h2>
<p>Master windows provide access from the local processor[s] out onto the VME bus.
The number of windows available and the available access modes is dependent on
the underlying chipset. A window must be configured before it can be used.</p>
<div class="section" id="master-window-configuration">
<h3>Master window configuration<a class="headerlink" href="#master-window-configuration" title="Permalink to this headline">¶</a></h3>
<p>Once a master window has been assigned the following functions can be used to
configure it and retrieve the current settings:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_master_set</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enabled</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">aspace</span><span class="p">,</span>
        <span class="n">u32</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">width</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vme_master_get</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">enabled</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">aspace</span><span class="p">,</span>
        <span class="n">u32</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">width</span><span class="p">);</span>
</pre></div>
</div>
<p>The address spaces, transfer widths and cycle types are the same as described
under resource management, however some of the options are mutually exclusive.
For example, only one address space may be specified.</p>
<p>These functions return 0 on success or an error code should the call fail.</p>
</div>
<div class="section" id="master-window-access">
<h3>Master window access<a class="headerlink" href="#master-window-access" title="Permalink to this headline">¶</a></h3>
<p>The following functions can be used to read from and write to configured master
windows. These functions return the number of bytes copied:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">ssize_t</span> <span class="nf">vme_master_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">);</span>

<span class="kt">ssize_t</span> <span class="nf">vme_master_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>
</div>
<p>In addition to simple reads and writes, a function is provided to do a
read-modify-write transaction. This function returns the original value of the
VME bus location :</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">vme_master_rmw</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">swap</span><span class="p">,</span>
        <span class="n">loff_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>
</div>
<p>This functions by reading the offset, applying the mask. If the bits selected in
the mask match with the values of the corresponding bits in the compare field,
the value of swap is written the specified offset.</p>
<p>Parts of a VME window can be mapped into user space memory using the following
function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">vme_master_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">resource</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="slave-windows">
<h2>Slave windows<a class="headerlink" href="#slave-windows" title="Permalink to this headline">¶</a></h2>
<p>Slave windows provide devices on the VME bus access into mapped portions of the
local memory. The number of windows available and the access modes that can be
used is dependent on the underlying chipset. A window must be configured before
it can be used.</p>
<div class="section" id="slave-window-configuration">
<h3>Slave window configuration<a class="headerlink" href="#slave-window-configuration" title="Permalink to this headline">¶</a></h3>
<p>Once a slave window has been assigned the following functions can be used to
configure it and retrieve the current settings:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_slave_set</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enabled</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
        <span class="n">dma_addr_t</span> <span class="n">mem</span><span class="p">,</span> <span class="n">u32</span> <span class="n">aspace</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cycle</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vme_slave_get</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">enabled</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span>
        <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">aspace</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cycle</span><span class="p">);</span>
</pre></div>
</div>
<p>The address spaces, transfer widths and cycle types are the same as described
under resource management, however some of the options are mutually exclusive.
For example, only one address space may be specified.</p>
<p>These functions return 0 on success or an error code should the call fail.</p>
</div>
<div class="section" id="slave-window-buffer-allocation">
<h3>Slave window buffer allocation<a class="headerlink" href="#slave-window-buffer-allocation" title="Permalink to this headline">¶</a></h3>
<p>Functions are provided to allow the user to allocate and free a contiguous
buffers which will be accessible by the VME bridge. These functions do not have
to be used, other methods can be used to allocate a buffer, though care must be
taken to ensure that they are contiguous and accessible by the VME bridge:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span> <span class="nf">vme_alloc_consistent</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
        <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vme_free_consistent</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">,</span>     <span class="n">dma_addr_t</span> <span class="n">mem</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="slave-window-access">
<h3>Slave window access<a class="headerlink" href="#slave-window-access" title="Permalink to this headline">¶</a></h3>
<p>Slave windows map local memory onto the VME bus, the standard methods for
accessing memory should be used.</p>
</div>
</div>
<div class="section" id="dma-channels">
<h2>DMA channels<a class="headerlink" href="#dma-channels" title="Permalink to this headline">¶</a></h2>
<p>The VME DMA transfer provides the ability to run link-list DMA transfers. The
API introduces the concept of DMA lists. Each DMA list is a link-list which can
be passed to a DMA controller. Multiple lists can be created, extended,
executed, reused and destroyed.</p>
<div class="section" id="list-management">
<h3>List Management<a class="headerlink" href="#list-management" title="Permalink to this headline">¶</a></h3>
<p>The following functions are provided to create and destroy DMA lists. Execution
of a list will not automatically destroy the list, thus enabling a list to be
reused for repetitive tasks:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">vme_dma_list</span> <span class="o">*</span><span class="nf">vme_new_dma_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vme_dma_list_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dma_list</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="list-population">
<h3>List Population<a class="headerlink" href="#list-population" title="Permalink to this headline">¶</a></h3>
<p>An item can be added to a list using the following function ( the source and
destination attributes need to be created before calling this function, this is
covered under &#8220;Transfer Attributes&#8221;):</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_dma_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dma_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">vme_dma_attr</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vme_dma_attr</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The detailed attributes of the transfers source and destination
are not checked until an entry is added to a DMA list, the request
for a DMA channel purely checks the directions in which the
controller is expected to transfer data. As a result it is
possible for this call to return an error, for example if the
source or destination is in an unsupported VME address space.</p>
</div>
</div>
<div class="section" id="transfer-attributes">
<h3>Transfer Attributes<a class="headerlink" href="#transfer-attributes" title="Permalink to this headline">¶</a></h3>
<p>The attributes for the source and destination are handled separately from adding
an item to a list. This is due to the diverse attributes required for each type
of source and destination. There are functions to create attributes for PCI, VME
and pattern sources and destinations (where appropriate):</p>
<p>Pattern source:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">vme_dma_attr</span> <span class="o">*</span><span class="nf">vme_dma_pattern_attribute</span><span class="p">(</span><span class="n">u32</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">u32</span> <span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
<p>PCI source or destination:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">vme_dma_attr</span> <span class="o">*</span><span class="nf">vme_dma_pci_attribute</span><span class="p">(</span><span class="n">dma_addr_t</span> <span class="n">mem</span><span class="p">);</span>
</pre></div>
</div>
<p>VME source or destination:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">vme_dma_attr</span> <span class="o">*</span><span class="nf">vme_dma_vme_attribute</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span>
        <span class="n">u32</span> <span class="n">aspace</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">width</span><span class="p">);</span>
</pre></div>
</div>
<p>The following function should be used to free an attribute:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">vme_dma_free_attribute</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dma_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="list-execution">
<h3>List Execution<a class="headerlink" href="#list-execution" title="Permalink to this headline">¶</a></h3>
<p>The following function queues a list for execution. The function will return
once the list has been executed:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_dma_list_exec</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dma_list</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="interrupts">
<h2>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">¶</a></h2>
<p>The VME API provides functions to attach and detach callbacks to specific VME
level and status ID combinations and for the generation of VME interrupts with
specific VME level and status IDs.</p>
<div class="section" id="attaching-interrupt-handlers">
<h3>Attaching Interrupt Handlers<a class="headerlink" href="#attaching-interrupt-handlers" title="Permalink to this headline">¶</a></h3>
<p>The following functions can be used to attach and free a specific VME level and
status ID combination. Any given combination can only be assigned a single
callback function. A void pointer parameter is provided, the value of which is
passed to the callback function, the use of this pointer is user undefined:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_irq_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">statid</span><span class="p">,</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vme_irq_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">statid</span><span class="p">);</span>
</pre></div>
</div>
<p>The callback parameters are as follows. Care must be taken in writing a callback
function, callback functions run in interrupt context:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">statid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="interrupt-generation">
<h3>Interrupt Generation<a class="headerlink" href="#interrupt-generation" title="Permalink to this headline">¶</a></h3>
<p>The following function can be used to generate a VME interrupt at a given VME
level and VME status ID:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_irq_generate</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">statid</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="location-monitors">
<h2>Location monitors<a class="headerlink" href="#location-monitors" title="Permalink to this headline">¶</a></h2>
<p>The VME API provides the following functionality to configure the location
monitor.</p>
<div class="section" id="location-monitor-management">
<h3>Location Monitor Management<a class="headerlink" href="#location-monitor-management" title="Permalink to this headline">¶</a></h3>
<p>The following functions are provided to request the use of a block of location
monitors and to free them after they are no longer required:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span> <span class="nf">vme_lm_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vme_lm_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span> <span class="n">res</span><span class="p">);</span>
</pre></div>
</div>
<p>Each block may provide a number of location monitors, monitoring adjacent
locations. The following function can be used to determine how many locations
are provided:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_lm_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span> <span class="n">res</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="location-monitor-configuration">
<h3>Location Monitor Configuration<a class="headerlink" href="#location-monitor-configuration" title="Permalink to this headline">¶</a></h3>
<p>Once a bank of location monitors has been allocated, the following functions
are provided to configure the location and mode of the location monitor:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_lm_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span>
        <span class="n">u32</span> <span class="n">aspace</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cycle</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vme_lm_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
        <span class="n">u32</span> <span class="o">*</span><span class="n">aspace</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">cycle</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="location-monitor-use">
<h3>Location Monitor Use<a class="headerlink" href="#location-monitor-use" title="Permalink to this headline">¶</a></h3>
<p>The following functions allow a callback to be attached and detached from each
location monitor location. Each location monitor can monitor a number of
adjacent locations:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_lm_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

<span class="kt">int</span> <span class="nf">vme_lm_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</pre></div>
</div>
<p>The callback function is declared as follows.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="slot-detection">
<h2>Slot Detection<a class="headerlink" href="#slot-detection" title="Permalink to this headline">¶</a></h2>
<p>This function returns the slot ID of the provided bridge.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_slot_num</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="bus-detection">
<h2>Bus Detection<a class="headerlink" href="#bus-detection" title="Permalink to this headline">¶</a></h2>
<p>This function returns the bus ID of the provided bridge.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">vme_bus_num</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="80211/index.html" class="btn btn-neutral float-right" title="Linux 802.11 Driver Developer’s Guide" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="miscellaneous.html" class="btn btn-neutral" title="Parallel Port Devices" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.10.0-rc8+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>