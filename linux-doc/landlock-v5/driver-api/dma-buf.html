

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Buffer Sharing and Synchronization &mdash; The Linux Kernel 4.10.0-rc8+ documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 4.10.0-rc8+ documentation" href="../index.html"/>
        <link rel="up" title="The Linux driver implementer’s API guide" href="index.html"/>
        <link rel="next" title="Device links" href="device_link.html"/>
        <link rel="prev" title="Device drivers infrastructure" href="infrastructure.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.10.0-rc8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Buffer Sharing and Synchronization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#shared-dma-buffers">Shared DMA Buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reservation-objects">Reservation Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dma-fences">DMA Fences</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#seqno-hardware-fences">Seqno Hardware Fences</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-fence-array">DMA Fence Array</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-fence-uabi-sync-file">DMA Fence uABI/Sync File</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb.html">The Linux-USB Host Side API</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer&#8217;s Guide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
      
    <li>Buffer Sharing and Synchronization</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/driver-api/dma-buf.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="buffer-sharing-and-synchronization">
<h1>Buffer Sharing and Synchronization<a class="headerlink" href="#buffer-sharing-and-synchronization" title="Permalink to this headline">¶</a></h1>
<p>The dma-buf subsystem provides the framework for sharing buffers for
hardware (DMA) access across multiple device drivers and subsystems, and
for synchronizing asynchronous hardware access.</p>
<p>This is used, for example, by drm &#8220;prime&#8221; multi-GPU support, but is of
course not limited to GPU use cases.</p>
<p>The three main components of this are: (1) dma-buf, representing a
sg_table and exposed to userspace as a file descriptor to allow passing
between devices, (2) fence, which provides a mechanism to signal when
one device as finished access, and (3) reservation, which manages the
shared or exclusive fence(s) associated with the buffer.</p>
<div class="section" id="shared-dma-buffers">
<h2>Shared DMA Buffers<a class="headerlink" href="#shared-dma-buffers" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.dma_buf_export">
struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> * <code class="descname">dma_buf_export</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.dma_buf_export_info" title="dma_buf_export_info">dma_buf_export_info</a> *<em>&nbsp;exp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_export" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new dma_buf, and associates an anon file with this buffer, so it can be exported. Also connect the allocator specific data and ops to the buffer. Additionally, provide a name string for exporter; useful in debugging.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_buf_export_info</span> <span class="pre">*</span> <span class="pre">exp_info</span></code></dt>
<dd>[in]  holds all the export related information provided
by the exporter. see struct dma_buf_export_info
for further details.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns, on success, a newly created dma_buf object, which wraps the
supplied private data and operations for dma_buf_ops. On either missing
ops, or error in allocating struct dma_buf, will return negative error.</p>
<dl class="function">
<dt id="c.dma_buf_fd">
int <code class="descname">dma_buf_fd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_fd" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a file descriptor for the given dma_buf</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  pointer to dma_buf for which fd is required.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>[in]    flags to give to fd</dd>
</dl>
<p><strong>Description</strong></p>
<p>On success, returns an associated &#8216;fd&#8217;. Else, returns error.</p>
<dl class="function">
<dt id="c.dma_buf_get">
struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> * <code class="descname">dma_buf_get</code><span class="sig-paren">(</span>int<em>&nbsp;fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_get" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the dma_buf structure related to an fd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>[in]  fd associated with the dma_buf to be returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>On success, returns the dma_buf structure associated with an fd; uses
file&#8217;s refcounting done by fget to increase refcount. returns ERR_PTR
otherwise.</p>
<dl class="function">
<dt id="c.dma_buf_put">
void <code class="descname">dma_buf_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_put" title="Permalink to this definition">¶</a></dt>
<dd><p>decreases refcount of the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to reduce refcount of</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses file&#8217;s refcounting done implicitly by <code class="xref c c-func docutils literal"><span class="pre">fput()</span></code></p>
<dl class="function">
<dt id="c.dma_buf_attach">
struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> * <code class="descname">dma_buf_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the device to dma_buf&#8217;s attachments list; optionally, calls <code class="xref c c-func docutils literal"><span class="pre">attach()</span></code> of dma_buf_ops to allow device-specific attach functionality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to attach device to.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>[in]  device to be attached.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns struct dma_buf_attachment * for this attachment; returns ERR_PTR on
error.</p>
<dl class="function">
<dt id="c.dma_buf_detach">
void <code class="descname">dma_buf_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the given attachment from dmabuf&#8217;s attachments list; optionally calls <code class="xref c c-func docutils literal"><span class="pre">detach()</span></code> of dma_buf_ops for device-specific detach</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to detach from.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>[in]  attachment to be detached; is free&#8217;d after this call.</dd>
</dl>
<dl class="function">
<dt id="c.dma_buf_map_attachment">
struct sg_table * <code class="descname">dma_buf_map_attachment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em>, enum dma_data_direction<em>&nbsp;direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_attachment" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the scatterlist table of the attachment; mapped into _device_ address space. Is a wrapper for <code class="xref c c-func docutils literal"><span class="pre">map_dma_buf()</span></code> of the dma_buf_ops.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>[in]  attachment whose scatterlist is to be returned</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt>
<dd>[in]  direction of DMA transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns sg_table containing the scatterlist to be returned; returns ERR_PTR
on error.</p>
<dl class="function">
<dt id="c.dma_buf_unmap_attachment">
void <code class="descname">dma_buf_unmap_attachment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em>, struct sg_table *<em>&nbsp;sg_table</em>, enum dma_data_direction<em>&nbsp;direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_unmap_attachment" title="Permalink to this definition">¶</a></dt>
<dd><p>unmaps and decreases usecount of the buffer;might deallocate the scatterlist associated. Is a wrapper for <code class="xref c c-func docutils literal"><span class="pre">unmap_dma_buf()</span></code> of dma_buf_ops.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>[in]  attachment to unmap buffer from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">sg_table</span></code></dt>
<dd>[in]  scatterlist info of the buffer to unmap</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt>
<dd>[in]    direction of DMA transfer</dd>
</dl>
<dl class="function">
<dt id="c.dma_buf_begin_cpu_access">
int <code class="descname">dma_buf_begin_cpu_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, enum dma_data_direction<em>&nbsp;direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_begin_cpu_access" title="Permalink to this definition">¶</a></dt>
<dd><p>Must be called before accessing a dma_buf from the cpu in the kernel context. Calls begin_cpu_access to allow exporter-specific preparations. Coherency is only guaranteed in the specified range for the specified access direction.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to prepare cpu access for.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt>
<dd>[in]  length of range for cpu access.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Can return negative error values, returns 0 on success.</p>
<dl class="function">
<dt id="c.dma_buf_end_cpu_access">
int <code class="descname">dma_buf_end_cpu_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, enum dma_data_direction<em>&nbsp;direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_end_cpu_access" title="Permalink to this definition">¶</a></dt>
<dd><p>Must be called after accessing a dma_buf from the cpu in the kernel context. Calls end_cpu_access to allow exporter-specific actions. Coherency is only guaranteed in the specified range for the specified access direction.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to complete cpu access for.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt>
<dd>[in]  length of range for cpu access.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Can return negative error values, returns 0 on success.</p>
<dl class="function">
<dt id="c.dma_buf_kmap_atomic">
void * <code class="descname">dma_buf_kmap_atomic</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, unsigned long<em>&nbsp;page_num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_kmap_atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a page of the buffer object into kernel address space. The same restrictions as for kmap_atomic and friends apply.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to map page from.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_num</span></code></dt>
<dd>[in]  page in PAGE_SIZE units to map.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call must always succeed, any necessary preparations that might fail
need to be done in begin_cpu_access.</p>
<dl class="function">
<dt id="c.dma_buf_kunmap_atomic">
void <code class="descname">dma_buf_kunmap_atomic</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, unsigned long<em>&nbsp;page_num</em>, void *<em>&nbsp;vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_kunmap_atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap a page obtained by dma_buf_kmap_atomic.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to unmap page from.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_num</span></code></dt>
<dd>[in]  page in PAGE_SIZE units to unmap.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>[in]  kernel space pointer obtained from dma_buf_kmap_atomic.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call must always succeed.</p>
<dl class="function">
<dt id="c.dma_buf_kmap">
void * <code class="descname">dma_buf_kmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, unsigned long<em>&nbsp;page_num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_kmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a page of the buffer object into kernel address space. The same restrictions as for kmap and friends apply.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to map page from.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_num</span></code></dt>
<dd>[in]  page in PAGE_SIZE units to map.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call must always succeed, any necessary preparations that might fail
need to be done in begin_cpu_access.</p>
<dl class="function">
<dt id="c.dma_buf_kunmap">
void <code class="descname">dma_buf_kunmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, unsigned long<em>&nbsp;page_num</em>, void *<em>&nbsp;vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_kunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap a page obtained by dma_buf_kmap.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to unmap page from.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_num</span></code></dt>
<dd>[in]  page in PAGE_SIZE units to unmap.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>[in]  kernel space pointer obtained from dma_buf_kmap.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call must always succeed.</p>
<dl class="function">
<dt id="c.dma_buf_mmap">
int <code class="descname">dma_buf_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;pgoff</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup up a userspace mmap with the given vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer that should back the vma</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>[in]  vma for the mmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt>
<dd>[in]  offset in pages where this mmap should start within the
dma-buf buffer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adjusts the passed in vma so that it points at the file of the
dma_buf operation. It also adjusts the starting pgoff and does bounds
checking on the size of the vma. Then it calls the exporters mmap function to
set up the mapping.</p>
<p>Can return negative error values, returns 0 on success.</p>
<dl class="function">
<dt id="c.dma_buf_vmap">
void * <code class="descname">dma_buf_vmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_vmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Create virtual mapping for the buffer object into kernel address space. Same restrictions as for vmap and friends apply.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to vmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call may fail due to lack of virtual mapping address space.
These calls are optional in drivers. The intended use for them
is for mapping objects linear in kernel space for high use objects.
Please attempt to use kmap/kunmap before thinking about these interfaces.</p>
<p>Returns NULL on error.</p>
<dl class="function">
<dt id="c.dma_buf_vunmap">
void <code class="descname">dma_buf_vunmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em>, void *<em>&nbsp;vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_vunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap a vmap obtained by dma_buf_vmap.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  buffer to vunmap</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>[in]  vmap to vunmap</dd>
</dl>
<dl class="type">
<dt id="c.dma_buf_ops">
struct <code class="descname">dma_buf_ops</code><a class="headerlink" href="#c.dma_buf_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>operations possible on struct dma_buf</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dma_buf_ops {
  int (* attach) (struct dma_buf *, struct device *,struct dma_buf_attachment *);
  void (* detach) (struct dma_buf *, struct dma_buf_attachment *);
  struct sg_table * (* map_dma_buf) (struct dma_buf_attachment *,enum dma_data_direction);
  void (* unmap_dma_buf) (struct dma_buf_attachment *,struct sg_table *,enum dma_data_direction);
  void (* release) (struct dma_buf *);
  int (* begin_cpu_access) (struct dma_buf *, enum dma_data_direction);
  int (* end_cpu_access) (struct dma_buf *, enum dma_data_direction);
  void *(* kmap_atomic) (struct dma_buf *, unsigned long);
  void (* kunmap_atomic) (struct dma_buf *, unsigned long, void *);
  void *(* kmap) (struct dma_buf *, unsigned long);
  void (* kunmap) (struct dma_buf *, unsigned long, void *);
  int (* mmap) (struct dma_buf *, struct vm_area_struct *vma);
  void *(* vmap) (struct dma_buf *);
  void (* vunmap) (struct dma_buf *, void *vaddr);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">attach</span></code></dt>
<dd>[optional] allows different devices to &#8216;attach&#8217; themselves to the
given buffer. It might return -EBUSY to signal that backing storage
is already allocated and incompatible with the requirements
of requesting device.</dd>
<dt><code class="docutils literal"><span class="pre">detach</span></code></dt>
<dd>[optional] detach a given device from this buffer.</dd>
<dt><code class="docutils literal"><span class="pre">map_dma_buf</span></code></dt>
<dd>returns list of scatter pages allocated, increases usecount
of the buffer. Requires atleast one attach to be called
before. Returned sg list should already be mapped into
_device_ address space. This call may sleep. May also return
-EINTR. Should return -EINVAL if attach hasn&#8217;t been called yet.</dd>
<dt><code class="docutils literal"><span class="pre">unmap_dma_buf</span></code></dt>
<dd>decreases usecount of buffer, might deallocate scatter
pages.</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>release this buffer; to be called after the last dma_buf_put.</dd>
<dt><code class="docutils literal"><span class="pre">begin_cpu_access</span></code></dt>
<dd>[optional] called before cpu access to invalidate cpu
caches and allocate backing storage (if not yet done)
respectively pin the object into memory.</dd>
<dt><code class="docutils literal"><span class="pre">end_cpu_access</span></code></dt>
<dd>[optional] called after cpu access to flush caches.</dd>
<dt><code class="docutils literal"><span class="pre">kmap_atomic</span></code></dt>
<dd>maps a page from the buffer into kernel address
space, users may not block until the subsequent unmap call.
This callback must not sleep.</dd>
<dt><code class="docutils literal"><span class="pre">kunmap_atomic</span></code></dt>
<dd>[optional] unmaps a atomically mapped page from the buffer.
This Callback must not sleep.</dd>
<dt><code class="docutils literal"><span class="pre">kmap</span></code></dt>
<dd>maps a page from the buffer into kernel address space.</dd>
<dt><code class="docutils literal"><span class="pre">kunmap</span></code></dt>
<dd>[optional] unmaps a page from the buffer.</dd>
<dt><code class="docutils literal"><span class="pre">mmap</span></code></dt>
<dd>used to expose the backing storage to userspace. Note that the
mapping needs to be coherent - if the exporter doesn&#8217;t directly
support this, it needs to fake coherency by shooting down any ptes
when transitioning away from the cpu domain.</dd>
<dt><code class="docutils literal"><span class="pre">vmap</span></code></dt>
<dd>[optional] creates a virtual mapping for the buffer into kernel
address space. Same restrictions as for vmap and friends apply.</dd>
<dt><code class="docutils literal"><span class="pre">vunmap</span></code></dt>
<dd>[optional] unmaps a vmap from the buffer</dd>
</dl>
<dl class="type">
<dt id="c.dma_buf">
struct <code class="descname">dma_buf</code><a class="headerlink" href="#c.dma_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>shared buffer object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dma_buf {
  size_t size;
  struct file * file;
  struct list_head attachments;
  const struct dma_buf_ops * ops;
  struct mutex lock;
  unsigned vmapping_counter;
  void * vmap_ptr;
  const char * exp_name;
  struct module * owner;
  struct list_head list_node;
  void * priv;
  struct reservation_object * resv;
  wait_queue_head_t poll;
  struct dma_buf_poll_cb_t cb_excl;
  struct dma_buf_poll_cb_t cb_shared;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>size of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">file</span></code></dt>
<dd>file pointer used for sharing buffers across, and for refcounting.</dd>
<dt><code class="docutils literal"><span class="pre">attachments</span></code></dt>
<dd>list of dma_buf_attachment that denotes all devices attached.</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>dma_buf_ops associated with this buffer object.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>used internally to serialize list manipulation, attach/detach and vmap/unmap</dd>
<dt><code class="docutils literal"><span class="pre">vmapping_counter</span></code></dt>
<dd>used internally to refcnt the vmaps</dd>
<dt><code class="docutils literal"><span class="pre">vmap_ptr</span></code></dt>
<dd>the current vmap ptr if vmapping_counter &gt; 0</dd>
<dt><code class="docutils literal"><span class="pre">exp_name</span></code></dt>
<dd>name of the exporter; useful for debugging.</dd>
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>pointer to exporter module; used for refcounting when exporter is a
kernel module.</dd>
<dt><code class="docutils literal"><span class="pre">list_node</span></code></dt>
<dd>node for dma_buf accounting and debugging.</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>exporter specific private data for this buffer object.</dd>
<dt><code class="docutils literal"><span class="pre">resv</span></code></dt>
<dd>reservation object linked to this dma-buf</dd>
<dt><code class="docutils literal"><span class="pre">poll</span></code></dt>
<dd>for userspace poll support</dd>
<dt><code class="docutils literal"><span class="pre">cb_excl</span></code></dt>
<dd>for userspace poll support</dd>
<dt><code class="docutils literal"><span class="pre">cb_shared</span></code></dt>
<dd>for userspace poll support</dd>
</dl>
<dl class="type">
<dt id="c.dma_buf_attachment">
struct <code class="descname">dma_buf_attachment</code><a class="headerlink" href="#c.dma_buf_attachment" title="Permalink to this definition">¶</a></dt>
<dd><p>holds device-buffer attachment data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dma_buf_attachment {
  struct dma_buf * dmabuf;
  struct device * dev;
  struct list_head node;
  void * priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dmabuf</span></code></dt>
<dd>buffer for this attachment.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>device attached to the buffer.</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>list of dma_buf_attachment.</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>exporter specific attachment data.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure holds the attachment information between the dma_buf buffer
and its user device(s). The list contains one attachment struct per device
attached to the buffer.</p>
<dl class="type">
<dt id="c.dma_buf_export_info">
struct <code class="descname">dma_buf_export_info</code><a class="headerlink" href="#c.dma_buf_export_info" title="Permalink to this definition">¶</a></dt>
<dd><p>holds information needed to export a dma_buf</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dma_buf_export_info {
  const char * exp_name;
  struct module * owner;
  const struct dma_buf_ops * ops;
  size_t size;
  int flags;
  struct reservation_object * resv;
  void * priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">exp_name</span></code></dt>
<dd>name of the exporter - useful for debugging.</dd>
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>pointer to exporter module - used for refcounting kernel module</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>Attach allocator-defined dma buf ops to the new buffer</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>Size of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>mode flags for the file</dd>
<dt><code class="docutils literal"><span class="pre">resv</span></code></dt>
<dd>reservation-object, NULL to allocate default one</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>Attach private data of allocator to this buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure holds the information required to export the buffer. Used
with <a class="reference internal" href="#c.dma_buf_export" title="dma_buf_export"><code class="xref c c-func docutils literal"><span class="pre">dma_buf_export()</span></code></a> only.</p>
<dl class="function">
<dt id="c.DEFINE_DMA_BUF_EXPORT_INFO">
<code class="descname">DEFINE_DMA_BUF_EXPORT_INFO</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_DMA_BUF_EXPORT_INFO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>export-info name</dd>
</dl>
<dl class="function">
<dt id="c.get_dma_buf">
void <code class="descname">get_dma_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dmabuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_dma_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>convenience wrapper for get_file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dmabuf</span></code></dt>
<dd>[in]  pointer to dma_buf</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments the reference count on the dma-buf, needed in case of drivers
that either need to create additional references to the dmabuf on the
kernel side.  For example, an exporter that needs to keep a dmabuf ptr
so that subsequent exports don&#8217;t create a new dmabuf.</p>
</div>
<div class="section" id="reservation-objects">
<h2>Reservation Objects<a class="headerlink" href="#reservation-objects" title="Permalink to this headline">¶</a></h2>
<p>The reservation object provides a mechanism to manage shared and
exclusive fences associated with a buffer.  A reservation object
can have attached one exclusive fence (normally associated with
write operations) or N shared fences (read operations).  The RCU
mechanism is used to protect read access to fences from locked
write-side updates.</p>
<dl class="function">
<dt id="c.reservation_object_reserve_shared">
int <code class="descname">reservation_object_reserve_shared</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_reserve_shared" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve space to add a shared fence to a reservation_object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>reservation object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called before <a class="reference internal" href="#c.reservation_object_add_shared_fence" title="reservation_object_add_shared_fence"><code class="xref c c-func docutils literal"><span class="pre">reservation_object_add_shared_fence()</span></code></a>.  Must
be called with obj-&gt;lock held.</p>
<p>RETURNS
Zero for success, or -errno</p>
<dl class="function">
<dt id="c.reservation_object_add_shared_fence">
void <code class="descname">reservation_object_add_shared_fence</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_add_shared_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a fence to a shared slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the reservation object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>the shared fence to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a fence to a shared slot, obj-&gt;lock must be held, and
<a class="reference internal" href="#c.reservation_object_reserve_shared" title="reservation_object_reserve_shared"><code class="xref c c-func docutils literal"><span class="pre">reservation_object_reserve_shared()</span></code></a> has been called.</p>
<dl class="function">
<dt id="c.reservation_object_add_excl_fence">
void <code class="descname">reservation_object_add_excl_fence</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_add_excl_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an exclusive fence.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the reservation object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>the shared fence to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a fence to the exclusive slot.  The obj-&gt;lock must be held.</p>
<dl class="function">
<dt id="c.reservation_object_get_fences_rcu">
int <code class="descname">reservation_object_get_fences_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;pfence_excl</em>, unsigned *<em>&nbsp;pshared_count</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> ***<em>&nbsp;pshared</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_get_fences_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an object&#8217;s shared and exclusive fences without update side lock held</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the reservation object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">pfence_excl</span></code></dt>
<dd>the returned exclusive fence (or NULL)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">*</span> <span class="pre">pshared_count</span></code></dt>
<dd>the number of shared fences returned</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">***</span> <span class="pre">pshared</span></code></dt>
<dd>the array of shared fence ptrs returned (array is krealloc&#8217;d to
the required size, and must be freed by caller)</dd>
</dl>
<p><strong>Description</strong></p>
<p>RETURNS
Zero or -errno</p>
<dl class="function">
<dt id="c.reservation_object_wait_timeout_rcu">
long <code class="descname">reservation_object_wait_timeout_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em>, bool<em>&nbsp;wait_all</em>, bool<em>&nbsp;intr</em>, unsigned long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_wait_timeout_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait on reservation&#8217;s objects shared and/or exclusive fences.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the reservation object</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">wait_all</span></code></dt>
<dd>if true, wait on all fences, else wait on just exclusive fence</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">intr</span></code></dt>
<dd>if true, do interruptible wait</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>timeout value in jiffies or zero to return immediately</dd>
</dl>
<p><strong>Description</strong></p>
<p>RETURNS
Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or
greater than zer on success.</p>
<dl class="function">
<dt id="c.reservation_object_test_signaled_rcu">
bool <code class="descname">reservation_object_test_signaled_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em>, bool<em>&nbsp;test_all</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_test_signaled_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a reservation object&#8217;s fences have been signaled.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the reservation object</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">test_all</span></code></dt>
<dd>if true, test all fences, otherwise only test the exclusive
fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>RETURNS
true if all fences signaled, else false</p>
<dl class="type">
<dt id="c.reservation_object_list">
struct <code class="descname">reservation_object_list</code><a class="headerlink" href="#c.reservation_object_list" title="Permalink to this definition">¶</a></dt>
<dd><p>a list of shared fences</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct reservation_object_list {
  struct rcu_head rcu;
  u32 shared_count;
  u32 shared_max;
  struct dma_fence __rcu * shared[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">rcu</span></code></dt>
<dd>for internal use</dd>
<dt><code class="docutils literal"><span class="pre">shared_count</span></code></dt>
<dd>table of shared fences</dd>
<dt><code class="docutils literal"><span class="pre">shared_max</span></code></dt>
<dd>for growing shared fence table</dd>
<dt><code class="docutils literal"><span class="pre">shared[]</span></code></dt>
<dd>shared fence table</dd>
</dl>
<dl class="type">
<dt id="c.reservation_object">
struct <code class="descname">reservation_object</code><a class="headerlink" href="#c.reservation_object" title="Permalink to this definition">¶</a></dt>
<dd><p>a reservation object manages fences for a buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct reservation_object {
  struct ww_mutex lock;
  seqcount_t seq;
  struct dma_fence __rcu * fence_excl;
  struct reservation_object_list __rcu * fence;
  struct reservation_object_list * staged;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>update side lock</dd>
<dt><code class="docutils literal"><span class="pre">seq</span></code></dt>
<dd>sequence count for managing RCU read-side synchronization</dd>
<dt><code class="docutils literal"><span class="pre">fence_excl</span></code></dt>
<dd>the exclusive fence, if there is one currently</dd>
<dt><code class="docutils literal"><span class="pre">fence</span></code></dt>
<dd>list of current shared fences</dd>
<dt><code class="docutils literal"><span class="pre">staged</span></code></dt>
<dd>staged copy of shared fences for RCU updates</dd>
</dl>
<dl class="function">
<dt id="c.reservation_object_init">
void <code class="descname">reservation_object_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a reservation object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the reservation object</dd>
</dl>
<dl class="function">
<dt id="c.reservation_object_fini">
void <code class="descname">reservation_object_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>destroys a reservation object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the reservation object</dd>
</dl>
<dl class="function">
<dt id="c.reservation_object_get_list">
struct <a class="reference internal" href="#c.reservation_object_list" title="reservation_object_list">reservation_object_list</a> * <code class="descname">reservation_object_get_list</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_get_list" title="Permalink to this definition">¶</a></dt>
<dd><p>get the reservation object&#8217;s shared fence list, with update-side lock held</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the reservation object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the shared fence list.  Does NOT take references to
the fence.  The obj-&gt;lock must be held.</p>
<dl class="function">
<dt id="c.reservation_object_get_excl">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="descname">reservation_object_get_excl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_get_excl" title="Permalink to this definition">¶</a></dt>
<dd><p>get the reservation object&#8217;s exclusive fence, with update-side lock held</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the reservation object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the exclusive fence (if any).  Does NOT take a
reference.  The obj-&gt;lock must be held.</p>
<p>RETURNS
The exclusive fence or NULL</p>
<dl class="function">
<dt id="c.reservation_object_get_excl_rcu">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="descname">reservation_object_get_excl_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reservation_object_get_excl_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get the reservation object&#8217;s exclusive fence, without lock held.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the reservation object</dd>
</dl>
<p><strong>Description</strong></p>
<p>If there is an exclusive fence, this atomically increments it&#8217;s
reference count and returns it.</p>
<p>RETURNS
The exclusive fence or NULL if none</p>
</div>
<div class="section" id="dma-fences">
<h2>DMA Fences<a class="headerlink" href="#dma-fences" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.dma_fence_context_alloc">
u64 <code class="descname">dma_fence_context_alloc</code><span class="sig-paren">(</span>unsigned<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_context_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an array of fence contexts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">num</span></code></dt>
<dd>[in]  amount of contexts to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will return the first index of the number of fences allocated.
The fence context is used for setting fence-&gt;context to a unique number.</p>
<dl class="function">
<dt id="c.dma_fence_signal_locked">
int <code class="descname">dma_fence_signal_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_signal_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>signal completion of a fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>the fence to signal</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal completion for software callbacks on a fence, this will unblock
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_wait()</span></code></a> calls and run all the callbacks added with
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_add_callback()</span></code></a>. Can be called multiple times, but since a fence
can only go from unsignaled to signaled state, it will only be effective
the first time.</p>
<p>Unlike dma_fence_signal, this function must be called with fence-&gt;lock held.</p>
<dl class="function">
<dt id="c.dma_fence_signal">
int <code class="descname">dma_fence_signal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>signal completion of a fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>the fence to signal</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal completion for software callbacks on a fence, this will unblock
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_wait()</span></code></a> calls and run all the callbacks added with
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_add_callback()</span></code></a>. Can be called multiple times, but since a fence
can only go from unsignaled to signaled state, it will only be effective
the first time.</p>
<dl class="function">
<dt id="c.dma_fence_wait_timeout">
signed long <code class="descname">dma_fence_wait_timeout</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, bool<em>&nbsp;intr</em>, signed long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_wait_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until the fence gets signaled or until timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  the fence to wait on</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">intr</span></code></dt>
<dd>[in]  if true, do an interruptible wait</dd>
<dt><code class="docutils literal"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>[in]  timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or the
remaining timeout in jiffies on success. Other error values may be
returned on custom implementations.</p>
<p>Performs a synchronous wait on this fence. It is assumed the caller
directly or indirectly (buf-mgr between reservation and committing)
holds a reference to the fence, otherwise the fence might be
freed before return, resulting in undefined behavior.</p>
<dl class="function">
<dt id="c.dma_fence_enable_sw_signaling">
void <code class="descname">dma_fence_enable_sw_signaling</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_enable_sw_signaling" title="Permalink to this definition">¶</a></dt>
<dd><p>enable signaling on fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  the fence to enable</dd>
</dl>
<p><strong>Description</strong></p>
<p>this will request for sw signaling to be enabled, to make the fence
complete as soon as possible</p>
<dl class="function">
<dt id="c.dma_fence_add_callback">
int <code class="descname">dma_fence_add_callback</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, struct <a class="reference internal" href="#c.dma_fence_cb" title="dma_fence_cb">dma_fence_cb</a> *<em>&nbsp;cb</em>, dma_fence_func_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_add_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>add a callback to be called when the fence is signaled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  the fence to wait on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence_cb</span> <span class="pre">*</span> <span class="pre">cb</span></code></dt>
<dd>[in]  the callback to register</dd>
<dt><code class="docutils literal"><span class="pre">dma_fence_func_t</span> <span class="pre">func</span></code></dt>
<dd>[in]  the function to call</dd>
</dl>
<p><strong>Description</strong></p>
<p>cb will be initialized by dma_fence_add_callback, no initialization
by the caller is required. Any number of callbacks can be registered
to a fence, but a callback can only be registered to one fence at a time.</p>
<p>Note that the callback can be called from an atomic context.  If
fence is already signaled, this function will return -ENOENT (and
<em>not</em> call the callback)</p>
<p>Add a software callback to the fence. Same restrictions apply to
refcount as it does to dma_fence_wait, however the caller doesn&#8217;t need to
keep a refcount to fence afterwards: when software access is enabled,
the creator of the fence is required to keep the fence alive until
after it signals with dma_fence_signal. The callback itself can be called
from irq context.</p>
<dl class="function">
<dt id="c.dma_fence_remove_callback">
bool <code class="descname">dma_fence_remove_callback</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, struct <a class="reference internal" href="#c.dma_fence_cb" title="dma_fence_cb">dma_fence_cb</a> *<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_remove_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a callback from the signaling list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  the fence to wait on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence_cb</span> <span class="pre">*</span> <span class="pre">cb</span></code></dt>
<dd>[in]  the callback to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a previously queued callback from the fence. This function returns
true if the callback is successfully removed, or false if the fence has
already been signaled.</p>
<p><em>WARNING</em>:
Cancelling a callback should only be done if you really know what you&#8217;re
doing, since deadlocks and race conditions could occur all too easily. For
this reason, it should only ever be done on hardware lockup recovery,
with a reference held to the fence.</p>
<dl class="function">
<dt id="c.dma_fence_default_wait">
signed long <code class="descname">dma_fence_default_wait</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, bool<em>&nbsp;intr</em>, signed long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_default_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>default sleep until the fence gets signaled or until timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  the fence to wait on</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">intr</span></code></dt>
<dd>[in]  if true, do an interruptible wait</dd>
<dt><code class="docutils literal"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>[in]  timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or the
remaining timeout in jiffies on success. If timeout is zero the value one is
returned if the fence is already signaled for consistency with other
functions taking a jiffies timeout.</p>
<dl class="function">
<dt id="c.dma_fence_wait_any_timeout">
signed long <code class="descname">dma_fence_wait_any_timeout</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fences</em>, uint32_t<em>&nbsp;count</em>, bool<em>&nbsp;intr</em>, signed long<em>&nbsp;timeout</em>, uint32_t *<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_wait_any_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until any fence gets signaled or until timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fences</span></code></dt>
<dd>[in]  array of fences to wait on</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">count</span></code></dt>
<dd>[in]  number of fences to wait on</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">intr</span></code></dt>
<dd>[in]  if true, do an interruptible wait</dd>
<dt><code class="docutils literal"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>[in]  timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">idx</span></code></dt>
<dd>[out] the first signaled fence index, meaningful only on
positive return</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -EINVAL on custom fence wait implementation, -ERESTARTSYS if
interrupted, 0 if the wait timed out, or the remaining timeout in jiffies
on success.</p>
<p>Synchronous waits for the first fence in the array to be signaled. The
caller needs to hold a reference to all fences in the array, otherwise a
fence might be freed before return, resulting in undefined behavior.</p>
<dl class="function">
<dt id="c.dma_fence_init">
void <code class="descname">dma_fence_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, const struct <a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops">dma_fence_ops</a> *<em>&nbsp;ops</em>, spinlock_t *<em>&nbsp;lock</em>, u64<em>&nbsp;context</em>, unsigned<em>&nbsp;seqno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a custom fence.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  the fence to initialize</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_fence_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>[in]  the dma_fence_ops for operations on this fence</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>[in]  the irqsafe spinlock to use for locking this fence</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">context</span></code></dt>
<dd>[in]  the execution context this fence is run on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">seqno</span></code></dt>
<dd>[in]  a linear increasing sequence number for this context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes an allocated fence, the caller doesn&#8217;t have to keep its
refcount after committing with this fence, but it will need to hold a
refcount again if dma_fence_ops.enable_signaling gets called. This can
be used for other implementing other types of fence.</p>
<p>context and seqno are used for easy comparison between fences, allowing
to check which fence is later by simply using dma_fence_later.</p>
<dl class="type">
<dt id="c.dma_fence">
struct <code class="descname">dma_fence</code><a class="headerlink" href="#c.dma_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>software synchronization primitive</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dma_fence {
  struct kref refcount;
  const struct dma_fence_ops * ops;
  struct rcu_head rcu;
  struct list_head cb_list;
  spinlock_t * lock;
  u64 context;
  unsigned seqno;
  unsigned long flags;
  ktime_t timestamp;
  int status;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>refcount for this fence</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>dma_fence_ops associated with this fence</dd>
<dt><code class="docutils literal"><span class="pre">rcu</span></code></dt>
<dd>used for releasing fence with kfree_rcu</dd>
<dt><code class="docutils literal"><span class="pre">cb_list</span></code></dt>
<dd>list of all callbacks to call</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>spin_lock_irqsave used for locking</dd>
<dt><code class="docutils literal"><span class="pre">context</span></code></dt>
<dd>execution context this fence belongs to, returned by
<a class="reference internal" href="#c.dma_fence_context_alloc" title="dma_fence_context_alloc"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_context_alloc()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">seqno</span></code></dt>
<dd>the sequence number of this fence inside the execution context,
can be compared to decide which fence would be signaled later.</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>A mask of DMA_FENCE_FLAG_* defined below</dd>
<dt><code class="docutils literal"><span class="pre">timestamp</span></code></dt>
<dd>Timestamp when the fence was signaled.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>Optional, only valid if &lt; 0, must be set before calling
dma_fence_signal, indicates that the fence has completed with an error.</dd>
</dl>
<p><strong>Description</strong></p>
<p>the flags member must be manipulated and read using the appropriate
atomic ops (bit_*), so taking the spinlock will not be needed most
of the time.</p>
<p>DMA_FENCE_FLAG_SIGNALED_BIT - fence is already signaled
DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT - enable_signaling might have been called
DMA_FENCE_FLAG_USER_BITS - start of the unused bits, can be used by the
implementer of the fence for its own purposes. Can be used in different
ways by different fence implementers, so do not rely on this.</p>
<p>Since atomic bitops are used, this is not guaranteed to be the case.
Particularly, if the bit was set, but dma_fence_signal was called right
before this bit was set, it would have been able to set the
DMA_FENCE_FLAG_SIGNALED_BIT, before enable_signaling was called.
Adding a check for DMA_FENCE_FLAG_SIGNALED_BIT after setting
DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT closes this race, and makes sure that
after dma_fence_signal was called, any enable_signaling call will have either
been completed, or never called at all.</p>
<dl class="type">
<dt id="c.dma_fence_cb">
struct <code class="descname">dma_fence_cb</code><a class="headerlink" href="#c.dma_fence_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>callback for dma_fence_add_callback</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dma_fence_cb {
  struct list_head node;
  dma_fence_func_t func;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>used by dma_fence_add_callback to append this struct to fence::cb_list</dd>
<dt><code class="docutils literal"><span class="pre">func</span></code></dt>
<dd>dma_fence_func_t to call</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct will be initialized by dma_fence_add_callback, additional
data can be passed along by embedding dma_fence_cb in another struct.</p>
<dl class="type">
<dt id="c.dma_fence_ops">
struct <code class="descname">dma_fence_ops</code><a class="headerlink" href="#c.dma_fence_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>operations implemented for fence</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dma_fence_ops {
  const char * (* get_driver_name) (struct dma_fence *fence);
  const char * (* get_timeline_name) (struct dma_fence *fence);
  bool (* enable_signaling) (struct dma_fence *fence);
  bool (* signaled) (struct dma_fence *fence);
  signed long (* wait) (struct dma_fence *fence,bool intr, signed long timeout);
  void (* release) (struct dma_fence *fence);
  int (* fill_driver_data) (struct dma_fence *fence, void *data, int size);
  void (* fence_value_str) (struct dma_fence *fence, char *str, int size);
  void (* timeline_value_str) (struct dma_fence *fence,char *str, int size);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">get_driver_name</span></code></dt>
<dd>returns the driver name.</dd>
<dt><code class="docutils literal"><span class="pre">get_timeline_name</span></code></dt>
<dd>return the name of the context this fence belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">enable_signaling</span></code></dt>
<dd>enable software signaling of fence.</dd>
<dt><code class="docutils literal"><span class="pre">signaled</span></code></dt>
<dd>[optional] peek whether the fence is signaled, can be null.</dd>
<dt><code class="docutils literal"><span class="pre">wait</span></code></dt>
<dd>custom wait implementation, or dma_fence_default_wait.</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>[optional] called on destruction of fence, can be null</dd>
<dt><code class="docutils literal"><span class="pre">fill_driver_data</span></code></dt>
<dd>[optional] callback to fill in free-form debug info
Returns amount of bytes filled, or -errno.</dd>
<dt><code class="docutils literal"><span class="pre">fence_value_str</span></code></dt>
<dd>[optional] fills in the value of the fence as a string</dd>
<dt><code class="docutils literal"><span class="pre">timeline_value_str</span></code></dt>
<dd>[optional] fills in the current value of the timeline
as a string</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notes on enable_signaling:
For fence implementations that have the capability for hw-&gt;hw
signaling, they can implement this op to enable the necessary
irqs, or insert commands into cmdstream, etc.  This is called
in the first <code class="xref c c-func docutils literal"><span class="pre">wait()</span></code> or <code class="xref c c-func docutils literal"><span class="pre">add_callback()</span></code> path to let the fence
implementation know that there is another driver waiting on
the signal (ie. hw-&gt;sw case).</p>
<p>This function can be called called from atomic context, but not
from irq context, so normal spinlocks can be used.</p>
<p>A return value of false indicates the fence already passed,
or some failure occurred that made it impossible to enable
signaling. True indicates successful enabling.</p>
<p>fence-&gt;status may be set in enable_signaling, but only when false is
returned.</p>
<p>Calling dma_fence_signal before enable_signaling is called allows
for a tiny race window in which enable_signaling is called during,
before, or after dma_fence_signal. To fight this, it is recommended
that before enable_signaling returns true an extra reference is
taken on the fence, to be released when the fence is signaled.
This will mean dma_fence_signal will still be called twice, but
the second time will be a noop since it was already signaled.</p>
<p>Notes on signaled:
May set fence-&gt;status if returning true.</p>
<p>Notes on wait:
Must not be NULL, set to dma_fence_default_wait for default implementation.
the dma_fence_default_wait implementation should work for any fence, as long
as enable_signaling works correctly.</p>
<p>Must return -ERESTARTSYS if the wait is intr = true and the wait was
interrupted, and remaining jiffies if fence has signaled, or 0 if wait
timed out. Can also return other error values on custom implementations,
which should be treated as if the fence is signaled. For example a hardware
lockup could be reported like that.</p>
<p>Notes on release:
Can be NULL, this function allows additional commands to run on
destruction of the fence. Can be called from irq context.
If pointer is set to NULL, kfree will get called instead.</p>
<dl class="function">
<dt id="c.dma_fence_put">
void <code class="descname">dma_fence_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_put" title="Permalink to this definition">¶</a></dt>
<dd><p>decreases refcount of the fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  fence to reduce refcount of</dd>
</dl>
<dl class="function">
<dt id="c.dma_fence_get">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="descname">dma_fence_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get" title="Permalink to this definition">¶</a></dt>
<dd><p>increases refcount of the fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  fence to increase refcount of</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the same fence, with refcount increased by 1.</p>
<dl class="function">
<dt id="c.dma_fence_get_rcu">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="descname">dma_fence_get_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get a fence from a reservation_object_list with rcu read lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  fence to increase refcount of</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns NULL if no refcount could be obtained, or the fence.</p>
<dl class="function">
<dt id="c.dma_fence_get_rcu_safe">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="descname">dma_fence_get_rcu_safe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *__rcu *<em>&nbsp;fencep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_rcu_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a reference to an RCU tracked fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*__rcu</span> <span class="pre">*</span> <span class="pre">fencep</span></code></dt>
<dd>[in]  pointer to fence to increase refcount of</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns NULL if no refcount could be obtained, or the fence.
This function handles acquiring a reference to a fence that may be
reallocated within the RCU grace period (such as with SLAB_DESTROY_BY_RCU),
so long as the caller is using RCU on the pointer to the fence.</p>
<p>An alternative mechanism is to employ a seqlock to protect a bunch of
fences, such as used by struct reservation_object. When using a seqlock,
the seqlock must be taken before and checked after a reference to the
fence is acquired (as shown here).</p>
<p>The caller is required to hold the RCU read lock.</p>
<dl class="function">
<dt id="c.dma_fence_is_signaled_locked">
bool <code class="descname">dma_fence_is_signaled_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_signaled_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an indication if the fence is signaled yet.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  the fence to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the fence was already signaled, false if not. Since this
function doesn&#8217;t enable signaling, it is not guaranteed to ever return
true if dma_fence_add_callback, dma_fence_wait or
dma_fence_enable_sw_signaling haven&#8217;t been called before.</p>
<p>This function requires fence-&gt;lock to be held.</p>
<dl class="function">
<dt id="c.dma_fence_is_signaled">
bool <code class="descname">dma_fence_is_signaled</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_signaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an indication if the fence is signaled yet.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  the fence to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the fence was already signaled, false if not. Since this
function doesn&#8217;t enable signaling, it is not guaranteed to ever return
true if dma_fence_add_callback, dma_fence_wait or
dma_fence_enable_sw_signaling haven&#8217;t been called before.</p>
<p>It&#8217;s recommended for seqno fences to call dma_fence_signal when the
operation is complete, it makes it possible to prevent issues from
wraparound between time of issue and time of use by checking the return
value of this function before calling hardware-specific wait instructions.</p>
<dl class="function">
<dt id="c.dma_fence_is_later">
bool <code class="descname">dma_fence_is_later</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;f1</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;f2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_later" title="Permalink to this definition">¶</a></dt>
<dd><p>return if f1 is chronologically later than f2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">f1</span></code></dt>
<dd>[in]  the first fence from the same context</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">f2</span></code></dt>
<dd>[in]  the second fence from the same context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if f1 is chronologically later than f2. Both fences must be
from the same context, since a seqno is not re-used across contexts.</p>
<dl class="function">
<dt id="c.dma_fence_later">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="descname">dma_fence_later</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;f1</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;f2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_later" title="Permalink to this definition">¶</a></dt>
<dd><p>return the chronologically later fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">f1</span></code></dt>
<dd>[in]  the first fence from the same context</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">f2</span></code></dt>
<dd>[in]  the second fence from the same context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if both fences are signaled, otherwise the fence that would be
signaled last. Both fences must be from the same context, since a seqno is
not re-used across contexts.</p>
<dl class="function">
<dt id="c.dma_fence_wait">
signed long <code class="descname">dma_fence_wait</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, bool<em>&nbsp;intr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until the fence gets signaled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>[in]  the fence to wait on</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">intr</span></code></dt>
<dd>[in]  if true, do an interruptible wait</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will return -ERESTARTSYS if interrupted by a signal,
or 0 if the fence was signaled. Other error values may be
returned on custom implementations.</p>
<p>Performs a synchronous wait on this fence. It is assumed the caller
directly or indirectly holds a reference to the fence, otherwise the
fence might be freed before return, resulting in undefined behavior.</p>
<div class="section" id="seqno-hardware-fences">
<h3>Seqno Hardware Fences<a class="headerlink" href="#seqno-hardware-fences" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.to_seqno_fence">
struct seqno_fence * <code class="descname">to_seqno_fence</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.to_seqno_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>cast a fence to a seqno_fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence to cast to a seqno_fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the fence is not a seqno_fence,
or the seqno_fence otherwise.</p>
<dl class="function">
<dt id="c.seqno_fence_init">
void <code class="descname">seqno_fence_init</code><span class="sig-paren">(</span>struct seqno_fence *<em>&nbsp;fence</em>, spinlock_t *<em>&nbsp;lock</em>, struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;sync_buf</em>, uint32_t<em>&nbsp;context</em>, uint32_t<em>&nbsp;seqno_ofs</em>, uint32_t<em>&nbsp;seqno</em>, enum seqno_fence_condition<em>&nbsp;cond</em>, const struct <a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops">dma_fence_ops</a> *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seqno_fence_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a seqno fence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seqno_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>seqno_fence to initialize</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>pointer to spinlock to use for fence</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">sync_buf</span></code></dt>
<dd>buffer containing the memory location to signal on</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">context</span></code></dt>
<dd>the execution context this fence is a part of</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">seqno_ofs</span></code></dt>
<dd>the offset within <strong>sync_buf</strong></dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">seqno</span></code></dt>
<dd>the sequence # to signal on</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">seqno_fence_condition</span> <span class="pre">cond</span></code></dt>
<dd>fence wait condition</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_fence_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the fence_ops for operations on this seqno fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes a struct seqno_fence with passed parameters,
and takes a reference on sync_buf which is released on fence destruction.</p>
<p>A seqno_fence is a dma_fence which can complete in software when
enable_signaling is called, but it also completes when
(s32)((sync_buf)[seqno_ofs] - seqno) &gt;= 0 is true</p>
<p>The seqno_fence will take a refcount on the sync_buf until it&#8217;s
destroyed, but actual lifetime of sync_buf may be longer if one of the
callers take a reference to it.</p>
<p>Certain hardware have instructions to insert this type of wait condition
in the command stream, so no intervention from software would be needed.
This type of fence can be destroyed before completed, however a reference
on the sync_buf dma-buf can be taken. It is encouraged to re-use the same
dma-buf for sync_buf, since mapping or unmapping the sync_buf to the
device&#8217;s vm can be expensive.</p>
<p>It is recommended for creators of seqno_fence to call <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_signal()</span></code></a>
before destruction. This will prevent possible issues from wraparound at
time of issue vs time of check, since users can check <a class="reference internal" href="#c.dma_fence_is_signaled" title="dma_fence_is_signaled"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_is_signaled()</span></code></a>
before submitting instructions for the hardware to wait on the fence.
However, when ops.enable_signaling is not called, it doesn&#8217;t have to be
done as soon as possible, just before there&#8217;s any real danger of seqno
wraparound.</p>
</div>
<div class="section" id="dma-fence-array">
<h3>DMA Fence Array<a class="headerlink" href="#dma-fence-array" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.dma_fence_array_create">
struct <a class="reference internal" href="#c.dma_fence_array" title="dma_fence_array">dma_fence_array</a> * <code class="descname">dma_fence_array_create</code><span class="sig-paren">(</span>int<em>&nbsp;num_fences</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fences</em>, u64<em>&nbsp;context</em>, unsigned<em>&nbsp;seqno</em>, bool<em>&nbsp;signal_on_any</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_array_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a custom fence array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_fences</span></code></dt>
<dd>[in]  number of fences to add in the array</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fences</span></code></dt>
<dd>[in]  array containing the fences</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">context</span></code></dt>
<dd>[in]  fence context to use</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">seqno</span></code></dt>
<dd>[in]  sequence number to use</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">signal_on_any</span></code></dt>
<dd>[in]  signal on any fence in the array</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a dma_fence_array object and initialize the base fence with
<a class="reference internal" href="#c.dma_fence_init" title="dma_fence_init"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_init()</span></code></a>.
In case of error it returns NULL.</p>
<p>The caller should allocate the fences array with num_fences size
and fill it with the fences it wants to add to the object. Ownership of this
array is taken and <a class="reference internal" href="#c.dma_fence_put" title="dma_fence_put"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_put()</span></code></a> is used on each fence on release.</p>
<p>If <strong>signal_on_any</strong> is true the fence array signals if any fence in the array
signals, otherwise it signals when all fences in the array signal.</p>
<dl class="type">
<dt id="c.dma_fence_array_cb">
struct <code class="descname">dma_fence_array_cb</code><a class="headerlink" href="#c.dma_fence_array_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>callback helper for fence array</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dma_fence_array_cb {
  struct dma_fence_cb cb;
  struct dma_fence_array * array;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cb</span></code></dt>
<dd>fence callback structure for signaling</dd>
<dt><code class="docutils literal"><span class="pre">array</span></code></dt>
<dd>reference to the parent fence array object</dd>
</dl>
<dl class="type">
<dt id="c.dma_fence_array">
struct <code class="descname">dma_fence_array</code><a class="headerlink" href="#c.dma_fence_array" title="Permalink to this definition">¶</a></dt>
<dd><p>fence to represent an array of fences</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dma_fence_array {
  struct dma_fence base;
  spinlock_t lock;
  unsigned num_fences;
  atomic_t num_pending;
  struct dma_fence ** fences;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>fence base class</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>spinlock for fence handling</dd>
<dt><code class="docutils literal"><span class="pre">num_fences</span></code></dt>
<dd>number of fences in the array</dd>
<dt><code class="docutils literal"><span class="pre">num_pending</span></code></dt>
<dd>fences in the array still pending</dd>
<dt><code class="docutils literal"><span class="pre">fences</span></code></dt>
<dd>array of the fences</dd>
</dl>
<dl class="function">
<dt id="c.dma_fence_is_array">
bool <code class="descname">dma_fence_is_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_array" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a fence is from the array subsclass</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if it is a dma_fence_array and false otherwise.</p>
<dl class="function">
<dt id="c.to_dma_fence_array">
struct <a class="reference internal" href="#c.dma_fence_array" title="dma_fence_array">dma_fence_array</a> * <code class="descname">to_dma_fence_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.to_dma_fence_array" title="Permalink to this definition">¶</a></dt>
<dd><p>cast a fence to a dma_fence_array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence to cast to a dma_fence_array</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the fence is not a dma_fence_array,
or the dma_fence_array otherwise.</p>
</div>
<div class="section" id="dma-fence-uabi-sync-file">
<h3>DMA Fence uABI/Sync File<a class="headerlink" href="#dma-fence-uabi-sync-file" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.sync_file_create">
struct <a class="reference internal" href="#c.sync_file" title="sync_file">sync_file</a> * <code class="descname">sync_file_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_file_create" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a sync file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence to add to the sync_fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a sync_file containg <strong>fence</strong>. Once this is called, the sync_file
takes ownership of <strong>fence</strong>. The sync_file can be released with
fput(sync_file-&gt;file). Returns the sync_file or NULL in case of error.</p>
<dl class="function">
<dt id="c.sync_file_get_fence">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="descname">sync_file_get_fence</code><span class="sig-paren">(</span>int<em>&nbsp;fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_file_get_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>get the fence related to the sync_file fd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>sync_file fd to get the fence from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ensures <strong>fd</strong> references a valid sync_file and returns a fence that
represents all fence in the sync_file. On error NULL is returned.</p>
<dl class="type">
<dt id="c.sync_file">
struct <code class="descname">sync_file</code><a class="headerlink" href="#c.sync_file" title="Permalink to this definition">¶</a></dt>
<dd><p>sync file to export to the userspace</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct sync_file {
  struct file * file;
  struct kref kref;
  char name[32];
#ifdef CONFIG_DEBUG_FS
  struct list_head sync_file_list;
#endif
  wait_queue_head_t wq;
  struct dma_fence * fence;
  struct dma_fence_cb cb;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">file</span></code></dt>
<dd>file representing this fence</dd>
<dt><code class="docutils literal"><span class="pre">kref</span></code></dt>
<dd>reference count on fence.</dd>
<dt><code class="docutils literal"><span class="pre">name[32]</span></code></dt>
<dd>name of sync_file.  Useful for debugging</dd>
<dt><code class="docutils literal"><span class="pre">sync_file_list</span></code></dt>
<dd>membership in global file list</dd>
<dt><code class="docutils literal"><span class="pre">wq</span></code></dt>
<dd>wait queue for fence signaling</dd>
<dt><code class="docutils literal"><span class="pre">fence</span></code></dt>
<dd>fence with the fences in the sync_file</dd>
<dt><code class="docutils literal"><span class="pre">cb</span></code></dt>
<dd>fence callback information</dd>
</dl>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="device_link.html" class="btn btn-neutral float-right" title="Device links" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="infrastructure.html" class="btn btn-neutral" title="Device drivers infrastructure" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.10.0-rc8+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>