

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Userland interfaces &mdash; The Linux Kernel 4.10.0-rc8+ documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 4.10.0-rc8+ documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developer’s Guide" href="index.html"/>
        <link rel="next" title="drm/i915 Intel GFX Driver" href="i915.html"/>
        <link rel="prev" title="Mode Setting Helper Functions" href="drm-kms-helpers.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.10.0-rc8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Userland interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#libdrm-device-lookup">libdrm Device Lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#primary-nodes-drm-master-and-authentication">Primary Nodes, DRM Master and Authentication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#open-source-userspace-requirements">Open-Source Userspace Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#render-nodes">Render nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#validating-changes-with-igt">Validating changes with IGT</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vblank-event-handling">VBlank event handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-and-validation">Testing and validation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
      
    <li>Userland interfaces</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/gpu/drm-uapi.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="userland-interfaces">
<h1>Userland interfaces<a class="headerlink" href="#userland-interfaces" title="Permalink to this headline">¶</a></h1>
<p>The DRM core exports several interfaces to applications, generally
intended to be used through corresponding libdrm wrapper functions. In
addition, drivers export device-specific interfaces for use by userspace
drivers &amp; device-aware applications through ioctls and sysfs files.</p>
<p>External interfaces include: memory mapping, context management, DMA
operations, AGP management, vblank control, fence management, memory
management, and output management.</p>
<p>Cover generic ioctls and sysfs layout here. We only need high-level
info, since man pages should cover the rest.</p>
<div class="section" id="libdrm-device-lookup">
<h2>libdrm Device Lookup<a class="headerlink" href="#libdrm-device-lookup" title="Permalink to this headline">¶</a></h2>
<p>BEWARE THE DRAGONS! MIND THE TRAPDOORS!</p>
<p>In an attempt to warn anyone else who&#8217;s trying to figure out what&#8217;s going
on here, I&#8217;ll try to summarize the story. First things first, let&#8217;s clear up
the names, because the kernel internals, libdrm and the ioctls are all named
differently:</p>
<blockquote>
<div><ul class="simple">
<li>GET_UNIQUE ioctl, implemented by drm_getunique is wrapped up in libdrm
through the drmGetBusid function.</li>
<li>The libdrm drmSetBusid function is backed by the SET_UNIQUE ioctl. All
that code is nerved in the kernel with <a class="reference internal" href="drm-internals.html#c.drm_invalid_op" title="drm_invalid_op"><code class="xref c c-func docutils literal"><span class="pre">drm_invalid_op()</span></code></a>.</li>
<li>The internal set_busid kernel functions and driver callbacks are
exclusively use by the SET_VERSION ioctl, because only drm 1.0 (which is
nerved) allowed userspace to set the busid through the above ioctl.</li>
<li>Other ioctls and functions involved are named consistently.</li>
</ul>
</div></blockquote>
<p>For anyone wondering what&#8217;s the difference between drm 1.1 and 1.4: Correctly
handling pci domains in the busid on ppc. Doing this correctly was only
implemented in libdrm in 2010, hence can&#8217;t be nerved yet. No one knows what&#8217;s
special with drm 1.2 and 1.3.</p>
<p>Now the actual horror story of how device lookup in drm works. At large,
there&#8217;s 2 different ways, either by busid, or by device driver name.</p>
<p>Opening by busid is fairly simple:</p>
<ol class="arabic simple">
<li>First call SET_VERSION to make sure pci domains are handled properly. As a
side-effect this fills out the unique name in the master structure.</li>
<li>Call GET_UNIQUE to read out the unique name from the master structure,
which matches the busid thanks to step 1. If it doesn&#8217;t, proceed to try
the next device node.</li>
</ol>
<p>Opening by name is slightly different:</p>
<ol class="arabic simple">
<li>Directly call VERSION to get the version and to match against the driver
name returned by that ioctl. Note that SET_VERSION is not called, which
means the the unique name for the master node just opening is _not_ filled
out. This despite that with current drm device nodes are always bound to
one device, and can&#8217;t be runtime assigned like with drm 1.0.</li>
<li>Match driver name. If it mismatches, proceed to the next device node.</li>
<li>Call GET_UNIQUE, and check whether the unique name has length zero (by
checking that the first byte in the string is 0). If that&#8217;s not the case
libdrm skips and proceeds to the next device node. Probably this is just
copypasta from drm 1.0 times where a set unique name meant that the driver
was in use already, but that&#8217;s just conjecture.</li>
</ol>
<p>Long story short: To keep the open by name logic working, GET_UNIQUE must
_not_ return a unique string when SET_VERSION hasn&#8217;t been called yet,
otherwise libdrm breaks. Even when that unique string can&#8217;t ever change, and
is totally irrelevant for actually opening the device because runtime
assignable device instances were only support in drm 1.0, which is long dead.
But the libdrm code in drmOpenByName somehow survived, hence this can&#8217;t be
broken.</p>
</div>
<div class="section" id="primary-nodes-drm-master-and-authentication">
<h2>Primary Nodes, DRM Master and Authentication<a class="headerlink" href="#primary-nodes-drm-master-and-authentication" title="Permalink to this headline">¶</a></h2>
<p>struct <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a> is used to track groups of clients with open
primary/legacy device nodes. For every struct <code class="xref c c-type docutils literal"><span class="pre">drm_file</span></code> which has had at
least once successfully became the device master (either through the
SET_MASTER IOCTL, or implicitly through opening the primary device node when
no one else is the current master that time) there exists one <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a>.
This is noted in the is_master member of <code class="xref c c-type docutils literal"><span class="pre">drm_file</span></code>. All other clients have
just a pointer to the <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a> they are associated with.</p>
<p>In addition only one <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a> can be the current master for a <code class="xref c c-type docutils literal"><span class="pre">drm_device</span></code>.
It can be switched through the DROP_MASTER and SET_MASTER IOCTL, or
implicitly through closing/openeing the primary device node. See also
<a class="reference internal" href="#c.drm_is_current_master" title="drm_is_current_master"><code class="xref c c-func docutils literal"><span class="pre">drm_is_current_master()</span></code></a>.</p>
<p>Clients can authenticate against the current master (if it matches their own)
using the GETMAGIC and AUTHMAGIC IOCTLs. Together with exchanging masters,
this allows controlled access to the device for an entire group of mutually
trusted clients.</p>
<dl class="function">
<dt id="c.drm_is_current_master">
bool <code class="descname">drm_is_current_master</code><span class="sig-paren">(</span>struct drm_file *<em>&nbsp;fpriv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_is_current_master" title="Permalink to this definition">¶</a></dt>
<dd><p>checks whether <strong>priv</strong> is the current master</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">fpriv</span></code></dt>
<dd>DRM file private</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether <strong>fpriv</strong> is current master on its device. This decides whether a
client is allowed to run DRM_MASTER IOCTLs.</p>
<p>Most of the modern IOCTL which require DRM_MASTER are for kernel modesetting
- the current master is assumed to own the non-shareable display hardware.</p>
<dl class="function">
<dt id="c.drm_master_get">
struct <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> * <code class="descname">drm_master_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> *<em>&nbsp;master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_master_get" title="Permalink to this definition">¶</a></dt>
<dd><p>reference a master pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_master</span> <span class="pre">*</span> <span class="pre">master</span></code></dt>
<dd>struct <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments the reference count of <strong>master</strong> and returns a pointer to <strong>master</strong>.</p>
<dl class="function">
<dt id="c.drm_master_put">
void <code class="descname">drm_master_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> **<em>&nbsp;master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_master_put" title="Permalink to this definition">¶</a></dt>
<dd><p>unreference and clear a master pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_master</span> <span class="pre">**</span> <span class="pre">master</span></code></dt>
<dd>pointer to a pointer of struct <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This decrements the <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a> behind <strong>master</strong> and sets it to NULL.</p>
<dl class="type">
<dt id="c.drm_master">
struct <code class="descname">drm_master</code><a class="headerlink" href="#c.drm_master" title="Permalink to this definition">¶</a></dt>
<dd><p>drm master structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_master {
  struct kref refcount;
  struct drm_device * dev;
  char * unique;
  int unique_len;
  struct idr magic_map;
  struct drm_lock_data lock;
  void * driver_priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>Refcount for this master object.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Link back to the DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unique</span></code></dt>
<dd>Unique identifier: e.g. busid. Protected by drm_global_mutex.</dd>
<dt><code class="docutils literal"><span class="pre">unique_len</span></code></dt>
<dd>Length of unique field. Protected by drm_global_mutex.</dd>
<dt><code class="docutils literal"><span class="pre">magic_map</span></code></dt>
<dd>Map of used authentication tokens. Protected by struct_mutex.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>DRI lock information.</dd>
<dt><code class="docutils literal"><span class="pre">driver_priv</span></code></dt>
<dd>Pointer to driver-private information.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that master structures are only relevant for the legacy/primary device
nodes, hence there can only be one per device, not one per drm_minor.</p>
</div>
<div class="section" id="open-source-userspace-requirements">
<h2>Open-Source Userspace Requirements<a class="headerlink" href="#open-source-userspace-requirements" title="Permalink to this headline">¶</a></h2>
<p>The DRM subsystem has stricter requirements than most other kernel subsystems on
what the userspace side for new uAPI needs to look like. This section here
explains what exactly those requirements are, and why they exist.</p>
<p>The short summary is that any addition of DRM uAPI requires corresponding
open-sourced userspace patches, and those patches must be reviewed and ready for
merging into a suitable and canonical upstream project.</p>
<p>GFX devices (both display and render/GPU side) are really complex bits of
hardware, with userspace and kernel by necessity having to work together really
closely.  The interfaces, for rendering and modesetting, must be extremely wide
and flexible, and therefore it is almost always impossible to precisely define
them for every possible corner case. This in turn makes it really practically
infeasible to differentiate between behaviour that&#8217;s required by userspace, and
which must not be changed to avoid regressions, and behaviour which is only an
accidental artifact of the current implementation.</p>
<p>Without access to the full source code of all userspace users that means it
becomes impossible to change the implementation details, since userspace could
depend upon the accidental behaviour of the current implementation in minute
details. And debugging such regressions without access to source code is pretty
much impossible. As a consequence this means:</p>
<ul class="simple">
<li>The Linux kernel&#8217;s &#8220;no regression&#8221; policy holds in practice only for
open-source userspace of the DRM subsystem. DRM developers are perfectly fine
if closed-source blob drivers in userspace use the same uAPI as the open
drivers, but they must do so in the exact same way as the open drivers.
Creative (ab)use of the interfaces will, and in the past routinely has, lead
to breakage.</li>
<li>Any new userspace interface must have an open-source implementation as
demonstration vehicle.</li>
</ul>
<p>The other reason for requiring open-source userspace is uAPI review. Since the
kernel and userspace parts of a GFX stack must work together so closely, code
review can only assess whether a new interface achieves its goals by looking at
both sides. Making sure that the interface indeed covers the use-case fully
leads to a few additional requirements:</p>
<ul class="simple">
<li>The open-source userspace must not be a toy/test application, but the real
thing. Specifically it needs to handle all the usual error and corner cases.
These are often the places where new uAPI falls apart and hence essential to
assess the fitness of a proposed interface.</li>
<li>The userspace side must be fully reviewed and tested to the standards of that
userspace project. For e.g. mesa this means piglit testcases and review on the
mailing list. This is again to ensure that the new interface actually gets the
job done.</li>
<li>The userspace patches must be against the canonical upstream, not some vendor
fork. This is to make sure that no one cheats on the review and testing
requirements by doing a quick fork.</li>
<li>The kernel patch can only be merged after all the above requirements are met,
but it <strong>must</strong> be merged <strong>before</strong> the userspace patches land. uAPI always flows
from the kernel, doing things the other way round risks divergence of the uAPI
definitions and header files.</li>
</ul>
<p>These are fairly steep requirements, but have grown out from years of shared
pain and experience with uAPI added hastily, and almost always regretted about
just as fast. GFX devices change really fast, requiring a paradigm shift and
entire new set of uAPI interfaces every few years at least. Together with the
Linux kernel&#8217;s guarantee to keep existing userspace running for 10+ years this
is already rather painful for the DRM subsystem, with multiple different uAPIs
for the same thing co-existing. If we add a few more complete mistakes into the
mix every year it would be entirely unmanageable.</p>
</div>
<div class="section" id="render-nodes">
<h2>Render nodes<a class="headerlink" href="#render-nodes" title="Permalink to this headline">¶</a></h2>
<p>DRM core provides multiple character-devices for user-space to use.
Depending on which device is opened, user-space can perform a different
set of operations (mainly ioctls). The primary node is always created
and called card&lt;num&gt;. Additionally, a currently unused control node,
called controlD&lt;num&gt; is also created. The primary node provides all
legacy operations and historically was the only interface used by
userspace. With KMS, the control node was introduced. However, the
planned KMS control interface has never been written and so the control
node stays unused to date.</p>
<p>With the increased use of offscreen renderers and GPGPU applications,
clients no longer require running compositors or graphics servers to
make use of a GPU. But the DRM API required unprivileged clients to
authenticate to a DRM-Master prior to getting GPU access. To avoid this
step and to grant clients GPU access without authenticating, render
nodes were introduced. Render nodes solely serve render clients, that
is, no modesetting or privileged ioctls can be issued on render nodes.
Only non-global rendering commands are allowed. If a driver supports
render nodes, it must advertise it via the DRIVER_RENDER DRM driver
capability. If not supported, the primary node must be used for render
clients together with the legacy drmAuth authentication procedure.</p>
<p>If a driver advertises render node support, DRM core will create a
separate render node called renderD&lt;num&gt;. There will be one render node
per device. No ioctls except PRIME-related ioctls will be allowed on
this node. Especially GEM_OPEN will be explicitly prohibited. Render
nodes are designed to avoid the buffer-leaks, which occur if clients
guess the flink names or mmap offsets on the legacy interface.
Additionally to this basic interface, drivers must mark their
driver-dependent render-only ioctls as DRM_RENDER_ALLOW so render
clients can use them. Driver authors must be careful not to allow any
privileged ioctls on render nodes.</p>
<p>With render nodes, user-space can now control access to the render node
via basic file-system access-modes. A running graphics server which
authenticates clients on the privileged primary/legacy node is no longer
required. Instead, a client can open the render node and is immediately
granted GPU access. Communication between clients (or servers) is done
via PRIME. FLINK from render node to legacy node is not supported. New
clients must not use the insecure FLINK interface.</p>
<p>Besides dropping all modeset/global ioctls, render nodes also drop the
DRM-Master concept. There is no reason to associate render clients with
a DRM-Master as they are independent of any graphics server. Besides,
they must work without any running master, anyway. Drivers must be able
to run without a master object if they support render nodes. If, on the
other hand, a driver requires shared state between clients which is
visible to user-space and accessible beyond open-file boundaries, they
cannot support render nodes.</p>
</div>
<div class="section" id="validating-changes-with-igt">
<h2>Validating changes with IGT<a class="headerlink" href="#validating-changes-with-igt" title="Permalink to this headline">¶</a></h2>
<p>There&#8217;s a collection of tests that aims to cover the whole functionality of
DRM drivers and that can be used to check that changes to DRM drivers or the
core don&#8217;t regress existing functionality. This test suite is called IGT and
its code can be found in <a class="reference external" href="https://cgit.freedesktop.org/drm/igt-gpu-tools/">https://cgit.freedesktop.org/drm/igt-gpu-tools/</a>.</p>
<p>To build IGT, start by installing its build dependencies. In Debian-based
systems:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span># apt-get build-dep intel-gpu-tools
</pre></div>
</div>
<p>And in Fedora-based systems:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span># dnf builddep intel-gpu-tools
</pre></div>
</div>
<p>Then clone the repository:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ git clone git://anongit.freedesktop.org/drm/igt-gpu-tools
</pre></div>
</div>
<p>Configure the build system and start the build:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ cd igt-gpu-tools &amp;&amp; ./autogen.sh &amp;&amp; make -j6
</pre></div>
</div>
<p>Download the piglit dependency:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ./scripts/run-tests.sh -d
</pre></div>
</div>
<p>And run the tests:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ./scripts/run-tests.sh -t kms -t core -s
</pre></div>
</div>
<p>run-tests.sh is a wrapper around piglit that will execute the tests matching
the -t options. A report in HTML format will be available in
./results/html/index.html. Results can be compared with piglit.</p>
</div>
<div class="section" id="vblank-event-handling">
<h2>VBlank event handling<a class="headerlink" href="#vblank-event-handling" title="Permalink to this headline">¶</a></h2>
<p>The DRM core exposes two vertical blank related ioctls:</p>
<dl class="docutils">
<dt>DRM_IOCTL_WAIT_VBLANK</dt>
<dd>This takes a struct drm_wait_vblank structure as its argument, and
it is used to block or request a signal when a specified vblank
event occurs.</dd>
<dt>DRM_IOCTL_MODESET_CTL</dt>
<dd>This was only used for user-mode-settind drivers around modesetting
changes to allow the kernel to update the vblank interrupt after
mode setting, since on many devices the vertical blank counter is
reset to 0 at some point during modeset. Modern drivers should not
call this any more since with kernel mode setting it is a no-op.</dd>
</dl>
<p>This second part of the GPU Driver Developer&#8217;s Guide documents driver
code, implementation details and also all the driver-specific userspace
interfaces. Especially since all hardware-acceleration interfaces to
userspace are driver specific for efficiency and other reasons these
interfaces can be rather substantial. Hence every driver has its own
chapter.</p>
</div>
<div class="section" id="testing-and-validation">
<h2>Testing and validation<a class="headerlink" href="#testing-and-validation" title="Permalink to this headline">¶</a></h2>
<p>DRM device drivers can provide to userspace CRC information of each frame as
it reached a given hardware component (a &#8220;source&#8221;).</p>
<p>Userspace can control generation of CRCs in a given CRTC by writing to the
file dri/0/crtc-N/crc/control in debugfs, with N being the index of the CRTC.
Accepted values are source names (which are driver-specific) and the &#8220;auto&#8221;
keyword, which will let the driver select a default source of frame CRCs
for this CRTC.</p>
<p>Once frame CRC generation is enabled, userspace can capture them by reading
the dri/0/crtc-N/crc/data file. Each line in that file contains the frame
number in the first field and then a number of unsigned integer fields
containing the CRC data. Fields are separated by a single space and the number
of CRC fields is source-specific.</p>
<p>Note that though in some cases the CRC is computed in a specified way and on
the frame contents as supplied by userspace (eDP 1.3), in general the CRC
computation is performed in an unspecified way and on frame contents that have
been already processed in also an unspecified way and thus userspace cannot
rely on being able to generate matching CRC values for the frame contents that
it submits. In this general case, the maximum userspace can do is to compare
the reported CRCs of frames that should have the same contents.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="i915.html" class="btn btn-neutral float-right" title="drm/i915 Intel GFX Driver" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-kms-helpers.html" class="btn btn-neutral" title="Mode Setting Helper Functions" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.10.0-rc8+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>