

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>drm/i915 Intel GFX Driver &mdash; The Linux Kernel 4.10.0-rc8+ documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 4.10.0-rc8+ documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developerâ€™s Guide" href="index.html"/>
        <link rel="next" title="VGA Switcheroo" href="vga-switcheroo.html"/>
        <link rel="prev" title="Userland interfaces" href="drm-uapi.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.10.0-rc8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">drm/i915 Intel GFX Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#core-driver-infrastructure">Core Driver Infrastructure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#runtime-power-management">Runtime Power Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-handling">Interrupt Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#intel-gvt-g-guest-support-vgpu">Intel GVT-g Guest Support(vGPU)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#intel-gvt-g-host-support-vgpu-device-model">Intel GVT-g Host Support(vGPU device model)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#display-hardware-handling">Display Hardware Handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mode-setting-infrastructure">Mode Setting Infrastructure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#frontbuffer-tracking">Frontbuffer Tracking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#display-fifo-underrun-reporting">Display FIFO Underrun Reporting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plane-configuration">Plane Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-plane-helpers">Atomic Plane Helpers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#output-probing">Output Probing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hotplug">Hotplug</a></li>
<li class="toctree-l4"><a class="reference internal" href="#high-definition-audio">High Definition Audio</a></li>
<li class="toctree-l4"><a class="reference internal" href="#panel-self-refresh-psr-psr-srd">Panel Self Refresh PSR (PSR/SRD)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#frame-buffer-compression-fbc">Frame Buffer Compression (FBC)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#display-refresh-rate-switching-drrs">Display Refresh Rate Switching (DRRS)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dpio">DPIO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#csr-firmware-support-for-dmc">CSR firmware support for DMC</a></li>
<li class="toctree-l4"><a class="reference internal" href="#video-bios-table-vbt">Video BIOS Table (VBT)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#memory-management-and-command-submission">Memory Management and Command Submission</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#batchbuffer-parsing">Batchbuffer Parsing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#batchbuffer-pools">Batchbuffer Pools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#logical-rings-logical-ring-contexts-and-execlists">Logical Rings, Logical Ring Contexts and Execlists</a></li>
<li class="toctree-l4"><a class="reference internal" href="#global-gtt-views">Global GTT views</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gtt-fences-and-swizzling">GTT Fences and Swizzling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#object-tiling-ioctls">Object Tiling IOCTLs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-object-eviction">Buffer Object Eviction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-object-memory-shrinking">Buffer Object Memory Shrinking</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#guc">GuC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#guc-specific-firmware-loader">GuC-specific firmware loader</a></li>
<li class="toctree-l4"><a class="reference internal" href="#guc-based-command-submission">GuC-based command submission</a></li>
<li class="toctree-l4"><a class="reference internal" href="#guc-firmware-layout">GuC Firmware Layout</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tracing">Tracing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i915-ppgtt-create-and-i915-ppgtt-release">i915_ppgtt_create and i915_ppgtt_release</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i915-context-create-and-i915-context-free">i915_context_create and i915_context_free</a></li>
<li class="toctree-l4"><a class="reference internal" href="#switch-mm">switch_mm</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
      
    <li>drm/i915 Intel GFX Driver</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/gpu/i915.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="drm-i915-intel-gfx-driver">
<h1>drm/i915 Intel GFX Driver<a class="headerlink" href="#drm-i915-intel-gfx-driver" title="Permalink to this headline">Â¶</a></h1>
<p>The drm/i915 driver supports all (with the exception of some very early
models) integrated GFX chipsets with both Intel display and rendering
blocks. This excludes a set of SoC platforms with an SGX rendering unit,
those have basic support through the gma500 drm driver.</p>
<div class="section" id="core-driver-infrastructure">
<h2>Core Driver Infrastructure<a class="headerlink" href="#core-driver-infrastructure" title="Permalink to this headline">Â¶</a></h2>
<p>This section covers core driver infrastructure used by both the display
and the GEM parts of the driver.</p>
<div class="section" id="runtime-power-management">
<h3>Runtime Power Management<a class="headerlink" href="#runtime-power-management" title="Permalink to this headline">Â¶</a></h3>
<p>The i915 driver supports dynamic enabling and disabling of entire hardware
blocks at runtime. This is especially important on the display side where
software is supposed to control many power gates manually on recent hardware,
since on the GT side a lot of the power management is done by the hardware.
But even there some manual control at the device level is required.</p>
<p>Since i915 supports a diverse set of platforms with a unified codebase and
hardware engineers just love to shuffle functionality around between power
domains there&#8217;s a sizeable amount of indirection required. This file provides
generic functions to the driver for grabbing and releasing references for
abstract power domains. It then maps those to the actual power wells
present for a given platform.</p>
<dl class="function">
<dt id="c.__intel_display_power_is_enabled">
bool <code class="descname">__intel_display_power_is_enabled</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum intel_display_power_domain<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__intel_display_power_is_enabled" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unlocked check for a power domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">intel_display_power_domain</span> <span class="pre">domain</span></code></dt>
<dd>power domain to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the unlocked version of <a class="reference internal" href="#c.intel_display_power_is_enabled" title="intel_display_power_is_enabled"><code class="xref c c-func docutils literal"><span class="pre">intel_display_power_is_enabled()</span></code></a> and should
only be used from error capture and recovery code where deadlocks are
possible.</p>
<p><strong>Return</strong></p>
<p>True when the power domain is enabled, false otherwise.</p>
<dl class="function">
<dt id="c.intel_display_power_is_enabled">
bool <code class="descname">intel_display_power_is_enabled</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum intel_display_power_domain<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_display_power_is_enabled" title="Permalink to this definition">Â¶</a></dt>
<dd><p>check for a power domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">intel_display_power_domain</span> <span class="pre">domain</span></code></dt>
<dd>power domain to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used to check the hw power domain state. It is mostly
used in hardware state readout functions. Everywhere else code should rely
upon explicit power domain reference counting to ensure that the hardware
block is powered up before accessing it.</p>
<p>Callers must hold the relevant modesetting locks to ensure that concurrent
threads can&#8217;t disable the power well while the caller tries to read a few
registers.</p>
<p><strong>Return</strong></p>
<p>True when the power domain is enabled, false otherwise.</p>
<dl class="function">
<dt id="c.intel_display_set_init_power">
void <code class="descname">intel_display_set_init_power</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, bool<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_display_set_init_power" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set the initial power domain state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">enable</span></code></dt>
<dd>whether to enable or disable the initial power domain state</dd>
</dl>
<p><strong>Description</strong></p>
<p>For simplicity our driver load/unload and system suspend/resume code assumes
that all power domains are always enabled. This functions controls the state
of this little hack. While the initial power domain state is enabled runtime
pm is effectively disabled.</p>
<dl class="function">
<dt id="c.intel_display_power_get">
void <code class="descname">intel_display_power_get</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum intel_display_power_domain<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_display_power_get" title="Permalink to this definition">Â¶</a></dt>
<dd><p>grab a power domain reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">intel_display_power_domain</span> <span class="pre">domain</span></code></dt>
<dd>power domain to reference</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function grabs a power domain reference for <strong>domain</strong> and ensures that the
power domain and all its parents are powered up. Therefore users should only
grab a reference to the innermost power domain they need.</p>
<p>Any power domain reference obtained by this function must have a symmetric
call to <a class="reference internal" href="#c.intel_display_power_put" title="intel_display_power_put"><code class="xref c c-func docutils literal"><span class="pre">intel_display_power_put()</span></code></a> to release the reference again.</p>
<dl class="function">
<dt id="c.intel_display_power_get_if_enabled">
bool <code class="descname">intel_display_power_get_if_enabled</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum intel_display_power_domain<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_display_power_get_if_enabled" title="Permalink to this definition">Â¶</a></dt>
<dd><p>grab a reference for an enabled display power domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">intel_display_power_domain</span> <span class="pre">domain</span></code></dt>
<dd>power domain to reference</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function grabs a power domain reference for <strong>domain</strong> and ensures that the
power domain and all its parents are powered up. Therefore users should only
grab a reference to the innermost power domain they need.</p>
<p>Any power domain reference obtained by this function must have a symmetric
call to <a class="reference internal" href="#c.intel_display_power_put" title="intel_display_power_put"><code class="xref c c-func docutils literal"><span class="pre">intel_display_power_put()</span></code></a> to release the reference again.</p>
<dl class="function">
<dt id="c.intel_display_power_put">
void <code class="descname">intel_display_power_put</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum intel_display_power_domain<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_display_power_put" title="Permalink to this definition">Â¶</a></dt>
<dd><p>release a power domain reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">intel_display_power_domain</span> <span class="pre">domain</span></code></dt>
<dd>power domain to reference</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function drops the power domain reference obtained by
<a class="reference internal" href="#c.intel_display_power_get" title="intel_display_power_get"><code class="xref c c-func docutils literal"><span class="pre">intel_display_power_get()</span></code></a> and might power down the corresponding hardware
block right away if this is the last reference.</p>
<dl class="function">
<dt id="c.intel_power_domains_init">
int <code class="descname">intel_power_domains_init</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_power_domains_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initializes the power domain structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the power domain structures for <strong>dev_priv</strong> depending upon the
supported platform.</p>
<dl class="function">
<dt id="c.intel_power_domains_fini">
void <code class="descname">intel_power_domains_fini</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_power_domains_fini" title="Permalink to this definition">Â¶</a></dt>
<dd><p>finalizes the power domain structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finalizes the power domain structures for <strong>dev_priv</strong> depending upon the
supported platform. This function also disables runtime pm and ensures that
the device stays powered up so that the driver can be reloaded.</p>
<dl class="function">
<dt id="c.intel_power_domains_init_hw">
void <code class="descname">intel_power_domains_init_hw</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, bool<em>&nbsp;resume</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_power_domains_init_hw" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize hardware power domain state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">resume</span></code></dt>
<dd>Called from resume code paths or not</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes the hardware power domain state and enables all
power domains using <a class="reference internal" href="#c.intel_display_set_init_power" title="intel_display_set_init_power"><code class="xref c c-func docutils literal"><span class="pre">intel_display_set_init_power()</span></code></a>.</p>
<dl class="function">
<dt id="c.intel_power_domains_suspend">
void <code class="descname">intel_power_domains_suspend</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_power_domains_suspend" title="Permalink to this definition">Â¶</a></dt>
<dd><p>suspend power domain state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prepares the hardware power domain state before entering
system suspend. It must be paired with <a class="reference internal" href="#c.intel_power_domains_init_hw" title="intel_power_domains_init_hw"><code class="xref c c-func docutils literal"><span class="pre">intel_power_domains_init_hw()</span></code></a>.</p>
<dl class="function">
<dt id="c.intel_runtime_pm_get">
void <code class="descname">intel_runtime_pm_get</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_get" title="Permalink to this definition">Â¶</a></dt>
<dd><p>grab a runtime pm reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function grabs a device-level runtime pm reference (mostly used for GEM
code to ensure the GTT or GT is on) and ensures that it is powered up.</p>
<p>Any runtime pm reference obtained by this function must have a symmetric
call to <a class="reference internal" href="#c.intel_runtime_pm_put" title="intel_runtime_pm_put"><code class="xref c c-func docutils literal"><span class="pre">intel_runtime_pm_put()</span></code></a> to release the reference again.</p>
<dl class="function">
<dt id="c.intel_runtime_pm_get_if_in_use">
bool <code class="descname">intel_runtime_pm_get_if_in_use</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_get_if_in_use" title="Permalink to this definition">Â¶</a></dt>
<dd><p>grab a runtime pm reference if device in use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function grabs a device-level runtime pm reference if the device is
already in use and ensures that it is powered up.</p>
<p>Any runtime pm reference obtained by this function must have a symmetric
call to <a class="reference internal" href="#c.intel_runtime_pm_put" title="intel_runtime_pm_put"><code class="xref c c-func docutils literal"><span class="pre">intel_runtime_pm_put()</span></code></a> to release the reference again.</p>
<dl class="function">
<dt id="c.intel_runtime_pm_get_noresume">
void <code class="descname">intel_runtime_pm_get_noresume</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_get_noresume" title="Permalink to this definition">Â¶</a></dt>
<dd><p>grab a runtime pm reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function grabs a device-level runtime pm reference (mostly used for GEM
code to ensure the GTT or GT is on).</p>
<p>It will _not_ power up the device but instead only check that it&#8217;s powered
on.  Therefore it is only valid to call this functions from contexts where
the device is known to be powered up and where trying to power it up would
result in hilarity and deadlocks. That pretty much means only the system
suspend/resume code where this is used to grab runtime pm references for
delayed setup down in work items.</p>
<p>Any runtime pm reference obtained by this function must have a symmetric
call to <a class="reference internal" href="#c.intel_runtime_pm_put" title="intel_runtime_pm_put"><code class="xref c c-func docutils literal"><span class="pre">intel_runtime_pm_put()</span></code></a> to release the reference again.</p>
<dl class="function">
<dt id="c.intel_runtime_pm_put">
void <code class="descname">intel_runtime_pm_put</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_put" title="Permalink to this definition">Â¶</a></dt>
<dd><p>release a runtime pm reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function drops the device-level runtime pm reference obtained by
<a class="reference internal" href="#c.intel_runtime_pm_get" title="intel_runtime_pm_get"><code class="xref c c-func docutils literal"><span class="pre">intel_runtime_pm_get()</span></code></a> and might power down the corresponding
hardware block right away if this is the last reference.</p>
<dl class="function">
<dt id="c.intel_runtime_pm_enable">
void <code class="descname">intel_runtime_pm_enable</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_enable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>enable runtime pm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables runtime pm at the end of the driver load sequence.</p>
<p>Note that this function does currently not enable runtime pm for the
subordinate display power domains. That is only done on the first modeset
using <a class="reference internal" href="#c.intel_display_set_init_power" title="intel_display_set_init_power"><code class="xref c c-func docutils literal"><span class="pre">intel_display_set_init_power()</span></code></a>.</p>
<dl class="function">
<dt id="c.intel_uncore_forcewake_get">
void <code class="descname">intel_uncore_forcewake_get</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum forcewake_domains<em>&nbsp;fw_domains</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_get" title="Permalink to this definition">Â¶</a></dt>
<dd><p>grab forcewake domain references</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">forcewake_domains</span> <span class="pre">fw_domains</span></code></dt>
<dd>forcewake domains to get reference on</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used get GT&#8217;s forcewake domain references.
Normal register access will handle the forcewake domains automatically.
However if some sequence requires the GT to not power down a particular
forcewake domains this function should be called at the beginning of the
sequence. And subsequently the reference should be dropped by symmetric
call to <code class="xref c c-func docutils literal"><span class="pre">intel_unforce_forcewake_put()</span></code>. Usually caller wants all the domains
to be kept awake so the <strong>fw_domains</strong> would be then FORCEWAKE_ALL.</p>
<dl class="function">
<dt id="c.intel_uncore_forcewake_get__locked">
void <code class="descname">intel_uncore_forcewake_get__locked</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum forcewake_domains<em>&nbsp;fw_domains</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_get__locked" title="Permalink to this definition">Â¶</a></dt>
<dd><p>grab forcewake domain references</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">forcewake_domains</span> <span class="pre">fw_domains</span></code></dt>
<dd>forcewake domains to get reference on</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.intel_uncore_forcewake_get" title="intel_uncore_forcewake_get"><code class="xref c c-func docutils literal"><span class="pre">intel_uncore_forcewake_get()</span></code></a>. This variant places the onus
on the caller to explicitly handle the dev_priv-&gt;uncore.lock spinlock.</p>
<dl class="function">
<dt id="c.intel_uncore_forcewake_put">
void <code class="descname">intel_uncore_forcewake_put</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum forcewake_domains<em>&nbsp;fw_domains</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_put" title="Permalink to this definition">Â¶</a></dt>
<dd><p>release a forcewake domain reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">forcewake_domains</span> <span class="pre">fw_domains</span></code></dt>
<dd>forcewake domains to put references</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function drops the device-level forcewakes for specified
domains obtained by <a class="reference internal" href="#c.intel_uncore_forcewake_get" title="intel_uncore_forcewake_get"><code class="xref c c-func docutils literal"><span class="pre">intel_uncore_forcewake_get()</span></code></a>.</p>
<dl class="function">
<dt id="c.intel_uncore_forcewake_put__locked">
void <code class="descname">intel_uncore_forcewake_put__locked</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum forcewake_domains<em>&nbsp;fw_domains</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_put__locked" title="Permalink to this definition">Â¶</a></dt>
<dd><p>grab forcewake domain references</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">forcewake_domains</span> <span class="pre">fw_domains</span></code></dt>
<dd>forcewake domains to get reference on</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.intel_uncore_forcewake_put" title="intel_uncore_forcewake_put"><code class="xref c c-func docutils literal"><span class="pre">intel_uncore_forcewake_put()</span></code></a>. This variant places the onus
on the caller to explicitly handle the dev_priv-&gt;uncore.lock spinlock.</p>
<dl class="function">
<dt id="c.gen6_reset_engines">
int <code class="descname">gen6_reset_engines</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned<em>&nbsp;engine_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen6_reset_engines" title="Permalink to this definition">Â¶</a></dt>
<dd><p>reset individual engines</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">engine_mask</span></code></dt>
<dd>mask of <code class="xref c c-func docutils literal"><span class="pre">intel_ring_flag()</span></code> engines or ALL_ENGINES for full reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will reset the individual engines that are set in engine_mask.
If you provide ALL_ENGINES as mask, full global domain reset will be issued.</p>
<p><strong>Note</strong></p>
<p>It is responsibility of the caller to handle the difference between
asking full domain reset versus reset for all available individual engines.</p>
<p>Returns 0 on success, nonzero on error.</p>
<dl class="function">
<dt id="c.intel_wait_for_register_fw">
int <code class="descname">intel_wait_for_register_fw</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, i915_reg_t<em>&nbsp;reg</em>, const u32<em>&nbsp;mask</em>, const u32<em>&nbsp;value</em>, const unsigned long<em>&nbsp;timeout_ms</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_wait_for_register_fw" title="Permalink to this definition">Â¶</a></dt>
<dd><p>wait until register matches expected state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>the i915 device</dd>
<dt><code class="docutils literal"><span class="pre">i915_reg_t</span> <span class="pre">reg</span></code></dt>
<dd>the register to read</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">mask</span></code></dt>
<dd>mask to apply to register value</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">value</span></code></dt>
<dd>expected value</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout_ms</span></code></dt>
<dd>timeout in millisecond</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine waits until the target register <strong>reg</strong> contains the expected
<strong>value</strong> after applying the <strong>mask</strong>, i.e. it waits until</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>(I915_READ_FW(reg) &amp; mask) == value
</pre></div>
</div>
<p>Otherwise, the wait will timeout after <strong>timeout_ms</strong> milliseconds.</p>
<p>Note that this routine assumes the caller holds forcewake asserted, it is
not suitable for very long waits. See <a class="reference internal" href="#c.intel_wait_for_register" title="intel_wait_for_register"><code class="xref c c-func docutils literal"><span class="pre">intel_wait_for_register()</span></code></a> if you
wish to wait without holding forcewake for the duration (i.e. you expect
the wait to be slow).</p>
<p>Returns 0 if the register matches the desired condition, or -ETIMEOUT.</p>
<dl class="function">
<dt id="c.intel_wait_for_register">
int <code class="descname">intel_wait_for_register</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, i915_reg_t<em>&nbsp;reg</em>, const u32<em>&nbsp;mask</em>, const u32<em>&nbsp;value</em>, const unsigned long<em>&nbsp;timeout_ms</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_wait_for_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>wait until register matches expected state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>the i915 device</dd>
<dt><code class="docutils literal"><span class="pre">i915_reg_t</span> <span class="pre">reg</span></code></dt>
<dd>the register to read</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">mask</span></code></dt>
<dd>mask to apply to register value</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">value</span></code></dt>
<dd>expected value</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout_ms</span></code></dt>
<dd>timeout in millisecond</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine waits until the target register <strong>reg</strong> contains the expected
<strong>value</strong> after applying the <strong>mask</strong>, i.e. it waits until</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>(I915_READ(reg) &amp; mask) == value
</pre></div>
</div>
<p>Otherwise, the wait will timeout after <strong>timeout_ms</strong> milliseconds.</p>
<p>Returns 0 if the register matches the desired condition, or -ETIMEOUT.</p>
<dl class="function">
<dt id="c.intel_uncore_forcewake_for_reg">
enum forcewake_domains <code class="descname">intel_uncore_forcewake_for_reg</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, i915_reg_t<em>&nbsp;reg</em>, unsigned int<em>&nbsp;op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_uncore_forcewake_for_reg" title="Permalink to this definition">Â¶</a></dt>
<dd><p>which forcewake domains are needed to access a register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>pointer to struct drm_i915_private</dd>
<dt><code class="docutils literal"><span class="pre">i915_reg_t</span> <span class="pre">reg</span></code></dt>
<dd>register in question</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt>
<dd>operation bitmask of FW_REG_READ and/or FW_REG_WRITE</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a set of forcewake domains required to be taken with for example
intel_uncore_forcewake_get for the specified register to be accessible in the
specified mode (read, write or read/write) with raw mmio accessors.</p>
<p><strong>NOTE</strong></p>
<p>On Gen6 and Gen7 write forcewake domain (FORCEWAKE_RENDER) requires the
callers to do FIFO management on their own or risk losing writes.</p>
</div>
<div class="section" id="interrupt-handling">
<h3>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">Â¶</a></h3>
<p>These functions provide the basic support for enabling and disabling the
interrupt handling support. There&#8217;s a lot more functionality in i915_irq.c
and related files, but that will be described in separate chapters.</p>
<dl class="function">
<dt id="c.intel_irq_init">
void <code class="descname">intel_irq_init</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_irq_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initializes irq support</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes all the irq support including work items, timers
and all the vtables. It does not setup the interrupt itself though.</p>
<dl class="function">
<dt id="c.intel_runtime_pm_disable_interrupts">
void <code class="descname">intel_runtime_pm_disable_interrupts</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_disable_interrupts" title="Permalink to this definition">Â¶</a></dt>
<dd><p>runtime interrupt disabling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to disable interrupts at runtime, both in the runtime
pm and the system suspend/resume code.</p>
<dl class="function">
<dt id="c.intel_runtime_pm_enable_interrupts">
void <code class="descname">intel_runtime_pm_enable_interrupts</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_runtime_pm_enable_interrupts" title="Permalink to this definition">Â¶</a></dt>
<dd><p>runtime interrupt enabling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to enable interrupts at runtime, both in the runtime
pm and the system suspend/resume code.</p>
</div>
<div class="section" id="intel-gvt-g-guest-support-vgpu">
<h3>Intel GVT-g Guest Support(vGPU)<a class="headerlink" href="#intel-gvt-g-guest-support-vgpu" title="Permalink to this headline">Â¶</a></h3>
<p>Intel GVT-g is a graphics virtualization technology which shares the
GPU among multiple virtual machines on a time-sharing basis. Each
virtual machine is presented a virtual GPU (vGPU), which has equivalent
features as the underlying physical GPU (pGPU), so i915 driver can run
seamlessly in a virtual machine. This file provides vGPU specific
optimizations when running in a virtual machine, to reduce the complexity
of vGPU emulation and to improve the overall performance.</p>
<p>A primary function introduced here is so-called &#8220;address space ballooning&#8221;
technique. Intel GVT-g partitions global graphics memory among multiple VMs,
so each VM can directly access a portion of the memory without hypervisor&#8217;s
intervention, e.g. filling textures or queuing commands. However with the
partitioning an unmodified i915 driver would assume a smaller graphics
memory starting from address ZERO, then requires vGPU emulation module to
translate the graphics address between &#8216;guest view&#8217; and &#8216;host view&#8217;, for
all registers and command opcodes which contain a graphics memory address.
To reduce the complexity, Intel GVT-g introduces &#8220;address space ballooning&#8221;,
by telling the exact partitioning knowledge to each guest i915 driver, which
then reserves and prevents non-allocated portions from allocation. Thus vGPU
emulation module only needs to scan and validate graphics addresses without
complexity of address translation.</p>
<dl class="function">
<dt id="c.i915_check_vgpu">
void <code class="descname">i915_check_vgpu</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_check_vgpu" title="Permalink to this definition">Â¶</a></dt>
<dd><p>detect virtual GPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device private</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the initialization stage, to detect whether
running on a vGPU.</p>
<dl class="function">
<dt id="c.intel_vgt_deballoon">
void <code class="descname">intel_vgt_deballoon</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_vgt_deballoon" title="Permalink to this definition">Â¶</a></dt>
<dd><p>deballoon reserved graphics address trunks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device private data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called to deallocate the ballooned-out graphic memory, when
driver is unloaded or when ballooning fails.</p>
<dl class="function">
<dt id="c.intel_vgt_balloon">
int <code class="descname">intel_vgt_balloon</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_vgt_balloon" title="Permalink to this definition">Â¶</a></dt>
<dd><p>balloon out reserved graphics address trunks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device private data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the initialization stage, to balloon out the
graphic address space allocated to other vGPUs, by marking these spaces as
reserved. The ballooning related knowledge(starting address and size of
the mappable/unmappable graphic memory) is described in the vgt_if structure
in a reserved mmio range.</p>
<p>To give an example, the drawing below depicts one typical scenario after
ballooning. Here the vGPU1 has 2 pieces of graphic address spaces ballooned
out each for the mappable and the non-mappable part. From the vGPU1 point of
view, the total size is the same as the physical one, with the start address
of its graphic space being zero. Yet there are some portions ballooned out(
the shadow part, which are marked as reserved by drm allocator). From the
host point of view, the graphic address space is partitioned by multiple
vGPUs in different VMs.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>                       vGPU1 view         Host view
            0 ------&gt; +-----------+     +-----------+
              ^       |###########|     |   vGPU3   |
              |       |###########|     +-----------+
              |       |###########|     |   vGPU2   |
              |       +-----------+     +-----------+
       mappable GM    | available | ==&gt; |   vGPU1   |
              |       +-----------+     +-----------+
              |       |###########|     |           |
              v       |###########|     |   Host    |
              +=======+===========+     +===========+
              ^       |###########|     |   vGPU3   |
              |       |###########|     +-----------+
              |       |###########|     |   vGPU2   |
              |       +-----------+     +-----------+
     unmappable GM    | available | ==&gt; |   vGPU1   |
              |       +-----------+     +-----------+
              |       |###########|     |           |
              |       |###########|     |   Host    |
              v       |###########|     |           |
total GM size ------&gt; +-----------+     +-----------+
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>zero on success, non-zero if configuration invalid or ballooning failed</p>
</div>
<div class="section" id="intel-gvt-g-host-support-vgpu-device-model">
<h3>Intel GVT-g Host Support(vGPU device model)<a class="headerlink" href="#intel-gvt-g-host-support-vgpu-device-model" title="Permalink to this headline">Â¶</a></h3>
<p>Intel GVT-g is a graphics virtualization technology which shares the
GPU among multiple virtual machines on a time-sharing basis. Each
virtual machine is presented a virtual GPU (vGPU), which has equivalent
features as the underlying physical GPU (pGPU), so i915 driver can run
seamlessly in a virtual machine.</p>
<p>To virtualize GPU resources GVT-g driver depends on hypervisor technology
e.g KVM/VFIO/mdev, Xen, etc. to provide resource access trapping capability
and be virtualized within GVT-g device module. More architectural design
doc is available on <a class="reference external" href="https://01.org/group/2230/documentation-list">https://01.org/group/2230/documentation-list</a>.</p>
<dl class="function">
<dt id="c.intel_gvt_init">
int <code class="descname">intel_gvt_init</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_gvt_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize GVT components</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>drm i915 private data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the initialization stage to create a GVT device.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code if failed.</p>
<dl class="function">
<dt id="c.intel_gvt_cleanup">
void <code class="descname">intel_gvt_cleanup</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_gvt_cleanup" title="Permalink to this definition">Â¶</a></dt>
<dd><p>cleanup GVT components when i915 driver is unloading</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>drm i915 private *</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the i915 driver unloading stage, to shutdown
GVT components and release the related resources.</p>
</div>
</div>
<div class="section" id="display-hardware-handling">
<h2>Display Hardware Handling<a class="headerlink" href="#display-hardware-handling" title="Permalink to this headline">Â¶</a></h2>
<p>This section covers everything related to the display hardware including
the mode setting infrastructure, plane, sprite and cursor handling and
display, output probing and related topics.</p>
<div class="section" id="mode-setting-infrastructure">
<h3>Mode Setting Infrastructure<a class="headerlink" href="#mode-setting-infrastructure" title="Permalink to this headline">Â¶</a></h3>
<p>The i915 driver is thus far the only DRM driver which doesn&#8217;t use the
common DRM helper code to implement mode setting sequences. Thus it has
its own tailor-made infrastructure for executing a display configuration
change.</p>
</div>
<div class="section" id="frontbuffer-tracking">
<h3>Frontbuffer Tracking<a class="headerlink" href="#frontbuffer-tracking" title="Permalink to this headline">Â¶</a></h3>
<p>Many features require us to track changes to the currently active
frontbuffer, especially rendering targeted at the frontbuffer.</p>
<p>To be able to do so GEM tracks frontbuffers using a bitmask for all possible
frontbuffer slots through <a class="reference internal" href="#c.i915_gem_track_fb" title="i915_gem_track_fb"><code class="xref c c-func docutils literal"><span class="pre">i915_gem_track_fb()</span></code></a>. The function in this file are
then called when the contents of the frontbuffer are invalidated, when
frontbuffer rendering has stopped again to flush out all the changes and when
the frontbuffer is exchanged with a flip. Subsystems interested in
frontbuffer changes (e.g. PSR, FBC, DRRS) should directly put their callbacks
into the relevant places and filter for the frontbuffer slots that they are
interested int.</p>
<p>On a high level there are two types of powersaving features. The first one
work like a special cache (FBC and PSR) and are interested when they should
stop caching and when to restart caching. This is done by placing callbacks
into the invalidate and the flush functions: At invalidate the caching must
be stopped and at flush time it can be restarted. And maybe they need to know
when the frontbuffer changes (e.g. when the hw doesn&#8217;t initiate an invalidate
and flush on its own) which can be achieved with placing callbacks into the
flip functions.</p>
<p>The other type of display power saving feature only cares about busyness
(e.g. DRRS). In that case all three (invalidate, flush and flip) indicate
busyness. There is no direct way to detect idleness. Instead an idle timer
work delayed work should be started from the flush and flip functions and
cancelled as soon as busyness is detected.</p>
<p>Note that there&#8217;s also an older frontbuffer activity tracking scheme which
just tracks general activity. This is done by the various mark_busy and
mark_idle functions. For display power management features using these
functions is deprecated and should be avoided.</p>
<dl class="function">
<dt id="c.intel_fb_obj_invalidate">
bool <code class="descname">intel_fb_obj_invalidate</code><span class="sig-paren">(</span>struct drm_i915_gem_object *<em>&nbsp;obj</em>, enum fb_op_origin<em>&nbsp;origin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fb_obj_invalidate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>invalidate frontbuffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM object to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">fb_op_origin</span> <span class="pre">origin</span></code></dt>
<dd>which operation caused the invalidation</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called every time rendering on the given object starts and
frontbuffer caching (fbc, low refresh rate for DRRS, panel self refresh) must
be invalidated. For ORIGIN_CS any subsequent invalidation will be delayed
until the rendering completes or a flip on this frontbuffer plane is
scheduled.</p>
<dl class="function">
<dt id="c.intel_fb_obj_flush">
void <code class="descname">intel_fb_obj_flush</code><span class="sig-paren">(</span>struct drm_i915_gem_object *<em>&nbsp;obj</em>, bool<em>&nbsp;retire</em>, enum fb_op_origin<em>&nbsp;origin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fb_obj_flush" title="Permalink to this definition">Â¶</a></dt>
<dd><p>flush frontbuffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM object to flush</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">retire</span></code></dt>
<dd>set when retiring asynchronous rendering</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">fb_op_origin</span> <span class="pre">origin</span></code></dt>
<dd>which operation caused the flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called every time rendering on the given object has
completed and frontbuffer caching can be started again. If <strong>retire</strong> is true
then any delayed flushes will be unblocked.</p>
<dl class="function">
<dt id="c.intel_frontbuffer_flush">
void <code class="descname">intel_frontbuffer_flush</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned<em>&nbsp;frontbuffer_bits</em>, enum fb_op_origin<em>&nbsp;origin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_frontbuffer_flush" title="Permalink to this definition">Â¶</a></dt>
<dd><p>flush frontbuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt>
<dd>frontbuffer plane tracking bits</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">fb_op_origin</span> <span class="pre">origin</span></code></dt>
<dd>which operation caused the flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called every time rendering on the given planes has
completed and frontbuffer caching can be started again. Flushes will get
delayed if they&#8217;re blocked by some outstanding asynchronous rendering.</p>
<p>Can be called without any locks held.</p>
<dl class="function">
<dt id="c.intel_frontbuffer_flip_prepare">
void <code class="descname">intel_frontbuffer_flip_prepare</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned<em>&nbsp;frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_frontbuffer_flip_prepare" title="Permalink to this definition">Â¶</a></dt>
<dd><p>prepare asynchronous frontbuffer flip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt>
<dd>frontbuffer plane tracking bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called after scheduling a flip on <strong>obj</strong>. The actual
frontbuffer flushing will be delayed until completion is signalled with
intel_frontbuffer_flip_complete. If an invalidate happens in between this
flush will be cancelled.</p>
<p>Can be called without any locks held.</p>
<dl class="function">
<dt id="c.intel_frontbuffer_flip_complete">
void <code class="descname">intel_frontbuffer_flip_complete</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned<em>&nbsp;frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_frontbuffer_flip_complete" title="Permalink to this definition">Â¶</a></dt>
<dd><p>complete asynchronous frontbuffer flip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt>
<dd>frontbuffer plane tracking bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called after the flip has been latched and will complete
on the next vblank. It will execute the flush if it hasn&#8217;t been cancelled yet.</p>
<p>Can be called without any locks held.</p>
<dl class="function">
<dt id="c.intel_frontbuffer_flip">
void <code class="descname">intel_frontbuffer_flip</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned<em>&nbsp;frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_frontbuffer_flip" title="Permalink to this definition">Â¶</a></dt>
<dd><p>synchronous frontbuffer flip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt>
<dd>frontbuffer plane tracking bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called after scheduling a flip on <strong>obj</strong>. This is for
synchronous plane updates which will happen on the next vblank and which will
not get delayed by pending gpu rendering.</p>
<p>Can be called without any locks held.</p>
<dl class="function">
<dt id="c.i915_gem_track_fb">
void <code class="descname">i915_gem_track_fb</code><span class="sig-paren">(</span>struct drm_i915_gem_object *<em>&nbsp;old</em>, struct drm_i915_gem_object *<em>&nbsp;new</em>, unsigned<em>&nbsp;frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_track_fb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>update frontbuffer tracking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_gem_object</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>current GEM buffer for the frontbuffer slots</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_gem_object</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new GEM buffer for the frontbuffer slots</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt>
<dd>bitmask of frontbuffer slots</dd>
</dl>
<p><strong>Description</strong></p>
<p>This updates the frontbuffer tracking bits <strong>frontbuffer_bits</strong> by clearing them
from <strong>old</strong> and setting them in <strong>new</strong>. Both <strong>old</strong> and <strong>new</strong> can be NULL.</p>
</div>
<div class="section" id="display-fifo-underrun-reporting">
<h3>Display FIFO Underrun Reporting<a class="headerlink" href="#display-fifo-underrun-reporting" title="Permalink to this headline">Â¶</a></h3>
<p>The i915 driver checks for display fifo underruns using the interrupt signals
provided by the hardware. This is enabled by default and fairly useful to
debug display issues, especially watermark settings.</p>
<p>If an underrun is detected this is logged into dmesg. To avoid flooding logs
and occupying the cpu underrun interrupts are disabled after the first
occurrence until the next modeset on a given pipe.</p>
<p>Note that underrun detection on gmch platforms is a bit more ugly since there
is no interrupt (despite that the signalling bit is in the PIPESTAT pipe
interrupt register). Also on some other platforms underrun interrupts are
shared, which means that if we detect an underrun we need to disable underrun
reporting on all pipes.</p>
<p>The code also supports underrun detection on the PCH transcoder.</p>
<dl class="function">
<dt id="c.intel_set_cpu_fifo_underrun_reporting">
bool <code class="descname">intel_set_cpu_fifo_underrun_reporting</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum pipe<em>&nbsp;pipe</em>, bool<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_set_cpu_fifo_underrun_reporting" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set cpu fifo underrrun reporting state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">pipe</span> <span class="pre">pipe</span></code></dt>
<dd>(CPU) pipe to set state for</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">enable</span></code></dt>
<dd>whether underruns should be reported or not</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets the fifo underrun state for <strong>pipe</strong>. It is used in the
modeset code to avoid false positives since on many platforms underruns are
expected when disabling or enabling the pipe.</p>
<p>Notice that on some platforms disabling underrun reports for one pipe
disables for all due to shared interrupts. Actual reporting is still per-pipe
though.</p>
<p>Returns the previous state of underrun reporting.</p>
<dl class="function">
<dt id="c.intel_set_pch_fifo_underrun_reporting">
bool <code class="descname">intel_set_pch_fifo_underrun_reporting</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum transcoder<em>&nbsp;pch_transcoder</em>, bool<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_set_pch_fifo_underrun_reporting" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set PCH fifo underrun reporting state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">transcoder</span> <span class="pre">pch_transcoder</span></code></dt>
<dd>the PCH transcoder (same as pipe on IVB and older)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">enable</span></code></dt>
<dd>whether underruns should be reported or not</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function makes us disable or enable PCH fifo underruns for a specific
PCH transcoder. Notice that on some PCHs (e.g. CPT/PPT), disabling FIFO
underrun reporting for one transcoder may also disable all the other PCH
error interruts for the other transcoders, due to the fact that there&#8217;s just
one interrupt mask/enable bit for all the transcoders.</p>
<p>Returns the previous state of underrun reporting.</p>
<dl class="function">
<dt id="c.intel_cpu_fifo_underrun_irq_handler">
void <code class="descname">intel_cpu_fifo_underrun_irq_handler</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum pipe<em>&nbsp;pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_cpu_fifo_underrun_irq_handler" title="Permalink to this definition">Â¶</a></dt>
<dd><p>handle CPU fifo underrun interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">pipe</span> <span class="pre">pipe</span></code></dt>
<dd>(CPU) pipe to set state for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This handles a CPU fifo underrun interrupt, generating an underrun warning
into dmesg if underrun reporting is enabled and then disables the underrun
interrupt to avoid an irq storm.</p>
<dl class="function">
<dt id="c.intel_pch_fifo_underrun_irq_handler">
void <code class="descname">intel_pch_fifo_underrun_irq_handler</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum transcoder<em>&nbsp;pch_transcoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_pch_fifo_underrun_irq_handler" title="Permalink to this definition">Â¶</a></dt>
<dd><p>handle PCH fifo underrun interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">transcoder</span> <span class="pre">pch_transcoder</span></code></dt>
<dd>the PCH transcoder (same as pipe on IVB and older)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This handles a PCH fifo underrun interrupt, generating an underrun warning
into dmesg if underrun reporting is enabled and then disables the underrun
interrupt to avoid an irq storm.</p>
<dl class="function">
<dt id="c.intel_check_cpu_fifo_underruns">
void <code class="descname">intel_check_cpu_fifo_underruns</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_check_cpu_fifo_underruns" title="Permalink to this definition">Â¶</a></dt>
<dd><p>check for CPU fifo underruns immediately</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for CPU fifo underruns immediately. Useful on IVB/HSW where the shared
error interrupt may have been disabled, and so CPU fifo underruns won&#8217;t
necessarily raise an interrupt, and on GMCH platforms where underruns never
raise an interrupt.</p>
<dl class="function">
<dt id="c.intel_check_pch_fifo_underruns">
void <code class="descname">intel_check_pch_fifo_underruns</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_check_pch_fifo_underruns" title="Permalink to this definition">Â¶</a></dt>
<dd><p>check for PCH fifo underruns immediately</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for PCH fifo underruns immediately. Useful on CPT/PPT where the shared
error interrupt may have been disabled, and so PCH fifo underruns won&#8217;t
necessarily raise an interrupt.</p>
</div>
<div class="section" id="plane-configuration">
<h3>Plane Configuration<a class="headerlink" href="#plane-configuration" title="Permalink to this headline">Â¶</a></h3>
<p>This section covers plane configuration and composition with the primary
plane, sprites, cursors and overlays. This includes the infrastructure
to do atomic vsync&#8217;ed updates of all this state and also tightly coupled
topics like watermark setup and computation, framebuffer compression and
panel self refresh.</p>
</div>
<div class="section" id="atomic-plane-helpers">
<h3>Atomic Plane Helpers<a class="headerlink" href="#atomic-plane-helpers" title="Permalink to this headline">Â¶</a></h3>
<p>The functions here are used by the atomic plane helper functions to
implement legacy plane updates (i.e., drm_plane-&gt;:c:func:<cite>update_plane()</cite> and
drm_plane-&gt;:c:func:<cite>disable_plane()</cite>).  This allows plane updates to use the
atomic state infrastructure and perform plane updates as separate
prepare/check/commit/cleanup steps.</p>
<dl class="function">
<dt id="c.intel_create_plane_state">
struct intel_plane_state * <code class="descname">intel_create_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_create_plane_state" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create plane state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a fresh plane state for the given plane and sets some of
the state values to sensible initial values.</p>
<p><strong>Return</strong></p>
<p>A newly allocated plane state, or NULL on failure</p>
<dl class="function">
<dt id="c.intel_plane_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">intel_plane_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_plane_duplicate_state" title="Permalink to this definition">Â¶</a></dt>
<dd><p>duplicate plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and returns a copy of the plane state (both common and
Intel-specific) for the specified plane.</p>
<p><strong>Return</strong></p>
<p>The newly allocated plane state, or NULL on failure.</p>
<dl class="function">
<dt id="c.intel_plane_destroy_state">
void <code class="descname">intel_plane_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_plane_destroy_state" title="Permalink to this definition">Â¶</a></dt>
<dd><p>destroy plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>state object to destroy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroys the plane state (both common and Intel-specific) for the
specified plane.</p>
<dl class="function">
<dt id="c.intel_plane_atomic_get_property">
int <code class="descname">intel_plane_atomic_get_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t *<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_plane_atomic_get_property" title="Permalink to this definition">Â¶</a></dt>
<dd><p>fetch plane property value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to fetch property for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>state containing the property value</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to look up</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">val</span></code></dt>
<dd>pointer to write property value into</dd>
</dl>
<p><strong>Description</strong></p>
<p>The DRM core does not store shadow copies of properties for
atomic-capable drivers.  This entrypoint is used to fetch
the current value of a driver-specific plane property.</p>
<dl class="function">
<dt id="c.intel_plane_atomic_set_property">
int <code class="descname">intel_plane_atomic_set_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_plane_atomic_set_property" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set plane property value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to set property for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>state to update property value in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>value to set property to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes the specified property value for a plane into the provided atomic
state object.</p>
<p>Returns 0 on success, -EINVAL on unrecognized properties</p>
</div>
<div class="section" id="output-probing">
<h3>Output Probing<a class="headerlink" href="#output-probing" title="Permalink to this headline">Â¶</a></h3>
<p>This section covers output probing and related infrastructure like the
hotplug interrupt storm detection and mitigation code. Note that the
i915 driver still uses most of the common DRM helper code for output
probing, so those sections fully apply.</p>
</div>
<div class="section" id="hotplug">
<h3>Hotplug<a class="headerlink" href="#hotplug" title="Permalink to this headline">Â¶</a></h3>
<p>Simply put, hotplug occurs when a display is connected to or disconnected
from the system. However, there may be adapters and docking stations and
Display Port short pulses and MST devices involved, complicating matters.</p>
<p>Hotplug in i915 is handled in many different levels of abstraction.</p>
<p>The platform dependent interrupt handling code in i915_irq.c enables,
disables, and does preliminary handling of the interrupts. The interrupt
handlers gather the hotplug detect (HPD) information from relevant registers
into a platform independent mask of hotplug pins that have fired.</p>
<p>The platform independent interrupt handler <a class="reference internal" href="#c.intel_hpd_irq_handler" title="intel_hpd_irq_handler"><code class="xref c c-func docutils literal"><span class="pre">intel_hpd_irq_handler()</span></code></a> in
intel_hotplug.c does hotplug irq storm detection and mitigation, and passes
further processing to appropriate bottom halves (Display Port specific and
regular hotplug).</p>
<p>The Display Port work function <code class="xref c c-func docutils literal"><span class="pre">i915_digport_work_func()</span></code> calls into
<code class="xref c c-func docutils literal"><span class="pre">intel_dp_hpd_pulse()</span></code> via hooks, which handles DP short pulses and DP MST long
pulses, with failures and non-MST long pulses triggering regular hotplug
processing on the connector.</p>
<p>The regular hotplug work function <code class="xref c c-func docutils literal"><span class="pre">i915_hotplug_work_func()</span></code> calls connector
detect hooks, and, if connector status changes, triggers sending of hotplug
uevent to userspace via <a class="reference internal" href="drm-kms-helpers.html#c.drm_kms_helper_hotplug_event" title="drm_kms_helper_hotplug_event"><code class="xref c c-func docutils literal"><span class="pre">drm_kms_helper_hotplug_event()</span></code></a>.</p>
<p>Finally, the userspace is responsible for triggering a modeset upon receiving
the hotplug uevent, disabling or enabling the crtc as needed.</p>
<p>The hotplug interrupt storm detection and mitigation code keeps track of the
number of interrupts per hotplug pin per a period of time, and if the number
of interrupts exceeds a certain threshold, the interrupt is disabled for a
while before being re-enabled. The intention is to mitigate issues raising
from broken hardware triggering massive amounts of interrupts and grinding
the system to a halt.</p>
<p>Current implementation expects that hotplug interrupt storm will not be
seen when display port sink is connected, hence on platforms whose DP
callback is handled by i915_digport_work_func reenabling of hpd is not
performed (it was never expected to be disabled in the first place ;) )
this is specific to DP sinks handled by this routine and any other display
such as HDMI or DVI enabled on the same port will have proper logic since
it will use i915_hotplug_work_func where this logic is handled.</p>
<dl class="function">
<dt id="c.intel_hpd_irq_storm_detect">
bool <code class="descname">intel_hpd_irq_storm_detect</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum hpd_pin<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_hpd_irq_storm_detect" title="Permalink to this definition">Â¶</a></dt>
<dd><p>gather stats and detect HPD irq storm on a pin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>private driver data pointer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">hpd_pin</span> <span class="pre">pin</span></code></dt>
<dd>the pin to gather stats on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gather stats about HPD irqs from the specified <strong>pin</strong>, and detect irq
storms. Only the pin specific stats and state are changed, the caller is
responsible for further action.</p>
<p><strong>HPD_STORM_THRESHOLD</strong> irqs are allowed within <strong>HPD_STORM_DETECT_PERIOD</strong> ms,
otherwise it&#8217;s considered an irq storm, and the irq state is set to
<strong>HPD_MARK_DISABLED</strong>.</p>
<p>Return true if an irq storm was detected on <strong>pin</strong>.</p>
<dl class="function">
<dt id="c.intel_hpd_irq_handler">
void <code class="descname">intel_hpd_irq_handler</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, u32<em>&nbsp;pin_mask</em>, u32<em>&nbsp;long_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_hpd_irq_handler" title="Permalink to this definition">Â¶</a></dt>
<dd><p>main hotplug irq handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>drm_i915_private</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">pin_mask</span></code></dt>
<dd>a mask of hpd pins that have triggered the irq</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">long_mask</span></code></dt>
<dd>a mask of hpd pins that may be long hpd pulses</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the main hotplug irq handler for all platforms. The platform specific
irq handlers call the platform specific hotplug irq handlers, which read and
decode the appropriate registers into bitmasks about hpd pins that have
triggered (<strong>pin_mask</strong>), and which of those pins may be long pulses
(<strong>long_mask</strong>). The <strong>long_mask</strong> is ignored if the port corresponding to the pin
is not a digital port.</p>
<p>Here, we do hotplug irq storm detection and mitigation, and pass further
processing to appropriate bottom halves.</p>
<dl class="function">
<dt id="c.intel_hpd_init">
void <code class="descname">intel_hpd_init</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_hpd_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initializes and enables hpd support</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables the hotplug support. It requires that interrupts have
already been enabled with <code class="xref c c-func docutils literal"><span class="pre">intel_irq_init_hw()</span></code>. From this point on hotplug and
poll request can run concurrently to other code, so locking rules must be
obeyed.</p>
<p>This is a separate step from interrupt enabling to simplify the locking rules
in the driver load and resume code.</p>
<p>Also see: <a class="reference internal" href="#c.intel_hpd_poll_init" title="intel_hpd_poll_init"><code class="xref c c-func docutils literal"><span class="pre">intel_hpd_poll_init()</span></code></a>, which enables connector polling</p>
<dl class="function">
<dt id="c.intel_hpd_poll_init">
void <code class="descname">intel_hpd_poll_init</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_hpd_poll_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>enables/disables polling for connectors with hpd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables polling for all connectors, regardless of whether or
not they support hotplug detection. Under certain conditions HPD may not be
functional. On most Intel GPUs, this happens when we enter runtime suspend.
On Valleyview and Cherryview systems, this also happens when we shut off all
of the powerwells.</p>
<p>Since this function can get called in contexts where we&#8217;re already holding
dev-&gt;mode_config.mutex, we do the actual hotplug enabling in a seperate
worker.</p>
<p>Also see: <a class="reference internal" href="#c.intel_hpd_init" title="intel_hpd_init"><code class="xref c c-func docutils literal"><span class="pre">intel_hpd_init()</span></code></a>, which restores hpd handling.</p>
</div>
<div class="section" id="high-definition-audio">
<h3>High Definition Audio<a class="headerlink" href="#high-definition-audio" title="Permalink to this headline">Â¶</a></h3>
<p>The graphics and audio drivers together support High Definition Audio over
HDMI and Display Port. The audio programming sequences are divided into audio
codec and controller enable and disable sequences. The graphics driver
handles the audio codec sequences, while the audio driver handles the audio
controller sequences.</p>
<p>The disable sequences must be performed before disabling the transcoder or
port. The enable sequences may only be performed after enabling the
transcoder and port, and after completed link training. Therefore the audio
enable/disable sequences are part of the modeset sequence.</p>
<p>The codec and controller sequences could be done either parallel or serial,
but generally the ELDV/PD change in the codec sequence indicates to the audio
driver that the controller sequence should start. Indeed, most of the
co-operation between the graphics and audio drivers is handled via audio
related registers. (The notable exception is the power management, not
covered here.)</p>
<p>The struct <a class="reference internal" href="#c.i915_audio_component" title="i915_audio_component"><code class="xref c c-type docutils literal"><span class="pre">i915_audio_component</span></code></a> is used to interact between the graphics
and audio drivers. The struct <a class="reference internal" href="#c.i915_audio_component_ops" title="i915_audio_component_ops"><code class="xref c c-type docutils literal"><span class="pre">i915_audio_component_ops</span></code></a> <strong>ops</strong> in it is
defined in graphics driver and called in audio driver. The
struct <a class="reference internal" href="#c.i915_audio_component_audio_ops" title="i915_audio_component_audio_ops"><code class="xref c c-type docutils literal"><span class="pre">i915_audio_component_audio_ops</span></code></a> <strong>audio_ops</strong> is called from i915 driver.</p>
<dl class="function">
<dt id="c.intel_audio_codec_enable">
void <code class="descname">intel_audio_codec_enable</code><span class="sig-paren">(</span>struct intel_encoder *<em>&nbsp;intel_encoder</em>, const struct intel_crtc_state *<em>&nbsp;crtc_state</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_audio_codec_enable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Enable the audio codec for HD audio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_encoder</span> <span class="pre">*</span> <span class="pre">intel_encoder</span></code></dt>
<dd>encoder on which to enable audio</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*</span> <span class="pre">crtc_state</span></code></dt>
<dd>pointer to the current crtc state.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt>
<dd>pointer to the current connector state.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The enable sequences may only be performed after enabling the transcoder and
port, and after completed link training.</p>
<dl class="function">
<dt id="c.intel_audio_codec_disable">
void <code class="descname">intel_audio_codec_disable</code><span class="sig-paren">(</span>struct intel_encoder *<em>&nbsp;intel_encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_audio_codec_disable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Disable the audio codec for HD audio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_encoder</span> <span class="pre">*</span> <span class="pre">intel_encoder</span></code></dt>
<dd>encoder on which to disable audio</dd>
</dl>
<p><strong>Description</strong></p>
<p>The disable sequences must be performed before disabling the transcoder or
port.</p>
<dl class="function">
<dt id="c.intel_init_audio_hooks">
void <code class="descname">intel_init_audio_hooks</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_init_audio_hooks" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set up chip specific audio hooks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>device private</dd>
</dl>
<dl class="function">
<dt id="c.i915_audio_component_init">
void <code class="descname">i915_audio_component_init</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_audio_component_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize and register the audio component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will register with the component framework a child component which
will bind dynamically to the snd_hda_intel driver&#8217;s corresponding master
component when the latter is registered. During binding the child
initializes an instance of struct i915_audio_component which it receives
from the master. The master can then start to use the interface defined by
this struct. Each side can break the binding at any point by deregistering
its own component after which each side&#8217;s component unbind callback is
called.</p>
<p>We ignore any error during registration and continue with reduced
functionality (i.e. without HDMI audio).</p>
<dl class="function">
<dt id="c.i915_audio_component_cleanup">
void <code class="descname">i915_audio_component_cleanup</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_audio_component_cleanup" title="Permalink to this definition">Â¶</a></dt>
<dd><p>deregister the audio component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deregisters the audio component, breaking any existing binding to the
corresponding snd_hda_intel driver&#8217;s master component.</p>
<dl class="type">
<dt id="c.i915_audio_component_ops">
struct <code class="descname">i915_audio_component_ops</code><a class="headerlink" href="#c.i915_audio_component_ops" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Ops implemented by i915 driver, called by hda driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i915_audio_component_ops {
  struct module * owner;
  void (* get_power) (struct device *);
  void (* put_power) (struct device *);
  void (* codec_wake_override) (struct device *, bool enable);
  int (* get_cdclk_freq) (struct device *);
  int (* sync_audio_rate) (struct device *, int port, int pipe, int rate);
  int (* get_eld) (struct device *, int port, int pipe, bool *enabled,unsigned char *buf, int max_bytes);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>i915 module</dd>
<dt><code class="docutils literal"><span class="pre">get_power</span></code></dt>
<dd><p class="first">get the POWER_DOMAIN_AUDIO power well</p>
<p class="last">Request the power well to be turned on.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">put_power</span></code></dt>
<dd><p class="first">put the POWER_DOMAIN_AUDIO power well</p>
<p class="last">Allow the power well to be turned off.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">codec_wake_override</span></code></dt>
<dd>Enable/disable codec wake signal</dd>
<dt><code class="docutils literal"><span class="pre">get_cdclk_freq</span></code></dt>
<dd>Get the Core Display Clock in kHz</dd>
<dt><code class="docutils literal"><span class="pre">sync_audio_rate</span></code></dt>
<dd><p class="first">set n/cts based on the sample rate</p>
<p class="last">Called from audio driver. After audio driver sets the
sample rate, it will call this function to set n/cts</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_eld</span></code></dt>
<dd><p class="first">fill the audio state and ELD bytes for the given port</p>
<p>Called from audio driver to get the HDMI/DP audio state of the given
digital port, and also fetch ELD bytes to the given pointer.</p>
<p>It returns the byte size of the original ELD (not the actually
copied size), zero for an invalid ELD, or a negative error code.</p>
<p class="last">Note that the returned size may be over <strong>max_bytes</strong>.  Then it
implies that only a part of ELD has been copied to the buffer.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.i915_audio_component_audio_ops">
struct <code class="descname">i915_audio_component_audio_ops</code><a class="headerlink" href="#c.i915_audio_component_audio_ops" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Ops implemented by hda driver, called by i915 driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i915_audio_component_audio_ops {
  void * audio_ptr;
  void (* pin_eld_notify) (void *audio_ptr, int port, int pipe);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">audio_ptr</span></code></dt>
<dd>Pointer to be used in call to pin_eld_notify</dd>
<dt><code class="docutils literal"><span class="pre">pin_eld_notify</span></code></dt>
<dd><p class="first">Notify the HDA driver that pin sense and/or ELD information has changed</p>
<p class="last">Called when the i915 driver has set up audio pipeline or has just
begun to tear it down. This allows the HDA driver to update its
status accordingly (even when the HDA controller is in power save
mode).</p>
</dd>
</dl>
<dl class="type">
<dt id="c.i915_audio_component">
struct <code class="descname">i915_audio_component</code><a class="headerlink" href="#c.i915_audio_component" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Used for direct communication between i915 and hda drivers</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i915_audio_component {
  struct device * dev;
  int aud_sample_rate[MAX_PORTS];
  const struct i915_audio_component_ops * ops;
  const struct i915_audio_component_audio_ops * audio_ops;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>i915 device, used as parameter for ops</dd>
<dt><code class="docutils literal"><span class="pre">aud_sample_rate[MAX_PORTS]</span></code></dt>
<dd>the array of audio sample rate per port</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>Ops implemented by i915 driver, called by hda driver</dd>
<dt><code class="docutils literal"><span class="pre">audio_ops</span></code></dt>
<dd>Ops implemented by hda driver, called by i915 driver</dd>
</dl>
</div>
<div class="section" id="panel-self-refresh-psr-psr-srd">
<h3>Panel Self Refresh PSR (PSR/SRD)<a class="headerlink" href="#panel-self-refresh-psr-psr-srd" title="Permalink to this headline">Â¶</a></h3>
<p>Since Haswell Display controller supports Panel Self-Refresh on display
panels witch have a remote frame buffer (RFB) implemented according to PSR
spec in eDP1.3. PSR feature allows the display to go to lower standby states
when system is idle but display is on as it eliminates display refresh
request to DDR memory completely as long as the frame buffer for that
display is unchanged.</p>
<p>Panel Self Refresh must be supported by both Hardware (source) and
Panel (sink).</p>
<p>PSR saves power by caching the framebuffer in the panel RFB, which allows us
to power down the link and memory controller. For DSI panels the same idea
is called &#8220;manual mode&#8221;.</p>
<p>The implementation uses the hardware-based PSR support which automatically
enters/exits self-refresh mode. The hardware takes care of sending the
required DP aux message and could even retrain the link (that part isn&#8217;t
enabled yet though). The hardware also keeps track of any frontbuffer
changes to know when to exit self-refresh mode again. Unfortunately that
part doesn&#8217;t work too well, hence why the i915 PSR support uses the
software frontbuffer tracking to make sure it doesn&#8217;t miss a screen
update. For this integration <a class="reference internal" href="#c.intel_psr_invalidate" title="intel_psr_invalidate"><code class="xref c c-func docutils literal"><span class="pre">intel_psr_invalidate()</span></code></a> and <a class="reference internal" href="#c.intel_psr_flush" title="intel_psr_flush"><code class="xref c c-func docutils literal"><span class="pre">intel_psr_flush()</span></code></a>
get called by the frontbuffer tracking code. Note that because of locking
issues the self-refresh re-enable code is done from a work queue, which
must be correctly synchronized/cancelled when shutting down the pipe.&#8221;</p>
<dl class="function">
<dt id="c.intel_psr_enable">
void <code class="descname">intel_psr_enable</code><span class="sig-paren">(</span>struct intel_dp *<em>&nbsp;intel_dp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_enable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Enable PSR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_dp</span> <span class="pre">*</span> <span class="pre">intel_dp</span></code></dt>
<dd>Intel DP</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can only be called after the pipe is fully trained and enabled.</p>
<dl class="function">
<dt id="c.intel_psr_disable">
void <code class="descname">intel_psr_disable</code><span class="sig-paren">(</span>struct intel_dp *<em>&nbsp;intel_dp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_disable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Disable PSR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_dp</span> <span class="pre">*</span> <span class="pre">intel_dp</span></code></dt>
<dd>Intel DP</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function needs to be called before disabling pipe.</p>
<dl class="function">
<dt id="c.intel_psr_single_frame_update">
void <code class="descname">intel_psr_single_frame_update</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned<em>&nbsp;frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_single_frame_update" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Single Frame Update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt>
<dd>frontbuffer plane tracking bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some platforms support a single frame update feature that is used to
send and update only one frame on Remote Frame Buffer.
So far it is only implemented for Valleyview and Cherryview because
hardware requires this to be done before a page flip.</p>
<dl class="function">
<dt id="c.intel_psr_invalidate">
void <code class="descname">intel_psr_invalidate</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned<em>&nbsp;frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_invalidate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Invalidade PSR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt>
<dd>frontbuffer plane tracking bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Since the hardware frontbuffer tracking has gaps we need to integrate
with the software frontbuffer tracking. This function gets called every
time frontbuffer rendering starts and a buffer gets dirtied. PSR must be
disabled if the frontbuffer mask contains a buffer relevant to PSR.</p>
<p>Dirty frontbuffers relevant to PSR are tracked in busy_frontbuffer_bits.&#8221;</p>
<dl class="function">
<dt id="c.intel_psr_flush">
void <code class="descname">intel_psr_flush</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned<em>&nbsp;frontbuffer_bits</em>, enum fb_op_origin<em>&nbsp;origin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_flush" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Flush PSR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">frontbuffer_bits</span></code></dt>
<dd>frontbuffer plane tracking bits</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">fb_op_origin</span> <span class="pre">origin</span></code></dt>
<dd>which operation caused the flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>Since the hardware frontbuffer tracking has gaps we need to integrate
with the software frontbuffer tracking. This function gets called every
time frontbuffer rendering has completed and flushed out to memory. PSR
can be enabled again if no other frontbuffer relevant to PSR is dirty.</p>
<p>Dirty frontbuffers relevant to PSR are tracked in busy_frontbuffer_bits.</p>
<dl class="function">
<dt id="c.intel_psr_init">
void <code class="descname">intel_psr_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_psr_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Init basic PSR work and mutex.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is  called only once at driver load to initialize basic
PSR stuff.</p>
</div>
<div class="section" id="frame-buffer-compression-fbc">
<h3>Frame Buffer Compression (FBC)<a class="headerlink" href="#frame-buffer-compression-fbc" title="Permalink to this headline">Â¶</a></h3>
<p>FBC tries to save memory bandwidth (and so power consumption) by
compressing the amount of memory used by the display. It is total
transparent to user space and completely handled in the kernel.</p>
<p>The benefits of FBC are mostly visible with solid backgrounds and
variation-less patterns. It comes from keeping the memory footprint small
and having fewer memory pages opened and accessed for refreshing the display.</p>
<p>i915 is responsible to reserve stolen memory for FBC and configure its
offset on proper registers. The hardware takes care of all
compress/decompress. However there are many known cases where we have to
forcibly disable it to allow proper screen updates.</p>
<dl class="function">
<dt id="c.intel_fbc_is_active">
bool <code class="descname">intel_fbc_is_active</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_is_active" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Is FBC active?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to verify the current state of FBC.</p>
<p>FIXME: This should be tracked in the plane config eventually
instead of queried at runtime for most callers.</p>
<dl class="function">
<dt id="c.intel_fbc_choose_crtc">
void <code class="descname">intel_fbc_choose_crtc</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_choose_crtc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>select a CRTC to enable FBC on</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the atomic state structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks at the proposed state for CRTCs and planes, then chooses
which pipe is going to have FBC by setting intel_crtc_state-&gt;enable_fbc to
true.</p>
<p>Later, intel_fbc_enable is going to look for state-&gt;enable_fbc and then maybe
enable FBC for the chosen CRTC. If it does, it will set dev_priv-&gt;fbc.crtc.</p>
<dl class="function">
<dt id="c.intel_fbc_enable">
void <code class="descname">intel_fbc_enable</code><span class="sig-paren">(</span>struct intel_crtc *<em>&nbsp;crtc</em>, struct intel_crtc_state *<em>&nbsp;crtc_state</em>, struct intel_plane_state *<em>&nbsp;plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_enable" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>the CRTC</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*</span> <span class="pre">crtc_state</span></code></dt>
<dd>corresponding <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state</span></code></a> for <strong>crtc</strong></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt>
<dd>corresponding <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state</span></code></a> for the primary plane of <strong>crtc</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks if the given CRTC was chosen for FBC, then enables it if
possible. Notice that it doesn&#8217;t activate FBC. It is valid to call
intel_fbc_enable multiple times for the same pipe without an
intel_fbc_disable in the middle, as long as it is deactivated.</p>
<dl class="function">
<dt id="c.__intel_fbc_disable">
void <code class="descname">__intel_fbc_disable</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__intel_fbc_disable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>disable FBC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the low level function that actually disables FBC. Callers should
grab the FBC lock.</p>
<dl class="function">
<dt id="c.intel_fbc_disable">
void <code class="descname">intel_fbc_disable</code><span class="sig-paren">(</span>struct intel_crtc *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_disable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>disable FBC if it&#8217;s associated with crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>the CRTC</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables FBC if it&#8217;s associated with the provided CRTC.</p>
<dl class="function">
<dt id="c.intel_fbc_global_disable">
void <code class="descname">intel_fbc_global_disable</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_global_disable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>globally disable FBC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables FBC regardless of which CRTC is associated with it.</p>
<dl class="function">
<dt id="c.intel_fbc_handle_fifo_underrun_irq">
void <code class="descname">intel_fbc_handle_fifo_underrun_irq</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_handle_fifo_underrun_irq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>disable FBC when we get a FIFO underrun</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Without FBC, most underruns are harmless and don&#8217;t really cause too many
problems, except for an annoying message on dmesg. With FBC, underruns can
become black screens or even worse, especially when paired with bad
watermarks. So in order for us to be on the safe side, completely disable FBC
in case we ever detect a FIFO underrun on any pipe. An underrun on any pipe
already suggests that watermarks may be bad, so try to be as safe as
possible.</p>
<p>This function is called from the IRQ handler.</p>
<dl class="function">
<dt id="c.intel_fbc_init_pipe_state">
void <code class="descname">intel_fbc_init_pipe_state</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_init_pipe_state" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize FBC&#8217;s CRTC visibility tracking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>The FBC code needs to track CRTC visibility since the older platforms can&#8217;t
have FBC enabled while multiple pipes are used. This function does the
initial setup at driver load to make sure FBC is matching the real hardware.</p>
<dl class="function">
<dt id="c.intel_fbc_init">
void <code class="descname">intel_fbc_init</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_fbc_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Initialize FBC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>the i915 device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function might be called during PM init process.</p>
</div>
<div class="section" id="display-refresh-rate-switching-drrs">
<h3>Display Refresh Rate Switching (DRRS)<a class="headerlink" href="#display-refresh-rate-switching-drrs" title="Permalink to this headline">Â¶</a></h3>
<p>Display Refresh Rate Switching (DRRS) is a power conservation feature
which enables swtching between low and high refresh rates,
dynamically, based on the usage scenario. This feature is applicable
for internal panels.</p>
<p>Indication that the panel supports DRRS is given by the panel EDID, which
would list multiple refresh rates for one resolution.</p>
<p>DRRS is of 2 types - static and seamless.
Static DRRS involves changing refresh rate (RR) by doing a full modeset
(may appear as a blink on screen) and is used in dock-undock scenario.
Seamless DRRS involves changing RR without any visual effect to the user
and can be used during normal system usage. This is done by programming
certain registers.</p>
<p>Support for static/seamless DRRS may be indicated in the VBT based on
inputs from the panel spec.</p>
<p>DRRS saves power by switching to low RR based on usage scenarios.</p>
<p>The implementation is based on frontbuffer tracking implementation.  When
there is a disturbance on the screen triggered by user activity or a periodic
system activity, DRRS is disabled (RR is changed to high RR).  When there is
no movement on screen, after a timeout of 1 second, a switch to low RR is
made.</p>
<p>For integration with frontbuffer tracking code, <a class="reference internal" href="#c.intel_edp_drrs_invalidate" title="intel_edp_drrs_invalidate"><code class="xref c c-func docutils literal"><span class="pre">intel_edp_drrs_invalidate()</span></code></a>
and <a class="reference internal" href="#c.intel_edp_drrs_flush" title="intel_edp_drrs_flush"><code class="xref c c-func docutils literal"><span class="pre">intel_edp_drrs_flush()</span></code></a> are called.</p>
<p>DRRS can be further extended to support other internal panels and also
the scenario of video playback wherein RR is set based on the rate
requested by userspace.</p>
<dl class="function">
<dt id="c.intel_dp_set_drrs_state">
void <code class="descname">intel_dp_set_drrs_state</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, struct intel_crtc_state *<em>&nbsp;crtc_state</em>, int<em>&nbsp;refresh_rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dp_set_drrs_state" title="Permalink to this definition">Â¶</a></dt>
<dd><p>program registers for RR switch to take effect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*</span> <span class="pre">crtc_state</span></code></dt>
<dd>a pointer to the active intel_crtc_state</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">refresh_rate</span></code></dt>
<dd>RR to be programmed</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called when refresh rate (RR) has to be changed from
one frequency to another. Switches can be between high and low RR
supported by the panel or to any other RR based on media playback (in
this case, RR value needs to be passed from user space).</p>
<p>The caller of this function needs to take a lock on dev_priv-&gt;drrs.</p>
<dl class="function">
<dt id="c.intel_edp_drrs_enable">
void <code class="descname">intel_edp_drrs_enable</code><span class="sig-paren">(</span>struct intel_dp *<em>&nbsp;intel_dp</em>, struct intel_crtc_state *<em>&nbsp;crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_edp_drrs_enable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>init drrs struct if supported</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_dp</span> <span class="pre">*</span> <span class="pre">intel_dp</span></code></dt>
<dd>DP struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*</span> <span class="pre">crtc_state</span></code></dt>
<dd>A pointer to the active crtc state.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes frontbuffer_bits and drrs.dp</p>
<dl class="function">
<dt id="c.intel_edp_drrs_disable">
void <code class="descname">intel_edp_drrs_disable</code><span class="sig-paren">(</span>struct intel_dp *<em>&nbsp;intel_dp</em>, struct intel_crtc_state *<em>&nbsp;old_crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_edp_drrs_disable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Disable DRRS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_dp</span> <span class="pre">*</span> <span class="pre">intel_dp</span></code></dt>
<dd>DP struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_crtc_state</span> <span class="pre">*</span> <span class="pre">old_crtc_state</span></code></dt>
<dd>Pointer to old crtc_state.</dd>
</dl>
<dl class="function">
<dt id="c.intel_edp_drrs_invalidate">
void <code class="descname">intel_edp_drrs_invalidate</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned int<em>&nbsp;frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_edp_drrs_invalidate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Disable Idleness DRRS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">frontbuffer_bits</span></code></dt>
<dd>frontbuffer plane tracking bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called everytime rendering on the given planes start.
Hence DRRS needs to be Upclocked, i.e. (LOW_RR -&gt; HIGH_RR).</p>
<p>Dirty frontbuffers relevant to DRRS are tracked in busy_frontbuffer_bits.</p>
<dl class="function">
<dt id="c.intel_edp_drrs_flush">
void <code class="descname">intel_edp_drrs_flush</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned int<em>&nbsp;frontbuffer_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_edp_drrs_flush" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Restart Idleness DRRS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">frontbuffer_bits</span></code></dt>
<dd>frontbuffer plane tracking bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets called every time rendering on the given planes has
completed or flip on a crtc is completed. So DRRS should be upclocked
(LOW_RR -&gt; HIGH_RR). And also Idleness detection should be started again,
if no other planes are dirty.</p>
<p>Dirty frontbuffers relevant to DRRS are tracked in busy_frontbuffer_bits.</p>
<dl class="function">
<dt id="c.intel_dp_drrs_init">
struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">intel_dp_drrs_init</code><span class="sig-paren">(</span>struct intel_connector *<em>&nbsp;intel_connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;fixed_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_dp_drrs_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Init basic DRRS work and mutex.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_connector</span> <span class="pre">*</span> <span class="pre">intel_connector</span></code></dt>
<dd>eDP connector</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">fixed_mode</span></code></dt>
<dd>preferred mode of panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is  called only once at driver load to initialize basic
DRRS stuff.</p>
<p><strong>Return</strong></p>
<p>Downclock mode if panel supports it, else return NULL.
DRRS support is determined by the presence of downclock mode (apart
from VBT setting).</p>
</div>
<div class="section" id="dpio">
<h3>DPIO<a class="headerlink" href="#dpio" title="Permalink to this headline">Â¶</a></h3>
<p>VLV, CHV and BXT have slightly peculiar display PHYs for driving DP/HDMI
ports. DPIO is the name given to such a display PHY. These PHYs
don&#8217;t follow the standard programming model using direct MMIO
registers, and instead their registers must be accessed trough IOSF
sideband. VLV has one such PHY for driving ports B and C, and CHV
adds another PHY for driving port D. Each PHY responds to specific
IOSF-SB port.</p>
<p>Each display PHY is made up of one or two channels. Each channel
houses a common lane part which contains the PLL and other common
logic. CH0 common lane also contains the IOSF-SB logic for the
Common Register Interface (CRI) ie. the DPIO registers. CRI clock
must be running when any DPIO registers are accessed.</p>
<p>In addition to having their own registers, the PHYs are also
controlled through some dedicated signals from the display
controller. These include PLL reference clock enable, PLL enable,
and CRI clock selection, for example.</p>
<p>Eeach channel also has two splines (also called data lanes), and
each spline is made up of one Physical Access Coding Sub-Layer
(PCS) block and two TX lanes. So each channel has two PCS blocks
and four TX lanes. The TX lanes are used as DP lanes or TMDS
data/clock pairs depending on the output type.</p>
<p>Additionally the PHY also contains an AUX lane with AUX blocks
for each channel. This is used for DP AUX communication, but
this fact isn&#8217;t really relevant for the driver since AUX is
controlled from the display controller side. No DPIO registers
need to be accessed during AUX communication,</p>
<p>Generally on VLV/CHV the common lane corresponds to the pipe and
the spline (PCS/TX) corresponds to the port.</p>
<p>For dual channel PHY (VLV/CHV):</p>
<blockquote>
<div><p>pipe A == CMN/PLL/REF CH0</p>
<p>pipe B == CMN/PLL/REF CH1</p>
<p>port B == PCS/TX CH0</p>
<p>port C == PCS/TX CH1</p>
</div></blockquote>
<p>This is especially important when we cross the streams
ie. drive port B with pipe B, or port C with pipe A.</p>
<p>For single channel PHY (CHV):</p>
<blockquote>
<div><p>pipe C == CMN/PLL/REF CH0</p>
<p>port D == PCS/TX CH0</p>
</div></blockquote>
<p>On BXT the entire PHY channel corresponds to the port. That means
the PLL is also now associated with the port rather than the pipe,
and so the clock needs to be routed to the appropriate transcoder.
Port A PLL is directly connected to transcoder EDP and port B/C
PLLs can be routed to any transcoder A/B/C.</p>
<p>Note: DDI0 is digital port B, DD1 is digital port C, and DDI2 is
digital port D (CHV) or port A (BXT).</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Dual channel PHY (VLV/CHV/BXT)
---------------------------------
|      CH0      |      CH1      |
|  CMN/PLL/REF  |  CMN/PLL/REF  |
|---------------|---------------| Display PHY
| PCS01 | PCS23 | PCS01 | PCS23 |
|-------|-------|-------|-------|
|TX0|TX1|TX2|TX3|TX0|TX1|TX2|TX3|
---------------------------------
|     DDI0      |     DDI1      | DP/HDMI ports
---------------------------------

Single channel PHY (CHV/BXT)
-----------------
|      CH0      |
|  CMN/PLL/REF  |
|---------------| Display PHY
| PCS01 | PCS23 |
|-------|-------|
|TX0|TX1|TX2|TX3|
-----------------
|     DDI2      | DP/HDMI port
-----------------
</pre></div>
</div>
</div>
<div class="section" id="csr-firmware-support-for-dmc">
<h3>CSR firmware support for DMC<a class="headerlink" href="#csr-firmware-support-for-dmc" title="Permalink to this headline">Â¶</a></h3>
<p>Display Context Save and Restore (CSR) firmware support added from gen9
onwards to drive newly added DMC (Display microcontroller) in display
engine to save and restore the state of display engine when it enter into
low-power state and comes back to normal.</p>
<dl class="function">
<dt id="c.intel_csr_load_program">
void <code class="descname">intel_csr_load_program</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_csr_load_program" title="Permalink to this definition">Â¶</a></dt>
<dd><p>write the firmware from memory to register.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 drm device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>CSR firmware is read from a .bin file and kept in internal memory one time.
Everytime display comes back from low power state this function is called to
copy the firmware from internal memory to registers.</p>
<dl class="function">
<dt id="c.intel_csr_ucode_init">
void <code class="descname">intel_csr_ucode_init</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_csr_ucode_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize the firmware loading.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 drm device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called at the time of loading the display driver to read
firmware from a .bin file and copied into a internal memory.</p>
<dl class="function">
<dt id="c.intel_csr_ucode_suspend">
void <code class="descname">intel_csr_ucode_suspend</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_csr_ucode_suspend" title="Permalink to this definition">Â¶</a></dt>
<dd><p>prepare CSR firmware before system suspend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 drm device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepare the DMC firmware before entering system suspend. This includes
flushing pending work items and releasing any resources acquired during
init.</p>
<dl class="function">
<dt id="c.intel_csr_ucode_resume">
void <code class="descname">intel_csr_ucode_resume</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_csr_ucode_resume" title="Permalink to this definition">Â¶</a></dt>
<dd><p>init CSR firmware during system resume</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 drm device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reinitialize the DMC firmware during system resume, reacquiring any
resources released in <a class="reference internal" href="#c.intel_csr_ucode_suspend" title="intel_csr_ucode_suspend"><code class="xref c c-func docutils literal"><span class="pre">intel_csr_ucode_suspend()</span></code></a>.</p>
<dl class="function">
<dt id="c.intel_csr_ucode_fini">
void <code class="descname">intel_csr_ucode_fini</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_csr_ucode_fini" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unload the CSR firmware.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 drm device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Firmmware unloading includes freeing the internal memory and reset the
firmware loading status.</p>
</div>
<div class="section" id="video-bios-table-vbt">
<h3>Video BIOS Table (VBT)<a class="headerlink" href="#video-bios-table-vbt" title="Permalink to this headline">Â¶</a></h3>
<p>The Video BIOS Table, or VBT, provides platform and board specific
configuration information to the driver that is not discoverable or available
through other means. The configuration is mostly related to display
hardware. The VBT is available via the ACPI OpRegion or, on older systems, in
the PCI ROM.</p>
<p>The VBT consists of a VBT Header (defined as <a class="reference internal" href="#c.vbt_header" title="vbt_header"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vbt_header</span></code></a>), a BDB
Header (<a class="reference internal" href="#c.bdb_header" title="bdb_header"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bdb_header</span></code></a>), and a number of BIOS Data Blocks (BDB) that
contain the actual configuration information. The VBT Header, and thus the
VBT, begins with &#8220;$VBT&#8221; signature. The VBT Header contains the offset of the
BDB Header. The data blocks are concatenated after the BDB Header. The data
blocks have a 1-byte Block ID, 2-byte Block Size, and Block Size bytes of
data. (Block 53, the MIPI Sequence Block is an exception.)</p>
<p>The driver parses the VBT during load. The relevant information is stored in
driver private data for ease of use, and the actual VBT is not read after
that.</p>
<dl class="function">
<dt id="c.intel_bios_is_valid_vbt">
bool <code class="descname">intel_bios_is_valid_vbt</code><span class="sig-paren">(</span>const void *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_valid_vbt" title="Permalink to this definition">Â¶</a></dt>
<dd><p>does the given buffer contain a valid VBT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to a buffer to validate</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true on valid VBT.</p>
<dl class="function">
<dt id="c.intel_bios_init">
int <code class="descname">intel_bios_init</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>find VBT and initialize settings from the BIOS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Loads the Video BIOS and checks that the VBT exists.  Sets scratch registers
to appropriate values.</p>
<p>Returns 0 on success, nonzero on failure.</p>
<dl class="function">
<dt id="c.intel_bios_is_tv_present">
bool <code class="descname">intel_bios_is_tv_present</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_tv_present" title="Permalink to this definition">Â¶</a></dt>
<dd><p>is integrated TV present in VBT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if TV is present. If no child devices were parsed from VBT,
assume TV is present.</p>
<dl class="function">
<dt id="c.intel_bios_is_lvds_present">
bool <code class="descname">intel_bios_is_lvds_present</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, u8 *<em>&nbsp;i2c_pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_lvds_present" title="Permalink to this definition">Â¶</a></dt>
<dd><p>is LVDS present in VBT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">i2c_pin</span></code></dt>
<dd>i2c pin for LVDS if present</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if LVDS is present. If no child devices were parsed from VBT,
assume LVDS is present.</p>
<dl class="function">
<dt id="c.intel_bios_is_port_present">
bool <code class="descname">intel_bios_is_port_present</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum port<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_port_present" title="Permalink to this definition">Â¶</a></dt>
<dd><p>is the specified digital port present</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">port</span></code></dt>
<dd>port to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the device in <code class="docutils literal"><span class="pre">port</span></code> is present.</p>
<dl class="function">
<dt id="c.intel_bios_is_port_edp">
bool <code class="descname">intel_bios_is_port_edp</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum port<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_port_edp" title="Permalink to this definition">Â¶</a></dt>
<dd><p>is the device in given port eDP</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">port</span></code></dt>
<dd>port to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the device in <code class="docutils literal"><span class="pre">port</span></code> is eDP.</p>
<dl class="function">
<dt id="c.intel_bios_is_dsi_present">
bool <code class="descname">intel_bios_is_dsi_present</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum port *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_dsi_present" title="Permalink to this definition">Â¶</a></dt>
<dd><p>is DSI present in VBT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>port for DSI if present</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if DSI is present, and return the port in <code class="docutils literal"><span class="pre">port</span></code>.</p>
<dl class="function">
<dt id="c.intel_bios_is_port_hpd_inverted">
bool <code class="descname">intel_bios_is_port_hpd_inverted</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum port<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_port_hpd_inverted" title="Permalink to this definition">Â¶</a></dt>
<dd><p>is HPD inverted for <code class="docutils literal"><span class="pre">port</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">port</span></code></dt>
<dd>port to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if HPD should be inverted for <code class="docutils literal"><span class="pre">port</span></code>.</p>
<dl class="function">
<dt id="c.intel_bios_is_lspcon_present">
bool <code class="descname">intel_bios_is_lspcon_present</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, enum port<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_bios_is_lspcon_present" title="Permalink to this definition">Â¶</a></dt>
<dd><p>if LSPCON is attached on <code class="docutils literal"><span class="pre">port</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device instance</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">port</span> <span class="pre">port</span></code></dt>
<dd>port to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if LSPCON is present on this port</p>
<dl class="type">
<dt id="c.vbt_header">
struct <code class="descname">vbt_header</code><a class="headerlink" href="#c.vbt_header" title="Permalink to this definition">Â¶</a></dt>
<dd><p>VBT Header structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vbt_header {
  u8 signature[20];
  u16 version;
  u16 header_size;
  u16 vbt_size;
  u8 vbt_checksum;
  u8 reserved0;
  u32 bdb_offset;
  u32 aim_offset[4];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">signature[20]</span></code></dt>
<dd>VBT signature, always starts with &#8220;$VBT&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">version</span></code></dt>
<dd>Version of this structure</dd>
<dt><code class="docutils literal"><span class="pre">header_size</span></code></dt>
<dd>Size of this structure</dd>
<dt><code class="docutils literal"><span class="pre">vbt_size</span></code></dt>
<dd>Size of VBT (VBT Header, BDB Header and data blocks)</dd>
<dt><code class="docutils literal"><span class="pre">vbt_checksum</span></code></dt>
<dd>Checksum</dd>
<dt><code class="docutils literal"><span class="pre">reserved0</span></code></dt>
<dd>Reserved</dd>
<dt><code class="docutils literal"><span class="pre">bdb_offset</span></code></dt>
<dd>Offset of <a class="reference internal" href="#c.bdb_header" title="bdb_header"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bdb_header</span></code></a> from beginning of VBT</dd>
<dt><code class="docutils literal"><span class="pre">aim_offset[4]</span></code></dt>
<dd>Offsets of add-in data blocks from beginning of VBT</dd>
</dl>
<dl class="type">
<dt id="c.bdb_header">
struct <code class="descname">bdb_header</code><a class="headerlink" href="#c.bdb_header" title="Permalink to this definition">Â¶</a></dt>
<dd><p>BDB Header structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct bdb_header {
  u8 signature[16];
  u16 version;
  u16 header_size;
  u16 bdb_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">signature[16]</span></code></dt>
<dd>BDB signature &#8220;BIOS_DATA_BLOCK&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">version</span></code></dt>
<dd>Version of the data block definitions</dd>
<dt><code class="docutils literal"><span class="pre">header_size</span></code></dt>
<dd>Size of this structure</dd>
<dt><code class="docutils literal"><span class="pre">bdb_size</span></code></dt>
<dd>Size of BDB (BDB Header and data blocks)</dd>
</dl>
</div>
</div>
<div class="section" id="memory-management-and-command-submission">
<h2>Memory Management and Command Submission<a class="headerlink" href="#memory-management-and-command-submission" title="Permalink to this headline">Â¶</a></h2>
<p>This sections covers all things related to the GEM implementation in the
i915 driver.</p>
<div class="section" id="batchbuffer-parsing">
<h3>Batchbuffer Parsing<a class="headerlink" href="#batchbuffer-parsing" title="Permalink to this headline">Â¶</a></h3>
<p>Motivation:
Certain OpenGL features (e.g. transform feedback, performance monitoring)
require userspace code to submit batches containing commands such as
MI_LOAD_REGISTER_IMM to access various registers. Unfortunately, some
generations of the hardware will noop these commands in &#8220;unsecure&#8221; batches
(which includes all userspace batches submitted via i915) even though the
commands may be safe and represent the intended programming model of the
device.</p>
<p>The software command parser is similar in operation to the command parsing
done in hardware for unsecure batches. However, the software parser allows
some operations that would be noop&#8217;d by hardware, if the parser determines
the operation is safe, and submits the batch as &#8220;secure&#8221; to prevent hardware
parsing.</p>
<p>Threats:
At a high level, the hardware (and software) checks attempt to prevent
granting userspace undue privileges. There are three categories of privilege.</p>
<p>First, commands which are explicitly defined as privileged or which should
only be used by the kernel driver. The parser generally rejects such
commands, though it may allow some from the drm master process.</p>
<p>Second, commands which access registers. To support correct/enhanced
userspace functionality, particularly certain OpenGL extensions, the parser
provides a whitelist of registers which userspace may safely access (for both
normal and drm master processes).</p>
<p>Third, commands which access privileged memory (i.e. GGTT, HWS page, etc).
The parser always rejects such commands.</p>
<p>The majority of the problematic commands fall in the MI_* range, with only a
few specific commands on each engine (e.g. PIPE_CONTROL and MI_FLUSH_DW).</p>
<p>Implementation:
Each engine maintains tables of commands and registers which the parser
uses in scanning batch buffers submitted to that engine.</p>
<p>Since the set of commands that the parser must check for is significantly
smaller than the number of commands supported, the parser tables contain only
those commands required by the parser. This generally works because command
opcode ranges have standard command length encodings. So for commands that
the parser does not need to check, it can easily skip them. This is
implemented via a per-engine length decoding vfunc.</p>
<p>Unfortunately, there are a number of commands that do not follow the standard
length encoding for their opcode range, primarily amongst the MI_* commands.
To handle this, the parser provides a way to define explicit &#8220;skip&#8221; entries
in the per-engine command tables.</p>
<p>Other command table entries map fairly directly to high level categories
mentioned above: rejected, master-only, register whitelist. The parser
implements a number of checks, including the privileged memory checks, via a
general bitmasking mechanism.</p>
<dl class="function">
<dt id="c.intel_engine_init_cmd_parser">
void <code class="descname">intel_engine_init_cmd_parser</code><span class="sig-paren">(</span>struct intel_engine_cs *<em>&nbsp;engine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_engine_init_cmd_parser" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set cmd parser related fields for an engine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*</span> <span class="pre">engine</span></code></dt>
<dd>the engine to initialize</dd>
</dl>
<p><strong>Description</strong></p>
<p>Optionally initializes fields related to batch buffer command parsing in the
struct intel_engine_cs based on whether the platform requires software
command parsing.</p>
<dl class="function">
<dt id="c.intel_engine_cleanup_cmd_parser">
void <code class="descname">intel_engine_cleanup_cmd_parser</code><span class="sig-paren">(</span>struct intel_engine_cs *<em>&nbsp;engine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_engine_cleanup_cmd_parser" title="Permalink to this definition">Â¶</a></dt>
<dd><p>clean up cmd parser related fields</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*</span> <span class="pre">engine</span></code></dt>
<dd>the engine to clean up</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases any resources related to command parsing that may have been
initialized for the specified engine.</p>
<dl class="function">
<dt id="c.intel_engine_needs_cmd_parser">
bool <code class="descname">intel_engine_needs_cmd_parser</code><span class="sig-paren">(</span>struct intel_engine_cs *<em>&nbsp;engine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_engine_needs_cmd_parser" title="Permalink to this definition">Â¶</a></dt>
<dd><p>should a given engine use software command parsing?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*</span> <span class="pre">engine</span></code></dt>
<dd>the engine in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only certain platforms require software batch buffer command parsing, and
only when enabled via module parameter.</p>
<p><strong>Return</strong></p>
<p>true if the engine requires software command parsing</p>
<dl class="function">
<dt id="c.intel_engine_cmd_parser">
int <code class="descname">intel_engine_cmd_parser</code><span class="sig-paren">(</span>struct intel_engine_cs *<em>&nbsp;engine</em>, struct drm_i915_gem_object *<em>&nbsp;batch_obj</em>, struct drm_i915_gem_object *<em>&nbsp;shadow_batch_obj</em>, u32<em>&nbsp;batch_start_offset</em>, u32<em>&nbsp;batch_len</em>, bool<em>&nbsp;is_master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_engine_cmd_parser" title="Permalink to this definition">Â¶</a></dt>
<dd><p>parse a submitted batch buffer for privilege violations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*</span> <span class="pre">engine</span></code></dt>
<dd>the engine on which the batch is to execute</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_gem_object</span> <span class="pre">*</span> <span class="pre">batch_obj</span></code></dt>
<dd>the batch buffer in question</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_gem_object</span> <span class="pre">*</span> <span class="pre">shadow_batch_obj</span></code></dt>
<dd>copy of the batch buffer in question</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">batch_start_offset</span></code></dt>
<dd>byte offset in the batch at which execution starts</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">batch_len</span></code></dt>
<dd>length of the commands in batch_obj</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">is_master</span></code></dt>
<dd>is the submitting process the drm master?</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parses the specified batch buffer looking for privilege violations as
described in the overview.</p>
<p><strong>Return</strong></p>
<p>non-zero if the parser finds violations or otherwise fails; -EACCES
if the batch appears legal but should use hardware parsing</p>
<dl class="function">
<dt id="c.i915_cmd_parser_get_version">
int <code class="descname">i915_cmd_parser_get_version</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_cmd_parser_get_version" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get the cmd parser version number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device private</dd>
</dl>
<p><strong>Description</strong></p>
<p>The cmd parser maintains a simple increasing integer version number suitable
for passing to userspace clients to determine what operations are permitted.</p>
<p><strong>Return</strong></p>
<p>the current version number of the cmd parser</p>
</div>
<div class="section" id="batchbuffer-pools">
<h3>Batchbuffer Pools<a class="headerlink" href="#batchbuffer-pools" title="Permalink to this headline">Â¶</a></h3>
<p>In order to submit batch buffers as &#8216;secure&#8217;, the software command parser
must ensure that a batch buffer cannot be modified after parsing. It does
this by copying the user provided batch buffer contents to a kernel owned
buffer from which the hardware will actually execute, and by carefully
managing the address space bindings for such buffers.</p>
<p>The batch pool framework provides a mechanism for the driver to manage a
set of scratch buffers to use for this purpose. The framework can be
extended to support other uses cases should they arise.</p>
<dl class="function">
<dt id="c.i915_gem_batch_pool_init">
void <code class="descname">i915_gem_batch_pool_init</code><span class="sig-paren">(</span>struct intel_engine_cs *<em>&nbsp;engine</em>, struct i915_gem_batch_pool *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_batch_pool_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize a batch buffer pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*</span> <span class="pre">engine</span></code></dt>
<dd>the associated request submission engine</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_gem_batch_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>the batch buffer pool</dd>
</dl>
<dl class="function">
<dt id="c.i915_gem_batch_pool_fini">
void <code class="descname">i915_gem_batch_pool_fini</code><span class="sig-paren">(</span>struct i915_gem_batch_pool *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_batch_pool_fini" title="Permalink to this definition">Â¶</a></dt>
<dd><p>clean up a batch buffer pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_gem_batch_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>the pool to clean up</dd>
</dl>
<p><strong>Note</strong></p>
<p>Callers must hold the struct_mutex.</p>
<dl class="function">
<dt id="c.i915_gem_batch_pool_get">
struct drm_i915_gem_object * <code class="descname">i915_gem_batch_pool_get</code><span class="sig-paren">(</span>struct i915_gem_batch_pool *<em>&nbsp;pool</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_batch_pool_get" title="Permalink to this definition">Â¶</a></dt>
<dd><p>allocate a buffer from the pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_gem_batch_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>the batch buffer pool</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the minimum desired size of the returned buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an inactive buffer from <strong>pool</strong> with at least <strong>size</strong> bytes,
with the pages pinned. The caller must <code class="xref c c-func docutils literal"><span class="pre">i915_gem_object_unpin_pages()</span></code>
on the returned object.</p>
<p><strong>Note</strong></p>
<p>Callers must hold the struct_mutex</p>
<p><strong>Return</strong></p>
<p>the buffer object or an error pointer</p>
</div>
<div class="section" id="logical-rings-logical-ring-contexts-and-execlists">
<h3>Logical Rings, Logical Ring Contexts and Execlists<a class="headerlink" href="#logical-rings-logical-ring-contexts-and-execlists" title="Permalink to this headline">Â¶</a></h3>
<p>Motivation:
GEN8 brings an expansion of the HW contexts: &#8220;Logical Ring Contexts&#8221;.
These expanded contexts enable a number of new abilities, especially
&#8220;Execlists&#8221; (also implemented in this file).</p>
<p>One of the main differences with the legacy HW contexts is that logical
ring contexts incorporate many more things to the context&#8217;s state, like
PDPs or ringbuffer control registers:</p>
<p>The reason why PDPs are included in the context is straightforward: as
PPGTTs (per-process GTTs) are actually per-context, having the PDPs
contained there mean you don&#8217;t need to do a ppgtt-&gt;switch_mm yourself,
instead, the GPU will do it for you on the context switch.</p>
<p>But, what about the ringbuffer control registers (head, tail, etc..)?
shouldn&#8217;t we just need a set of those per engine command streamer? This is
where the name &#8220;Logical Rings&#8221; starts to make sense: by virtualizing the
rings, the engine cs shifts to a new &#8220;ring buffer&#8221; with every context
switch. When you want to submit a workload to the GPU you: A) choose your
context, B) find its appropriate virtualized ring, C) write commands to it
and then, finally, D) tell the GPU to switch to that context.</p>
<p>Instead of the legacy MI_SET_CONTEXT, the way you tell the GPU to switch
to a contexts is via a context execution list, ergo &#8220;Execlists&#8221;.</p>
<p>LRC implementation:
Regarding the creation of contexts, we have:</p>
<ul class="simple">
<li>One global default context.</li>
<li>One local default context for each opened fd.</li>
<li>One local extra context for each context create ioctl call.</li>
</ul>
<p>Now that ringbuffers belong per-context (and not per-engine, like before)
and that contexts are uniquely tied to a given engine (and not reusable,
like before) we need:</p>
<ul class="simple">
<li>One ringbuffer per-engine inside each context.</li>
<li>One backing object per-engine inside each context.</li>
</ul>
<p>The global default context starts its life with these new objects fully
allocated and populated. The local default context for each opened fd is
more complex, because we don&#8217;t know at creation time which engine is going
to use them. To handle this, we have implemented a deferred creation of LR
contexts:</p>
<p>The local context starts its life as a hollow or blank holder, that only
gets populated for a given engine once we receive an execbuffer. If later
on we receive another execbuffer ioctl for the same context but a different
engine, we allocate/populate a new ringbuffer and context backing object and
so on.</p>
<p>Finally, regarding local contexts created using the ioctl call: as they are
only allowed with the render ring, we can allocate &amp; populate them right
away (no need to defer anything, at least for now).</p>
<p>Execlists implementation:
Execlists are the new method by which, on gen8+ hardware, workloads are
submitted for execution (as opposed to the legacy, ringbuffer-based, method).
This method works as follows:</p>
<p>When a request is committed, its commands (the BB start and any leading or
trailing commands, like the seqno breadcrumbs) are placed in the ringbuffer
for the appropriate context. The tail pointer in the hardware context is not
updated at this time, but instead, kept by the driver in the ringbuffer
structure. A structure representing this request is added to a request queue
for the appropriate engine: this structure contains a copy of the context&#8217;s
tail after the request was written to the ring buffer and a pointer to the
context itself.</p>
<p>If the engine&#8217;s request queue was empty before the request was added, the
queue is processed immediately. Otherwise the queue will be processed during
a context switch interrupt. In any case, elements on the queue will get sent
(in pairs) to the GPU&#8217;s ExecLists Submit Port (ELSP, for short) with a
globally unique 20-bits submission ID.</p>
<p>When execution of a request completes, the GPU updates the context status
buffer with a context complete event and generates a context switch interrupt.
During the interrupt handling, the driver examines the events in the buffer:
for each context complete event, if the announced ID matches that on the head
of the request queue, then that request is retired and removed from the queue.</p>
<p>After processing, if any requests were retired and the queue is not empty
then a new execution list can be submitted. The two requests at the front of
the queue are next to be submitted but since a context may not occur twice in
an execution list, if subsequent requests have the same ID as the first then
the two requests must be combined. This is done simply by discarding requests
at the head of the queue until either only one requests is left (in which case
we use a NULL second context) or the first two requests have unique IDs.</p>
<p>By always executing the first two requests in the queue the driver ensures
that the GPU is kept as busy as possible. In the case where a single context
completes but a second context is still executing, the request for this second
context will be at the head of the queue when we remove the first one. This
request will then be resubmitted along with a new request for a different context,
which will cause the hardware to continue executing the second request and queue
the new request (the GPU detects the condition of a context getting preempted
with the same context and optimizes the context switch flow by not doing
preemption, but just sampling the new tail pointer).</p>
<dl class="function">
<dt id="c.intel_sanitize_enable_execlists">
int <code class="descname">intel_sanitize_enable_execlists</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, int<em>&nbsp;enable_execlists</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_sanitize_enable_execlists" title="Permalink to this definition">Â¶</a></dt>
<dd><p>sanitize i915.enable_execlists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device private</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">enable_execlists</span></code></dt>
<dd>value of i915.enable_execlists module parameter.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only certain platforms support Execlists (the prerequisites being
support for Logical Ring Contexts and Aliasing PPGTT or better).</p>
<p><strong>Return</strong></p>
<p>1 if Execlists is supported and has to be enabled.</p>
<dl class="function">
<dt id="c.intel_lr_context_descriptor_update">
void <code class="descname">intel_lr_context_descriptor_update</code><span class="sig-paren">(</span>struct i915_gem_context *<em>&nbsp;ctx</em>, struct intel_engine_cs *<em>&nbsp;engine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_lr_context_descriptor_update" title="Permalink to this definition">Â¶</a></dt>
<dd><p>calculate &amp; cache the descriptor descriptor for a pinned context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_gem_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>Context to work on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*</span> <span class="pre">engine</span></code></dt>
<dd>Engine the descriptor will be used with</dd>
</dl>
<p><strong>Description</strong></p>
<p>The context descriptor encodes various attributes of a context,
including its GTT address and some flags. Because it&#8217;s fairly
expensive to calculate, we&#8217;ll just do it once and cache the result,
which remains valid until the context is unpinned.</p>
<p>This is what a descriptor looks like, from LSB to MSB:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>bits  0-11:    flags, GEN8_CTX_* (cached in ctx_desc_template)
bits 12-31:    LRCA, GTT address of (the HWSP of) this context
bits 32-52:    ctx ID, a globally unique tag
bits 53-54:    mbz, reserved for use by hardware
bits 55-63:    group ID, currently unused and set to 0
</pre></div>
</div>
<dl class="function">
<dt id="c.intel_execlists_idle">
bool <code class="descname">intel_execlists_idle</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_execlists_idle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Determine if all engine submission ports are idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device private</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if there are no requests pending on any of the submission ports
of any engines.</p>
<dl class="function">
<dt id="c.intel_logical_ring_cleanup">
void <code class="descname">intel_logical_ring_cleanup</code><span class="sig-paren">(</span>struct intel_engine_cs *<em>&nbsp;engine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_logical_ring_cleanup" title="Permalink to this definition">Â¶</a></dt>
<dd><p>deallocate the Engine Command Streamer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*</span> <span class="pre">engine</span></code></dt>
<dd>Engine Command Streamer.</dd>
</dl>
<dl class="function">
<dt id="c.intel_lr_context_size">
uint32_t <code class="descname">intel_lr_context_size</code><span class="sig-paren">(</span>struct intel_engine_cs *<em>&nbsp;engine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_lr_context_size" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return the size of the context for an engine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_engine_cs</span> <span class="pre">*</span> <span class="pre">engine</span></code></dt>
<dd>which engine to find the context size for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each engine may require a different amount of space for a context image,
so when allocating (or copying) an image, this function can be used to
find the right size for the specific engine.</p>
<p><strong>Return</strong></p>
<p>size (in bytes) of an engine-specific context image</p>
<p><strong>Note</strong></p>
<p>this size includes the HWSP, which is part of the context image
in LRC mode, but does not include the &#8220;shared data page&#8221; used with
GuC submission. The caller should account for this if using the GuC.</p>
</div>
<div class="section" id="global-gtt-views">
<h3>Global GTT views<a class="headerlink" href="#global-gtt-views" title="Permalink to this headline">Â¶</a></h3>
<p>Background and previous state</p>
<p>Historically objects could exists (be bound) in global GTT space only as
singular instances with a view representing all of the object&#8217;s backing pages
in a linear fashion. This view will be called a normal view.</p>
<p>To support multiple views of the same object, where the number of mapped
pages is not equal to the backing store, or where the layout of the pages
is not linear, concept of a GGTT view was added.</p>
<p>One example of an alternative view is a stereo display driven by a single
image. In this case we would have a framebuffer looking like this
(2x2 pages):</p>
<blockquote>
<div>12
34</div></blockquote>
<p>Above would represent a normal GGTT view as normally mapped for GPU or CPU
rendering. In contrast, fed to the display engine would be an alternative
view which could look something like this:</p>
<blockquote>
<div>1212
3434</div></blockquote>
<p>In this example both the size and layout of pages in the alternative view is
different from the normal view.</p>
<p>Implementation and usage</p>
<p>GGTT views are implemented using VMAs and are distinguished via enum
i915_ggtt_view_type and struct i915_ggtt_view.</p>
<p>A new flavour of core GEM functions which work with GGTT bound objects were
added with the _ggtt_ infix, and sometimes with _view postfix to avoid
renaming  in large amounts of code. They take the struct i915_ggtt_view
parameter encapsulating all metadata required to implement a view.</p>
<p>As a helper for callers which are only interested in the normal view,
globally const i915_ggtt_view_normal singleton instance exists. All old core
GEM API functions, the ones not taking the view parameter, are operating on,
or with the normal GGTT view.</p>
<p>Code wanting to add or use a new GGTT view needs to:</p>
<ol class="arabic simple">
<li>Add a new enum with a suitable name.</li>
<li>Extend the metadata in the i915_ggtt_view structure if required.</li>
<li>Add support to <code class="xref c c-func docutils literal"><span class="pre">i915_get_vma_pages()</span></code>.</li>
</ol>
<p>New views are required to build a scatter-gather table from within the
i915_get_vma_pages function. This table is stored in the vma.ggtt_view and
exists for the lifetime of an VMA.</p>
<p>Core API is designed to have copy semantics which means that passed in
struct i915_ggtt_view does not need to be persistent (left around after
calling the core API functions).</p>
<dl class="function">
<dt id="c.gen8_ppgtt_alloc_pagetabs">
int <code class="descname">gen8_ppgtt_alloc_pagetabs</code><span class="sig-paren">(</span>struct i915_address_space *<em>&nbsp;vm</em>, struct i915_page_directory *<em>&nbsp;pd</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;length</em>, unsigned long *<em>&nbsp;new_pts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen8_ppgtt_alloc_pagetabs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Allocate page tables for VA range.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_address_space</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>Master vm structure.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_page_directory</span> <span class="pre">*</span> <span class="pre">pd</span></code></dt>
<dd>Page directory for this address range.</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>Starting virtual address to begin allocations.</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">length</span></code></dt>
<dd>Size of the allocations.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new_pts</span></code></dt>
<dd>Bitmap set by function with new allocations. Likely used by the
caller to free on error.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the required number of page tables. Extremely similar to
<a class="reference internal" href="#c.gen8_ppgtt_alloc_page_directories" title="gen8_ppgtt_alloc_page_directories"><code class="xref c c-func docutils literal"><span class="pre">gen8_ppgtt_alloc_page_directories()</span></code></a>. The main difference is here we are limited by
the page directory boundary (instead of the page directory pointer). That
boundary is 1GB virtual. Therefore, unlike <a class="reference internal" href="#c.gen8_ppgtt_alloc_page_directories" title="gen8_ppgtt_alloc_page_directories"><code class="xref c c-func docutils literal"><span class="pre">gen8_ppgtt_alloc_page_directories()</span></code></a>, it is
possible, and likely that the caller will need to use multiple calls of this
function to achieve the appropriate allocation.</p>
<p><strong>Return</strong></p>
<p>0 if success; negative error code otherwise.</p>
<dl class="function">
<dt id="c.gen8_ppgtt_alloc_page_directories">
int <code class="descname">gen8_ppgtt_alloc_page_directories</code><span class="sig-paren">(</span>struct i915_address_space *<em>&nbsp;vm</em>, struct i915_page_directory_pointer *<em>&nbsp;pdp</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;length</em>, unsigned long *<em>&nbsp;new_pds</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen8_ppgtt_alloc_page_directories" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Allocate page directories for VA range.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_address_space</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>Master vm structure.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_page_directory_pointer</span> <span class="pre">*</span> <span class="pre">pdp</span></code></dt>
<dd>Page directory pointer for this address range.</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>Starting virtual address to begin allocations.</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">length</span></code></dt>
<dd>Size of the allocations.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new_pds</span></code></dt>
<dd>Bitmap set by function with new allocations. Likely used by the
caller to free on error.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the required number of page directories starting at the pde index of
<strong>start</strong>, and ending at the pde index <strong>start</strong> + <strong>length</strong>. This function will skip
over already allocated page directories within the range, and only allocate
new ones, setting the appropriate pointer within the pdp as well as the
correct position in the bitmap <strong>new_pds</strong>.</p>
<p>The function will only allocate the pages within the range for a give page
directory pointer. In other words, if <strong>start</strong> + <strong>length</strong> straddles a virtually
addressed PDP boundary (512GB for 4k pages), there will be more allocations
required by the caller, This is not currently possible, and the BUG in the
code will prevent it.</p>
<p><strong>Return</strong></p>
<p>0 if success; negative error code otherwise.</p>
<dl class="function">
<dt id="c.gen8_ppgtt_alloc_page_dirpointers">
int <code class="descname">gen8_ppgtt_alloc_page_dirpointers</code><span class="sig-paren">(</span>struct i915_address_space *<em>&nbsp;vm</em>, struct i915_pml4 *<em>&nbsp;pml4</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;length</em>, unsigned long *<em>&nbsp;new_pdps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen8_ppgtt_alloc_page_dirpointers" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Allocate pdps for VA range.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_address_space</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>Master vm structure.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_pml4</span> <span class="pre">*</span> <span class="pre">pml4</span></code></dt>
<dd>Page map level 4 for this address range.</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>Starting virtual address to begin allocations.</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">length</span></code></dt>
<dd>Size of the allocations.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new_pdps</span></code></dt>
<dd>Bitmap set by function with new allocations. Likely used by the
caller to free on error.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the required number of page directory pointers. Extremely similar to
<a class="reference internal" href="#c.gen8_ppgtt_alloc_page_directories" title="gen8_ppgtt_alloc_page_directories"><code class="xref c c-func docutils literal"><span class="pre">gen8_ppgtt_alloc_page_directories()</span></code></a> and <a class="reference internal" href="#c.gen8_ppgtt_alloc_pagetabs" title="gen8_ppgtt_alloc_pagetabs"><code class="xref c c-func docutils literal"><span class="pre">gen8_ppgtt_alloc_pagetabs()</span></code></a>.
The main difference is here we are limited by the pml4 boundary (instead of
the page directory pointer).</p>
<p><strong>Return</strong></p>
<p>0 if success; negative error code otherwise.</p>
<dl class="function">
<dt id="c.i915_ggtt_cleanup_hw">
void <code class="descname">i915_ggtt_cleanup_hw</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_ggtt_cleanup_hw" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Clean up GGTT hardware initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
</dl>
<dl class="function">
<dt id="c.i915_ggtt_probe_hw">
int <code class="descname">i915_ggtt_probe_hw</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_ggtt_probe_hw" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Probe GGTT hardware location</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
</dl>
<dl class="function">
<dt id="c.i915_ggtt_init_hw">
int <code class="descname">i915_ggtt_init_hw</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_ggtt_init_hw" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Initialize GGTT hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
</dl>
</div>
<div class="section" id="gtt-fences-and-swizzling">
<h3>GTT Fences and Swizzling<a class="headerlink" href="#gtt-fences-and-swizzling" title="Permalink to this headline">Â¶</a></h3>
<dl class="function">
<dt id="c.i915_vma_put_fence">
int <code class="descname">i915_vma_put_fence</code><span class="sig-paren">(</span>struct i915_vma *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_vma_put_fence" title="Permalink to this definition">Â¶</a></dt>
<dd><p>force-remove fence for a VMA</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_vma</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma to map linearly (not through a fence reg)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function force-removes any fence from the given object, which is useful
if the kernel wants to do untiled GTT access.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.i915_vma_get_fence">
int <code class="descname">i915_vma_get_fence</code><span class="sig-paren">(</span>struct i915_vma *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_vma_get_fence" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set up fencing for a vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_vma</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma to map through a fence reg</dd>
</dl>
<p><strong>Description</strong></p>
<p>When mapping objects through the GTT, userspace wants to be able to write
to them without having to worry about swizzling if the object is tiled.
This function walks the fence regs looking for a free one for <strong>obj</strong>,
stealing one if it can&#8217;t find any.</p>
<p>It then sets up the reg based on the object&#8217;s properties: address, pitch
and tiling format.</p>
<p>For an untiled surface, this removes any existing fence.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.i915_gem_restore_fences">
void <code class="descname">i915_gem_restore_fences</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_restore_fences" title="Permalink to this definition">Â¶</a></dt>
<dd><p>restore fence state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device private</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restore the hw fence state to match the software tracking again, to be called
after a gpu reset and on resume. Note that on runtime suspend we only cancel
the fences, to be reacquired by the user later.</p>
<dl class="function">
<dt id="c.i915_gem_detect_bit_6_swizzle">
void <code class="descname">i915_gem_detect_bit_6_swizzle</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_detect_bit_6_swizzle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>detect bit 6 swizzling pattern</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device private</dd>
</dl>
<p><strong>Description</strong></p>
<p>Detects bit 6 swizzling of address lookup between IGD access and CPU
access through main memory.</p>
<dl class="function">
<dt id="c.i915_gem_object_do_bit_17_swizzle">
void <code class="descname">i915_gem_object_do_bit_17_swizzle</code><span class="sig-paren">(</span>struct drm_i915_gem_object *<em>&nbsp;obj</em>, struct sg_table *<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_object_do_bit_17_swizzle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>fixup bit 17 swizzling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>i915 GEM buffer object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">pages</span></code></dt>
<dd>the scattergather list of physical pages</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function fixes up the swizzling in case any page frame number for this
object has changed in bit 17 since that state has been saved with
<a class="reference internal" href="#c.i915_gem_object_save_bit_17_swizzle" title="i915_gem_object_save_bit_17_swizzle"><code class="xref c c-func docutils literal"><span class="pre">i915_gem_object_save_bit_17_swizzle()</span></code></a>.</p>
<p>This is called when pinning backing storage again, since the kernel is free
to move unpinned backing storage around (either by directly moving pages or
by swapping them out and back in again).</p>
<dl class="function">
<dt id="c.i915_gem_object_save_bit_17_swizzle">
void <code class="descname">i915_gem_object_save_bit_17_swizzle</code><span class="sig-paren">(</span>struct drm_i915_gem_object *<em>&nbsp;obj</em>, struct sg_table *<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_object_save_bit_17_swizzle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>save bit 17 swizzling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>i915 GEM buffer object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">pages</span></code></dt>
<dd>the scattergather list of physical pages</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function saves the bit 17 of each page frame number so that swizzling
can be fixed up later on with <a class="reference internal" href="#c.i915_gem_object_do_bit_17_swizzle" title="i915_gem_object_do_bit_17_swizzle"><code class="xref c c-func docutils literal"><span class="pre">i915_gem_object_do_bit_17_swizzle()</span></code></a>. This must
be called before the backing storage can be unpinned.</p>
<div class="section" id="global-gtt-fence-handling">
<h4>Global GTT Fence Handling<a class="headerlink" href="#global-gtt-fence-handling" title="Permalink to this headline">Â¶</a></h4>
<p>Important to avoid confusions: &#8220;fences&#8221; in the i915 driver are not execution
fences used to track command completion but hardware detiler objects which
wrap a given range of the global GTT. Each platform has only a fairly limited
set of these objects.</p>
<p>Fences are used to detile GTT memory mappings. They&#8217;re also connected to the
hardware frontbuffer render tracking and hence interact with frontbuffer
compression. Furthermore on older platforms fences are required for tiled
objects used by the display engine. They can also be used by the render
engine - they&#8217;re required for blitter commands and are optional for render
commands. But on gen4+ both display (with the exception of fbc) and rendering
have their own tiling state bits and don&#8217;t need fences.</p>
<p>Also note that fences only support X and Y tiling and hence can&#8217;t be used for
the fancier new tiling formats like W, Ys and Yf.</p>
<p>Finally note that because fences are such a restricted resource they&#8217;re
dynamically associated with objects. Furthermore fence state is committed to
the hardware lazily to avoid unnecessary stalls on gen2/3. Therefore code must
explicitly call <code class="xref c c-func docutils literal"><span class="pre">i915_gem_object_get_fence()</span></code> to synchronize fencing status
for cpu access. Also note that some code wants an unfenced view, for those
cases the fence can be removed forcefully with <code class="xref c c-func docutils literal"><span class="pre">i915_gem_object_put_fence()</span></code>.</p>
<p>Internally these functions will synchronize with userspace access by removing
CPU ptes into GTT mmaps (not the GTT ptes themselves) as needed.</p>
</div>
<div class="section" id="hardware-tiling-and-swizzling-details">
<h4>Hardware Tiling and Swizzling Details<a class="headerlink" href="#hardware-tiling-and-swizzling-details" title="Permalink to this headline">Â¶</a></h4>
<p>The idea behind tiling is to increase cache hit rates by rearranging
pixel data so that a group of pixel accesses are in the same cacheline.
Performance improvement from doing this on the back/depth buffer are on
the order of 30%.</p>
<p>Intel architectures make this somewhat more complicated, though, by
adjustments made to addressing of data when the memory is in interleaved
mode (matched pairs of DIMMS) to improve memory bandwidth.
For interleaved memory, the CPU sends every sequential 64 bytes
to an alternate memory channel so it can get the bandwidth from both.</p>
<p>The GPU also rearranges its accesses for increased bandwidth to interleaved
memory, and it matches what the CPU does for non-tiled.  However, when tiled
it does it a little differently, since one walks addresses not just in the
X direction but also Y.  So, along with alternating channels when bit
6 of the address flips, it also alternates when other bits flip &#8211;  Bits 9
(every 512 bytes, an X tile scanline) and 10 (every two X tile scanlines)
are common to both the 915 and 965-class hardware.</p>
<p>The CPU also sometimes XORs in higher bits as well, to improve
bandwidth doing strided access like we do so frequently in graphics.  This
is called &#8220;Channel XOR Randomization&#8221; in the MCH documentation.  The result
is that the CPU is XORing in either bit 11 or bit 17 to bit 6 of its address
decode.</p>
<p>All of this bit 6 XORing has an effect on our memory management,
as we need to make sure that the 3d driver can correctly address object
contents.</p>
<p>If we don&#8217;t have interleaved memory, all tiling is safe and no swizzling is
required.</p>
<p>When bit 17 is XORed in, we simply refuse to tile at all.  Bit
17 is not just a page offset, so as we page an object out and back in,
individual pages in it will have different bit 17 addresses, resulting in
each 64 bytes being swapped with its neighbor!</p>
<p>Otherwise, if interleaved, we have to tell the 3d driver what the address
swizzling it needs to do is, since it&#8217;s writing with the CPU to the pages
(bit 6 and potentially bit 11 XORed in), and the GPU is reading from the
pages (bit 6, 9, and 10 XORed in), resulting in a cumulative bit swizzling
required by the CPU of XORing in bit 6, 9, 10, and potentially 11, in order
to match what the GPU expects.</p>
</div>
</div>
<div class="section" id="object-tiling-ioctls">
<h3>Object Tiling IOCTLs<a class="headerlink" href="#object-tiling-ioctls" title="Permalink to this headline">Â¶</a></h3>
<dl class="function">
<dt id="c.i915_gem_set_tiling">
int <code class="descname">i915_gem_set_tiling</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, void *<em>&nbsp;data</em>, struct drm_file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_set_tiling" title="Permalink to this definition">Â¶</a></dt>
<dd><p>IOCTL handler to set tiling mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data pointer for the ioctl</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>DRM file for the ioctl call</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the tiling mode of an object, returning the required swizzling of
bit 6 of addresses in the object.</p>
<p>Called by the user via ioctl.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.i915_gem_get_tiling">
int <code class="descname">i915_gem_get_tiling</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, void *<em>&nbsp;data</em>, struct drm_file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_get_tiling" title="Permalink to this definition">Â¶</a></dt>
<dd><p>IOCTL handler to get tiling mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data pointer for the ioctl</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>DRM file for the ioctl call</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the current tiling mode and required bit 6 swizzling for the object.</p>
<p>Called by the user via ioctl.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<p><a class="reference internal" href="#c.i915_gem_set_tiling" title="i915_gem_set_tiling"><code class="xref c c-func docutils literal"><span class="pre">i915_gem_set_tiling()</span></code></a> and <a class="reference internal" href="#c.i915_gem_get_tiling" title="i915_gem_get_tiling"><code class="xref c c-func docutils literal"><span class="pre">i915_gem_get_tiling()</span></code></a> is the userspace interface to
declare fence register requirements.</p>
<p>In principle GEM doesn&#8217;t care at all about the internal data layout of an
object, and hence it also doesn&#8217;t care about tiling or swizzling. There&#8217;s two
exceptions:</p>
<ul class="simple">
<li>For X and Y tiling the hardware provides detilers for CPU access, so called
fences. Since there&#8217;s only a limited amount of them the kernel must manage
these, and therefore userspace must tell the kernel the object tiling if it
wants to use fences for detiling.</li>
<li>On gen3 and gen4 platforms have a swizzling pattern for tiled objects which
depends upon the physical page frame number. When swapping such objects the
page frame number might change and the kernel must be able to fix this up
and hence now the tiling. Note that on a subset of platforms with
asymmetric memory channel population the swizzling pattern changes in an
unknown way, and for those the kernel simply forbids swapping completely.</li>
</ul>
<p>Since neither of this applies for new tiling layouts on modern platforms like
W, Ys and Yf tiling GEM only allows object tiling to be set to X or Y tiled.
Anything else can be handled in userspace entirely without the kernel&#8217;s
invovlement.</p>
</div>
<div class="section" id="buffer-object-eviction">
<h3>Buffer Object Eviction<a class="headerlink" href="#buffer-object-eviction" title="Permalink to this headline">Â¶</a></h3>
<p>This section documents the interface functions for evicting buffer
objects to make space available in the virtual gpu address spaces. Note
that this is mostly orthogonal to shrinking buffer objects caches, which
has the goal to make main memory (shared with the gpu through the
unified memory architecture) available.</p>
<dl class="function">
<dt id="c.i915_gem_evict_something">
int <code class="descname">i915_gem_evict_something</code><span class="sig-paren">(</span>struct i915_address_space *<em>&nbsp;vm</em>, u64<em>&nbsp;min_size</em>, u64<em>&nbsp;alignment</em>, unsigned<em>&nbsp;cache_level</em>, u64<em>&nbsp;start</em>, u64<em>&nbsp;end</em>, unsigned<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_evict_something" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Evict vmas to make room for binding a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_address_space</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>address space to evict from</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">min_size</span></code></dt>
<dd>size of the desired free space</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt>
<dd>alignment constraint of the desired free space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">cache_level</span></code></dt>
<dd>cache_level for the desired space</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">start</span></code></dt>
<dd>start (inclusive) of the range from which to evict objects</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">end</span></code></dt>
<dd>end (exclusive) of the range from which to evict objects</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt>
<dd>additional flags to control the eviction algorithm</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will try to evict vmas until a free space satisfying the
requirements is found. Callers must check first whether any such hole exists
already before calling this function.</p>
<p>This function is used by the object/vma binding code.</p>
<p>Since this function is only used to free up virtual address space it only
ignores pinned vmas, and not object where the backing storage itself is
pinned. Hence obj-&gt;pages_pin_count does not protect against eviction.</p>
<p>To clarify: This is for freeing up virtual address space, not for freeing
memory in e.g. the shrinker.</p>
<dl class="function">
<dt id="c.i915_gem_evict_vm">
int <code class="descname">i915_gem_evict_vm</code><span class="sig-paren">(</span>struct i915_address_space *<em>&nbsp;vm</em>, bool<em>&nbsp;do_idle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_evict_vm" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Evict all idle vmas from a vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_address_space</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>Address space to cleanse</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">do_idle</span></code></dt>
<dd>Boolean directing whether to idle first.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function evicts all idles vmas from a vm. If all unpinned vmas should be
evicted the <strong>do_idle</strong> needs to be set to true.</p>
<p>This is used by the execbuf code as a last-ditch effort to defragment the
address space.</p>
<p>To clarify: This is for freeing up virtual address space, not for freeing
memory in e.g. the shrinker.</p>
</div>
<div class="section" id="buffer-object-memory-shrinking">
<h3>Buffer Object Memory Shrinking<a class="headerlink" href="#buffer-object-memory-shrinking" title="Permalink to this headline">Â¶</a></h3>
<p>This section documents the interface function for shrinking memory usage
of buffer object caches. Shrinking is used to make main memory
available. Note that this is mostly orthogonal to evicting buffer
objects, which has the goal to make space in gpu virtual address spaces.</p>
<dl class="function">
<dt id="c.i915_gem_shrink">
unsigned long <code class="descname">i915_gem_shrink</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, unsigned long<em>&nbsp;target</em>, unsigned<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_shrink" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Shrink buffer object caches</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">target</span></code></dt>
<dd>amount of memory to make available, in pages</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt>
<dd>control flags for selecting cache types</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is the main interface to the shrinker. It will try to release
up to <strong>target</strong> pages of main memory backing storage from buffer objects.
Selection of the specific caches can be done with <strong>flags</strong>. This is e.g. useful
when purgeable objects should be removed from caches preferentially.</p>
<p>Note that it&#8217;s not guaranteed that released amount is actually available as
free system memory - the pages might still be in-used to due to other reasons
(like cpu mmaps) or the mm core has reused them before we could grab them.
Therefore code that needs to explicitly shrink buffer objects caches (e.g. to
avoid deadlocks in memory reclaim) must fall back to <a class="reference internal" href="#c.i915_gem_shrink_all" title="i915_gem_shrink_all"><code class="xref c c-func docutils literal"><span class="pre">i915_gem_shrink_all()</span></code></a>.</p>
<p>Also note that any kind of pinning (both per-vma address space pins and
backing storage pins at the buffer object level) result in the shrinker code
having to skip the object.</p>
<p><strong>Return</strong></p>
<p>The number of pages of backing storage actually released.</p>
<dl class="function">
<dt id="c.i915_gem_shrink_all">
unsigned long <code class="descname">i915_gem_shrink_all</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_shrink_all" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Shrink buffer object caches completely</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simple wraper around <a class="reference internal" href="#c.i915_gem_shrink" title="i915_gem_shrink"><code class="xref c c-func docutils literal"><span class="pre">i915_gem_shrink()</span></code></a> to aggressively shrink all
caches completely. It also first waits for and retires all outstanding
requests to also be able to release backing storage for active objects.</p>
<p>This should only be used in code to intentionally quiescent the gpu or as a
last-ditch effort when memory seems to have run out.</p>
<p><strong>Return</strong></p>
<p>The number of pages of backing storage actually released.</p>
<dl class="function">
<dt id="c.i915_gem_shrinker_init">
void <code class="descname">i915_gem_shrinker_init</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_shrinker_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Initialize i915 shrinker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers and sets up the i915 shrinker and OOM handler.</p>
<dl class="function">
<dt id="c.i915_gem_shrinker_cleanup">
void <code class="descname">i915_gem_shrinker_cleanup</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_gem_shrinker_cleanup" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Clean up i915 shrinker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>i915 device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters the i915 shrinker and OOM handler.</p>
</div>
</div>
<div class="section" id="guc">
<h2>GuC<a class="headerlink" href="#guc" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="guc-specific-firmware-loader">
<h3>GuC-specific firmware loader<a class="headerlink" href="#guc-specific-firmware-loader" title="Permalink to this headline">Â¶</a></h3>
<p>intel_guc:
Top level structure of guc. It handles firmware loading and manages client
pool and doorbells. intel_guc owns a i915_guc_client to replace the legacy
ExecList submission.</p>
<p>Firmware versioning:
The firmware build process will generate a version header file with major and
minor version defined. The versions are built into CSS header of firmware.
i915 kernel driver set the minimal firmware version required per platform.
The firmware installation package will install (symbolic link) proper version
of firmware.</p>
<p>GuC address space:
GuC does not allow any gfx GGTT address that falls into range [0, WOPCM_TOP),
which is reserved for Boot ROM, SRAM and WOPCM. Currently this top address is
512K. In order to exclude 0-512K address space from GGTT, all gfx objects
used by GuC is pinned with PIN_OFFSET_BIAS along with size of WOPCM.</p>
<p>Firmware log:
Firmware log is enabled by setting i915.guc_log_level to non-negative level.
Log data is printed out via reading debugfs i915_guc_log_dump. Reading from
i915_guc_load_status will print out firmware loading status and scratch
registers value.</p>
<dl class="function">
<dt id="c.intel_guc_setup">
int <code class="descname">intel_guc_setup</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_guc_setup" title="Permalink to this definition">Â¶</a></dt>
<dd><p>finish preparing the GuC for activity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from <code class="xref c c-func docutils literal"><span class="pre">gem_init_hw()</span></code> during driver loading and also after a GPU reset.</p>
<p>The main action required here it to load the GuC uCode into the device.
The firmware image should have already been fetched into memory by the
earlier call to <a class="reference internal" href="#c.intel_guc_init" title="intel_guc_init"><code class="xref c c-func docutils literal"><span class="pre">intel_guc_init()</span></code></a>, so here we need only check that worked,
and then transfer the image to the h/w.</p>
<p><strong>Return</strong></p>
<p>non-zero code on error</p>
<dl class="function">
<dt id="c.intel_guc_init">
void <code class="descname">intel_guc_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_guc_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>define parameters and fetch firmware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called early during driver load, but after GEM is initialised.</p>
<p>The firmware will be transferred to the GuC&#8217;s memory later,
when <a class="reference internal" href="#c.intel_guc_setup" title="intel_guc_setup"><code class="xref c c-func docutils literal"><span class="pre">intel_guc_setup()</span></code></a> is called.</p>
<dl class="function">
<dt id="c.intel_guc_fini">
void <code class="descname">intel_guc_fini</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_guc_fini" title="Permalink to this definition">Â¶</a></dt>
<dd><p>clean up all allocated resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
</dl>
</div>
<div class="section" id="guc-based-command-submission">
<h3>GuC-based command submission<a class="headerlink" href="#guc-based-command-submission" title="Permalink to this headline">Â¶</a></h3>
<p>i915_guc_client:
We use the term client to avoid confusion with contexts. A i915_guc_client is
equivalent to GuC object guc_context_desc. This context descriptor is
allocated from a pool of 1024 entries. Kernel driver will allocate doorbell
and workqueue for it. Also the process descriptor (guc_process_desc), which
is mapped to client space. So the client can write Work Item then ring the
doorbell.</p>
<p>To simplify the implementation, we allocate one gem object that contains all
pages for doorbell, process descriptor and workqueue.</p>
<p>The Scratch registers:
There are 16 MMIO-based registers start from 0xC180. The kernel driver writes
a value to the action register (SOFT_SCRATCH_0) along with any data. It then
triggers an interrupt on the GuC via another register write (0xC4C8).
Firmware writes a success/fail code back to the action register after
processes the request. The kernel driver polls waiting for this update and
then proceeds.
See <code class="xref c c-func docutils literal"><span class="pre">host2guc_action()</span></code></p>
<p>Doorbells:
Doorbells are interrupts to uKernel. A doorbell is a single cache line (QW)
mapped into process space.</p>
<p>Work Items:
There are several types of work items that the host may place into a
workqueue, each with its own requirements and limitations. Currently only
WQ_TYPE_INORDER is needed to support legacy submission via GuC, which
represents in-order queue. The kernel driver packs ring tail pointer and an
ELSP context descriptor dword into Work Item.
See <code class="xref c c-func docutils literal"><span class="pre">guc_wq_item_append()</span></code></p>
<dl class="function">
<dt id="c.i915_guc_wq_reserve">
int <code class="descname">i915_guc_wq_reserve</code><span class="sig-paren">(</span>struct drm_i915_gem_request *<em>&nbsp;request</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_guc_wq_reserve" title="Permalink to this definition">Â¶</a></dt>
<dd><p>reserve space in the GuC&#8217;s workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_gem_request</span> <span class="pre">*</span> <span class="pre">request</span></code></dt>
<dd>request associated with the commands</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>0 if space is available</dt>
<dd>-EAGAIN if space is not currently available</dd>
</dl>
<p>This function must be called (and must return 0) before a request
is submitted to the GuC via <a class="reference internal" href="#c.i915_guc_submit" title="i915_guc_submit"><code class="xref c c-func docutils literal"><span class="pre">i915_guc_submit()</span></code></a> below. Once a result
of 0 has been returned, it must be balanced by a corresponding
call to <code class="xref c c-func docutils literal"><span class="pre">submit()</span></code>.</p>
<p>Reservation allows the caller to determine in advance that space
will be available for the next submission before committing resources
to it, and helps avoid late failures with complicated recovery paths.</p>
<dl class="function">
<dt id="c.i915_guc_submit">
void <code class="descname">i915_guc_submit</code><span class="sig-paren">(</span>struct drm_i915_gem_request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i915_guc_submit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Submit commands through GuC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_gem_request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request associated with the commands</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>0 on success, otherwise an errno.</dt>
<dd>(Note: nonzero really shouldn&#8217;t happen!)</dd>
</dl>
<p>The caller must have already called <a class="reference internal" href="#c.i915_guc_wq_reserve" title="i915_guc_wq_reserve"><code class="xref c c-func docutils literal"><span class="pre">i915_guc_wq_reserve()</span></code></a> above with
a result of 0 (success), guaranteeing that there is space in the work
queue for the new request, so enqueuing the item cannot fail.</p>
<p>Bad Things Will Happen if the caller violates this protocol e.g. calls
<code class="xref c c-func docutils literal"><span class="pre">submit()</span></code> when <code class="xref c c-func docutils literal"><span class="pre">_reserve()</span></code> says there&#8217;s no space, or calls <code class="xref c c-func docutils literal"><span class="pre">_submit()</span></code>
a different number of times from (successful) calls to <code class="xref c c-func docutils literal"><span class="pre">_reserve()</span></code>.</p>
<p>The only error here arises if the doorbell hardware isn&#8217;t functioning
as expected, which really shouln&#8217;t happen.</p>
<dl class="function">
<dt id="c.guc_allocate_vma">
struct i915_vma * <code class="descname">guc_allocate_vma</code><span class="sig-paren">(</span>struct intel_guc *<em>&nbsp;guc</em>, u32<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.guc_allocate_vma" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Allocate a GGTT VMA for GuC usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">intel_guc</span> <span class="pre">*</span> <span class="pre">guc</span></code></dt>
<dd>the guc</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">size</span></code></dt>
<dd>size of area to allocate (both virtual space and memory)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a wrapper to create an object for use with the GuC. In order to
use it inside the GuC, an object needs to be pinned lifetime, so we allocate
both some backing storage and a range inside the Global GTT. We must pin
it in the GGTT somewhere other than than [0, GUC_WOPCM_TOP) because that
range is reserved inside GuC.</p>
<p><strong>Return</strong></p>
<p>A i915_vma if successful, otherwise an ERR_PTR.</p>
<dl class="function">
<dt id="c.guc_client_alloc">
struct i915_guc_client * <code class="descname">guc_client_alloc</code><span class="sig-paren">(</span>struct drm_i915_private *<em>&nbsp;dev_priv</em>, uint32_t<em>&nbsp;engines</em>, uint32_t<em>&nbsp;priority</em>, struct i915_gem_context *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.guc_client_alloc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Allocate an i915_guc_client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_i915_private</span> <span class="pre">*</span> <span class="pre">dev_priv</span></code></dt>
<dd>driver private data structure</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">engines</span></code></dt>
<dd>The set of engines to enable for this client</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">priority</span></code></dt>
<dd>four levels priority _CRITICAL, _HIGH, _NORMAL and _LOW
The kernel client to replace ExecList submission is created with
NORMAL priority. Priority of a client for scheduler can be HIGH,
while a preemption context can use CRITICAL.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i915_gem_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>the context that owns the client (we use the default render
context)</dd>
</dl>
<p><strong>Return</strong></p>
<p>An i915_guc_client object if success, else NULL.</p>
<dl class="function">
<dt id="c.intel_guc_suspend">
int <code class="descname">intel_guc_suspend</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_guc_suspend" title="Permalink to this definition">Â¶</a></dt>
<dd><p>notify GuC entering suspend state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
</dl>
<dl class="function">
<dt id="c.intel_guc_resume">
int <code class="descname">intel_guc_resume</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intel_guc_resume" title="Permalink to this definition">Â¶</a></dt>
<dd><p>notify GuC resuming from suspend state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
</dl>
</div>
<div class="section" id="guc-firmware-layout">
<h3>GuC Firmware Layout<a class="headerlink" href="#guc-firmware-layout" title="Permalink to this headline">Â¶</a></h3>
<p>The GuC firmware layout looks like this:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="100%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><blockquote class="first">
<div>guc_css_header</div></blockquote>
<p class="last">contains major/minor version</p>
</td>
</tr>
<tr class="row-even"><td>uCode</td>
</tr>
<tr class="row-odd"><td>RSA signature</td>
</tr>
<tr class="row-even"><td>modulus key</td>
</tr>
<tr class="row-odd"><td>exponent val</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The firmware may or may not have modulus key and exponent data. The header,
uCode and RSA signature are must-have components that will be used by driver.
Length of each components, which is all in dwords, can be found in header.
In the case that modulus and exponent are not present in fw, a.k.a truncated
image, the length value still appears in header.</p>
<p>Driver will do some basic fw size validation based on the following rules:</p>
<ol class="arabic simple">
<li>Header, uCode and RSA are must-have components.</li>
<li>All firmware components, if they present, are in the sequence illustrated
in the layout table above.</li>
<li>Length info of each component can be found in header, in dwords.</li>
<li>Modulus and exponent key are not required by driver. They may not appear
in fw. So driver will load a truncated firmware in this case.</li>
</ol>
</div>
</div>
<div class="section" id="tracing">
<h2>Tracing<a class="headerlink" href="#tracing" title="Permalink to this headline">Â¶</a></h2>
<p>This sections covers all things related to the tracepoints implemented
in the i915 driver.</p>
<div class="section" id="i915-ppgtt-create-and-i915-ppgtt-release">
<h3>i915_ppgtt_create and i915_ppgtt_release<a class="headerlink" href="#i915-ppgtt-create-and-i915-ppgtt-release" title="Permalink to this headline">Â¶</a></h3>
<p>With full ppgtt enabled each process using drm will allocate at least one
translation table. With these traces it is possible to keep track of the
allocation and of the lifetime of the tables; this can be used during
testing/debug to verify that we are not leaking ppgtts.
These traces identify the ppgtt through the vm pointer, which is also printed
by the i915_vma_bind and i915_vma_unbind tracepoints.</p>
</div>
<div class="section" id="i915-context-create-and-i915-context-free">
<h3>i915_context_create and i915_context_free<a class="headerlink" href="#i915-context-create-and-i915-context-free" title="Permalink to this headline">Â¶</a></h3>
<p>These tracepoints are used to track creation and deletion of contexts.
If full ppgtt is enabled, they also print the address of the vm assigned to
the context.</p>
</div>
<div class="section" id="switch-mm">
<h3>switch_mm<a class="headerlink" href="#switch-mm" title="Permalink to this headline">Â¶</a></h3>
<p>This tracepoint allows tracking of the mm switch, which is an important point
in the lifetime of the vm in the legacy submission path. This tracepoint is
called only if full ppgtt is enabled.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="vga-switcheroo.html" class="btn btn-neutral float-right" title="VGA Switcheroo" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-uapi.html" class="btn btn-neutral" title="Userland interfaces" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.10.0-rc8+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>