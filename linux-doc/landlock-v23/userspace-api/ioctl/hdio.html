

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Summary of HDIO_ ioctl calls &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Linux Media Infrastructure userspace API" href="../media/index.html" />
    <link rel="prev" title="Summary of CDROM ioctl calls" href="cdrom.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux kernel user-space API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../no_new_privs.html">No New Privileges Flag</a></li>
<li class="toctree-l2"><a class="reference internal" href="../seccomp_filter.html">Seccomp BPF (SECure COMPuting with filters)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../landlock.html">Landlock: unprivileged access control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../unshare.html">unshare system call</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spec_ctrl.html">Speculation Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../accelerators/ocxl.html">OpenCAPI (Open Coherent Accelerator Processor Interface)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">IOCTLs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ioctl-number.html">Ioctl Numbers</a></li>
<li class="toctree-l3"><a class="reference internal" href="ioctl-decoding.html">Decoding an IOCTL Magic Number</a></li>
<li class="toctree-l3"><a class="reference internal" href="cdrom.html">Summary of CDROM ioctl calls</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Summary of <cite>HDIO_</cite> ioctl calls</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Linux Media Infrastructure userspace API</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux kernel user-space API guide</a> &raquo;</li>
        
          <li><a href="index.html">IOCTLs</a> &raquo;</li>
        
      <li>Summary of <cite>HDIO_</cite> ioctl calls</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/userspace-api/ioctl/hdio.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="summary-of-hdio-ioctl-calls">
<h1>Summary of <cite>HDIO_</cite> ioctl calls<a class="headerlink" href="#summary-of-hdio-ioctl-calls" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p>Edward A. Falk &lt;<a class="reference external" href="mailto:efalk&#37;&#52;&#48;google&#46;com">efalk<span>&#64;</span>google<span>&#46;</span>com</a>&gt;</p></li>
</ul>
<p>November, 2004</p>
<p>This document attempts to describe the ioctl(2) calls supported by
the HD/IDE layer.  These are by-and-large implemented (as of Linux 2.6)
in drivers/ide/ide.c and drivers/block/scsi_ioctl.c</p>
<p>ioctl values are listed in &lt;linux/hdreg.h&gt;.  As of this writing, they
are as follows:</p>
<blockquote>
<div><p>ioctls that pass argument pointers to user space:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 37%" />
<col style="width: 63%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>HDIO_GETGEO</p></td>
<td><p>get device geometry</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_GET_UNMASKINTR</p></td>
<td><p>get current unmask setting</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_GET_MULTCOUNT</p></td>
<td><p>get current IDE blockmode setting</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_GET_QDMA</p></td>
<td><p>get use-qdma flag</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_SET_XFER</p></td>
<td><p>set transfer rate via proc</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_OBSOLETE_IDENTITY</p></td>
<td><p>OBSOLETE, DO NOT USE</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_GET_KEEPSETTINGS</p></td>
<td><p>get keep-settings-on-reset flag</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_GET_32BIT</p></td>
<td><p>get current io_32bit setting</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_GET_NOWERR</p></td>
<td><p>get ignore-write-error flag</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_GET_DMA</p></td>
<td><p>get use-dma flag</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_GET_NICE</p></td>
<td><p>get nice flags</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_GET_IDENTITY</p></td>
<td><p>get IDE identification info</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_GET_WCACHE</p></td>
<td><p>get write cache mode on|off</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_GET_ACOUSTIC</p></td>
<td><p>get acoustic value</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_GET_ADDRESS</p></td>
<td><p>get sector addressing mode</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_GET_BUSSTATE</p></td>
<td><p>get the bus state of the hwif</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_TRISTATE_HWIF</p></td>
<td><p>execute a channel tristate</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_DRIVE_RESET</p></td>
<td><p>execute a device reset</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_DRIVE_TASKFILE</p></td>
<td><p>execute raw taskfile</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_DRIVE_TASK</p></td>
<td><p>execute task and special drive command</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_DRIVE_CMD</p></td>
<td><p>execute a special drive command</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_DRIVE_CMD_AEB</p></td>
<td><p>HDIO_DRIVE_TASK</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>ioctls that pass non-pointer values:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 37%" />
<col style="width: 63%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>HDIO_SET_MULTCOUNT</p></td>
<td><p>change IDE blockmode</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_SET_UNMASKINTR</p></td>
<td><p>permit other irqs during I/O</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_SET_KEEPSETTINGS</p></td>
<td><p>keep ioctl settings on reset</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_SET_32BIT</p></td>
<td><p>change io_32bit flags</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_SET_NOWERR</p></td>
<td><p>change ignore-write-error flag</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_SET_DMA</p></td>
<td><p>change use-dma flag</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_SET_PIO_MODE</p></td>
<td><p>reconfig interface to new speed</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_SCAN_HWIF</p></td>
<td><p>register and (re)scan interface</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_SET_NICE</p></td>
<td><p>set nice flags</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_UNREGISTER_HWIF</p></td>
<td><p>unregister interface</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_SET_WCACHE</p></td>
<td><p>change write cache enable-disable</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_SET_ACOUSTIC</p></td>
<td><p>change acoustic behavior</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_SET_BUSSTATE</p></td>
<td><p>set the bus state of the hwif</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_SET_QDMA</p></td>
<td><p>change use-qdma flag</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_SET_ADDRESS</p></td>
<td><p>change lba addressing modes</p></td>
</tr>
<tr class="row-even"><td><p>HDIO_SET_IDE_SCSI</p></td>
<td><p>Set scsi emulation mode on/off</p></td>
</tr>
<tr class="row-odd"><td><p>HDIO_SET_SCSI_IDE</p></td>
<td><p>not implemented yet</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div></blockquote>
<p>The information that follows was determined from reading kernel source
code.  It is likely that some corrections will be made over time.</p>
<hr class="docutils" />
<p>General:</p>
<blockquote>
<div><p>Unless otherwise specified, all ioctl calls return 0 on success
and -1 with errno set to an appropriate value on error.</p>
<p>Unless otherwise specified, all ioctl calls return -1 and set
errno to EFAULT on a failed attempt to copy data to or from user
address space.</p>
<p>Unless otherwise specified, all data structures and constants
are defined in &lt;linux/hdreg.h&gt;</p>
</div></blockquote>
<hr class="docutils" />
<dl>
<dt>HDIO_GETGEO</dt><dd><p>get device geometry</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hd_geometry geom;

ioctl(fd, HDIO_GETGEO, &amp;geom);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>hd_geometry structure containing:</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>heads</p></td>
<td><p>number of heads</p></td>
</tr>
<tr class="row-even"><td><p>sectors</p></td>
<td><p>number of sectors/track</p></td>
</tr>
<tr class="row-odd"><td><p>cylinders</p></td>
<td><p>number of cylinders, mod 65536</p></td>
</tr>
<tr class="row-even"><td><p>start</p></td>
<td><p>starting sector of this partition.</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>error returns:</dt><dd><ul>
<li><p>EINVAL</p>
<blockquote>
<div><p>if the device is not a disk drive or floppy drive,
or if the user passes a null pointer</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt>notes:</dt><dd><p>Not particularly useful with modern disk drives, whose geometry
is a polite fiction anyway.  Modern drives are addressed
purely by sector number nowadays (lba addressing), and the
drive geometry is an abstraction which is actually subject
to change.  Currently (as of Nov 2004), the geometry values
are the “bios” values – presumably the values the drive had
when Linux first booted.</p>
<p>In addition, the cylinders field of the hd_geometry is an
unsigned short, meaning that on most architectures, this
ioctl will not return a meaningful value on drives with more
than 65535 tracks.</p>
<p>The start field is unsigned long, meaning that it will not
contain a meaningful value for disks over 219 Gb in size.</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_UNMASKINTR</dt><dd><p>get current unmask setting</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_UNMASKINTR, &amp;val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The value of the drive’s current unmask setting</p>
</dd>
</dl>
</dd>
<dt>HDIO_SET_UNMASKINTR</dt><dd><p>permit other irqs during I/O</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned long val;

ioctl(fd, HDIO_SET_UNMASKINTR, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New value for unmask flag</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range [0 1]</p></li>
<li><p>EBUSY       Controller busy</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_GET_MULTCOUNT</dt><dd><p>get current IDE blockmode setting</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_MULTCOUNT, &amp;val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The value of the current IDE block mode setting.  This
controls how many sectors the drive will transfer per
interrupt.</p>
</dd>
</dl>
</dd>
<dt>HDIO_SET_MULTCOUNT</dt><dd><p>change IDE blockmode</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_MULTCOUNT, val);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>New value for IDE block mode setting.  This controls how many
sectors the drive will transfer per interrupt.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range supported by disk.</p></li>
<li><p>EBUSY       Controller busy or blockmode already set.</p></li>
<li><p>EIO         Drive did not accept new block mode.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><p>Source code comments read:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This is tightly woven into the driver-&gt;do_special cannot
touch.  DON&#39;T do it again until a total personality rewrite
is committed.
</pre></div>
</div>
<p>If blockmode has already been set, this ioctl will fail with
-EBUSY</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_QDMA</dt><dd><p>get use-qdma flag</p>
<p>Not implemented, as of 2.6.8.1</p>
</dd>
<dt>HDIO_SET_XFER</dt><dd><p>set transfer rate via proc</p>
<p>Not implemented, as of 2.6.8.1</p>
</dd>
<dt>HDIO_OBSOLETE_IDENTITY</dt><dd><p>OBSOLETE, DO NOT USE</p>
<p>Same as HDIO_GET_IDENTITY (see below), except that it only
returns the first 142 bytes of drive identity information.</p>
</dd>
<dt>HDIO_GET_IDENTITY</dt><dd><p>get IDE identification info</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned char identity[512];

ioctl(fd, HDIO_GET_IDENTITY, identity);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>ATA drive identity information.  For full description, see
the IDENTIFY DEVICE and IDENTIFY PACKET DEVICE commands in
the ATA specification.</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>ENOMSG      IDENTIFY DEVICE information not available</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><p>Returns information that was obtained when the drive was
probed.  Some of this information is subject to change, and
this ioctl does not re-probe the drive to update the
information.</p>
<p>This information is also available from /proc/ide/hdX/identify</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_KEEPSETTINGS</dt><dd><p>get keep-settings-on-reset flag</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_KEEPSETTINGS, &amp;val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The value of the current “keep settings” flag</p>
</dd>
<dt>notes:</dt><dd><p>When set, indicates that kernel should restore settings
after a drive reset.</p>
</dd>
</dl>
</dd>
<dt>HDIO_SET_KEEPSETTINGS</dt><dd><p>keep ioctl settings on reset</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_SET_KEEPSETTINGS, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New value for keep_settings flag</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range [0 1]</p></li>
<li><p>EBUSY               Controller busy</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_GET_32BIT</dt><dd><p>get current io_32bit setting</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_32BIT, &amp;val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The value of the current io_32bit setting</p>
</dd>
<dt>notes:</dt><dd><p>0=16-bit, 1=32-bit, 2,3 = 32bit+sync</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_NOWERR</dt><dd><p>get ignore-write-error flag</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_NOWERR, &amp;val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The value of the current ignore-write-error flag</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_DMA</dt><dd><p>get use-dma flag</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_DMA, &amp;val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The value of the current use-dma flag</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_NICE</dt><dd><p>get nice flags</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long nice;

ioctl(fd, HDIO_GET_NICE, &amp;nice);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The drive’s “nice” values.</p>
</dd>
<dt>notes:</dt><dd><p>Per-drive flags which determine when the system will give more
bandwidth to other devices sharing the same IDE bus.</p>
<p>See &lt;linux/hdreg.h&gt;, near symbol IDE_NICE_DSC_OVERLAP.</p>
</dd>
</dl>
</dd>
<dt>HDIO_SET_NICE</dt><dd><p>set nice flags</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned long nice;

...
ioctl(fd, HDIO_SET_NICE, nice);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>bitmask of nice flags.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EPERM       Flags other than DSC_OVERLAP and NICE_1 set.</p></li>
<li><p>EPERM       DSC_OVERLAP specified but not supported by drive</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><p>This ioctl sets the DSC_OVERLAP and NICE_1 flags from values
provided by the user.</p>
<p>Nice flags are listed in &lt;linux/hdreg.h&gt;, starting with
IDE_NICE_DSC_OVERLAP.  These values represent shifts.</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_WCACHE</dt><dd><p>get write cache mode on|off</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_WCACHE, &amp;val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The value of the current write cache mode</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_ACOUSTIC</dt><dd><p>get acoustic value</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_ACOUSTIC, &amp;val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The value of the current acoustic settings</p>
</dd>
<dt>notes:</dt><dd><p>See HDIO_SET_ACOUSTIC</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_ADDRESS</dt><dd><p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_ADDRESS, &amp;val);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>The value of the current addressing mode:</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 5%" />
<col style="width: 95%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>28-bit</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>48-bit</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>48-bit doing 28-bit</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>64-bit</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
<dt>HDIO_GET_BUSSTATE</dt><dd><p>get the bus state of the hwif</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long state;

ioctl(fd, HDIO_SCAN_HWIF, &amp;state);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>Current power state of the IDE bus.  One of BUSSTATE_OFF,
BUSSTATE_ON, or BUSSTATE_TRISTATE</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_BUSSTATE</dt><dd><p>set the bus state of the hwif</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int state;

...
ioctl(fd, HDIO_SCAN_HWIF, state);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>Desired IDE power state.  One of BUSSTATE_OFF, BUSSTATE_ON,
or BUSSTATE_TRISTATE</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_RAWIO</p></li>
<li><p>EOPNOTSUPP  Hardware interface does not support bus power control</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_TRISTATE_HWIF</dt><dd><p>execute a channel tristate</p>
<p>Not implemented, as of 2.6.8.1.  See HDIO_SET_BUSSTATE</p>
</dd>
<dt>HDIO_DRIVE_RESET</dt><dd><p>execute a device reset</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int args[3]

...
ioctl(fd, HDIO_DRIVE_RESET, args);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>ENXIO       No such device: phy dead or ctl_addr == 0</p></li>
<li><p>EIO         I/O error:      reset timed out or hardware error</p></li>
</ul>
</dd>
</dl>
<p>notes:</p>
<blockquote>
<div><ul class="simple">
<li><p>Execute a reset on the device as soon as the current IO
operation has completed.</p></li>
<li><p>Executes an ATAPI soft reset if applicable, otherwise
executes an ATA soft reset on the controller.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>HDIO_DRIVE_TASKFILE</dt><dd><p>execute raw taskfile</p>
<dl class="simple">
<dt>Note:</dt><dd><p>If you don’t have a copy of the ANSI ATA specification
handy, you should probably ignore this ioctl.</p>
</dd>
</dl>
<ul class="simple">
<li><p>Execute an ATA disk command directly by writing the “taskfile”
registers of the drive.  Requires ADMIN and RAWIO access
privileges.</p></li>
</ul>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct {

  ide_task_request_t req_task;
  u8 outbuf[OUTPUT_SIZE];
  u8 inbuf[INPUT_SIZE];
} task;
memset(&amp;task.req_task, 0, sizeof(task.req_task));
task.req_task.out_size = sizeof(task.outbuf);
task.req_task.in_size = sizeof(task.inbuf);
...
ioctl(fd, HDIO_DRIVE_TASKFILE, &amp;task);
...
</pre></div>
</div>
<p>inputs:</p>
<blockquote>
<div><p>(See below for details on memory area passed to ioctl.)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>io_ports[8]</p></td>
<td><p>values to be written to taskfile registers</p></td>
</tr>
<tr class="row-even"><td><p>hob_ports[8]</p></td>
<td><p>high-order bytes, for extended commands.</p></td>
</tr>
<tr class="row-odd"><td><p>out_flags</p></td>
<td><p>flags indicating which registers are valid</p></td>
</tr>
<tr class="row-even"><td><p>in_flags</p></td>
<td><p>flags indicating which registers should be returned</p></td>
</tr>
<tr class="row-odd"><td><p>data_phase</p></td>
<td><p>see below</p></td>
</tr>
<tr class="row-even"><td><p>req_cmd</p></td>
<td><p>command type to be executed</p></td>
</tr>
<tr class="row-odd"><td><p>out_size</p></td>
<td><p>size of output buffer</p></td>
</tr>
<tr class="row-even"><td><p>outbuf</p></td>
<td><p>buffer of data to be transmitted to disk</p></td>
</tr>
<tr class="row-odd"><td><p>inbuf</p></td>
<td><p>buffer of data to be received from disk (see [1])</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>outputs:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 83%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>io_ports[]</p></td>
<td><p>values returned in the taskfile registers</p></td>
</tr>
<tr class="row-even"><td><p>hob_ports[]</p></td>
<td><p>high-order bytes, for extended commands.</p></td>
</tr>
<tr class="row-odd"><td><p>out_flags</p></td>
<td><p>flags indicating which registers are valid (see [2])</p></td>
</tr>
<tr class="row-even"><td><p>in_flags</p></td>
<td><p>flags indicating which registers should be returned</p></td>
</tr>
<tr class="row-odd"><td><p>outbuf</p></td>
<td><p>buffer of data to be transmitted to disk (see [1])</p></td>
</tr>
<tr class="row-even"><td><p>inbuf</p></td>
<td><p>buffer of data to be received from disk</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl>
<dt>error returns:</dt><dd><ul>
<li><p>EACCES      CAP_SYS_ADMIN or CAP_SYS_RAWIO privilege not set.</p></li>
<li><p>ENOMSG      Device is not a disk drive.</p></li>
<li><p>ENOMEM      Unable to allocate memory for task</p></li>
<li><p>EFAULT      req_cmd == TASKFILE_IN_OUT (not implemented as of 2.6.8)</p></li>
<li><p>EPERM</p>
<blockquote>
<div><p>req_cmd == TASKFILE_MULTI_OUT and drive
multi-count not yet set.</p>
</div></blockquote>
</li>
<li><p>EIO         Drive failed the command.</p></li>
</ul>
</dd>
</dl>
<p>notes:</p>
<blockquote>
<div><p>[1] READ THE FOLLOWING NOTES <em>CAREFULLY</em>.  THIS IOCTL IS
FULL OF GOTCHAS.  Extreme caution should be used with using
this ioctl.  A mistake can easily corrupt data or hang the
system.</p>
<p>[2] Both the input and output buffers are copied from the
user and written back to the user, even when not used.</p>
<p>[3] If one or more bits are set in out_flags and in_flags is
zero, the following values are used for in_flags.all and
written back into in_flags on completion.</p>
<blockquote>
<div><ul class="simple">
<li><p>IDE_TASKFILE_STD_IN_FLAGS | (IDE_HOB_STD_IN_FLAGS &lt;&lt; 8)
if LBA48 addressing is enabled for the drive</p></li>
<li><p>IDE_TASKFILE_STD_IN_FLAGS
if CHS/LBA28</p></li>
</ul>
</div></blockquote>
<p>The association between in_flags.all and each enable
bitfield flips depending on endianness; fortunately, TASKFILE
only uses inflags.b.data bit and ignores all other bits.
The end result is that, on any endian machines, it has no
effect other than modifying in_flags on completion.</p>
<p>[4] The default value of SELECT is (0xa0|DEV_bit|LBA_bit)
except for four drives per port chipsets.  For four drives
per port chipsets, it’s (0xa0|DEV_bit|LBA_bit) for the first
pair and (0x80|DEV_bit|LBA_bit) for the second pair.</p>
<p>[5] The argument to the ioctl is a pointer to a region of
memory containing a ide_task_request_t structure, followed
by an optional buffer of data to be transmitted to the
drive, followed by an optional buffer to receive data from
the drive.</p>
<p>Command is passed to the disk drive via the ide_task_request_t
structure, which contains these fields:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>io_ports[8]</p></td>
<td><p>values for the taskfile registers</p></td>
</tr>
<tr class="row-even"><td><p>hob_ports[8]</p></td>
<td><p>high-order bytes, for extended commands</p></td>
</tr>
<tr class="row-odd"><td><p>out_flags</p></td>
<td><p>flags indicating which entries in the
io_ports[] and hob_ports[] arrays
contain valid values.  Type ide_reg_valid_t.</p></td>
</tr>
<tr class="row-even"><td><p>in_flags</p></td>
<td><p>flags indicating which entries in the
io_ports[] and hob_ports[] arrays
are expected to contain valid values
on return.</p></td>
</tr>
<tr class="row-odd"><td><p>data_phase</p></td>
<td><p>See below</p></td>
</tr>
<tr class="row-even"><td><p>req_cmd</p></td>
<td><p>Command type, see below</p></td>
</tr>
<tr class="row-odd"><td><p>out_size</p></td>
<td><p>output (user-&gt;drive) buffer size, bytes</p></td>
</tr>
<tr class="row-even"><td><p>in_size</p></td>
<td><p>input (drive-&gt;user) buffer size, bytes</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>When out_flags is zero, the following registers are loaded.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>HOB_FEATURE</p></td>
<td><p>If the drive supports LBA48</p></td>
</tr>
<tr class="row-even"><td><p>HOB_NSECTOR</p></td>
<td><p>If the drive supports LBA48</p></td>
</tr>
<tr class="row-odd"><td><p>HOB_SECTOR</p></td>
<td><p>If the drive supports LBA48</p></td>
</tr>
<tr class="row-even"><td><p>HOB_LCYL</p></td>
<td><p>If the drive supports LBA48</p></td>
</tr>
<tr class="row-odd"><td><p>HOB_HCYL</p></td>
<td><p>If the drive supports LBA48</p></td>
</tr>
<tr class="row-even"><td><p>FEATURE</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>NSECTOR</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>SECTOR</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>LCYL</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>HCYL</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>SELECT</p></td>
<td><p>First, masked with 0xE0 if LBA48, 0xEF
otherwise; then, or’ed with the default
value of SELECT.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If any bit in out_flags is set, the following registers are loaded.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>HOB_DATA</p></td>
<td><p>If out_flags.b.data is set.  HOB_DATA will
travel on DD8-DD15 on little endian machines
and on DD0-DD7 on big endian machines.</p></td>
</tr>
<tr class="row-even"><td><p>DATA</p></td>
<td><p>If out_flags.b.data is set.  DATA will
travel on DD0-DD7 on little endian machines
and on DD8-DD15 on big endian machines.</p></td>
</tr>
<tr class="row-odd"><td><p>HOB_NSECTOR</p></td>
<td><p>If out_flags.b.nsector_hob is set</p></td>
</tr>
<tr class="row-even"><td><p>HOB_SECTOR</p></td>
<td><p>If out_flags.b.sector_hob is set</p></td>
</tr>
<tr class="row-odd"><td><p>HOB_LCYL</p></td>
<td><p>If out_flags.b.lcyl_hob is set</p></td>
</tr>
<tr class="row-even"><td><p>HOB_HCYL</p></td>
<td><p>If out_flags.b.hcyl_hob is set</p></td>
</tr>
<tr class="row-odd"><td><p>FEATURE</p></td>
<td><p>If out_flags.b.feature is set</p></td>
</tr>
<tr class="row-even"><td><p>NSECTOR</p></td>
<td><p>If out_flags.b.nsector is set</p></td>
</tr>
<tr class="row-odd"><td><p>SECTOR</p></td>
<td><p>If out_flags.b.sector is set</p></td>
</tr>
<tr class="row-even"><td><p>LCYL</p></td>
<td><p>If out_flags.b.lcyl is set</p></td>
</tr>
<tr class="row-odd"><td><p>HCYL</p></td>
<td><p>If out_flags.b.hcyl is set</p></td>
</tr>
<tr class="row-even"><td><p>SELECT</p></td>
<td><p>Or’ed with the default value of SELECT and
loaded regardless of out_flags.b.select.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Taskfile registers are read back from the drive into
{io|hob}_ports[] after the command completes iff one of the
following conditions is met; otherwise, the original values
will be written back, unchanged.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The drive fails the command (EIO).</p></li>
<li><p>One or more than one bits are set in out_flags.</p></li>
<li><p>The requested data_phase is TASKFILE_NO_DATA.</p></li>
</ol>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>HOB_DATA</p></td>
<td><p>If in_flags.b.data is set.  It will contain
DD8-DD15 on little endian machines and
DD0-DD7 on big endian machines.</p></td>
</tr>
<tr class="row-even"><td><p>DATA</p></td>
<td><p>If in_flags.b.data is set.  It will contain
DD0-DD7 on little endian machines and
DD8-DD15 on big endian machines.</p></td>
</tr>
<tr class="row-odd"><td><p>HOB_FEATURE</p></td>
<td><p>If the drive supports LBA48</p></td>
</tr>
<tr class="row-even"><td><p>HOB_NSECTOR</p></td>
<td><p>If the drive supports LBA48</p></td>
</tr>
<tr class="row-odd"><td><p>HOB_SECTOR</p></td>
<td><p>If the drive supports LBA48</p></td>
</tr>
<tr class="row-even"><td><p>HOB_LCYL</p></td>
<td><p>If the drive supports LBA48</p></td>
</tr>
<tr class="row-odd"><td><p>HOB_HCYL</p></td>
<td><p>If the drive supports LBA48</p></td>
</tr>
<tr class="row-even"><td><p>NSECTOR</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>SECTOR</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>LCYL</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>HCYL</p></td>
<td></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The data_phase field describes the data transfer to be
performed.  Value is one of:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>TASKFILE_IN</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TASKFILE_MULTI_IN</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>TASKFILE_OUT</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TASKFILE_MULTI_OUT</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>TASKFILE_IN_OUT</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TASKFILE_IN_DMA</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>TASKFILE_IN_DMAQ</p></td>
<td><p>== IN_DMA (queueing not supported)</p></td>
</tr>
<tr class="row-even"><td><p>TASKFILE_OUT_DMA</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>TASKFILE_OUT_DMAQ</p></td>
<td><p>== OUT_DMA (queueing not supported)</p></td>
</tr>
<tr class="row-even"><td><p>TASKFILE_P_IN</p></td>
<td><p>unimplemented</p></td>
</tr>
<tr class="row-odd"><td><p>TASKFILE_P_IN_DMA</p></td>
<td><p>unimplemented</p></td>
</tr>
<tr class="row-even"><td><p>TASKFILE_P_IN_DMAQ</p></td>
<td><p>unimplemented</p></td>
</tr>
<tr class="row-odd"><td><p>TASKFILE_P_OUT</p></td>
<td><p>unimplemented</p></td>
</tr>
<tr class="row-even"><td><p>TASKFILE_P_OUT_DMA</p></td>
<td><p>unimplemented</p></td>
</tr>
<tr class="row-odd"><td><p>TASKFILE_P_OUT_DMAQ</p></td>
<td><p>unimplemented</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The req_cmd field classifies the command type.  It may be
one of:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 62%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>IDE_DRIVE_TASK_NO_DATA</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>IDE_DRIVE_TASK_SET_XFER</p></td>
<td><p>unimplemented</p></td>
</tr>
<tr class="row-odd"><td><p>IDE_DRIVE_TASK_IN</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>IDE_DRIVE_TASK_OUT</p></td>
<td><p>unimplemented</p></td>
</tr>
<tr class="row-odd"><td><p>IDE_DRIVE_TASK_RAW_WRITE</p></td>
<td></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>[6] Do not access {in|out}_flags-&gt;all except for resetting
all the bits.  Always access individual bit fields.  -&gt;all
value will flip depending on endianness.  For the same
reason, do not use IDE_{TASKFILE|HOB}_STD_{OUT|IN}_FLAGS
constants defined in hdreg.h.</p>
</div></blockquote>
</dd>
<dt>HDIO_DRIVE_CMD</dt><dd><p>execute a special drive command</p>
<p>Note:  If you don’t have a copy of the ANSI ATA specification
handy, you should probably ignore this ioctl.</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u8 args[4+XFER_SIZE];

...
ioctl(fd, HDIO_DRIVE_CMD, args);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>Commands other than WIN_SMART:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>args[0]</p></td>
<td><p>COMMAND</p></td>
</tr>
<tr class="row-even"><td><p>args[1]</p></td>
<td><p>NSECTOR</p></td>
</tr>
<tr class="row-odd"><td><p>args[2]</p></td>
<td><p>FEATURE</p></td>
</tr>
<tr class="row-even"><td><p>args[3]</p></td>
<td><p>NSECTOR</p></td>
</tr>
</tbody>
</table>
<p>WIN_SMART:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>args[0]</p></td>
<td><p>COMMAND</p></td>
</tr>
<tr class="row-even"><td><p>args[1]</p></td>
<td><p>SECTOR</p></td>
</tr>
<tr class="row-odd"><td><p>args[2]</p></td>
<td><p>FEATURE</p></td>
</tr>
<tr class="row-even"><td><p>args[3]</p></td>
<td><p>NSECTOR</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>args[] buffer is filled with register values followed by any</p>
</div></blockquote>
<p>data returned by the disk.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>args[0]</p></td>
<td><p>status</p></td>
</tr>
<tr class="row-even"><td><p>args[1]</p></td>
<td><p>error</p></td>
</tr>
<tr class="row-odd"><td><p>args[2]</p></td>
<td><p>NSECTOR</p></td>
</tr>
<tr class="row-even"><td><p>args[3]</p></td>
<td><p>undefined</p></td>
</tr>
<tr class="row-odd"><td><p>args[4+]</p></td>
<td><p>NSECTOR * 512 bytes of data returned by the command.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_RAWIO</p></li>
<li><p>ENOMEM      Unable to allocate memory for task</p></li>
<li><p>EIO         Drive reports error</p></li>
</ul>
</dd>
</dl>
<p>notes:</p>
<blockquote>
<div><p>[1] For commands other than WIN_SMART, args[1] should equal
args[3].  SECTOR, LCYL and HCYL are undefined.  For
WIN_SMART, 0x4f and 0xc2 are loaded into LCYL and HCYL
respectively.  In both cases SELECT will contain the default
value for the drive.  Please refer to HDIO_DRIVE_TASKFILE
notes for the default value of SELECT.</p>
<p>[2] If NSECTOR value is greater than zero and the drive sets
DRQ when interrupting for the command, NSECTOR * 512 bytes
are read from the device into the area following NSECTOR.
In the above example, the area would be
args[4..4+XFER_SIZE].  16bit PIO is used regardless of
HDIO_SET_32BIT setting.</p>
<p>[3] If COMMAND == WIN_SETFEATURES &amp;&amp; FEATURE == SETFEATURES_XFER
&amp;&amp; NSECTOR &gt;= XFER_SW_DMA_0 &amp;&amp; the drive supports any DMA
mode, IDE driver will try to tune the transfer mode of the
drive accordingly.</p>
</div></blockquote>
</dd>
<dt>HDIO_DRIVE_TASK</dt><dd><p>execute task and special drive command</p>
<p>Note:  If you don’t have a copy of the ANSI ATA specification
handy, you should probably ignore this ioctl.</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u8 args[7];

...
ioctl(fd, HDIO_DRIVE_TASK, args);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>Taskfile register values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>args[0]</p></td>
<td><p>COMMAND</p></td>
</tr>
<tr class="row-even"><td><p>args[1]</p></td>
<td><p>FEATURE</p></td>
</tr>
<tr class="row-odd"><td><p>args[2]</p></td>
<td><p>NSECTOR</p></td>
</tr>
<tr class="row-even"><td><p>args[3]</p></td>
<td><p>SECTOR</p></td>
</tr>
<tr class="row-odd"><td><p>args[4]</p></td>
<td><p>LCYL</p></td>
</tr>
<tr class="row-even"><td><p>args[5]</p></td>
<td><p>HCYL</p></td>
</tr>
<tr class="row-odd"><td><p>args[6]</p></td>
<td><p>SELECT</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt><dd><p>Taskfile register values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>args[0]</p></td>
<td><p>status</p></td>
</tr>
<tr class="row-even"><td><p>args[1]</p></td>
<td><p>error</p></td>
</tr>
<tr class="row-odd"><td><p>args[2]</p></td>
<td><p>NSECTOR</p></td>
</tr>
<tr class="row-even"><td><p>args[3]</p></td>
<td><p>SECTOR</p></td>
</tr>
<tr class="row-odd"><td><p>args[4]</p></td>
<td><p>LCYL</p></td>
</tr>
<tr class="row-even"><td><p>args[5]</p></td>
<td><p>HCYL</p></td>
</tr>
<tr class="row-odd"><td><p>args[6]</p></td>
<td><p>SELECT</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_RAWIO</p></li>
<li><p>ENOMEM      Unable to allocate memory for task</p></li>
<li><p>ENOMSG      Device is not a disk drive.</p></li>
<li><p>EIO         Drive failed the command.</p></li>
</ul>
</dd>
</dl>
<p>notes:</p>
<blockquote>
<div><p>[1] DEV bit (0x10) of SELECT register is ignored and the
appropriate value for the drive is used.  All other bits
are used unaltered.</p>
</div></blockquote>
</dd>
<dt>HDIO_DRIVE_CMD_AEB</dt><dd><p>HDIO_DRIVE_TASK</p>
<p>Not implemented, as of 2.6.8.1</p>
</dd>
<dt>HDIO_SET_32BIT</dt><dd><p>change io_32bit flags</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_32BIT, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New value for io_32bit flag</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range [0 3]</p></li>
<li><p>EBUSY       Controller busy</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_NOWERR</dt><dd><p>change ignore-write-error flag</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_NOWERR, val);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><blockquote>
<div><p>New value for ignore-write-error flag.  Used for ignoring</p>
</div></blockquote>
<p>WRERR_STAT</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range [0 1]</p></li>
<li><p>EBUSY               Controller busy</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_DMA</dt><dd><p>change use-dma flag</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_SET_DMA, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New value for use-dma flag</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range [0 1]</p></li>
<li><p>EBUSY       Controller busy</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_PIO_MODE</dt><dd><p>reconfig interface to new speed</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_SET_PIO_MODE, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New interface speed.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range [0 255]</p></li>
<li><p>EBUSY       Controller busy</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SCAN_HWIF</dt><dd><p>register and (re)scan interface</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int args[3]

...
ioctl(fd, HDIO_SCAN_HWIF, args);
</pre></div>
</div>
<p>inputs:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>args[0]</p></td>
<td><p>io address to probe</p></td>
</tr>
<tr class="row-even"><td><p>args[1]</p></td>
<td><p>control address to probe</p></td>
</tr>
<tr class="row-odd"><td><p>args[2]</p></td>
<td><p>irq number</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="simple">
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_RAWIO</p></li>
<li><p>EIO         Probe failed.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><p>This ioctl initializes the addresses and irq for a disk
controller, probes for drives, and creates /proc/ide
interfaces as appropriate.</p>
</dd>
</dl>
</dd>
<dt>HDIO_UNREGISTER_HWIF</dt><dd><p>unregister interface</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int index;

ioctl(fd, HDIO_UNREGISTER_HWIF, index);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>index           index of hardware interface to unregister</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_RAWIO</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><p>This ioctl removes a hardware interface from the kernel.</p>
<p>Currently (2.6.8) this ioctl silently fails if any drive on
the interface is busy.</p>
</dd>
</dl>
</dd>
<dt>HDIO_SET_WCACHE</dt><dd><p>change write cache enable-disable</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_WCACHE, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New value for write cache enable</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range [0 1]</p></li>
<li><p>EBUSY       Controller busy</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_ACOUSTIC</dt><dd><p>change acoustic behavior</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_ACOUSTIC, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New value for drive acoustic settings</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range [0 254]</p></li>
<li><p>EBUSY       Controller busy</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_QDMA</dt><dd><p>change use-qdma flag</p>
<p>Not implemented, as of 2.6.8.1</p>
</dd>
<dt>HDIO_SET_ADDRESS</dt><dd><p>change lba addressing modes</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_ADDRESS, val);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><blockquote>
<div><p>New value for addressing mode</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 5%" />
<col style="width: 95%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>28-bit</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>48-bit</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>48-bit doing 28-bit</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range [0 2]</p></li>
<li><p>EBUSY               Controller busy</p></li>
<li><p>EIO         Drive does not support lba48 mode.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_IDE_SCSI</dt><dd><p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_SET_IDE_SCSI, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New value for scsi emulation mode (?)</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Called on a partition instead of the whole disk device</p></li>
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>EINVAL      value out of range [0 1]</p></li>
<li><p>EBUSY       Controller busy</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_SCSI_IDE</dt><dd><p>Not implemented, as of 2.6.8.1</p>
</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../media/index.html" class="btn btn-neutral float-right" title="Linux Media Infrastructure userspace API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cdrom.html" class="btn btn-neutral float-left" title="Summary of CDROM ioctl calls" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>