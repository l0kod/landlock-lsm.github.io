

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PCI Support Library &mdash; The Linux Kernel 5.10.0-rc3+ documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="PCI Peer-to-Peer DMA Support" href="p2pdma.html" />
    <link rel="prev" title="The Linux PCI driver implementer’s API guide" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">The Linux PCI driver implementer’s API guide</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">PCI Support Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="p2pdma.html">PCI Peer-to-Peer DMA Support</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">The Linux PCI driver implementer’s API guide</a> &raquo;</li>
        
      <li>PCI Support Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/pci/pci.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pci-support-library">
<h1>PCI Support Library<a class="headerlink" href="#pci-support-library" title="Permalink to this headline">¶</a></h1>
<dl class="c function">
<dt id="c.pci_bus_max_busnr">
unsigned char <code class="sig-name descname">pci_bus_max_busnr</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_max_busnr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns maximum PCI bus number of given bus’ children</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>pointer to PCI bus structure to search</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI bus, returns the highest PCI bus number present in the set
including the given PCI bus and its list of child PCI buses.</p>
<dl class="c function">
<dt id="c.pci_status_get_and_clear_errors">
int <code class="sig-name descname">pci_status_get_and_clear_errors</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_status_get_and_clear_errors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return and clear error bits in PCI_STATUS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns error bits set in PCI_STATUS and clears them.</p>
<dl class="c function">
<dt id="c.pci_find_capability">
int <code class="sig-name descname">pci_find_capability</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_capability" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query for devices’ capabilities</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell if a device supports a given PCI capability.
Returns the address of the requested capability structure within the
device’s PCI configuration space or 0 in case the device does not
support it.  Possible values for <strong>cap</strong> include:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_PM</span></code>           Power Management
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_AGP</span></code>          Accelerated Graphics Port
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_VPD</span></code>          Vital Product Data
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_SLOTID</span></code>       Slot Identification
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_MSI</span></code>          Message Signalled Interrupts
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_CHSWP</span></code>        CompactPCI HotSwap
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_PCIX</span></code>         PCI-X
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_EXP</span></code>          PCI Express</p>
</div></blockquote>
<dl class="c function">
<dt id="c.pci_bus_find_capability">
int <code class="sig-name descname">pci_bus_find_capability</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>bus</em>, unsigned int <em>devfn</em>, int <em>cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_find_capability" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query for devices’ capabilities</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the PCI bus to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">devfn</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.pci_find_capability" title="pci_find_capability"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_find_capability()</span></code></a> but works for PCI devices that do not have a
pci_dev structure set up yet.</p>
<p>Returns the address of the requested capability structure within the
device’s PCI configuration space or 0 in case the device does not
support it.</p>
<dl class="c function">
<dt id="c.pci_find_next_ext_capability">
int <code class="sig-name descname">pci_find_next_ext_capability</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>start</em>, int <em>cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_next_ext_capability" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find an extended capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">start</span></code></dt><dd><p>address at which to start looking (0 to start at beginning of list)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the next matching extended capability structure
within the device’s PCI configuration space or 0 if the device does
not support it.  Some capabilities can occur several times, e.g., the
vendor-specific capability, and this provides a way to find them all.</p>
<dl class="c function">
<dt id="c.pci_find_ext_capability">
int <code class="sig-name descname">pci_find_ext_capability</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_ext_capability" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find an extended capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the requested extended capability structure
within the device’s PCI configuration space or 0 if the device does
not support it.  Possible values for <strong>cap</strong> include:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">PCI_EXT_CAP_ID_ERR</span></code>         Advanced Error Reporting
<code class="docutils literal notranslate"><span class="pre">PCI_EXT_CAP_ID_VC</span></code>          Virtual Channel
<code class="docutils literal notranslate"><span class="pre">PCI_EXT_CAP_ID_DSN</span></code>         Device Serial Number
<code class="docutils literal notranslate"><span class="pre">PCI_EXT_CAP_ID_PWR</span></code>         Power Budgeting</p>
</div></blockquote>
<dl class="c function">
<dt id="c.pci_get_dsn">
u64 <code class="sig-name descname">pci_get_dsn</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_dsn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read and return the 8-byte Device Serial Number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the PCI_EXT_CAP_ID_DSN and reads the 8 bytes of the Device Serial
Number.</p>
<p>Returns the DSN, or zero if the capability does not exist.</p>
<dl class="c function">
<dt id="c.pci_find_next_ht_capability">
int <code class="sig-name descname">pci_find_next_ht_capability</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>pos</em>, int <em>ht_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_next_ht_capability" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query a device’s Hypertransport capabilities</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pos</span></code></dt><dd><p>Position from which to continue searching</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ht_cap</span></code></dt><dd><p>Hypertransport capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>To be used in conjunction with <a class="reference internal" href="#c.pci_find_ht_capability" title="pci_find_ht_capability"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_find_ht_capability()</span></code></a> to search for
all capabilities matching <strong>ht_cap</strong>. <strong>pos</strong> should always be a value returned
from <a class="reference internal" href="#c.pci_find_ht_capability" title="pci_find_ht_capability"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_find_ht_capability()</span></code></a>.</p>
<p>NB. To be 100% safe against broken PCI devices, the caller should take
steps to avoid an infinite loop.</p>
<dl class="c function">
<dt id="c.pci_find_ht_capability">
int <code class="sig-name descname">pci_find_ht_capability</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>ht_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_ht_capability" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query a device’s Hypertransport capabilities</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ht_cap</span></code></dt><dd><p>Hypertransport capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell if a device supports a given Hypertransport capability.
Returns an address within the device’s PCI configuration space
or 0 in case the device does not support the request capability.
The address points to the PCI capability, of type PCI_CAP_ID_HT,
which has a Hypertransport capability matching <strong>ht_cap</strong>.</p>
<dl class="c function">
<dt id="c.pci_find_parent_resource">
<em class="property">struct</em> resource *<code class="sig-name descname">pci_find_parent_resource</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> pci_dev *<em>dev</em>, <em class="property">struct</em> resource *<em>res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_parent_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return resource region of parent bus of given region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device structure contains resources to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>child resource record for which parent is sought</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For given resource region of given device, return the resource region of
parent bus the given region is contained in.</p>
<dl class="c function">
<dt id="c.pci_find_resource">
<em class="property">struct</em> resource *<code class="sig-name descname">pci_find_resource</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, <em class="property">struct</em> resource *<em>res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return matching PCI device resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>Resource to look for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Goes over standard PCI resources (BARs) and checks if the given resource
is partially or fully contained in any of them. In that case the
matching resource is returned, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.pci_platform_power_transition">
int <code class="sig-name descname">pci_platform_power_transition</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, pci_power_t <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_platform_power_transition" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Use platform to change device power state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt><dd><p>State to put the device into.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_set_power_state">
int <code class="sig-name descname">pci_set_power_state</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, pci_power_t <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_power_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the power state of a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt><dd><p>PCI power state (D0, D1, D2, D3hot) to put the device into.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Transition a device to a new power state, using the platform firmware and/or
the device’s PCI PM registers.</p>
<p>RETURN VALUE:
-EINVAL if the requested state is invalid.
-EIO if device does not support PCI PM or its PM capabilities register has a
wrong version, or device doesn’t support the requested state.
0 if the transition is to D1 or D2 but D1 and D2 are not supported.
0 if device already is in the requested state.
0 if the transition is to D3 but D3 is not supported.
0 if device’s power state has been successfully changed.</p>
<dl class="c function">
<dt id="c.pci_choose_state">
pci_power_t <code class="sig-name descname">pci_choose_state</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, pm_message_t <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_choose_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Choose the power state of a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be suspended</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm_message_t</span> <span class="pre">state</span></code></dt><dd><p>target sleep state for the whole system. This is the value
that is passed to suspend() function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns PCI power state suitable for given device and given system
message.</p>
<dl class="c function">
<dt id="c.pci_save_state">
int <code class="sig-name descname">pci_save_state</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_save_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>save the PCI configuration space of a device before suspending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device that we’re dealing with</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_restore_state">
void <code class="sig-name descname">pci_restore_state</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_restore_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Restore the saved state of a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device that we’re dealing with</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_store_saved_state">
<em class="property">struct</em> pci_saved_state *<code class="sig-name descname">pci_store_saved_state</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_store_saved_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate and return an opaque struct containing the device saved state.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device that we’re dealing with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return NULL if no state or error.</p>
<dl class="c function">
<dt id="c.pci_load_saved_state">
int <code class="sig-name descname">pci_load_saved_state</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, <em class="property">struct</em> pci_saved_state *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_load_saved_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reload the provided save state into struct pci_dev.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device that we’re dealing with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_saved_state</span> <span class="pre">*state</span></code></dt><dd><p>Saved state returned from <a class="reference internal" href="#c.pci_store_saved_state" title="pci_store_saved_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_store_saved_state()</span></code></a></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_load_and_free_saved_state">
int <code class="sig-name descname">pci_load_and_free_saved_state</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, <em class="property">struct</em> pci_saved_state **<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_load_and_free_saved_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reload the save state pointed to by state, and free the memory allocated for it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device that we’re dealing with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_saved_state</span> <span class="pre">**state</span></code></dt><dd><p>Pointer to saved state returned from <a class="reference internal" href="#c.pci_store_saved_state" title="pci_store_saved_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_store_saved_state()</span></code></a></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_reenable_device">
int <code class="sig-name descname">pci_reenable_device</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reenable_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resume abandoned device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be resumed</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>This function is a backend of pci_default_resume() and is not supposed
to be called by normal code, write proper resume handler and use it instead.</p>
<dl class="c function">
<dt id="c.pci_enable_device_io">
int <code class="sig-name descname">pci_enable_device_io</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_device_io" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a device for use with IO space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize device before it’s used by a driver. Ask low-level code
to enable I/O resources. Wake up the device if it was suspended.
Beware, this function can fail.</p>
<dl class="c function">
<dt id="c.pci_enable_device_mem">
int <code class="sig-name descname">pci_enable_device_mem</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_device_mem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a device for use with Memory space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize device before it’s used by a driver. Ask low-level code
to enable Memory resources. Wake up the device if it was suspended.
Beware, this function can fail.</p>
<dl class="c function">
<dt id="c.pci_enable_device">
int <code class="sig-name descname">pci_enable_device</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize device before it’s used by a driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize device before it’s used by a driver. Ask low-level code
to enable I/O and memory. Wake up the device if it was suspended.
Beware, this function can fail.</p>
<p>Note we don’t actually enable the device many times if we call
this function repeatedly (we just increment the count).</p>
<dl class="c function">
<dt id="c.pcim_enable_device">
int <code class="sig-name descname">pcim_enable_device</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcim_enable_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Managed <a class="reference internal" href="#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_device()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_device()</span></code></a>.</p>
<dl class="c function">
<dt id="c.pcim_pin_device">
void <code class="sig-name descname">pcim_pin_device</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcim_pin_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pin managed PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device to pin</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pin managed PCI device <strong>pdev</strong>.  Pinned device won’t be disabled on
driver detach.  <strong>pdev</strong> must have been enabled with
<a class="reference internal" href="#c.pcim_enable_device" title="pcim_enable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pcim_enable_device()</span></code></a>.</p>
<dl class="c function">
<dt id="c.pci_disable_device">
void <code class="sig-name descname">pci_disable_device</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disable PCI device after use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be disabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal to the system that the PCI device is not in use by the system
anymore.  This only involves disabling PCI bus-mastering, if active.</p>
<p>Note we don’t actually disable the device until all callers of
<a class="reference internal" href="#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_device()</span></code></a> have called <a class="reference internal" href="#c.pci_disable_device" title="pci_disable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_disable_device()</span></code></a>.</p>
<dl class="c function">
<dt id="c.pci_set_pcie_reset_state">
int <code class="sig-name descname">pci_set_pcie_reset_state</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, <em class="property">enum</em> pcie_reset_state <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_pcie_reset_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set reset state for device dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCIe device reset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pcie_reset_state</span> <span class="pre">state</span></code></dt><dd><p>Reset state to enter into</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the PCI reset state for the device.</p>
<dl class="c function">
<dt id="c.pci_pme_capable">
bool <code class="sig-name descname">pci_pme_capable</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, pci_power_t <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_pme_capable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check the capability of PCI device to generate PME#</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt><dd><p>PCI state from which device will issue PME#.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_pme_active">
void <code class="sig-name descname">pci_pme_active</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, bool <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_pme_active" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable or disable PCI device’s PME# function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>‘true’ to enable PME# generation; ‘false’ to disable it.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must verify that the device is capable of generating PME# before
calling this function with <strong>enable</strong> equal to ‘true’.</p>
<dl class="c function">
<dt id="c.pci_enable_wake">
int <code class="sig-name descname">pci_enable_wake</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pci_dev</em>, pci_power_t <em>state</em>, bool <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_wake" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>change wakeup settings for a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pci_dev</span></code></dt><dd><p>Target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt><dd><p>PCI state from which device will issue wakeup events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>Whether or not to enable event generation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>enable</strong> is set, check device_may_wakeup() for the device before calling
__pci_enable_wake() for it.</p>
<dl class="c function">
<dt id="c.pci_wake_from_d3">
int <code class="sig-name descname">pci_wake_from_d3</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, bool <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_wake_from_d3" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable/disable device to wake up from D3_hot or D3_cold</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to prepare</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>True to enable wake-up event generation; false to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Many drivers want the device to wake up the system from D3_hot or D3_cold
and this function allows them to set that up cleanly - <a class="reference internal" href="#c.pci_enable_wake" title="pci_enable_wake"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_wake()</span></code></a>
should not be called twice in a row to enable wake-up due to PCI PM vs ACPI
ordering constraints.</p>
<p>This function only returns error code if the device is not allowed to wake
up the system from sleep or it is not capable of generating PME# from both
D3_hot and D3_cold and the platform is unable to enable wake-up power for it.</p>
<dl class="c function">
<dt id="c.pci_prepare_to_sleep">
int <code class="sig-name descname">pci_prepare_to_sleep</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_prepare_to_sleep" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>prepare PCI device for system-wide transition into a sleep state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Device to handle.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Choose the power state appropriate for the device depending on whether
it can wake up the system and/or is power manageable by the platform
(PCI_D3hot is the default) and put the device into that state.</p>
<dl class="c function">
<dt id="c.pci_back_from_sleep">
int <code class="sig-name descname">pci_back_from_sleep</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_back_from_sleep" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>turn PCI device on during system-wide transition into working state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Device to handle.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable device’s system wake-up capability and put it into D0.</p>
<dl class="c function">
<dt id="c.pci_dev_run_wake">
bool <code class="sig-name descname">pci_dev_run_wake</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_run_wake" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if device can generate run-time wake-up events.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Device to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the device itself is capable of generating wake-up events
(through the platform or using the native PCIe PME) or if the device supports
PME and one of its upstream bridges can generate wake-up events.</p>
<dl class="c function">
<dt id="c.pci_d3cold_enable">
void <code class="sig-name descname">pci_d3cold_enable</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_d3cold_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enable D3cold for device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers to enable D3cold from the device
they handle.  It also updates upstream PCI bridge PM capabilities
accordingly.</p>
<dl class="c function">
<dt id="c.pci_d3cold_disable">
void <code class="sig-name descname">pci_d3cold_disable</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_d3cold_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disable D3cold for device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers to disable D3cold from the device
they handle.  It also updates upstream PCI bridge PM capabilities
accordingly.</p>
<dl class="c function">
<dt id="c.pci_enable_atomic_ops_to_root">
int <code class="sig-name descname">pci_enable_atomic_ops_to_root</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, u32 <em>cap_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_atomic_ops_to_root" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable AtomicOp requests to root port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">cap_mask</span></code></dt><dd><p>mask of desired AtomicOp sizes, including one or more of:
PCI_EXP_DEVCAP2_ATOMIC_COMP32
PCI_EXP_DEVCAP2_ATOMIC_COMP64
PCI_EXP_DEVCAP2_ATOMIC_COMP128</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if all upstream bridges support AtomicOp routing, egress
blocking is disabled on all upstream ports, and the root port supports
the requested completion capabilities (32-bit, 64-bit and/or 128-bit
AtomicOp completion), or negative otherwise.</p>
<dl class="c function">
<dt id="c.pci_common_swizzle">
u8 <code class="sig-name descname">pci_common_swizzle</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, u8 *<em>pinp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_common_swizzle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>swizzle INTx all the way to root bridge</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*pinp</span></code></dt><dd><p>pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI
bridges all the way up to a PCI root bus.</p>
<dl class="c function">
<dt id="c.pci_release_region">
void <code class="sig-name descname">pci_release_region</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em>, int <em>bar</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_release_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release a PCI bar</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources were previously reserved by
<a class="reference internal" href="#c.pci_request_region" title="pci_request_region"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_region()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bar</span></code></dt><dd><p>BAR to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the PCI I/O and memory resources previously reserved by a
successful call to <a class="reference internal" href="#c.pci_request_region" title="pci_request_region"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_region()</span></code></a>.  Call this function only
after all use of the PCI regions has ceased.</p>
<dl class="c function">
<dt id="c.pci_request_region">
int <code class="sig-name descname">pci_request_region</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em>, int <em>bar</em>, <em class="property">const</em> char *<em>res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reserve PCI I/O and memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources are to be reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bar</span></code></dt><dd><p>BAR to be reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*res_name</span></code></dt><dd><p>Name to be associated with resource</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark the PCI region associated with PCI device <strong>pdev</strong> BAR <strong>bar</strong> as
being reserved by owner <strong>res_name</strong>.  Do not access any
address inside the PCI regions unless this call returns
successfully.</p>
<p>Returns 0 on success, or <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> on error.  A warning
message is also printed on failure.</p>
<dl class="c function">
<dt id="c.pci_release_selected_regions">
void <code class="sig-name descname">pci_release_selected_regions</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em>, int <em>bars</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_release_selected_regions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release selected PCI I/O and memory resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources were previously reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bars</span></code></dt><dd><p>Bitmask of BARs to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release selected PCI I/O and memory resources previously reserved.
Call this function only after all use of the PCI regions has ceased.</p>
<dl class="c function">
<dt id="c.pci_request_selected_regions">
int <code class="sig-name descname">pci_request_selected_regions</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em>, int <em>bars</em>, <em class="property">const</em> char *<em>res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_selected_regions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reserve selected PCI I/O and memory resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources are to be reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bars</span></code></dt><dd><p>Bitmask of BARs to be requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*res_name</span></code></dt><dd><p>Name to be associated with resource</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_release_regions">
void <code class="sig-name descname">pci_release_regions</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_release_regions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release reserved PCI I/O and memory resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources were previously reserved by
<a class="reference internal" href="#c.pci_request_regions" title="pci_request_regions"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_regions()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all PCI I/O and memory resources previously reserved by a
successful call to <a class="reference internal" href="#c.pci_request_regions" title="pci_request_regions"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_regions()</span></code></a>.  Call this function only
after all use of the PCI regions has ceased.</p>
<dl class="c function">
<dt id="c.pci_request_regions">
int <code class="sig-name descname">pci_request_regions</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em>, <em class="property">const</em> char *<em>res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_regions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reserve PCI I/O and memory resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources are to be reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*res_name</span></code></dt><dd><p>Name to be associated with resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all PCI regions associated with PCI device <strong>pdev</strong> as
being reserved by owner <strong>res_name</strong>.  Do not access any
address inside the PCI regions unless this call returns
successfully.</p>
<p>Returns 0 on success, or <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> on error.  A warning
message is also printed on failure.</p>
<dl class="c function">
<dt id="c.pci_request_regions_exclusive">
int <code class="sig-name descname">pci_request_regions_exclusive</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em>, <em class="property">const</em> char *<em>res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_regions_exclusive" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reserve PCI I/O and memory resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources are to be reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*res_name</span></code></dt><dd><p>Name to be associated with resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all PCI regions associated with PCI device <strong>pdev</strong> as being reserved
by owner <strong>res_name</strong>.  Do not access any address inside the PCI regions
unless this call returns successfully.</p>
<p><a class="reference internal" href="#c.pci_request_regions_exclusive" title="pci_request_regions_exclusive"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_regions_exclusive()</span></code></a> will mark the region so that /dev/mem
and the sysfs MMIO access will not be allowed.</p>
<p>Returns 0 on success, or <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> on error.  A warning message is also
printed on failure.</p>
<dl class="c function">
<dt id="c.pci_remap_iospace">
int <code class="sig-name descname">pci_remap_iospace</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> resource *<em>res</em>, phys_addr_t <em>phys_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_remap_iospace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remap the memory mapped I/O space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>Resource describing the I/O space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr_t</span> <span class="pre">phys_addr</span></code></dt><dd><p>physical address of range to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remap the memory mapped I/O space described by the <strong>res</strong> and the CPU
physical address <strong>phys_addr</strong> into virtual address space.  Only
architectures that have memory mapped IO functions defined (and the
PCI_IOBASE value defined) should call this function.</p>
<dl class="c function">
<dt id="c.pci_unmap_iospace">
void <code class="sig-name descname">pci_unmap_iospace</code><span class="sig-paren">(</span><em class="property">struct</em> resource *<em>res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_unmap_iospace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unmap the memory mapped I/O space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>resource to be unmapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmap the CPU virtual address <strong>res</strong> from virtual address space.  Only
architectures that have memory mapped IO functions defined (and the
PCI_IOBASE value defined) should call this function.</p>
<dl class="c function">
<dt id="c.devm_pci_remap_iospace">
int <code class="sig-name descname">devm_pci_remap_iospace</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, <em class="property">const</em> <em class="property">struct</em> resource *<em>res</em>, phys_addr_t <em>phys_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pci_remap_iospace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Managed <a class="reference internal" href="#c.pci_remap_iospace" title="pci_remap_iospace"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_remap_iospace()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Generic device to remap IO address for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>Resource describing the I/O space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr_t</span> <span class="pre">phys_addr</span></code></dt><dd><p>physical address of range to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.pci_remap_iospace" title="pci_remap_iospace"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_remap_iospace()</span></code></a>.  Map is automatically unmapped on driver
detach.</p>
<dl class="c function">
<dt id="c.devm_pci_remap_cfgspace">
void __iomem *<code class="sig-name descname">devm_pci_remap_cfgspace</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, resource_size_t <em>offset</em>, resource_size_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pci_remap_cfgspace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Managed pci_remap_cfgspace()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Generic device to remap IO address for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">offset</span></code></dt><dd><p>Resource address to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of map</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed pci_remap_cfgspace().  Map is automatically unmapped on driver
detach.</p>
<dl class="c function">
<dt id="c.devm_pci_remap_cfg_resource">
void __iomem *<code class="sig-name descname">devm_pci_remap_cfg_resource</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, <em class="property">struct</em> resource *<em>res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pci_remap_cfg_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check, request region and ioremap cfg resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>generic device to handle the resource for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>configuration space resource to be handled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a resource is a valid memory region, requests the memory
region and ioremaps with pci_remap_cfgspace() API that ensures the
proper PCI configuration space memory attributes are guaranteed.</p>
<p>All operations are managed and will be undone on driver detach.</p>
<p>Returns a pointer to the remapped memory or an ERR_PTR() encoded error code
on failure. Usage example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
base = devm_pci_remap_cfg_resource(&amp;pdev-&gt;dev, res);
if (IS_ERR(base))
        return PTR_ERR(base);
</pre></div>
</div>
<dl class="c function">
<dt id="c.pci_set_master">
void <code class="sig-name descname">pci_set_master</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_master" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enables bus-mastering for device dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables bus-mastering on the device and calls pcibios_set_master()
to do the needed arch specific settings.</p>
<dl class="c function">
<dt id="c.pci_clear_master">
void <code class="sig-name descname">pci_clear_master</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_clear_master" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>disables bus-mastering for device dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to disable</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_set_cacheline_size">
int <code class="sig-name descname">pci_set_cacheline_size</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_cacheline_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ensure the CACHE_LINE_SIZE register is programmed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device for which MWI is to be enabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for pci_set_mwi.
Originally copied from drivers/net/acenic.c.
Copyright 1998-2001 by Jes Sorensen, &lt;jes**trained**-monkey.org&gt;.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
<dl class="c function">
<dt id="c.pci_set_mwi">
int <code class="sig-name descname">pci_set_mwi</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_mwi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enables memory-write-invalidate PCI transaction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device for which MWI is enabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables the Memory-Write-Invalidate transaction in <code class="docutils literal notranslate"><span class="pre">PCI_COMMAND</span></code>.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
<dl class="c function">
<dt id="c.pcim_set_mwi">
int <code class="sig-name descname">pcim_set_mwi</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcim_set_mwi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>a device-managed <a class="reference internal" href="#c.pci_set_mwi" title="pci_set_mwi"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_set_mwi()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device for which MWI is enabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.pci_set_mwi" title="pci_set_mwi"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_set_mwi()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
<dl class="c function">
<dt id="c.pci_try_set_mwi">
int <code class="sig-name descname">pci_try_set_mwi</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_try_set_mwi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enables memory-write-invalidate PCI transaction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device for which MWI is enabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables the Memory-Write-Invalidate transaction in <code class="docutils literal notranslate"><span class="pre">PCI_COMMAND</span></code>.
Callers are not required to check the return value.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
<dl class="c function">
<dt id="c.pci_clear_mwi">
void <code class="sig-name descname">pci_clear_mwi</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_clear_mwi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>disables Memory-Write-Invalidate for device dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables PCI Memory-Write-Invalidate transaction on the device</p>
<dl class="c function">
<dt id="c.pci_intx">
void <code class="sig-name descname">pci_intx</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em>, int <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_intx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enables/disables PCI INTx for device dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">enable</span></code></dt><dd><p>boolean: whether to enable or disable PCI INTx</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables/disables PCI INTx for device <strong>pdev</strong></p>
<dl class="c function">
<dt id="c.pci_check_and_mask_intx">
bool <code class="sig-name descname">pci_check_and_mask_intx</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_check_and_mask_intx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mask INTx on pending interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the device dev has its INTx line asserted, mask it and return
true in that case. False is returned if no interrupt was pending.</p>
<dl class="c function">
<dt id="c.pci_check_and_unmask_intx">
bool <code class="sig-name descname">pci_check_and_unmask_intx</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_check_and_unmask_intx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unmask INTx if no interrupt is pending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the device dev has its INTx line asserted, unmask it if not and
return true. False is returned and the mask remains active if there was
still an interrupt pending.</p>
<dl class="c function">
<dt id="c.pci_wait_for_pending_transaction">
int <code class="sig-name descname">pci_wait_for_pending_transaction</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_wait_for_pending_transaction" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for pending transaction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if transaction is pending 1 otherwise.</p>
<dl class="c function">
<dt id="c.pcie_has_flr">
bool <code class="sig-name descname">pcie_has_flr</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_has_flr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if a device supports function level resets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the device advertises support for PCIe function level
resets.</p>
<dl class="c function">
<dt id="c.pcie_flr">
int <code class="sig-name descname">pcie_flr</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_flr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initiate a PCIe function level reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initiate a function level reset on <strong>dev</strong>.  The caller should ensure the
device supports FLR before calling this function, e.g. by using the
<a class="reference internal" href="#c.pcie_has_flr" title="pcie_has_flr"><code class="xref c c-func docutils literal notranslate"><span class="pre">pcie_has_flr()</span></code></a> helper.</p>
<dl class="c function">
<dt id="c.pci_bridge_secondary_bus_reset">
int <code class="sig-name descname">pci_bridge_secondary_bus_reset</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bridge_secondary_bus_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reset the secondary bus on a PCI bridge.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Bridge device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the bridge control register to assert reset on the secondary bus.
Devices on the secondary bus are left in power-on state.</p>
<dl class="c function">
<dt id="c.__pci_reset_function_locked">
int <code class="sig-name descname">__pci_reset_function_locked</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_reset_function_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reset a PCI device function while holding the <strong>dev</strong> mutex lock.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.</p>
<p>The device function is presumed to be unused and the caller is holding
the device mutex lock when this function is called.</p>
<p>Resetting the device will make the contents of PCI configuration space
random, so any caller of this must be prepared to reinitialise the
device including MSI, bus mastering, BARs, decoding IO and memory spaces,
etc.</p>
<p>Returns 0 if the device function was successfully reset or negative if the
device doesn’t support resetting a single function.</p>
<dl class="c function">
<dt id="c.pci_reset_function">
int <code class="sig-name descname">pci_reset_function</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_function" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>quiesce and reset a PCI device function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.</p>
<p>This function does not just reset the PCI portion of a device, but
clears all the state associated with the device.  This function differs
from <a class="reference internal" href="#c.__pci_reset_function_locked" title="__pci_reset_function_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">__pci_reset_function_locked()</span></code></a> in that it saves and restores device state
over the reset and takes the PCI device lock.</p>
<p>Returns 0 if the device function was successfully reset or negative if the
device doesn’t support resetting a single function.</p>
<dl class="c function">
<dt id="c.pci_reset_function_locked">
int <code class="sig-name descname">pci_reset_function_locked</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_function_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>quiesce and reset a PCI device function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.</p>
<p>This function does not just reset the PCI portion of a device, but
clears all the state associated with the device.  This function differs
from <a class="reference internal" href="#c.__pci_reset_function_locked" title="__pci_reset_function_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">__pci_reset_function_locked()</span></code></a> in that it saves and restores device state
over the reset.  It also differs from <a class="reference internal" href="#c.pci_reset_function" title="pci_reset_function"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_reset_function()</span></code></a> in that it
requires the PCI device lock to be held.</p>
<p>Returns 0 if the device function was successfully reset or negative if the
device doesn’t support resetting a single function.</p>
<dl class="c function">
<dt id="c.pci_try_reset_function">
int <code class="sig-name descname">pci_try_reset_function</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_try_reset_function" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>quiesce and reset a PCI device function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as above, except return -EAGAIN if unable to lock device.</p>
<dl class="c function">
<dt id="c.pci_probe_reset_slot">
int <code class="sig-name descname">pci_probe_reset_slot</code><span class="sig-paren">(</span><em class="property">struct</em> pci_slot *<em>slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_probe_reset_slot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>probe whether a PCI slot can be reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*slot</span></code></dt><dd><p>PCI slot to probe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if slot can be reset, negative if a slot reset is not supported.</p>
<dl class="c function">
<dt id="c.pci_probe_reset_bus">
int <code class="sig-name descname">pci_probe_reset_bus</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_probe_reset_bus" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>probe whether a PCI bus can be reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>PCI bus to probe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if bus can be reset, negative if a bus reset is not supported.</p>
<dl class="c function">
<dt id="c.pci_reset_bus">
int <code class="sig-name descname">pci_reset_bus</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_bus" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Try to reset a PCI bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>top level PCI device to reset via slot/bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as above except return -EAGAIN if the bus cannot be locked</p>
<dl class="c function">
<dt id="c.pcix_get_max_mmrbc">
int <code class="sig-name descname">pcix_get_max_mmrbc</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcix_get_max_mmrbc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get PCI-X maximum designed memory read byte count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns mmrbc: maximum designed memory read count in bytes or
appropriate error value.</p>
<dl class="c function">
<dt id="c.pcix_get_mmrbc">
int <code class="sig-name descname">pcix_get_mmrbc</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcix_get_mmrbc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get PCI-X maximum memory read byte count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns mmrbc: maximum memory read count in bytes or appropriate error
value.</p>
<dl class="c function">
<dt id="c.pcix_set_mmrbc">
int <code class="sig-name descname">pcix_set_mmrbc</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>mmrbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcix_set_mmrbc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set PCI-X maximum memory read byte count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mmrbc</span></code></dt><dd><p>maximum memory read count in bytes
valid values are 512, 1024, 2048, 4096</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If possible sets maximum memory read byte count, some bridges have errata
that prevent this.</p>
<dl class="c function">
<dt id="c.pcie_get_readrq">
int <code class="sig-name descname">pcie_get_readrq</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_readrq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get PCI Express read request size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns maximum memory read request in bytes or appropriate error value.</p>
<dl class="c function">
<dt id="c.pcie_set_readrq">
int <code class="sig-name descname">pcie_set_readrq</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_set_readrq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set PCI Express maximum memory read request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">rq</span></code></dt><dd><p>maximum memory read count in bytes
valid values are 128, 256, 512, 1024, 2048, 4096</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If possible sets maximum memory read request in bytes</p>
<dl class="c function">
<dt id="c.pcie_get_mps">
int <code class="sig-name descname">pcie_get_mps</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_mps" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get PCI Express maximum payload size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns maximum payload size in bytes</p>
<dl class="c function">
<dt id="c.pcie_set_mps">
int <code class="sig-name descname">pcie_set_mps</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>mps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_set_mps" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set PCI Express maximum payload size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mps</span></code></dt><dd><p>maximum payload size in bytes
valid values are 128, 256, 512, 1024, 2048, 4096</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If possible sets maximum payload size</p>
<dl class="c function">
<dt id="c.pcie_bandwidth_available">
u32 <code class="sig-name descname">pcie_bandwidth_available</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, <em class="property">struct</em> pci_dev **<em>limiting_dev</em>, <em class="property">enum</em> pci_bus_speed *<em>speed</em>, <em class="property">enum</em> pcie_link_width *<em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_bandwidth_available" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>determine minimum link settings of a PCIe device and its bandwidth limitation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">**limiting_dev</span></code></dt><dd><p>storage for device causing the bandwidth limitation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pci_bus_speed</span> <span class="pre">*speed</span></code></dt><dd><p>storage for speed of limiting device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pcie_link_width</span> <span class="pre">*width</span></code></dt><dd><p>storage for width of limiting device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk up the PCI device chain and find the point where the minimum
bandwidth is available.  Return the bandwidth available there and (if
limiting_dev, speed, and width pointers are supplied) information about
that point.  The bandwidth returned is in Mb/s, i.e., megabits/second of
raw bandwidth.</p>
<dl class="c function">
<dt id="c.pcie_get_speed_cap">
<em class="property">enum</em> pci_bus_speed <code class="sig-name descname">pcie_get_speed_cap</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_speed_cap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query for the PCI device’s link speed capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Query the PCI device speed capability.  Return the maximum link speed
supported by the device.</p>
<dl class="c function">
<dt id="c.pcie_get_width_cap">
<em class="property">enum</em> pcie_link_width <code class="sig-name descname">pcie_get_width_cap</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_width_cap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query for the PCI device’s link width capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Query the PCI device width capability.  Return the maximum link width
supported by the device.</p>
<dl class="c function">
<dt id="c.pcie_print_link_status">
void <code class="sig-name descname">pcie_print_link_status</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_print_link_status" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report the PCI device’s link speed and width</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Report the available bandwidth at the device.</p>
<dl class="c function">
<dt id="c.pci_select_bars">
int <code class="sig-name descname">pci_select_bars</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, unsigned long <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_select_bars" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Make BAR mask from the type of resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device for which BAR mask is made</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>resource type mask to be selected</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper routine makes bar mask from the type of resource.</p>
<dl class="c function">
<dt id="c.pci_add_dynid">
int <code class="sig-name descname">pci_add_dynid</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver">pci_driver</a> *<em>drv</em>, unsigned int <em>vendor</em>, unsigned int <em>device</em>, unsigned int <em>subvendor</em>, unsigned int <em>subdevice</em>, unsigned int <em>class</em>, unsigned int <em>class_mask</em>, unsigned long <em>driver_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_add_dynid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a new PCI device ID to this driver and re-probe devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span> <span class="pre">*drv</span></code></dt><dd><p>target pci driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vendor</span></code></dt><dd><p>PCI vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>PCI device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">subvendor</span></code></dt><dd><p>PCI subvendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">subdevice</span></code></dt><dd><p>PCI subdevice ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">class</span></code></dt><dd><p>PCI class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">class_mask</span></code></dt><dd><p>PCI class mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">driver_data</span></code></dt><dd><p>private driver data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a new dynamic pci device ID to this driver and causes the
driver to probe for all devices again.  <strong>drv</strong> must have been
registered prior to calling this function.</p>
<p><strong>Context</strong></p>
<p>Does GFP_KERNEL allocation.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="c function">
<dt id="c.pci_match_id">
<em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id">pci_device_id</a> *<code class="sig-name descname">pci_match_id</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id">pci_device_id</a> *<em>ids</em>, <em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_match_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>See if a pci device matches a given pci_id table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_device_id</span> <span class="pre">*ids</span></code></dt><dd><p>array of PCI device id structures to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device structure to match against.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by a driver to check whether a PCI device present in the
system is in its list of supported devices.  Returns the matching
pci_device_id structure or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is no match.</p>
<p>Deprecated, don’t use this as it will not catch any dynamic ids
that a driver might want to check for.</p>
<dl class="c function">
<dt id="c.__pci_register_driver">
int <code class="sig-name descname">__pci_register_driver</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver">pci_driver</a> *<em>drv</em>, <em class="property">struct</em> module *<em>owner</em>, <em class="property">const</em> char *<em>mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_register_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a new pci driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span> <span class="pre">*drv</span></code></dt><dd><p>the driver structure to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owner module of drv</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>module name string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the driver structure to the list of registered drivers.
Returns a negative value on error, otherwise 0.
If no error occurred, the driver remains registered even if
no device was claimed during registration.</p>
<dl class="c function">
<dt id="c.pci_unregister_driver">
void <code class="sig-name descname">pci_unregister_driver</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver">pci_driver</a> *<em>drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_unregister_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a pci driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span> <span class="pre">*drv</span></code></dt><dd><p>the driver structure to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deletes the driver structure from the list of registered PCI drivers,
gives it a chance to clean up by calling its remove() function for
each device it was responsible for, and marks those devices as
driverless.</p>
<dl class="c function">
<dt id="c.pci_dev_driver">
<em class="property">struct</em> <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver">pci_driver</a> *<code class="sig-name descname">pci_dev_driver</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the pci_driver of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the appropriate pci_driver structure or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is no
registered driver for the device.</p>
<dl class="c function">
<dt id="c.pci_dev_get">
<em class="property">struct</em> pci_dev *<code class="sig-name descname">pci_dev_get</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increments the reference count of the pci device structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the device being referenced</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each live reference to a device should be refcounted.</p>
<p>Drivers for PCI devices should normally record such references in
their probe() methods, when they bind to a device, and release
them by calling <a class="reference internal" href="#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_dev_put()</span></code></a>, in their disconnect() methods.</p>
<p>A pointer to the device with the incremented reference counter is returned.</p>
<dl class="c function">
<dt id="c.pci_dev_put">
void <code class="sig-name descname">pci_dev_put</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a use of the pci device structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device that’s been disconnected</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called when a user of a device is finished with it.  When the last
user of the device calls this function, the memory of the device is freed.</p>
<dl class="c function">
<dt id="c.pci_stop_and_remove_bus_device">
void <code class="sig-name descname">pci_stop_and_remove_bus_device</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_stop_and_remove_bus_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove a PCI device and any children</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the device to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a PCI device from the device lists, informing the drivers
that the device has been removed.  We also remove any subordinate
buses and children in a depth-first manner.</p>
<p>For each device we remove, delete the device structure from the
device lists, remove the /proc entry, and notify userspace
(/sbin/hotplug).</p>
<dl class="c function">
<dt id="c.pci_find_bus">
<em class="property">struct</em> pci_bus *<code class="sig-name descname">pci_find_bus</code><span class="sig-paren">(</span>int <em>domain</em>, int <em>busnr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_bus" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>locate PCI bus from a given domain and bus number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">domain</span></code></dt><dd><p>number of PCI domain to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">busnr</span></code></dt><dd><p>number of desired PCI bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI bus number and domain number, the desired PCI bus is located
in the global list of PCI buses.  If the bus is found, a pointer to its
data structure is returned.  If no bus is found, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
<dl class="c function">
<dt id="c.pci_find_next_bus">
<em class="property">struct</em> pci_bus *<code class="sig-name descname">pci_find_next_bus</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> pci_bus *<em>from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_next_bus" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>begin or continue searching for a PCI bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*from</span></code></dt><dd><p>Previous PCI bus found, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for new search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI buses.  A new search is
initiated by passing <code class="docutils literal notranslate"><span class="pre">NULL</span></code> as the <strong>from</strong> argument.  Otherwise if
<strong>from</strong> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, searches continue from next device on the
global list.</p>
<dl class="c function">
<dt id="c.pci_get_slot">
<em class="property">struct</em> pci_dev *<code class="sig-name descname">pci_get_slot</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>bus</em>, unsigned int <em>devfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_slot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>locate PCI device for a given PCI slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>PCI bus on which desired PCI device resides</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">devfn</span></code></dt><dd><p>encodes number of PCI slot in which the desired PCI
device resides and the logical device number within that slot
in case of multi-function devices.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI bus and slot/function number, the desired PCI device
is located in the list of PCI devices.
If the device is found, its reference count is increased and this
function returns a pointer to its data structure.  The caller must
decrement the reference count by calling <a class="reference internal" href="#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_dev_put()</span></code></a>.
If no device is found, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
<dl class="c function">
<dt id="c.pci_get_domain_bus_and_slot">
<em class="property">struct</em> pci_dev *<code class="sig-name descname">pci_get_domain_bus_and_slot</code><span class="sig-paren">(</span>int <em>domain</em>, unsigned int <em>bus</em>, unsigned int <em>devfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_domain_bus_and_slot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>locate PCI device for a given PCI domain (segment), bus, and slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">domain</span></code></dt><dd><p>PCI domain/segment on which the PCI device resides.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bus</span></code></dt><dd><p>PCI bus on which desired PCI device resides</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">devfn</span></code></dt><dd><p>encodes number of PCI slot in which the desired PCI device
resides and the logical device number within that slot in case of
multi-function devices.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI domain, bus, and slot/function number, the desired PCI
device is located in the list of PCI devices. If the device is
found, its reference count is increased and this function returns a
pointer to its data structure.  The caller must decrement the
reference count by calling <a class="reference internal" href="#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_dev_put()</span></code></a>.  If no device is found,
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
<dl class="c function">
<dt id="c.pci_get_subsys">
<em class="property">struct</em> pci_dev *<code class="sig-name descname">pci_get_subsys</code><span class="sig-paren">(</span>unsigned int <em>vendor</em>, unsigned int <em>device</em>, unsigned int <em>ss_vendor</em>, unsigned int <em>ss_device</em>, <em class="property">struct</em> pci_dev *<em>from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_subsys" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>begin or continue searching for a PCI device by vendor/subvendor/device/subdevice id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vendor</span></code></dt><dd><p>PCI vendor id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all vendor ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>PCI device id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all device ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ss_vendor</span></code></dt><dd><p>PCI subsystem vendor id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all vendor ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ss_device</span></code></dt><dd><p>PCI subsystem device id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all device ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*from</span></code></dt><dd><p>Previous PCI device found in search, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for new search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI devices.  If a PCI device is found
with a matching <strong>vendor</strong>, <strong>device</strong>, <strong>ss_vendor</strong> and <strong>ss_device</strong>, a pointer to its
device structure is returned, and the reference count to the device is
incremented.  Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.  A new search is initiated by
passing <code class="docutils literal notranslate"><span class="pre">NULL</span></code> as the <strong>from</strong> argument.  Otherwise if <strong>from</strong> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>,
searches continue from next device on the global list.
The reference count for <strong>from</strong> is always decremented if it is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<dl class="c function">
<dt id="c.pci_get_device">
<em class="property">struct</em> pci_dev *<code class="sig-name descname">pci_get_device</code><span class="sig-paren">(</span>unsigned int <em>vendor</em>, unsigned int <em>device</em>, <em class="property">struct</em> pci_dev *<em>from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>begin or continue searching for a PCI device by vendor/device id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vendor</span></code></dt><dd><p>PCI vendor id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all vendor ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>PCI device id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all device ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*from</span></code></dt><dd><p>Previous PCI device found in search, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for new search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI devices.  If a PCI device is
found with a matching <strong>vendor</strong> and <strong>device</strong>, the reference count to the
device is incremented and a pointer to its device structure is returned.
Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.  A new search is initiated by passing <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
as the <strong>from</strong> argument.  Otherwise if <strong>from</strong> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, searches continue
from next device on the global list.  The reference count for <strong>from</strong> is
always decremented if it is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<dl class="c function">
<dt id="c.pci_get_class">
<em class="property">struct</em> pci_dev *<code class="sig-name descname">pci_get_class</code><span class="sig-paren">(</span>unsigned int <em>class</em>, <em class="property">struct</em> pci_dev *<em>from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_class" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>begin or continue searching for a PCI device by class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">class</span></code></dt><dd><p>search for a PCI device with this class designation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*from</span></code></dt><dd><p>Previous PCI device found in search, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for new search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI devices.  If a PCI device is
found with a matching <strong>class</strong>, the reference count to the device is
incremented and a pointer to its device structure is returned.
Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.
A new search is initiated by passing <code class="docutils literal notranslate"><span class="pre">NULL</span></code> as the <strong>from</strong> argument.
Otherwise if <strong>from</strong> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, searches continue from next device
on the global list.  The reference count for <strong>from</strong> is always decremented
if it is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<dl class="c function">
<dt id="c.pci_dev_present">
int <code class="sig-name descname">pci_dev_present</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id">pci_device_id</a> *<em>ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_present" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns 1 if device matching the device list is present, 0 if not.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_device_id</span> <span class="pre">*ids</span></code></dt><dd><p>A pointer to a null terminated list of <a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_device_id</span></code></a> structures
that describe the type of PCI device the caller is trying to find.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obvious fact: You do not have a reference to any device that might be found
by this function, so if that device is removed from the system right after
this function is finished, the value will be stale.  Use this function to
find devices that are usually built into a system, or for a general hint as
to if another device happens to be present at this specific moment in time.</p>
<dl class="c function">
<dt id="c.pci_msi_mask_irq">
void <code class="sig-name descname">pci_msi_mask_irq</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../../core-api/genericirq.html#c.irq_data" title="irq_data">irq_data</a> *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_mask_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Generic IRQ chip callback to mask PCI/MSI interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>pointer to irqdata associated to that interrupt</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_msi_unmask_irq">
void <code class="sig-name descname">pci_msi_unmask_irq</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../../core-api/genericirq.html#c.irq_data" title="irq_data">irq_data</a> *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_unmask_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Generic IRQ chip callback to unmask PCI/MSI interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>pointer to irqdata associated to that interrupt</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_msi_vec_count">
int <code class="sig-name descname">pci_msi_vec_count</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_vec_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of MSI vectors a device can send</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device to report about</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the number of MSI vectors a device requested via
Multiple Message Capable register. It returns a negative errno if the
device is not capable sending MSI interrupts. Otherwise, the call succeeds
and returns a power of two, up to a maximum of 2^5 (32), according to the
MSI specification.</p>
<dl class="c function">
<dt id="c.pci_msix_vec_count">
int <code class="sig-name descname">pci_msix_vec_count</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msix_vec_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the number of device’s MSI-X table entries</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the pci_dev data structure of MSI-X device function
This function returns the number of device’s MSI-X table entries and
therefore the number of MSI-X vectors device is capable of sending.
It returns a negative errno if the device is not capable of sending MSI-X
interrupts.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_msi_enabled">
int <code class="sig-name descname">pci_msi_enabled</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_enabled" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is MSI enabled?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if MSI has not been disabled by the command-line option
pci=nomsi.</p>
<dl class="c function">
<dt id="c.pci_enable_msix_range">
int <code class="sig-name descname">pci_enable_msix_range</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, <em class="property">struct</em> msix_entry *<em>entries</em>, int <em>minvec</em>, int <em>maxvec</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_msix_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>configure device’s MSI-X capability structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the pci_dev data structure of MSI-X device function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msix_entry</span> <span class="pre">*entries</span></code></dt><dd><p>pointer to an array of MSI-X entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">minvec</span></code></dt><dd><p>minimum number of MSI-X IRQs requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">maxvec</span></code></dt><dd><p>maximum number of MSI-X IRQs requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup the MSI-X capability structure of device function with a maximum
possible number of interrupts in the range between <strong>minvec</strong> and <strong>maxvec</strong>
upon its software driver call to request for MSI-X mode enabled on its
hardware device function. It returns a negative errno if an error occurs.
If it succeeds, it returns the actual number of interrupts allocated and
indicates the successful configuration of MSI-X capability structure
with new allocated MSI-X interrupts.</p>
<dl class="c function">
<dt id="c.pci_alloc_irq_vectors_affinity">
int <code class="sig-name descname">pci_alloc_irq_vectors_affinity</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, unsigned int <em>min_vecs</em>, unsigned int <em>max_vecs</em>, unsigned int <em>flags</em>, <em class="property">struct</em> <a class="reference internal" href="../../core-api/genericirq.html#c.irq_affinity" title="irq_affinity">irq_affinity</a> *<em>affd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_alloc_irq_vectors_affinity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate multiple IRQs for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min_vecs</span></code></dt><dd><p>minimum number of vectors required (must be &gt;= 1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_vecs</span></code></dt><dd><p>maximum (desired) number of vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags or quirks for the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_affinity</span> <span class="pre">*affd</span></code></dt><dd><p>optional description of the affinity requirements</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate up to <strong>max_vecs</strong> interrupt vectors for <strong>dev</strong>, using MSI-X or MSI
vectors if available, and fall back to a single legacy vector
if neither is available.  Return the number of vectors allocated,
(which might be smaller than <strong>max_vecs</strong>) if successful, or a negative
error code on error. If less than <strong>min_vecs</strong> interrupt vectors are
available for <strong>dev</strong> the function will fail with -ENOSPC.</p>
<p>To get the Linux IRQ number used for a vector that can be passed to
<a class="reference internal" href="../../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> use the <a class="reference internal" href="#c.pci_irq_vector" title="pci_irq_vector"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_irq_vector()</span></code></a> helper.</p>
<dl class="c function">
<dt id="c.pci_free_irq_vectors">
void <code class="sig-name descname">pci_free_irq_vectors</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_free_irq_vectors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free previously allocated IRQs for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undoes the allocations and enabling in pci_alloc_irq_vectors().</p>
<dl class="c function">
<dt id="c.pci_irq_vector">
int <code class="sig-name descname">pci_irq_vector</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, unsigned int <em>nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_irq_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return Linux IRQ number of a device vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>device-relative interrupt vector index (0-based).</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_irq_get_affinity">
<em class="property">const</em> <em class="property">struct</em> cpumask *<code class="sig-name descname">pci_irq_get_affinity</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_irq_get_affinity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the affinity of a particular MSI vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>device-relative interrupt vector index (0-based).</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_msi_create_irq_domain">
<em class="property">struct</em> irq_domain *<code class="sig-name descname">pci_msi_create_irq_domain</code><span class="sig-paren">(</span><em class="property">struct</em> fwnode_handle *<em>fwnode</em>, <em class="property">struct</em> msi_domain_info *<em>info</em>, <em class="property">struct</em> irq_domain *<em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_create_irq_domain" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a MSI interrupt domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>Optional fwnode of the interrupt controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msi_domain_info</span> <span class="pre">*info</span></code></dt><dd><p>MSI domain info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*parent</span></code></dt><dd><p>Parent irq domain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates the domain and chip ops and creates a MSI interrupt domain.</p>
<p><strong>Return</strong></p>
<p>A domain pointer or NULL in case of failure.</p>
<dl class="c function">
<dt id="c.pci_bus_alloc_resource">
int <code class="sig-name descname">pci_bus_alloc_resource</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>bus</em>, <em class="property">struct</em> resource *<em>res</em>, resource_size_t <em>size</em>, resource_size_t <em>align</em>, resource_size_t <em>min</em>, unsigned long <em>type_mask</em>, resource_size_t (*<em>alignf</em>)<span class="sig-paren">(</span>void*, <em class="property">const</em> <em class="property">struct</em> resource*, resource_size_t, resource_size_t<span class="sig-paren">)</span>, void *<em>alignf_data</em>, <span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_alloc_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a resource from a parent bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>PCI bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>resource to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>size of resource to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment of resource to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">min</span></code></dt><dd><p>minimum /proc/iomem address to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">type_mask</span></code></dt><dd><p>IORESOURCE_* type flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">(*alignf)(void</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*,</span> <span class="pre">resource_size_t,</span> <span class="pre">resource_size_t)</span></code></dt><dd><p>resource alignment function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*alignf_data</span></code></dt><dd><p>data argument for resource alignment function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given the PCI bus a device resides on, the size, minimum address,
alignment and type, try to find an acceptable resource allocation
for a specific device resource.</p>
<dl class="c function">
<dt id="c.pci_bus_add_device">
void <code class="sig-name descname">pci_bus_add_device</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_add_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>start driver for a single device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds add sysfs entries and start device drivers</p>
<dl class="c function">
<dt id="c.pci_bus_add_devices">
void <code class="sig-name descname">pci_bus_add_devices</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> pci_bus *<em>bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_add_devices" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>start driver for PCI devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>bus to check for new devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start driver for PCI devices and add some sysfs entries.</p>
<dl class="c function">
<dt id="c.pci_bus_set_ops">
<em class="property">struct</em> pci_ops *<code class="sig-name descname">pci_bus_set_ops</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>bus</em>, <em class="property">struct</em> pci_ops *<em>ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_set_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set raw operations of pci bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>pci bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_ops</span> <span class="pre">*ops</span></code></dt><dd><p>new raw operations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return previous raw operations</p>
<dl class="c function">
<dt id="c.pci_cfg_access_lock">
void <code class="sig-name descname">pci_cfg_access_lock</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_cfg_access_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Lock PCI config reads/writes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pci device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When access is locked, any userspace reads or writes to config
space and concurrent lock requests will sleep until access is
allowed via <a class="reference internal" href="#c.pci_cfg_access_unlock" title="pci_cfg_access_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_cfg_access_unlock()</span></code></a> again.</p>
<dl class="c function">
<dt id="c.pci_cfg_access_trylock">
bool <code class="sig-name descname">pci_cfg_access_trylock</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_cfg_access_trylock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>try to lock PCI config reads/writes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pci device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as pci_cfg_access_lock, but will return 0 if access is
already locked, 1 otherwise. This function can be used from
atomic contexts.</p>
<dl class="c function">
<dt id="c.pci_cfg_access_unlock">
void <code class="sig-name descname">pci_cfg_access_unlock</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_cfg_access_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unlock PCI config reads/writes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pci device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows PCI config accesses to resume.</p>
<dl class="c function">
<dt id="c.pci_request_irq">
int <code class="sig-name descname">pci_request_irq</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, unsigned int <em>nr</em>, irq_handler_t <em>handler</em>, irq_handler_t <em>thread_fn</em>, void *<em>dev_id</em>, <em class="property">const</em> char *<em>fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate an interrupt line for a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>device-relative interrupt vector index (0-based).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.
Primary handler for threaded interrupts.
If NULL and thread_fn != NULL the default primary handler is
installed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">thread_fn</span></code></dt><dd><p>Function called from the IRQ handler thread
If NULL, no IRQ thread is created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>Cookie passed back to the handler function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>Printf-like format string naming the handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call allocates interrupt resources and enables the interrupt line and
IRQ handling. From the point this call is made <strong>handler</strong> and <strong>thread_fn</strong> may
be invoked.  All interrupts requested using this function might be shared.</p>
<p><strong>dev_id</strong> must not be NULL and must be globally unique.</p>
<dl class="c function">
<dt id="c.pci_free_irq">
void <code class="sig-name descname">pci_free_irq</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, unsigned int <em>nr</em>, void *<em>dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_free_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free an interrupt allocated with pci_request_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>device-relative interrupt vector index (0-based).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>Device identity to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove an interrupt handler. The handler is removed and if the interrupt
line is no longer in use by any driver it is disabled.  The caller must
ensure the interrupt is disabled on the device before calling this function.
The function does not return until any executing interrupts for this IRQ
have completed.</p>
<p>This function must not be called from interrupt context.</p>
<dl class="c function">
<dt id="c.pcie_relaxed_ordering_enabled">
bool <code class="sig-name descname">pcie_relaxed_ordering_enabled</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_relaxed_ordering_enabled" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Probe for PCIe relaxed ordering enable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the device has enabled relaxed ordering attribute.</p>
<dl class="c function">
<dt id="c.pci_scan_slot">
int <code class="sig-name descname">pci_scan_slot</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>bus</em>, int <em>devfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_scan_slot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Scan a PCI slot on a bus for devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>PCI bus to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devfn</span></code></dt><dd><p>slot number to scan (must have zero function)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan a PCI slot on the specified PCI bus for devices, adding
discovered devices to the <strong>bus-&gt;devices</strong> list.  New devices
will not have is_added set.</p>
<p>Returns the number of new devices found.</p>
<dl class="c function">
<dt id="c.pci_scan_child_bus">
unsigned int <code class="sig-name descname">pci_scan_child_bus</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_scan_child_bus" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Scan devices below a bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>Bus to scan for devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scans devices below <strong>bus</strong> including subordinate buses. Returns new
subordinate number including all the found devices.</p>
<dl class="c function">
<dt id="c.pci_rescan_bus">
unsigned int <code class="sig-name descname">pci_rescan_bus</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_rescan_bus" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Scan a PCI bus for devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>PCI bus to scan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan a PCI bus and child buses for new devices, add them,
and enable them.</p>
<p>Returns the max number of subordinate bus discovered.</p>
<dl class="c function">
<dt id="c.pci_create_slot">
<em class="property">struct</em> pci_slot *<code class="sig-name descname">pci_create_slot</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>parent</em>, int <em>slot_nr</em>, <em class="property">const</em> char *<em>name</em>, <em class="property">struct</em> hotplug_slot *<em>hotplug</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_create_slot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create or increment refcount for physical PCI slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*parent</span></code></dt><dd><p>struct pci_bus of parent bridge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">slot_nr</span></code></dt><dd><p>PCI_SLOT(pci_dev-&gt;devfn) or -1 for placeholder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>user visible string presented in /sys/bus/pci/slots/&lt;name&gt;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*hotplug</span></code></dt><dd><p>set if caller is hotplug driver, NULL otherwise</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>PCI slots have first class attributes such as address, speed, width,
and a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span></code> is used to manage them. This interface will
either return a new <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span></code> to the caller, or if the pci_slot
already exists, its refcount will be incremented.</p>
<p>Slots are uniquely identified by a <strong>pci_bus</strong>, <strong>slot_nr</strong> tuple.</p>
<p>There are known platforms with broken firmware that assign the same
name to multiple slots. Workaround these broken platforms by renaming
the slots on behalf of the caller. If firmware assigns name N to
multiple slots:</p>
<p>The first slot is assigned N
The second slot is assigned N-1
The third slot is assigned N-2
etc.</p>
<p>Placeholder slots:
In most cases, <strong>pci_bus</strong>, <strong>slot_nr</strong> will be sufficient to uniquely identify
a slot. There is one notable exception - pSeries (rpaphp), where the
<strong>slot_nr</strong> cannot be determined until a device is actually inserted into
the slot. In this scenario, the caller may pass -1 for <strong>slot_nr</strong>.</p>
<p>The following semantics are imposed when the caller passes <strong>slot_nr</strong> ==
-1. First, we no longer check for an existing <code class="docutils literal notranslate"><span class="pre">struct</span></code> pci_slot, as there
may be many slots with <strong>slot_nr</strong> of -1.  The other change in semantics is
user-visible, which is the ‘address’ parameter presented in sysfs will
consist solely of a dddd:bb tuple, where dddd is the PCI domain of the
<code class="docutils literal notranslate"><span class="pre">struct</span></code> pci_bus and bb is the bus number. In other words, the devfn of
the ‘placeholder’ slot will not be displayed.</p>
<dl class="c function">
<dt id="c.pci_destroy_slot">
void <code class="sig-name descname">pci_destroy_slot</code><span class="sig-paren">(</span><em class="property">struct</em> pci_slot *<em>slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_destroy_slot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement refcount for physical PCI slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*slot</span></code></dt><dd><p>struct pci_slot to decrement</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span></code> pci_slot is refcounted, so destroying them is really easy; we
just call kobject_put on its kobj and let our release methods do the
rest.</p>
<dl class="c function">
<dt id="c.pci_hp_create_module_link">
void <code class="sig-name descname">pci_hp_create_module_link</code><span class="sig-paren">(</span><em class="property">struct</em> pci_slot *<em>pci_slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_create_module_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create symbolic link to the hotplug driver module.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*pci_slot</span></code></dt><dd><p>struct pci_slot</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for pci_hotplug_core.c to create symbolic link to
the hotplug driver module.</p>
<dl class="c function">
<dt id="c.pci_hp_remove_module_link">
void <code class="sig-name descname">pci_hp_remove_module_link</code><span class="sig-paren">(</span><em class="property">struct</em> pci_slot *<em>pci_slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_remove_module_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove symbolic link to the hotplug driver module.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*pci_slot</span></code></dt><dd><p>struct pci_slot</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for pci_hotplug_core.c to remove symbolic link to
the hotplug driver module.</p>
<dl class="c function">
<dt id="c.pci_enable_rom">
int <code class="sig-name descname">pci_enable_rom</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_rom" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable ROM decoding for a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable ROM decoding on <strong>dev</strong>.  This involves simply turning on the last
bit of the PCI ROM BAR.  Note that some cards may share address decoders
between the ROM and other resources, so enabling it may disable access
to MMIO registers or other card memory.</p>
<dl class="c function">
<dt id="c.pci_disable_rom">
void <code class="sig-name descname">pci_disable_rom</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_rom" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>disable ROM decoding for a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable ROM decoding on a PCI device by turning off the last bit in the
ROM BAR.</p>
<dl class="c function">
<dt id="c.pci_map_rom">
void __iomem *<code class="sig-name descname">pci_map_rom</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em>, size_t *<em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_map_rom" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map a PCI ROM to kernel space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>pointer to pci device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*size</span></code></dt><dd><p>pointer to receive size of pci window over ROM</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>kernel virtual pointer to image of ROM</p>
<p><strong>Description</strong></p>
<p>Map a PCI ROM into kernel space. If ROM is boot video ROM,
the shadow BIOS copy will be returned instead of the
actual ROM.</p>
<dl class="c function">
<dt id="c.pci_unmap_rom">
void <code class="sig-name descname">pci_unmap_rom</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em>, void __iomem *<em>rom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_unmap_rom" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unmap the ROM from kernel space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>pointer to pci device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*rom</span></code></dt><dd><p>virtual address of the previous mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a mapping of a previously mapped ROM</p>
<dl class="c function">
<dt id="c.pci_enable_sriov">
int <code class="sig-name descname">pci_enable_sriov</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>nr_virtfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_sriov" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable the SR-IOV capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_virtfn</span></code></dt><dd><p>number of virtual functions to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, or negative on failure.</p>
<dl class="c function">
<dt id="c.pci_disable_sriov">
void <code class="sig-name descname">pci_disable_sriov</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_sriov" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>disable the SR-IOV capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.pci_num_vf">
int <code class="sig-name descname">pci_num_vf</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_num_vf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return number of VFs associated with a PF device_release_driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of VFs, or 0 if SR-IOV is not enabled.</p>
<dl class="c function">
<dt id="c.pci_vfs_assigned">
int <code class="sig-name descname">pci_vfs_assigned</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_vfs_assigned" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns number of VFs are assigned to a guest</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of VFs belonging to this device that are assigned to a guest.
If device is not a physical function returns 0.</p>
<dl class="c function">
<dt id="c.pci_sriov_set_totalvfs">
int <code class="sig-name descname">pci_sriov_set_totalvfs</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, u16 <em>numvfs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_sriov_set_totalvfs" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>reduce the TotalVFs available</p></li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI PF device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">numvfs</span></code></dt><dd><p>number that should be used for TotalVFs supported</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from PF driver’s probe routine with
device’s mutex held.</p>
<p>Returns 0 if PF is an SRIOV-capable device and
value of numvfs valid. If not a PF return -ENOSYS;
if numvfs is invalid return -EINVAL;
if VFs already enabled, return -EBUSY.</p>
<dl class="c function">
<dt id="c.pci_sriov_get_totalvfs">
int <code class="sig-name descname">pci_sriov_get_totalvfs</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_sriov_get_totalvfs" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>get total VFs supported on this device</p></li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI PF device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For a PCIe device with SRIOV support, return the PCIe
SRIOV capability value of TotalVFs or the value of driver_max_VFs
if the driver reduced it.  Otherwise 0.</p>
<dl class="c function">
<dt id="c.pci_sriov_configure_simple">
int <code class="sig-name descname">pci_sriov_configure_simple</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, int <em>nr_virtfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_sriov_configure_simple" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>helper to configure SR-IOV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_virtfn</span></code></dt><dd><p>number of virtual functions to enable, 0 to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable or disable SR-IOV for devices that don’t require any PF setup
before enabling SR-IOV.  Return value is negative on error, or number of
VFs allocated on success.</p>
<dl class="c function">
<dt id="c.pci_read_legacy_io">
ssize_t <code class="sig-name descname">pci_read_legacy_io</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>filp</em>, <em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> bin_attribute *<em>bin_attr</em>, char *<em>buf</em>, loff_t <em>off</em>, size_t <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_read_legacy_io" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>read byte(s) from legacy I/O port space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>open sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject corresponding to file to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*bin_attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to store results</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>offset into legacy I/O port space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific
callback routine (pci_legacy_read).</p>
<dl class="c function">
<dt id="c.pci_write_legacy_io">
ssize_t <code class="sig-name descname">pci_write_legacy_io</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>filp</em>, <em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> bin_attribute *<em>bin_attr</em>, char *<em>buf</em>, loff_t <em>off</em>, size_t <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_write_legacy_io" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>write byte(s) to legacy I/O port space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>open sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject corresponding to file to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*bin_attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer containing value to be written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>offset into legacy I/O port space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific
callback routine (pci_legacy_write).</p>
<dl class="c function">
<dt id="c.pci_mmap_legacy_mem">
int <code class="sig-name descname">pci_mmap_legacy_mem</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>filp</em>, <em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> bin_attribute *<em>attr</em>, <em class="property">struct</em> vm_area_struct *<em>vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_mmap_legacy_mem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map legacy PCI memory into user memory space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>open sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject corresponding to device to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>struct vm_area_struct passed to mmap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses an arch specific callback, pci_mmap_legacy_mem_page_range, to mmap
legacy memory space (first meg of bus space) into application virtual
memory space.</p>
<dl class="c function">
<dt id="c.pci_mmap_legacy_io">
int <code class="sig-name descname">pci_mmap_legacy_io</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>filp</em>, <em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> bin_attribute *<em>attr</em>, <em class="property">struct</em> vm_area_struct *<em>vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_mmap_legacy_io" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map legacy PCI IO into user memory space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>open sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject corresponding to device to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>struct vm_area_struct passed to mmap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses an arch specific callback, pci_mmap_legacy_io_page_range, to mmap
legacy IO space (first meg of bus space) into application virtual
memory space. Returns -ENOSYS if the operation isn’t supported</p>
<dl class="c function">
<dt id="c.pci_adjust_legacy_attr">
void <code class="sig-name descname">pci_adjust_legacy_attr</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>b</em>, <em class="property">enum</em> pci_mmap_state <em>mmap_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_adjust_legacy_attr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>adjustment of legacy file attributes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*b</span></code></dt><dd><p>bus to create files under</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pci_mmap_state</span> <span class="pre">mmap_type</span></code></dt><dd><p>I/O port or memory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stub implementation. Can be overridden by arch if necessary.</p>
<dl class="c function">
<dt id="c.pci_create_legacy_files">
void <code class="sig-name descname">pci_create_legacy_files</code><span class="sig-paren">(</span><em class="property">struct</em> pci_bus *<em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_create_legacy_files" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create legacy I/O port and memory files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*b</span></code></dt><dd><p>bus to create files under</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some platforms allow access to legacy I/O port and ISA memory space on
a per-bus basis.  This routine creates the files and ties them into
their associated read, write and mmap files from pci-sysfs.c</p>
<p>On error unwind, but don’t propagate the error to the caller
as it is ok to set up the PCI bus without these files.</p>
<dl class="c function">
<dt id="c.pci_mmap_resource">
int <code class="sig-name descname">pci_mmap_resource</code><span class="sig-paren">(</span><em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> bin_attribute *<em>attr</em>, <em class="property">struct</em> vm_area_struct *<em>vma</em>, int <em>write_combine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_mmap_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map a PCI resource into user memory space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject for mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>struct bin_attribute for the file being mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>struct vm_area_struct passed into the mmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write_combine</span></code></dt><dd><p>1 for write_combine mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the regular PCI mapping routines to map a PCI resource into userspace.</p>
<dl class="c function">
<dt id="c.pci_remove_resource_files">
void <code class="sig-name descname">pci_remove_resource_files</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_remove_resource_files" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cleanup resource files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>dev to cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If we created resource files for <strong>pdev</strong>, remove them from sysfs and
free their resources.</p>
<dl class="c function">
<dt id="c.pci_create_resource_files">
int <code class="sig-name descname">pci_create_resource_files</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_create_resource_files" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create resource files in sysfs for <strong>dev</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>dev in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the resources in <strong>pdev</strong> creating files for each resource available.</p>
<dl class="c function">
<dt id="c.pci_write_rom">
ssize_t <code class="sig-name descname">pci_write_rom</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>filp</em>, <em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> bin_attribute *<em>bin_attr</em>, char *<em>buf</em>, loff_t <em>off</em>, size_t <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_write_rom" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>used to enable access to the PCI ROM display</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kernel object handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*bin_attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>user input</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>file offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of byte in input</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>writing anything except 0 enables it</p>
<dl class="c function">
<dt id="c.pci_read_rom">
ssize_t <code class="sig-name descname">pci_read_rom</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>filp</em>, <em class="property">struct</em> kobject *<em>kobj</em>, <em class="property">struct</em> bin_attribute *<em>bin_attr</em>, char *<em>buf</em>, loff_t <em>off</em>, size_t <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_read_rom" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>read a PCI ROM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kernel object handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*bin_attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>where to put the data we read from the ROM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>file offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Put <strong>count</strong> bytes starting at <strong>off</strong> into <strong>buf</strong> from the ROM in the PCI
device corresponding to <strong>kobj</strong>.</p>
<dl class="c function">
<dt id="c.pci_remove_sysfs_dev_files">
void <code class="sig-name descname">pci_remove_sysfs_dev_files</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_remove_sysfs_dev_files" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cleanup PCI specific sysfs files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>device whose entries we should free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup when <strong>pdev</strong> is removed from sysfs.</p>
</div>
<div class="section" id="pci-hotplug-support-library">
<h1>PCI Hotplug Support Library<a class="headerlink" href="#pci-hotplug-support-library" title="Permalink to this headline">¶</a></h1>
<dl class="c function">
<dt id="c.__pci_hp_register">
int <code class="sig-name descname">__pci_hp_register</code><span class="sig-paren">(</span><em class="property">struct</em> hotplug_slot *<em>slot</em>, <em class="property">struct</em> pci_bus *<em>bus</em>, int <em>devnr</em>, <em class="property">const</em> char *<em>name</em>, <em class="property">struct</em> module *<em>owner</em>, <em class="property">const</em> char *<em>mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_hp_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a hotplug_slot with the PCI hotplug subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>bus this slot is on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devnr</span></code></dt><dd><p>device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name registered with kobject core</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>caller module owner</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>caller module name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepares a hotplug slot for in-kernel use and immediately publishes it to
user space in one go.  Drivers may alternatively carry out the two steps
separately by invoking pci_hp_initialize() and <a class="reference internal" href="#c.pci_hp_add" title="pci_hp_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_hp_add()</span></code></a>.</p>
<p>Returns 0 if successful, anything else for an error.</p>
<dl class="c function">
<dt id="c.__pci_hp_initialize">
int <code class="sig-name descname">__pci_hp_initialize</code><span class="sig-paren">(</span><em class="property">struct</em> hotplug_slot *<em>slot</em>, <em class="property">struct</em> pci_bus *<em>bus</em>, int <em>devnr</em>, <em class="property">const</em> char *<em>name</em>, <em class="property">struct</em> module *<em>owner</em>, <em class="property">const</em> char *<em>mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_hp_initialize" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>prepare hotplug slot for in-kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>bus this slot is on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devnr</span></code></dt><dd><p>slot number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name registered with kobject core</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>caller module owner</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>caller module name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and fill in a PCI slot for use by a hotplug driver.  Once this has
been called, the driver may invoke hotplug_slot_name() to get the slot’s
unique name.  The driver must be prepared to handle a -&gt;reset_slot callback
from this point on.</p>
<p>Returns 0 on success or a negative int on error.</p>
<dl class="c function">
<dt id="c.pci_hp_add">
int <code class="sig-name descname">pci_hp_add</code><span class="sig-paren">(</span><em class="property">struct</em> hotplug_slot *<em>slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>publish hotplug slot to user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to publish</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make a hotplug slot’s sysfs interface available and inform user space of its
addition by sending a uevent.  The hotplug driver must be prepared to handle
all <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot_ops</span></code> callbacks from this point on.</p>
<p>Returns 0 on success or a negative int on error.</p>
<dl class="c function">
<dt id="c.pci_hp_deregister">
void <code class="sig-name descname">pci_hp_deregister</code><span class="sig-paren">(</span><em class="property">struct</em> hotplug_slot *<em>slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_deregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deregister a hotplug_slot with the PCI hotplug subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to deregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>slot</strong> must have been registered with the pci hotplug subsystem
previously with a call to pci_hp_register().</p>
<p>Returns 0 if successful, anything else for an error.</p>
<dl class="c function">
<dt id="c.pci_hp_del">
void <code class="sig-name descname">pci_hp_del</code><span class="sig-paren">(</span><em class="property">struct</em> hotplug_slot *<em>slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_del" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unpublish hotplug slot from user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to unpublish</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a hotplug slot’s sysfs interface.</p>
<p>Returns 0 on success or a negative int on error.</p>
<dl class="c function">
<dt id="c.pci_hp_destroy">
void <code class="sig-name descname">pci_hp_destroy</code><span class="sig-paren">(</span><em class="property">struct</em> hotplug_slot *<em>slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove hotplug slot from in-kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroy a PCI slot used by a hotplug driver.  Once this has been called,
the driver may no longer invoke hotplug_slot_name() to get the slot’s
unique name.  The driver no longer needs to handle a -&gt;reset_slot callback
from this point on.</p>
<p>Returns 0 on success or a negative int on error.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="p2pdma.html" class="btn btn-neutral float-right" title="PCI Peer-to-Peer DMA Support" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="The Linux PCI driver implementer’s API guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>