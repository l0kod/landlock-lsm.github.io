

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux Networking and Network Devices APIs &mdash; The Linux Kernel 5.7.0-rc1+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Z8530 Programming Guide" href="z8530book.html" />
    <link rel="prev" title="J1939 Documentation" href="j1939.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Networking Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="netdev-FAQ.html">netdev FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="af_xdp.html">AF_XDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="bareudp.html">Bare UDP Tunnelling Module Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="batman-adv.html">batman-adv</a></li>
<li class="toctree-l2"><a class="reference internal" href="can.html">SocketCAN - Controller Area Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="can_ucan_protocol.html">The UCAN Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_drivers/index.html">Vendor Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dsa/index.html">Distributed Switch Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="devlink/index.html">Linux Devlink Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="ethtool-netlink.html">Netlink interface for ethtool</a></li>
<li class="toctree-l2"><a class="reference internal" href="ieee802154.html">IEEE 802.15.4 Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="j1939.html">J1939 Documentation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Linux Networking and Network Devices APIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#linux-networking">Linux Networking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#networking-base-types">Networking Base Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#socket-buffer-functions">Socket Buffer Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#socket-filter">Socket Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generic-network-statistics">Generic Network Statistics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sun-rpc-subsystem">SUN RPC subsystem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wimax">WiMAX</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#network-device-support">Network device support</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#driver-support">Driver Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#phy-support">PHY Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#phylink">PHYLINK</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sfp-support">SFP support</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="z8530book.html">Z8530 Programming Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="msg_zerocopy.html">MSG_ZEROCOPY</a></li>
<li class="toctree-l2"><a class="reference internal" href="failover.html">FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="net_failover.html">NET_FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy.html">PHY Abstraction Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfp-phylink.html">phylink</a></li>
<li class="toctree-l2"><a class="reference internal" href="alias.html">IP-Aliasing</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge.html">Ethernet Bridging</a></li>
<li class="toctree-l2"><a class="reference internal" href="snmp_counter.html">SNMP counter</a></li>
<li class="toctree-l2"><a class="reference internal" href="checksum-offloads.html">Checksum Offloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="segmentation-offloads.html">Segmentation Offloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="scaling.html">Scaling in the Linux Networking Stack</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls.html">Kernel TLS</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls-offload.html">Kernel TLS offload</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc.html">Linux NFC subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="6lowpan.html">Netdev private dataroom for 6lowpan interfaces</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Networking Documentation</a> &raquo;</li>
        
      <li>Linux Networking and Network Devices APIs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/networking/kapi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-networking-and-network-devices-apis">
<h1>Linux Networking and Network Devices APIs<a class="headerlink" href="#linux-networking-and-network-devices-apis" title="Permalink to this headline">¶</a></h1>
<div class="section" id="linux-networking">
<h2>Linux Networking<a class="headerlink" href="#linux-networking" title="Permalink to this headline">¶</a></h2>
<div class="section" id="networking-base-types">
<h3>Networking Base Types<a class="headerlink" href="#networking-base-types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.sock_type">
enum <code class="sig-name descname">sock_type</code><a class="headerlink" href="#c.sock_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Socket types</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></dt><dd><p>stream (connection) socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></dt><dd><p>datagram (conn.less) socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_RAW</span></code></dt><dd><p>raw socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_RDM</span></code></dt><dd><p>reliably-delivered message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_SEQPACKET</span></code></dt><dd><p>sequential packet socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_DCCP</span></code></dt><dd><p>Datagram Congestion Control Protocol socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_PACKET</span></code></dt><dd><p>linux specific way of getting packets at the dev level.
For writing rarp and other similar things on the user level.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When adding some new socket type please
grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS
overrides this enum for binary compat reasons.</p>
<dl class="type">
<dt id="c.sock_shutdown_cmd">
enum <code class="sig-name descname">sock_shutdown_cmd</code><a class="headerlink" href="#c.sock_shutdown_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown types</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SHUT_RD</span></code></dt><dd><p>shutdown receptions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SHUT_WR</span></code></dt><dd><p>shutdown transmissions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SHUT_RDWR</span></code></dt><dd><p>shutdown receptions/transmissions</p>
</dd>
</dl>
<dl class="type">
<dt id="c.socket">
struct <code class="sig-name descname">socket</code><a class="headerlink" href="#c.socket" title="Permalink to this definition">¶</a></dt>
<dd><p>general BSD socket</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct socket {
  socket_state state;
  short type;
  unsigned long           flags;
  struct file             *file;
  struct sock             *sk;
  const struct proto_ops  *ops;
  struct socket_wq        wq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>socket state (<code class="docutils literal notranslate"><span class="pre">SS_CONNECTED</span></code>, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>socket type (<code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>socket flags (<code class="docutils literal notranslate"><span class="pre">SOCK_NOSPACE</span></code>, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>File back pointer for gc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk</span></code></dt><dd><p>internal networking protocol agnostic socket representation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>protocol specific socket operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>wait queue for several uses</p>
</dd>
</dl>
</div>
<div class="section" id="socket-buffer-functions">
<h3>Socket Buffer Functions<a class="headerlink" href="#socket-buffer-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.skb_frag_size">
unsigned int <code class="sig-name descname">skb_frag_size</code><span class="sig-paren">(</span>const skb_frag_t *<em> frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of a skb fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>skb fragment</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_size_set">
void <code class="sig-name descname">skb_frag_size_set</code><span class="sig-paren">(</span>skb_frag_t *<em> frag</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_size_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the size of a skb fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>skb fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size of fragment</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_size_add">
void <code class="sig-name descname">skb_frag_size_add</code><span class="sig-paren">(</span>skb_frag_t *<em> frag</em>, int<em> delta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_size_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Increments the size of a skb fragment by <strong>delta</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>skb fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">delta</span></code></dt><dd><p>value to add</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_size_sub">
void <code class="sig-name descname">skb_frag_size_sub</code><span class="sig-paren">(</span>skb_frag_t *<em> frag</em>, int<em> delta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_size_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrements the size of a skb fragment by <strong>delta</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>skb fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">delta</span></code></dt><dd><p>value to subtract</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_must_loop">
bool <code class="sig-name descname">skb_frag_must_loop</code><span class="sig-paren">(</span>struct page *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_must_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <code class="docutils literal notranslate"><span class="pre">p</span></code> is a high memory page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>fragment’s page</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_foreach_page">
<code class="sig-name descname">skb_frag_foreach_page</code><span class="sig-paren">(</span><em>f</em>, <em>f_off</em>, <em>f_len</em>, <em>p</em>, <em>p_off</em>, <em>p_len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_foreach_page" title="Permalink to this definition">¶</a></dt>
<dd><p>loop over pages in a fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code></dt><dd><p>skb frag to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f_off</span></code></dt><dd><p>offset from start of f-&gt;bv_page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f_len</span></code></dt><dd><p>length from f_off to loop over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>(temp var) current page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p_off</span></code></dt><dd><p>(temp var) offset from start of current page,
non-zero only on first page.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p_len</span></code></dt><dd><p>(temp var) length in current page,
&lt; PAGE_SIZE only on first and last page.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copied</span></code></dt><dd><p>(temp var) length so far, excluding current p_len.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>A fragment can hold a compound page, in which case per-page
operations, notably kmap_atomic, must be called for each
regular page.</p>
</div></blockquote>
<dl class="type">
<dt id="c.skb_shared_hwtstamps">
struct <code class="sig-name descname">skb_shared_hwtstamps</code><a class="headerlink" href="#c.skb_shared_hwtstamps" title="Permalink to this definition">¶</a></dt>
<dd><p>hardware time stamps</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct skb_shared_hwtstamps {
  ktime_t hwtstamp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">hwtstamp</span></code></dt><dd><p>hardware time stamp transformed into duration
since arbitrary point in time</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Software time stamps generated by <a class="reference internal" href="../core-api/timekeeping.html#c.ktime_get_real" title="ktime_get_real"><code class="xref c c-func docutils literal notranslate"><span class="pre">ktime_get_real()</span></code></a> are stored in
skb-&gt;tstamp.</p>
<p>hwtstamps can only be compared against other hwtstamps from
the same device.</p>
<p>This structure is attached to packets as part of the
<code class="xref c c-type docutils literal notranslate"><span class="pre">skb_shared_info</span></code>. Use skb_hwtstamps() to get a pointer.</p>
<dl class="type">
<dt id="c.sk_buff">
struct <code class="sig-name descname">sk_buff</code><a class="headerlink" href="#c.sk_buff" title="Permalink to this definition">¶</a></dt>
<dd><p>socket buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sk_buff {
  union {
    struct {
      struct sk_buff          *next;
      struct sk_buff          *prev;
      union {
        struct net_device       *dev;
        unsigned long           dev_scratch;
      };
    };
    struct rb_node          rbnode;
    struct list_head        list;
  };
  union {
    struct sock             *sk;
    int ip_defrag_offset;
  };
  union {
    ktime_t tstamp;
    u64 skb_mstamp_ns;
  };
  char cb[48] ;
  union {
    struct {
      unsigned long   _skb_refdst;
      void (*destructor)(struct sk_buff *skb);
    };
    struct list_head        tcp_tsorted_anchor;
  };
#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE);
  unsigned long            _nfct;
#endif;
  unsigned int            len, data_len;
  __u16 mac_len, hdr_len;
  __u16 queue_mapping;
#ifdef __BIG_ENDIAN_BITFIELD;
#define CLONED_MASK     (1 &lt;&lt; 7);
#else;
#define CLONED_MASK     1;
#endif;
#define CLONED_OFFSET()         offsetof(struct sk_buff, __cloned_offset);
  __u8 cloned:1,nohdr:1,fclone:2,peeked:1,head_frag:1, pfmemalloc:1;
#ifdef CONFIG_SKB_EXTENSIONS;
  __u8 active_extensions;
#endif;
#ifdef __BIG_ENDIAN_BITFIELD;
#define PKT_TYPE_MAX    (7 &lt;&lt; 5);
#else;
#define PKT_TYPE_MAX    7;
#endif;
#define PKT_TYPE_OFFSET()       offsetof(struct sk_buff, __pkt_type_offset);
  __u8 pkt_type:3;
  __u8 ignore_df:1;
  __u8 nf_trace:1;
  __u8 ip_summed:2;
  __u8 ooo_okay:1;
  __u8 l4_hash:1;
  __u8 sw_hash:1;
  __u8 wifi_acked_valid:1;
  __u8 wifi_acked:1;
  __u8 no_fcs:1;
  __u8 encapsulation:1;
  __u8 encap_hdr_csum:1;
  __u8 csum_valid:1;
#ifdef __BIG_ENDIAN_BITFIELD;
#define PKT_VLAN_PRESENT_BIT    7;
#else;
#define PKT_VLAN_PRESENT_BIT    0;
#endif;
#define PKT_VLAN_PRESENT_OFFSET()       offsetof(struct sk_buff, __pkt_vlan_present_offset);
  __u8 vlan_present:1;
  __u8 csum_complete_sw:1;
  __u8 csum_level:2;
  __u8 csum_not_inet:1;
  __u8 dst_pending_confirm:1;
#ifdef CONFIG_IPV6_NDISC_NODETYPE;
  __u8 ndisc_nodetype:2;
#endif;
  __u8 ipvs_property:1;
  __u8 inner_protocol_type:1;
  __u8 remcsum_offload:1;
#ifdef CONFIG_NET_SWITCHDEV;
  __u8 offload_fwd_mark:1;
  __u8 offload_l3_fwd_mark:1;
#endif;
#ifdef CONFIG_NET_CLS_ACT;
  __u8 tc_skip_classify:1;
  __u8 tc_at_ingress:1;
#endif;
#ifdef CONFIG_NET_REDIRECT;
  __u8 redirected:1;
  __u8 from_ingress:1;
#endif;
#ifdef CONFIG_TLS_DEVICE;
  __u8 decrypted:1;
#endif;
#ifdef CONFIG_NET_SCHED;
  __u16 tc_index;
#endif;
  union {
    __wsum csum;
    struct {
      __u16 csum_start;
      __u16 csum_offset;
    };
  };
  __u32 priority;
  int skb_iif;
  __u32 hash;
  __be16 vlan_proto;
  __u16 vlan_tci;
#if defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS);
  union {
    unsigned int    napi_id;
    unsigned int    sender_cpu;
  };
#endif;
#ifdef CONFIG_NETWORK_SECMARK;
  __u32 secmark;
#endif;
  union {
    __u32 mark;
    __u32 reserved_tailroom;
  };
  union {
    __be16 inner_protocol;
    __u8 inner_ipproto;
  };
  __u16 inner_transport_header;
  __u16 inner_network_header;
  __u16 inner_mac_header;
  __be16 protocol;
  __u16 transport_header;
  __u16 network_header;
  __u16 mac_header;
  sk_buff_data_t tail;
  sk_buff_data_t end;
  unsigned char           *head, *data;
  unsigned int            truesize;
  refcount_t users;
#ifdef CONFIG_SKB_EXTENSIONS;
  struct skb_ext          *extensions;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p>Next buffer in list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prev</span></code></dt><dd><p>Previous buffer in list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Device we arrived on/are leaving by</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_scratch</span></code></dt><dd><p>(aka <strong>dev</strong>) alternate use of <strong>dev</strong> when <strong>dev</strong> would be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rbnode</span></code></dt><dd><p>RB tree node, alternative to next/prev for netem/tcp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>queue head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk</span></code></dt><dd><p>Socket we are owned by</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip_defrag_offset</span></code></dt><dd><p>(aka <strong>sk</strong>) alternate use of <strong>sk</strong>, used in
fragmentation management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tstamp</span></code></dt><dd><p>Time we arrived/left</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skb_mstamp_ns</span></code></dt><dd><p>(aka <strong>tstamp</strong>) earliest departure time; start point
for retransmit timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt><dd><p>Control buffer. Free for use by every layer. Put private vars here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_skb_refdst</span></code></dt><dd><p>destination entry (with norefcount bit)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destructor</span></code></dt><dd><p>Destruct function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tcp_tsorted_anchor</span></code></dt><dd><p>list structure for TCP (tp-&gt;tsorted_sent_queue)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_nfct</span></code></dt><dd><p>Associated connection, if any (with nfctinfo bits)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>Length of actual data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_len</span></code></dt><dd><p>Data length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_len</span></code></dt><dd><p>Length of link layer header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdr_len</span></code></dt><dd><p>writable header length of cloned skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue_mapping</span></code></dt><dd><p>Queue mapping for multiqueue devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cloned</span></code></dt><dd><p>Head may be cloned (check refcnt to be sure)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nohdr</span></code></dt><dd><p>Payload reference only, must not modify header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fclone</span></code></dt><dd><p>skbuff clone status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peeked</span></code></dt><dd><p>this packet has been seen already, so stats have been
done for it, don’t do them again</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_frag</span></code></dt><dd><p>skb was allocated from page fragments,
not allocated by <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or <a class="reference internal" href="../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pfmemalloc</span></code></dt><dd><p>skbuff was allocated from PFMEMALLOC reserves</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_extensions</span></code></dt><dd><p>active extensions (skb_ext_id types)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pkt_type</span></code></dt><dd><p>Packet class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ignore_df</span></code></dt><dd><p>allow local fragmentation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nf_trace</span></code></dt><dd><p>netfilter packet trace flag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip_summed</span></code></dt><dd><p>Driver fed us an IP checksum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ooo_okay</span></code></dt><dd><p>allow the mapping of a socket to a queue to be changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l4_hash</span></code></dt><dd><p>indicate hash is a canonical 4-tuple hash over transport
ports.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw_hash</span></code></dt><dd><p>indicates hash was computed in software stack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wifi_acked_valid</span></code></dt><dd><p>wifi_acked was set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wifi_acked</span></code></dt><dd><p>whether frame was acked on wifi or not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">no_fcs</span></code></dt><dd><p>Request NIC to treat last 4 bytes as Ethernet FCS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encapsulation</span></code></dt><dd><p>indicates the inner headers in the skbuff are valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encap_hdr_csum</span></code></dt><dd><p>software checksum is needed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_valid</span></code></dt><dd><p>checksum is already valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_present</span></code></dt><dd><p>VLAN tag is present</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_complete_sw</span></code></dt><dd><p>checksum was completed by software</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_level</span></code></dt><dd><p>indicates the number of consecutive checksums found in
the packet minus one that have been verified as
CHECKSUM_UNNECESSARY (max 3)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_not_inet</span></code></dt><dd><p>use CRC32c to resolve CHECKSUM_PARTIAL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dst_pending_confirm</span></code></dt><dd><p>need to confirm neighbour</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ndisc_nodetype</span></code></dt><dd><p>router type (from link layer)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipvs_property</span></code></dt><dd><p>skbuff is owned by ipvs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_protocol_type</span></code></dt><dd><p>whether the inner protocol is
ENCAP_TYPE_ETHER or ENCAP_TYPE_IPPROTO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remcsum_offload</span></code></dt><dd><p>remote checksum offload is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offload_fwd_mark</span></code></dt><dd><p>Packet was L2-forwarded in hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offload_l3_fwd_mark</span></code></dt><dd><p>Packet was L3-forwarded in hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tc_skip_classify</span></code></dt><dd><p>do not classify packet. set by IFB device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tc_at_ingress</span></code></dt><dd><p>used within tc_classify to distinguish in/egress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">redirected</span></code></dt><dd><p>packet was redirected by packet classifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">from_ingress</span></code></dt><dd><p>packet was redirected from the ingress path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">decrypted</span></code></dt><dd><p>Decrypted SKB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tc_index</span></code></dt><dd><p>Traffic control index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum</span></code></dt><dd><p>Checksum (must include start/offset pair)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_start</span></code></dt><dd><p>Offset from skb-&gt;head where checksumming should start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_offset</span></code></dt><dd><p>Offset from csum_start where checksum should be stored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priority</span></code></dt><dd><p>Packet queueing priority</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skb_iif</span></code></dt><dd><p>ifindex of device we arrived on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hash</span></code></dt><dd><p>the packet hash</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_proto</span></code></dt><dd><p>vlan encapsulation protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_tci</span></code></dt><dd><p>vlan tag control information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">napi_id</span></code></dt><dd><p>id of the NAPI struct this skb came from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sender_cpu</span></code></dt><dd><p>(aka <strong>napi_id</strong>) source CPU in XPS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secmark</span></code></dt><dd><p>security marking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mark</span></code></dt><dd><p>Generic packet mark</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved_tailroom</span></code></dt><dd><p>(aka <strong>mark</strong>) number of bytes of free space available
at the tail of an sk_buff</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_protocol</span></code></dt><dd><p>Protocol (encapsulation)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_ipproto</span></code></dt><dd><p>(aka <strong>inner_protocol</strong>) stores ipproto when
skb-&gt;inner_protocol_type == ENCAP_TYPE_IPPROTO;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_transport_header</span></code></dt><dd><p>Inner transport layer header (encapsulation)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_network_header</span></code></dt><dd><p>Network layer header (encapsulation)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_mac_header</span></code></dt><dd><p>Link layer header (encapsulation)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol</span></code></dt><dd><p>Packet protocol from driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transport_header</span></code></dt><dd><p>Transport layer header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">network_header</span></code></dt><dd><p>Network layer header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_header</span></code></dt><dd><p>Link layer header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tail</span></code></dt><dd><p>Tail pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end</span></code></dt><dd><p>End pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>Head of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Data head pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">truesize</span></code></dt><dd><p>Buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">users</span></code></dt><dd><p>User count - see {datagram,tcp}.c</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>allocated extensions, valid if active_extensions is nonzero</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_pfmemalloc">
bool <code class="sig-name descname">skb_pfmemalloc</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pfmemalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the skb was allocated from PFMEMALLOC reserves</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_dst">
struct dst_entry * <code class="sig-name descname">skb_dst</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst" title="Permalink to this definition">¶</a></dt>
<dd><p>returns skb dst_entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns skb dst_entry, regardless of reference taken or not.</p>
<dl class="function">
<dt id="c.skb_dst_set">
void <code class="sig-name descname">skb_dst_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct dst_entry *<em> dst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst_set" title="Permalink to this definition">¶</a></dt>
<dd><p>sets skb dst</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dst_entry</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>dst entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets skb dst, assuming a reference was taken on dst and should
be released by skb_dst_drop()</p>
<dl class="function">
<dt id="c.skb_dst_set_noref">
void <code class="sig-name descname">skb_dst_set_noref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct dst_entry *<em> dst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst_set_noref" title="Permalink to this definition">¶</a></dt>
<dd><p>sets skb dst, hopefully, without taking reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dst_entry</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>dst entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets skb dst, assuming a reference was not taken on dst.
If dst entry is cached, we do not take reference and dst_release
will be avoided by refdst_drop. If dst entry is not cached, we take
reference, so that last dst_release can destroy the dst immediately.</p>
<dl class="function">
<dt id="c.skb_dst_is_noref">
bool <code class="sig-name descname">skb_dst_is_noref</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst_is_noref" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if skb dst isn’t refcounted</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_rtable">
struct rtable * <code class="sig-name descname">skb_rtable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_rtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the skb <code class="xref c c-type docutils literal notranslate"><span class="pre">rtable</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_napi_id">
unsigned int <code class="sig-name descname">skb_napi_id</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_napi_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the skb’s NAPI id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_unref">
bool <code class="sig-name descname">skb_unref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement the skb’s reference count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if we can free the skb.</p>
<dl class="function">
<dt id="c.alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">alloc_skb</code><span class="sig-paren">(</span>unsigned int<em> size</em>, gfp_t<em> priority</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a network buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt><dd><p>allocation mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a convenient wrapper around <a class="reference internal" href="#c.__alloc_skb" title="__alloc_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">__alloc_skb()</span></code></a>.</p>
<dl class="function">
<dt id="c.skb_fclone_busy">
bool <code class="sig-name descname">skb_fclone_busy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_fclone_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if fclone is busy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if skb is a fast clone, and its clone is not freed.
Some drivers call <a class="reference internal" href="#c.skb_orphan" title="skb_orphan"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_orphan()</span></code></a> in their ndo_start_xmit(),
so we also check that this didnt happen.</p>
<dl class="function">
<dt id="c.alloc_skb_fclone">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">alloc_skb_fclone</code><span class="sig-paren">(</span>unsigned int<em> size</em>, gfp_t<em> priority</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_skb_fclone" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a network buffer from fclone cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt><dd><p>allocation mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a convenient wrapper around <a class="reference internal" href="#c.__alloc_skb" title="__alloc_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">__alloc_skb()</span></code></a>.</p>
<dl class="function">
<dt id="c.skb_pad">
int <code class="sig-name descname">skb_pad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> pad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>zero pad the tail of an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pad</span></code></dt><dd><p>space to pad</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Ensure that a buffer is followed by a padding area that is zero
filled. Used by network drivers which may DMA or transfer data
beyond the buffer end onto the wire.</p>
<p>May return error in out of memory cases. The skb is freed on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_empty">
int <code class="sig-name descname">skb_queue_empty</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a queue is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>queue head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns true if the queue is empty, false otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_empty_lockless">
bool <code class="sig-name descname">skb_queue_empty_lockless</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_empty_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a queue is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>queue head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns true if the queue is empty, false otherwise.
This variant can be used in lockless contexts.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_is_last">
bool <code class="sig-name descname">skb_queue_is_last</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_is_last" title="Permalink to this definition">¶</a></dt>
<dd><p>check if skb is the last entry in the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>queue head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns true if <strong>skb</strong> is the last buffer on the list.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_is_first">
bool <code class="sig-name descname">skb_queue_is_first</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_is_first" title="Permalink to this definition">¶</a></dt>
<dd><p>check if skb is the first entry in the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>queue head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns true if <strong>skb</strong> is the first buffer on the list.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_next">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_queue_next</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_next" title="Permalink to this definition">¶</a></dt>
<dd><p>return the next packet in the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>queue head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>current buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return the next packet in <strong>list</strong> after <strong>skb</strong>.  It is only valid to
call this if <a class="reference internal" href="#c.skb_queue_is_last" title="skb_queue_is_last"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_queue_is_last()</span></code></a> evaluates to false.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_prev">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_queue_prev</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>return the prev packet in the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>queue head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>current buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return the prev packet in <strong>list</strong> before <strong>skb</strong>.  It is only valid to
call this if <a class="reference internal" href="#c.skb_queue_is_first" title="skb_queue_is_first"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_queue_is_first()</span></code></a> evaluates to false.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_get">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_get" title="Permalink to this definition">¶</a></dt>
<dd><p>reference buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to reference</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Makes another reference to a socket buffer and returns a pointer
to the buffer.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_cloned">
int <code class="sig-name descname">skb_cloned</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cloned" title="Permalink to this definition">¶</a></dt>
<dd><p>is the buffer a clone</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns true if the buffer was generated with <a class="reference internal" href="#c.skb_clone" title="skb_clone"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_clone()</span></code></a> and is
one of multiple shared copies of the buffer. Cloned buffers are
shared data so must not be written to under normal circumstances.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_header_cloned">
int <code class="sig-name descname">skb_header_cloned</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_header_cloned" title="Permalink to this definition">¶</a></dt>
<dd><p>is the header a clone</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns true if modifying the header part of the buffer requires
the data to be copied.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_header_release">
void <code class="sig-name descname">__skb_header_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_header_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release reference to header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to operate on</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_shared">
int <code class="sig-name descname">skb_shared</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_shared" title="Permalink to this definition">¶</a></dt>
<dd><p>is the buffer shared</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns true if more than one person has a reference to this
buffer.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_share_check">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_share_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, gfp_t<em> pri</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_share_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check if buffer is shared and if so clone it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">pri</span></code></dt><dd><p>priority for memory allocation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If the buffer is shared the buffer is cloned and the old copy
drops a reference. A new clone with a single reference is returned.
If the buffer is not shared the original buffer is returned. When
being called from interrupt status or with spinlocks held pri must
be GFP_ATOMIC.</p>
<p>NULL is returned on a memory allocation failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_unshare">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_unshare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, gfp_t<em> pri</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_unshare" title="Permalink to this definition">¶</a></dt>
<dd><p>make a copy of a shared buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">pri</span></code></dt><dd><p>priority for memory allocation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If the socket buffer is a clone then this function creates a new
copy of the data, drops a reference count on the old copy and returns
the new copy with the reference count at 1. If the buffer is not a clone
the original buffer is returned. When called with a spinlock held or
from interrupt state <strong>pri</strong> must be <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned on a memory allocation failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_peek">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_peek</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the head of an <code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff_head</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list_</span></code></dt><dd><p>list to peek at</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Peek an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>. Unlike most other operations you _MUST_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for an empty list or a pointer to the head element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_peek">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__skb_peek</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the head of a non-empty <code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff_head</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list_</span></code></dt><dd><p>list to peek at</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Like <a class="reference internal" href="#c.skb_peek" title="skb_peek"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_peek()</span></code></a>, but the caller knows that the list is not empty.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_peek_next">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_peek_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, const struct sk_buff_head *<em> list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_peek_next" title="Permalink to this definition">¶</a></dt>
<dd><p>peek skb following the given one from a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>skb to start from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list_</span></code></dt><dd><p>list to peek at</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when the end of the list is met or a pointer to the
next element. The reference count is not incremented and the
reference is therefore volatile. Use with caution.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_peek_tail">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_peek_tail</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_peek_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the tail of an <code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff_head</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list_</span></code></dt><dd><p>list to peek at</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Peek an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>. Unlike most other operations you _MUST_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for an empty list or a pointer to the tail element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_len">
__u32 <code class="sig-name descname">skb_queue_len</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_len" title="Permalink to this definition">¶</a></dt>
<dd><p>get queue length</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list_</span></code></dt><dd><p>list to measure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return the length of an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> queue.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_len_lockless">
__u32 <code class="sig-name descname">skb_queue_len_lockless</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_len_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>get queue length</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list_</span></code></dt><dd><p>list to measure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return the length of an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> queue.
This variant can be used in lockless contexts.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_queue_head_init">
void <code class="sig-name descname">__skb_queue_head_init</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_head_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize non-spinlock portions of sk_buff_head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>queue to initialize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This initializes only the list and queue length aspects of
an sk_buff_head object.  This allows to initialize the list
aspects of an sk_buff_head without reinitializing things like
the spinlock.  It can also be used for on-stack sk_buff_head
objects where the spinlock is known to not be used.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_splice">
void <code class="sig-name descname">skb_queue_splice</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list</em>, struct sk_buff_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists, this is designed for stacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the new list to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the place to add it in the first list</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_queue_splice_init">
void <code class="sig-name descname">skb_queue_splice_init</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em>, struct sk_buff_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists and reinitialise the emptied list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the new list to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the place to add it in the first list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The list at <strong>list</strong> is reinitialised</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_splice_tail">
void <code class="sig-name descname">skb_queue_splice_tail</code><span class="sig-paren">(</span>const struct sk_buff_head *<em> list</em>, struct sk_buff_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists, each list being a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the new list to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the place to add it in the first list</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_queue_splice_tail_init">
void <code class="sig-name descname">skb_queue_splice_tail_init</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em>, struct sk_buff_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice_tail_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists and reinitialise the emptied list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the new list to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the place to add it in the first list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Each of the lists is a queue.
The list at <strong>list</strong> is reinitialised</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_queue_after">
void <code class="sig-name descname">__skb_queue_after</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> prev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_after" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">prev</span></code></dt><dd><p>place after this buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt><dd><p>buffer to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a buffer int the middle of a list. This function takes no locks
and you must therefore hold required locks before calling it.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_queue_head">
void <code class="sig-name descname">__skb_queue_head</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_head" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt><dd><p>buffer to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a buffer at the start of a list. This function takes no locks
and you must therefore hold required locks before calling it.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_queue_tail">
void <code class="sig-name descname">__skb_queue_tail</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list tail</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt><dd><p>buffer to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a buffer at the end of a list. This function takes no locks
and you must therefore hold required locks before calling it.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_dequeue">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__skb_dequeue</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_dequeue" title="Permalink to this definition">¶</a></dt>
<dd><p>remove from the head of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to dequeue from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove the head of the list. This function does not take any locks
so must be used with appropriate locks held only. The head item is
returned or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the list is empty.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_dequeue_tail">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__skb_dequeue_tail</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_dequeue_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>remove from the tail of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to dequeue from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove the tail of the list. This function does not take any locks
so must be used with appropriate locks held only. The tail item is
returned or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the list is empty.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_fill_page_desc">
void <code class="sig-name descname">__skb_fill_page_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> i</em>, struct page *<em> page</em>, int<em> off</em>, int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_fill_page_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a paged fragment in an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer containing fragment to be initialised</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>paged fragment index to initialise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt><dd><p>the page to use for this fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">off</span></code></dt><dd><p>the offset to the data with <strong>page</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the length of the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises the <strong>i</strong>’th fragment of <strong>skb</strong> to point to <code class="xref c c-type docutils literal notranslate"><span class="pre">size</span></code> bytes at
offset <strong>off</strong> within <strong>page</strong>.</p>
<p>Does not take any additional reference on the fragment.</p>
<dl class="function">
<dt id="c.skb_fill_page_desc">
void <code class="sig-name descname">skb_fill_page_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> i</em>, struct page *<em> page</em>, int<em> off</em>, int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_fill_page_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a paged fragment in an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer containing fragment to be initialised</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>paged fragment index to initialise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt><dd><p>the page to use for this fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">off</span></code></dt><dd><p>the offset to the data with <strong>page</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the length of the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>As per <a class="reference internal" href="#c.__skb_fill_page_desc" title="__skb_fill_page_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">__skb_fill_page_desc()</span></code></a> – initialises the <strong>i</strong>’th fragment of
<strong>skb</strong> to point to <strong>size</strong> bytes at offset <strong>off</strong> within <strong>page</strong>. In
addition updates <strong>skb</strong> such that <strong>i</strong> is the last fragment.</p>
<p>Does not take any additional reference on the fragment.</p>
<dl class="function">
<dt id="c.skb_headroom">
unsigned int <code class="sig-name descname">skb_headroom</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_headroom" title="Permalink to this definition">¶</a></dt>
<dd><p>bytes at buffer head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return the number of bytes of free space at the head of an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_tailroom">
int <code class="sig-name descname">skb_tailroom</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tailroom" title="Permalink to this definition">¶</a></dt>
<dd><p>bytes at buffer end</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return the number of bytes of free space at the tail of an sk_buff</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_availroom">
int <code class="sig-name descname">skb_availroom</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_availroom" title="Permalink to this definition">¶</a></dt>
<dd><p>bytes at buffer end</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return the number of bytes of free space at the tail of an sk_buff
allocated by sk_stream_alloc()</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_reserve">
void <code class="sig-name descname">skb_reserve</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust headroom</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to alter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>bytes to move</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Increase the headroom of an empty <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> by reducing the tail
room. This is only allowed for an empty buffer.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_tailroom_reserve">
void <code class="sig-name descname">skb_tailroom_reserve</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> mtu</em>, unsigned int<em> needed_tailroom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tailroom_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust reserved_tailroom</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to alter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mtu</span></code></dt><dd><p>maximum amount of headlen permitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">needed_tailroom</span></code></dt><dd><p>minimum amount of reserved_tailroom</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Set reserved_tailroom so that headlen can be as large as possible but
not larger than mtu and tailroom cannot be smaller than
needed_tailroom.
The required headroom should already have been reserved before using
this function.</p>
</div></blockquote>
<dl class="function">
<dt id="c.pskb_trim_unique">
void <code class="sig-name descname">pskb_trim_unique</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_trim_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>remove end from a paged unique (not cloned) buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to alter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>new length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This is identical to pskb_trim except that the caller knows that
the skb is not cloned so we should never get an error due to out-
of-memory.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_orphan">
void <code class="sig-name descname">skb_orphan</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_orphan" title="Permalink to this definition">¶</a></dt>
<dd><p>orphan a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to orphan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If a buffer currently has an owner then we call the owner’s
destructor function and make the <strong>skb</strong> unowned. The buffer continues
to exist but is no longer charged to its former owner.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_orphan_frags">
int <code class="sig-name descname">skb_orphan_frags</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_orphan_frags" title="Permalink to this definition">¶</a></dt>
<dd><p>orphan the frags contained in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to orphan frags from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation mask for replacement pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>For each frag in the SKB which needs a destructor (i.e. has an
owner) create a copy of that frag and release the original
page by calling the destructor.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_queue_purge">
void <code class="sig-name descname">__skb_queue_purge</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_purge" title="Permalink to this definition">¶</a></dt>
<dd><p>empty a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to empty</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Delete all buffers on an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> list. Each buffer is removed from
the list and one reference dropped. This function does not take the
list lock and the caller must hold the relevant locks to use it.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">netdev_alloc_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, unsigned int<em> length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an skbuff for rx on a specific device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device to receive on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">length</span></code></dt><dd><p>length to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a new <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and assign it a usage count of one. The
buffer has unspecified headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no free memory. Although this function
allocates memory it can be called from an interrupt.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__dev_alloc_pages">
struct page * <code class="sig-name descname">__dev_alloc_pages</code><span class="sig-paren">(</span>gfp_t<em> gfp_mask</em>, unsigned int<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_alloc_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate page for network Rx</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority. Set __GFP_NOMEMALLOC if not for network Rx</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>size of the allocation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a new page.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
<dl class="function">
<dt id="c.__dev_alloc_page">
struct page * <code class="sig-name descname">__dev_alloc_page</code><span class="sig-paren">(</span>gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_alloc_page" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a page for network Rx</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority. Set __GFP_NOMEMALLOC if not for network Rx</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a new page.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
<dl class="function">
<dt id="c.skb_propagate_pfmemalloc">
void <code class="sig-name descname">skb_propagate_pfmemalloc</code><span class="sig-paren">(</span>struct page *<em> page</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_propagate_pfmemalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate pfmemalloc if skb is allocated after RX page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt><dd><p>The page that was allocated from skb_alloc_page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>The skb that may need pfmemalloc set</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_off">
unsigned int <code class="sig-name descname">skb_frag_off</code><span class="sig-paren">(</span>const skb_frag_t *<em> frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the offset of a skb fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>the paged fragment</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_off_add">
void <code class="sig-name descname">skb_frag_off_add</code><span class="sig-paren">(</span>skb_frag_t *<em> frag</em>, int<em> delta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_off_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Increments the offset of a skb fragment by <strong>delta</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>skb fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">delta</span></code></dt><dd><p>value to add</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_off_set">
void <code class="sig-name descname">skb_frag_off_set</code><span class="sig-paren">(</span>skb_frag_t *<em> frag</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_off_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the offset of a skb fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>skb fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset of fragment</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_off_copy">
void <code class="sig-name descname">skb_frag_off_copy</code><span class="sig-paren">(</span>skb_frag_t *<em> fragto</em>, const skb_frag_t *<em> fragfrom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_off_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the offset of a skb fragment from another fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">fragto</span></code></dt><dd><p>skb fragment where offset is set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">fragfrom</span></code></dt><dd><p>skb fragment offset is copied from</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_page">
struct page * <code class="sig-name descname">skb_frag_page</code><span class="sig-paren">(</span>const skb_frag_t *<em> frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_page" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve the page referred to by a paged fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>the paged fragment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> associated with <strong>frag</strong>.</p>
<dl class="function">
<dt id="c.__skb_frag_ref">
void <code class="sig-name descname">__skb_frag_ref</code><span class="sig-paren">(</span>skb_frag_t *<em> frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_frag_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>take an addition reference on a paged fragment.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>the paged fragment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes an additional reference on the paged fragment <strong>frag</strong>.</p>
<dl class="function">
<dt id="c.skb_frag_ref">
void <code class="sig-name descname">skb_frag_ref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>take an addition reference on a paged fragment of an skb.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">f</span></code></dt><dd><p>the fragment offset.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes an additional reference on the <strong>f</strong>’th paged fragment of <strong>skb</strong>.</p>
<dl class="function">
<dt id="c.__skb_frag_unref">
void <code class="sig-name descname">__skb_frag_unref</code><span class="sig-paren">(</span>skb_frag_t *<em> frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_frag_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference on a paged fragment.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>the paged fragment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a reference on the paged fragment <strong>frag</strong>.</p>
<dl class="function">
<dt id="c.skb_frag_unref">
void <code class="sig-name descname">skb_frag_unref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference on a paged fragment of an skb.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">f</span></code></dt><dd><p>the fragment offset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a reference on the <strong>f</strong>’th paged fragment of <strong>skb</strong>.</p>
<dl class="function">
<dt id="c.skb_frag_address">
void * <code class="sig-name descname">skb_frag_address</code><span class="sig-paren">(</span>const skb_frag_t *<em> frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_address" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the address of the data contained in a paged fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>the paged fragment buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the data within <strong>frag</strong>. The page must already
be mapped.</p>
<dl class="function">
<dt id="c.skb_frag_address_safe">
void * <code class="sig-name descname">skb_frag_address_safe</code><span class="sig-paren">(</span>const skb_frag_t *<em> frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_address_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the address of the data contained in a paged fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>the paged fragment buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the data within <strong>frag</strong>. Checks that the page
is mapped and returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.skb_frag_page_copy">
void <code class="sig-name descname">skb_frag_page_copy</code><span class="sig-paren">(</span>skb_frag_t *<em> fragto</em>, const skb_frag_t *<em> fragfrom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_page_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the page in a fragment from another fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">fragto</span></code></dt><dd><p>skb fragment where page is set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">fragfrom</span></code></dt><dd><p>skb fragment page is copied from</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__skb_frag_set_page">
void <code class="sig-name descname">__skb_frag_set_page</code><span class="sig-paren">(</span>skb_frag_t *<em> frag</em>, struct page *<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_frag_set_page" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the page contained in a paged fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>the paged fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt><dd><p>the page to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the fragment <strong>frag</strong> to contain <strong>page</strong>.</p>
<dl class="function">
<dt id="c.skb_frag_set_page">
void <code class="sig-name descname">skb_frag_set_page</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> f</em>, struct page *<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_set_page" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the page contained in a paged fragment of an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">f</span></code></dt><dd><p>the fragment offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt><dd><p>the page to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the <strong>f</strong>’th fragment of <strong>skb</strong> to contain <strong>page</strong>.</p>
<dl class="function">
<dt id="c.skb_frag_dma_map">
dma_addr_t <code class="sig-name descname">skb_frag_dma_map</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const skb_frag_t *<em> frag</em>, size_t<em> offset</em>, size_t<em> size</em>, enum dma_data_direction<em> dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_dma_map" title="Permalink to this definition">¶</a></dt>
<dd><p>maps a paged fragment via the DMA API</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the device to map the fragment to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt><dd><p>the paged fragment to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">offset</span></code></dt><dd><p>the offset within the fragment (starting at the
fragment’s own offset)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the number of bytes to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>the direction of the mapping (<code class="docutils literal notranslate"><span class="pre">PCI_DMA_*</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps the page associated with <strong>frag</strong> to <strong>device</strong>.</p>
<dl class="function">
<dt id="c.skb_clone_writable">
int <code class="sig-name descname">skb_clone_writable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_clone_writable" title="Permalink to this definition">¶</a></dt>
<dd><p>is the header of a clone writable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length up to which to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns true if modifying the header part of the cloned buffer
does not requires the data to be copied.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_cow">
int <code class="sig-name descname">skb_cow</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> headroom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cow" title="Permalink to this definition">¶</a></dt>
<dd><p>copy header of skb when it is required</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to cow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">headroom</span></code></dt><dd><p>needed headroom</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If the skb passed lacks sufficient headroom or its data part
is shared, data is reallocated. If reallocation fails, an error
is returned and original skb is not changed.</p>
<p>The result is skb with writable area skb-&gt;head…skb-&gt;tail
and at least <strong>headroom</strong> of space at head.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_cow_head">
int <code class="sig-name descname">skb_cow_head</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> headroom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cow_head" title="Permalink to this definition">¶</a></dt>
<dd><p>skb_cow but only making the head writable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to cow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">headroom</span></code></dt><dd><p>needed headroom</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is identical to skb_cow except that we replace the
skb_cloned check by skb_header_cloned.  It should be used when
you only need to push on some header and do not need to modify
the data.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_padto">
int <code class="sig-name descname">skb_padto</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_padto" title="Permalink to this definition">¶</a></dt>
<dd><p>pad an skbuff up to a minimal size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>minimal length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_put_padto">
int <code class="sig-name descname">__skb_put_padto</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em>, bool<em> free_on_error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_put_padto" title="Permalink to this definition">¶</a></dt>
<dd><p>increase size and pad an skbuff up to a minimal size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>minimal length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">free_on_error</span></code></dt><dd><p>free buffer on error</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error if <strong>free_on_error</strong> is true.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_put_padto">
int <code class="sig-name descname">skb_put_padto</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_put_padto" title="Permalink to this definition">¶</a></dt>
<dd><p>increase size and pad an skbuff up to a minimal size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>minimal length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_linearize">
int <code class="sig-name descname">skb_linearize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_linearize" title="Permalink to this definition">¶</a></dt>
<dd><p>convert paged skb to linear one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to linarize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_has_shared_frag">
bool <code class="sig-name descname">skb_has_shared_frag</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_has_shared_frag" title="Permalink to this definition">¶</a></dt>
<dd><p>can any frag be overwritten</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the skb has at least one frag that might be modified
by an external entity (as in vmsplice()/sendfile())</p>
<dl class="function">
<dt id="c.skb_linearize_cow">
int <code class="sig-name descname">skb_linearize_cow</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_linearize_cow" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure skb is linear and writable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to process</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_postpull_rcsum">
void <code class="sig-name descname">skb_postpull_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, const void *<em> start</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_postpull_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>update checksum for received skb after pull</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">start</span></code></dt><dd><p>start of data before pull</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data pulled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>After doing a pull on a received packet, you need to call this to
update the CHECKSUM_COMPLETE checksum, or set ip_summed to
CHECKSUM_NONE so that it can be recomputed from scratch.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_postpush_rcsum">
void <code class="sig-name descname">skb_postpush_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, const void *<em> start</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_postpush_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>update checksum for received skb after push</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">start</span></code></dt><dd><p>start of data after push</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data pushed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>After doing a push on a received packet, you need to call this to
update the CHECKSUM_COMPLETE checksum.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_push_rcsum">
void * <code class="sig-name descname">skb_push_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_push_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>push skb and update receive checksum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data pulled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function performs an skb_push on the packet and updates
the CHECKSUM_COMPLETE checksum.  It should be used on
receive path processing instead of skb_push unless you know
that the checksum difference is zero (e.g., a valid IP header)
or you are setting ip_summed to CHECKSUM_NONE.</p>
</div></blockquote>
<dl class="function">
<dt id="c.pskb_trim_rcsum">
int <code class="sig-name descname">pskb_trim_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_trim_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>trim received skb and update checksum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to trim</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>new length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This is exactly the same as pskb_trim except that it ensures the
checksum of received packets are still valid after the operation.
It can change skb pointers.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_needs_linearize">
bool <code class="sig-name descname">skb_needs_linearize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, netdev_features_t<em> features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_needs_linearize" title="Permalink to this definition">¶</a></dt>
<dd><p>check if we need to linearize a given skb depending on the given device features.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>socket buffer to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt><dd><p>net device features</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns true if either:
1. skb has frag_list and the device doesn’t support FRAGLIST, or
2. skb is fragmented and the device does not support SG.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_get_timestamp">
void <code class="sig-name descname">skb_get_timestamp</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct __kernel_old_timeval *<em> stamp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_get_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>get timestamp from a skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>skb to get stamp from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">__kernel_old_timeval</span> <span class="pre">*</span> <span class="pre">stamp</span></code></dt><dd><p>pointer to struct __kernel_old_timeval to store stamp in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Timestamps are stored in the skb as offsets to a base timestamp.
This function converts the offset back to a struct timeval and stores
it in stamp.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_complete_tx_timestamp">
void <code class="sig-name descname">skb_complete_tx_timestamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct <a class="reference internal" href="#c.skb_shared_hwtstamps" title="skb_shared_hwtstamps">skb_shared_hwtstamps</a> *<em> hwtstamps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_complete_tx_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>deliver cloned skb with tx timestamps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>clone of the the original outgoing packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skb_shared_hwtstamps</span> <span class="pre">*</span> <span class="pre">hwtstamps</span></code></dt><dd><p>hardware time stamps</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>PHY drivers may accept clones of transmitted packets for
timestamping via their phy_driver.txtstamp method. These drivers
must call this function to return the skb back to the stack with a
timestamp.</p>
<dl class="function">
<dt id="c.skb_tstamp_tx">
void <code class="sig-name descname">skb_tstamp_tx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> orig_skb</em>, struct <a class="reference internal" href="#c.skb_shared_hwtstamps" title="skb_shared_hwtstamps">skb_shared_hwtstamps</a> *<em> hwtstamps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tstamp_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>queue clone of skb with send time stamps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">orig_skb</span></code></dt><dd><p>the original outgoing packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skb_shared_hwtstamps</span> <span class="pre">*</span> <span class="pre">hwtstamps</span></code></dt><dd><p>hardware time stamps, may be NULL if not available</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the skb has a socket associated, then this function clones the
skb (thus sharing the actual data and optional structures), stores
the optional hardware time stamping information (if non NULL) or
generates a software time stamp (otherwise), then queues the clone
to the error queue of the socket.  Errors are silently ignored.</p>
<dl class="function">
<dt id="c.skb_tx_timestamp">
void <code class="sig-name descname">skb_tx_timestamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tx_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver hook for transmit timestamping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>A socket buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ethernet MAC Drivers should call this function in their hard_xmit()
function immediately before giving the sk_buff to the MAC hardware.</p>
<p>Specifically, one should make absolutely sure that this function is
called before TX completion of this packet can trigger.  Otherwise
the packet could potentially already be freed.</p>
<dl class="function">
<dt id="c.skb_complete_wifi_ack">
void <code class="sig-name descname">skb_complete_wifi_ack</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, bool<em> acked</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_complete_wifi_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>deliver skb with wifi status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the original outgoing packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">acked</span></code></dt><dd><p>ack status</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_checksum_complete">
__sum16 <code class="sig-name descname">skb_checksum_complete</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate checksum of an entire packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>packet to process</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function calculates the checksum over the entire packet plus
the value of skb-&gt;csum.  The latter can be used to supply the
checksum of a pseudo header as used by TCP/UDP.  It returns the
checksum.</p>
<p>For protocols that contain complete checksums such as ICMP/TCP/UDP,
this function can be used to verify that checksum on received
packets.  In that case the function should return zero if the
checksum is correct.  In particular, this function will return zero
if skb-&gt;ip_summed is CHECKSUM_UNNECESSARY which indicates that the
hardware has already verified the correctness of the checksum.</p>
</div></blockquote>
<dl class="type">
<dt id="c.skb_ext">
struct <code class="sig-name descname">skb_ext</code><a class="headerlink" href="#c.skb_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>sk_buff extensions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct skb_ext {
  refcount_t refcnt;
  u8 offset[SKB_EXT_NUM];
  u8 chunks;
  char data[0] ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcnt</span></code></dt><dd><p>1 on allocation, deallocated on 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>offset to add to <strong>data</strong> to obtain extension address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chunks</span></code></dt><dd><p>size currently allocated, stored in SKB_EXT_ALIGN_SHIFT units</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>start of extension data, variable sized</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>offsets/lengths are stored in chunks of 8 bytes, this allows</dt><dd><p>to use ‘u8’ types while allowing up to 2kb worth of extension data.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_checksum_none_assert">
void <code class="sig-name descname">skb_checksum_none_assert</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_none_assert" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure skb ip_summed is CHECKSUM_NONE</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>skb to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>fresh skbs have their ip_summed set to CHECKSUM_NONE.
Instead of forcing ip_summed to CHECKSUM_NONE, we can
use this helper, to document places where we make this assertion.</p>
<dl class="function">
<dt id="c.skb_head_is_locked">
bool <code class="sig-name descname">skb_head_is_locked</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_head_is_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the skb-&gt;head is locked down</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>skb to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The head on skbs build around a head frag can be removed if they are
not cloned.  This function returns true if the skb head is locked down
due to either being allocated via kmalloc, or by being a clone with
multiple references to the head.</p>
<dl class="type">
<dt id="c.sock_common">
struct <code class="sig-name descname">sock_common</code><a class="headerlink" href="#c.sock_common" title="Permalink to this definition">¶</a></dt>
<dd><p>minimal network layer representation of sockets</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sock_common {
  union {
    __addrpair skc_addrpair;
    struct {
      __be32 skc_daddr;
      __be32 skc_rcv_saddr;
    };
  };
  union {
    unsigned int    skc_hash;
    __u16 skc_u16hashes[2];
  };
  union {
    __portpair skc_portpair;
    struct {
      __be16 skc_dport;
      __u16 skc_num;
    };
  };
  unsigned short          skc_family;
  volatile unsigned char  skc_state;
  unsigned char           skc_reuse:4;
  unsigned char           skc_reuseport:1;
  unsigned char           skc_ipv6only:1;
  unsigned char           skc_net_refcnt:1;
  int skc_bound_dev_if;
  union {
    struct hlist_node       skc_bind_node;
    struct hlist_node       skc_portaddr_node;
  };
  struct proto            *skc_prot;
  possible_net_t skc_net;
#if IS_ENABLED(CONFIG_IPV6);
  struct in6_addr         skc_v6_daddr;
  struct in6_addr         skc_v6_rcv_saddr;
#endif;
  atomic64_t skc_cookie;
  union {
    unsigned long   skc_flags;
    struct sock     *skc_listener;
    struct inet_timewait_death_row *skc_tw_dr;
  };
  union {
    struct hlist_node       skc_node;
    struct hlist_nulls_node skc_nulls_node;
  };
  unsigned short          skc_tx_queue_mapping;
#ifdef CONFIG_XPS;
  unsigned short          skc_rx_queue_mapping;
#endif;
  union {
    int skc_incoming_cpu;
    u32 skc_rcv_wnd;
    u32 skc_tw_rcv_nxt;
  };
  refcount_t skc_refcnt;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_addrpair</span></code></dt><dd><p>8-byte-aligned __u64 union of <strong>skc_daddr</strong> &amp; <strong>skc_rcv_saddr</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_daddr</span></code></dt><dd><p>Foreign IPv4 addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_rcv_saddr</span></code></dt><dd><p>Bound local IPv4 addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_hash</span></code></dt><dd><p>hash value used with various protocol lookup tables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_u16hashes</span></code></dt><dd><p>two u16 hash values used by UDP lookup tables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_portpair</span></code></dt><dd><p>__u32 union of <strong>skc_dport</strong> &amp; <strong>skc_num</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_dport</span></code></dt><dd><p>placeholder for inet_dport/tw_dport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_num</span></code></dt><dd><p>placeholder for inet_num/tw_num</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_family</span></code></dt><dd><p>network address family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_state</span></code></dt><dd><p>Connection state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_reuse</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_reuseport</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_ipv6only</span></code></dt><dd><p>socket is IPV6 only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_net_refcnt</span></code></dt><dd><p>socket is using net ref counting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_bound_dev_if</span></code></dt><dd><p>bound device index if != 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_bind_node</span></code></dt><dd><p>bind hash linkage for various protocol lookup tables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_portaddr_node</span></code></dt><dd><p>second hash linkage for UDP/UDP-Lite protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_prot</span></code></dt><dd><p>protocol handlers inside a network family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_net</span></code></dt><dd><p>reference to the network namespace of this socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_v6_daddr</span></code></dt><dd><p>IPV6 destination address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_v6_rcv_saddr</span></code></dt><dd><p>IPV6 source address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_cookie</span></code></dt><dd><p>socket’s cookie value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_flags</span></code></dt><dd><p>place holder for sk_flags
<code class="docutils literal notranslate"><span class="pre">SO_LINGER</span></code> (l_onoff), <code class="docutils literal notranslate"><span class="pre">SO_BROADCAST</span></code>, <code class="docutils literal notranslate"><span class="pre">SO_KEEPALIVE</span></code>,
<code class="docutils literal notranslate"><span class="pre">SO_OOBINLINE</span></code> settings, <code class="docutils literal notranslate"><span class="pre">SO_TIMESTAMPING</span></code> settings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_listener</span></code></dt><dd><p>connection request listener socket (aka rsk_listener)
[union with <strong>skc_flags</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_tw_dr</span></code></dt><dd><p>(aka tw_dr) ptr to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inet_timewait_death_row</span></code>
[union with <strong>skc_flags</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_node</span></code></dt><dd><p>main hash linkage for various protocol lookup tables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_nulls_node</span></code></dt><dd><p>main hash linkage for TCP/UDP/UDP-Lite protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_tx_queue_mapping</span></code></dt><dd><p>tx queue number for this connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_rx_queue_mapping</span></code></dt><dd><p>rx queue number for this connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_incoming_cpu</span></code></dt><dd><p>record/match cpu processing incoming packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_rcv_wnd</span></code></dt><dd><p>(aka rsk_rcv_wnd) TCP receive window size (possibly scaled)
[union with <strong>skc_incoming_cpu</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_tw_rcv_nxt</span></code></dt><dd><p>(aka tw_rcv_nxt) TCP window next expected seq number
[union with <strong>skc_incoming_cpu</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_refcnt</span></code></dt><dd><p>reference count</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This is the minimal network layer representation of sockets, the header
for struct sock and struct inet_timewait_sock.</p>
</div></blockquote>
<dl class="type">
<dt id="c.sock">
struct <code class="sig-name descname">sock</code><a class="headerlink" href="#c.sock" title="Permalink to this definition">¶</a></dt>
<dd><p>network layer representation of sockets</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sock {
  struct sock_common      __sk_common;
#define sk_node                 __sk_common.skc_node;
#define sk_nulls_node           __sk_common.skc_nulls_node;
#define sk_refcnt               __sk_common.skc_refcnt;
#define sk_tx_queue_mapping     __sk_common.skc_tx_queue_mapping;
#ifdef CONFIG_XPS;
#define sk_rx_queue_mapping     __sk_common.skc_rx_queue_mapping;
#endif;
#define sk_dontcopy_begin       __sk_common.skc_dontcopy_begin;
#define sk_dontcopy_end         __sk_common.skc_dontcopy_end;
#define sk_hash                 __sk_common.skc_hash;
#define sk_portpair             __sk_common.skc_portpair;
#define sk_num                  __sk_common.skc_num;
#define sk_dport                __sk_common.skc_dport;
#define sk_addrpair             __sk_common.skc_addrpair;
#define sk_daddr                __sk_common.skc_daddr;
#define sk_rcv_saddr            __sk_common.skc_rcv_saddr;
#define sk_family               __sk_common.skc_family;
#define sk_state                __sk_common.skc_state;
#define sk_reuse                __sk_common.skc_reuse;
#define sk_reuseport            __sk_common.skc_reuseport;
#define sk_ipv6only             __sk_common.skc_ipv6only;
#define sk_net_refcnt           __sk_common.skc_net_refcnt;
#define sk_bound_dev_if         __sk_common.skc_bound_dev_if;
#define sk_bind_node            __sk_common.skc_bind_node;
#define sk_prot                 __sk_common.skc_prot;
#define sk_net                  __sk_common.skc_net;
#define sk_v6_daddr             __sk_common.skc_v6_daddr;
#define sk_v6_rcv_saddr __sk_common.skc_v6_rcv_saddr;
#define sk_cookie               __sk_common.skc_cookie;
#define sk_incoming_cpu         __sk_common.skc_incoming_cpu;
#define sk_flags                __sk_common.skc_flags;
#define sk_rxhash               __sk_common.skc_rxhash;
  socket_lock_t sk_lock;
  atomic_t sk_drops;
  int sk_rcvlowat;
  struct sk_buff_head     sk_error_queue;
  struct sk_buff          *sk_rx_skb_cache;
  struct sk_buff_head     sk_receive_queue;
  struct {
    atomic_t rmem_alloc;
    int len;
    struct sk_buff  *head;
    struct sk_buff  *tail;
  } sk_backlog;
#define sk_rmem_alloc sk_backlog.rmem_alloc;
  int sk_forward_alloc;
#ifdef CONFIG_NET_RX_BUSY_POLL;
  unsigned int            sk_ll_usec;
  unsigned int            sk_napi_id;
#endif;
  int sk_rcvbuf;
  struct sk_filter __rcu  *sk_filter;
  union {
    struct socket_wq __rcu  *sk_wq;
  };
#ifdef CONFIG_XFRM;
  struct xfrm_policy __rcu *sk_policy[2];
#endif;
  struct dst_entry        *sk_rx_dst;
  struct dst_entry __rcu  *sk_dst_cache;
  atomic_t sk_omem_alloc;
  int sk_sndbuf;
  int sk_wmem_queued;
  refcount_t sk_wmem_alloc;
  unsigned long           sk_tsq_flags;
  union {
    struct sk_buff  *sk_send_head;
    struct rb_root  tcp_rtx_queue;
  };
  struct sk_buff          *sk_tx_skb_cache;
  struct sk_buff_head     sk_write_queue;
  __s32 sk_peek_off;
  int sk_write_pending;
  __u32 sk_dst_pending_confirm;
  u32 sk_pacing_status;
  long sk_sndtimeo;
  struct timer_list       sk_timer;
  __u32 sk_priority;
  __u32 sk_mark;
  unsigned long           sk_pacing_rate;
  unsigned long           sk_max_pacing_rate;
  struct page_frag        sk_frag;
  netdev_features_t sk_route_caps;
  netdev_features_t sk_route_nocaps;
  netdev_features_t sk_route_forced_caps;
  int sk_gso_type;
  unsigned int            sk_gso_max_size;
  gfp_t sk_allocation;
  __u32 sk_txhash;
  u8 sk_padding : 1,sk_kern_sock : 1,sk_no_check_tx : 1,sk_no_check_rx : 1, sk_userlocks : 4;
  u8 sk_pacing_shift;
  u16 sk_type;
  u16 sk_protocol;
  u16 sk_gso_max_segs;
  unsigned long           sk_lingertime;
  struct proto            *sk_prot_creator;
  rwlock_t sk_callback_lock;
  int sk_err, sk_err_soft;
  u32 sk_ack_backlog;
  u32 sk_max_ack_backlog;
  kuid_t sk_uid;
  struct pid              *sk_peer_pid;
  const struct cred       *sk_peer_cred;
  long sk_rcvtimeo;
  ktime_t sk_stamp;
#if BITS_PER_LONG==32;
  seqlock_t sk_stamp_seq;
#endif;
  u16 sk_tsflags;
  u8 sk_shutdown;
  u32 sk_tskey;
  atomic_t sk_zckey;
  u8 sk_clockid;
  u8 sk_txtime_deadline_mode : 1,sk_txtime_report_errors : 1, sk_txtime_unused : 6;
  struct socket           *sk_socket;
  void *sk_user_data;
#ifdef CONFIG_SECURITY;
  void *sk_security;
#endif;
  struct sock_cgroup_data sk_cgrp_data;
  struct mem_cgroup       *sk_memcg;
  void (*sk_state_change)(struct sock *sk);
  void (*sk_data_ready)(struct sock *sk);
  void (*sk_write_space)(struct sock *sk);
  void (*sk_error_report)(struct sock *sk);
  int (*sk_backlog_rcv)(struct sock *sk, struct sk_buff *skb);
#ifdef CONFIG_SOCK_VALIDATE_XMIT;
  struct sk_buff*         (*sk_validate_xmit_skb)(struct sock *sk,struct net_device *dev, struct sk_buff *skb);
#endif;
  void (*sk_destruct)(struct sock *sk);
  struct sock_reuseport __rcu     *sk_reuseport_cb;
#ifdef CONFIG_BPF_SYSCALL;
  struct bpf_sk_storage __rcu     *sk_bpf_storage;
#endif;
  struct rcu_head         sk_rcu;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__sk_common</span></code></dt><dd><p>shared layout with inet_timewait_sock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_lock</span></code></dt><dd><p>synchronizer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_drops</span></code></dt><dd><p>raw/udp drops counter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rcvlowat</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_RCVLOWAT</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_error_queue</span></code></dt><dd><p>rarely used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rx_skb_cache</span></code></dt><dd><p>cache copy of recently accessed RX skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_receive_queue</span></code></dt><dd><p>incoming packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_backlog</span></code></dt><dd><p>always used with the per-socket spinlock held</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_forward_alloc</span></code></dt><dd><p>space allocated forward</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_ll_usec</span></code></dt><dd><p>usecs to busypoll when there is no data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_napi_id</span></code></dt><dd><p>id of the last napi context to receive data for sk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rcvbuf</span></code></dt><dd><p>size of receive buffer in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_filter</span></code></dt><dd><p>socket filtering instructions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_wq</span></code></dt><dd><p>sock wait queue and async head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_policy</span></code></dt><dd><p>flow policy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rx_dst</span></code></dt><dd><p>receive input route used by early demux</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_dst_cache</span></code></dt><dd><p>destination cache</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_omem_alloc</span></code></dt><dd><p>“o” is “option” or “other”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_sndbuf</span></code></dt><dd><p>size of send buffer in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_wmem_queued</span></code></dt><dd><p>persistent queue size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_wmem_alloc</span></code></dt><dd><p>transmit queue bytes committed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_tsq_flags</span></code></dt><dd><p>TCP Small Queues flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_send_head</span></code></dt><dd><p>front of stuff to transmit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tcp_rtx_queue</span></code></dt><dd><p>TCP re-transmit queue [union with <strong>sk_send_head</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_tx_skb_cache</span></code></dt><dd><p>cache copy of recently accessed TX skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_write_queue</span></code></dt><dd><p>Packet sending queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_peek_off</span></code></dt><dd><p>current peek_offset value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_write_pending</span></code></dt><dd><p>a write to stream socket waits to start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_dst_pending_confirm</span></code></dt><dd><p>need to confirm neighbour</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_pacing_status</span></code></dt><dd><p>Pacing status (requested, handled by sch_fq)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_sndtimeo</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_SNDTIMEO</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_timer</span></code></dt><dd><p>sock cleanup timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_priority</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_PRIORITY</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_mark</span></code></dt><dd><p>generic packet mark</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_pacing_rate</span></code></dt><dd><p>Pacing rate (if supported by transport/packet scheduler)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_max_pacing_rate</span></code></dt><dd><p>Maximum pacing rate (<code class="docutils literal notranslate"><span class="pre">SO_MAX_PACING_RATE</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_frag</span></code></dt><dd><p>cached page frag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_route_caps</span></code></dt><dd><p>route capabilities (e.g. <code class="docutils literal notranslate"><span class="pre">NETIF_F_TSO</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_route_nocaps</span></code></dt><dd><p>forbidden route capabilities (e.g NETIF_F_GSO_MASK)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_route_forced_caps</span></code></dt><dd><p>static, forced route capabilities
(set in tcp_init_sock())</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_gso_type</span></code></dt><dd><p>GSO type (e.g. <code class="docutils literal notranslate"><span class="pre">SKB_GSO_TCPV4</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_gso_max_size</span></code></dt><dd><p>Maximum GSO segment size to build</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_allocation</span></code></dt><dd><p>allocation mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_txhash</span></code></dt><dd><p>computed flow hash for use on transmit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_padding</span></code></dt><dd><p>unused element for alignment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_kern_sock</span></code></dt><dd><p>True if sock is using kernel lock classes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_no_check_tx</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_NO_CHECK</span></code> setting, set checksum in TX packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_no_check_rx</span></code></dt><dd><p>allow zero checksum in RX packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_userlocks</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_SNDBUF</span></code> and <code class="docutils literal notranslate"><span class="pre">SO_RCVBUF</span></code> settings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_pacing_shift</span></code></dt><dd><p>scaling factor for TCP Small Queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_type</span></code></dt><dd><p>socket type (<code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_protocol</span></code></dt><dd><p>which protocol this socket belongs in this network family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_gso_max_segs</span></code></dt><dd><p>Maximum number of GSO segments</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_lingertime</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_LINGER</span></code> l_linger setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_prot_creator</span></code></dt><dd><p>sk_prot of original sock creator (see ipv6_setsockopt,
IPV6_ADDRFORM for instance)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_callback_lock</span></code></dt><dd><p>used with the callbacks in the end of this struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_err</span></code></dt><dd><p>last error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_err_soft</span></code></dt><dd><p>errors that don’t cause failure but are the cause of a
persistent failure not just ‘timed out’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_ack_backlog</span></code></dt><dd><p>current listen backlog</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_max_ack_backlog</span></code></dt><dd><p>listen backlog set in listen()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_uid</span></code></dt><dd><p>user id of owner</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_peer_pid</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pid</span></code> for this socket’s peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_peer_cred</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_PEERCRED</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rcvtimeo</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_RCVTIMEO</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_stamp</span></code></dt><dd><p>time stamp of last packet received</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_stamp_seq</span></code></dt><dd><p>lock for accessing sk_stamp on 32 bit architectures only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_tsflags</span></code></dt><dd><p>SO_TIMESTAMPING socket options</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_shutdown</span></code></dt><dd><p>mask of <code class="docutils literal notranslate"><span class="pre">SEND_SHUTDOWN</span></code> and/or <code class="docutils literal notranslate"><span class="pre">RCV_SHUTDOWN</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_tskey</span></code></dt><dd><p>counter to disambiguate concurrent tstamp requests</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_zckey</span></code></dt><dd><p>counter to order MSG_ZEROCOPY notifications</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_clockid</span></code></dt><dd><p>clockid used by time-based scheduling (SO_TXTIME)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_txtime_deadline_mode</span></code></dt><dd><p>set deadline mode for SO_TXTIME</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_txtime_report_errors</span></code></dt><dd><p>set report errors mode for SO_TXTIME</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_txtime_unused</span></code></dt><dd><p>unused txtime flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_socket</span></code></dt><dd><p>Identd and reporting IO signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_user_data</span></code></dt><dd><p>RPC layer private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_security</span></code></dt><dd><p>used by security modules</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_cgrp_data</span></code></dt><dd><p>cgroup data for this cgroup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_memcg</span></code></dt><dd><p>this socket’s memory cgroup association</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_state_change</span></code></dt><dd><p>callback to indicate change in the state of the sock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_data_ready</span></code></dt><dd><p>callback to indicate there is data to be processed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_write_space</span></code></dt><dd><p>callback to indicate there is bf sending space available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_error_report</span></code></dt><dd><p>callback to indicate errors (e.g. <code class="docutils literal notranslate"><span class="pre">MSG_ERRQUEUE</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_backlog_rcv</span></code></dt><dd><p>callback to process the backlog</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_validate_xmit_skb</span></code></dt><dd><p>ptr to an optional validate function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_destruct</span></code></dt><dd><p>called at sock freeing time, i.e. when all refcnt == 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_reuseport_cb</span></code></dt><dd><p>reuseport group container</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_bpf_storage</span></code></dt><dd><p>ptr to cache and control for bpf_sk_storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rcu</span></code></dt><dd><p>used during RCU grace period</p>
</dd>
</dl>
<dl class="function">
<dt id="c.sk_user_data_is_nocopy">
bool <code class="sig-name descname">sk_user_data_is_nocopy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_user_data_is_nocopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if sk_user_data pointer must not be copied</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<dl class="function">
<dt id="c.sk_for_each_entry_offset_rcu">
<code class="sig-name descname">sk_for_each_entry_offset_rcu</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_for_each_entry_offset_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list at a given struct offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tpos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>offset of hlist_node within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.unlock_sock_fast">
void <code class="sig-name descname">unlock_sock_fast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, bool<em> slow</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_sock_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>complement of lock_sock_fast</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">slow</span></code></dt><dd><p>slow mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>fast unlock socket for user context.
If slow mode is on, we call regular release_sock()</p>
<dl class="function">
<dt id="c.sk_wmem_alloc_get">
int <code class="sig-name descname">sk_wmem_alloc_get</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_wmem_alloc_get" title="Permalink to this definition">¶</a></dt>
<dd><p>returns write allocations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>sk_wmem_alloc minus initial offset of one</p>
<dl class="function">
<dt id="c.sk_rmem_alloc_get">
int <code class="sig-name descname">sk_rmem_alloc_get</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_rmem_alloc_get" title="Permalink to this definition">¶</a></dt>
<dd><p>returns read allocations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>sk_rmem_alloc</p>
<dl class="function">
<dt id="c.sk_has_allocations">
bool <code class="sig-name descname">sk_has_allocations</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_has_allocations" title="Permalink to this definition">¶</a></dt>
<dd><p>check if allocations are outstanding</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if socket has write or read allocations</p>
<dl class="function">
<dt id="c.skwq_has_sleeper">
bool <code class="sig-name descname">skwq_has_sleeper</code><span class="sig-paren">(</span>struct socket_wq *<em> wq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skwq_has_sleeper" title="Permalink to this definition">¶</a></dt>
<dd><p>check if there are any waiting processes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket_wq</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt><dd><p>struct socket_wq</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if socket_wq has waiting processes</p>
<p>The purpose of the skwq_has_sleeper and sock_poll_wait is to wrap the memory
barrier call. They were added due to the race found within the tcp code.</p>
<p>Consider following tcp code paths:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU1                CPU2
sys_select          receive packet
...                 ...
__add_wait_queue    update tp-&gt;rcv_nxt
...                 ...
tp-&gt;rcv_nxt check   sock_def_readable
...                 {
schedule               rcu_read_lock();
                       wq = rcu_dereference(sk-&gt;sk_wq);
                       if (wq &amp;&amp; waitqueue_active(&amp;wq-&gt;wait))
                           wake_up_interruptible(&amp;wq-&gt;wait)
                       ...
                    }
</pre></div>
</div>
<p>The race for tcp fires when the __add_wait_queue changes done by CPU1 stay
in its cache, and so does the tp-&gt;rcv_nxt update on CPU2 side.  The CPU1
could then endup calling schedule and sleep forever if there are no more
data on the socket.</p>
<dl class="function">
<dt id="c.sock_poll_wait">
void <code class="sig-name descname">sock_poll_wait</code><span class="sig-paren">(</span>struct file *<em> filp</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, poll_table *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_poll_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>place memory barrier behind the poll_wait call.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>poll_table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See the comments in the wq_has_sleeper function.</p>
<dl class="function">
<dt id="c.sk_page_frag">
struct page_frag * <code class="sig-name descname">sk_page_frag</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_page_frag" title="Permalink to this definition">¶</a></dt>
<dd><p>return an appropriate page_frag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the per task page_frag instead of the per socket one for
optimization when we know that we’re in the normal context and owns
everything that’s associated with <code class="docutils literal notranslate"><span class="pre">current</span></code>.</p>
<p>gfpflags_allow_blocking() isn’t enough here as direct reclaim may nest
inside other socket operations and end up recursing into <a class="reference internal" href="#c.sk_page_frag" title="sk_page_frag"><code class="xref c c-func docutils literal notranslate"><span class="pre">sk_page_frag()</span></code></a>
while it’s already in use.</p>
<p><strong>Return</strong></p>
<p>a per task page_frag if context allows that,
otherwise a per socket one.</p>
<dl class="function">
<dt id="c._sock_tx_timestamp">
void <code class="sig-name descname">_sock_tx_timestamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, __u16<em> tsflags</em>, __u8 *<em> tx_flags</em>, __u32 *<em> tskey</em><span class="sig-paren">)</span><a class="headerlink" href="#c._sock_tx_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>checks whether the outgoing packet is to be time stamped</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket sending this packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">tsflags</span></code></dt><dd><p>timestamping flags to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">*</span> <span class="pre">tx_flags</span></code></dt><dd><p>completed with instructions for time stamping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u32</span> <span class="pre">*</span> <span class="pre">tskey</span></code></dt><dd><p>filled in with next sk_tskey (not for TCP, which uses seqno)</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>callers should take care of initial <code class="docutils literal notranslate"><span class="pre">*tx_flags</span></code> value (usually 0)</p>
<dl class="function">
<dt id="c.sk_eat_skb">
void <code class="sig-name descname">sk_eat_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_eat_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a skb if it is no longer needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket to eat this skb from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>socket buffer to eat</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine must be called with interrupts disabled or with the socket
locked so that the sk_buff queue operation is ok.</p>
<dl class="function">
<dt id="c.skb_steal_sock">
struct <a class="reference internal" href="#c.sock" title="sock">sock</a> * <code class="sig-name descname">skb_steal_sock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, bool *<em> refcounted</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_steal_sock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p><em>undescribed</em></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">refcounted</span></code></dt><dd><p><em>undescribed</em></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>skb</strong> to steal the socket from
<strong>refcounted</strong> is set to true if the socket is reference-counted</p>
<dl class="function">
<dt id="c.sock_alloc_file">
struct file * <code class="sig-name descname">sock_alloc_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, int<em> flags</em>, const char *<em> dname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_alloc_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind a <a class="reference internal" href="#c.socket" title="socket"><code class="xref c c-type docutils literal notranslate"><span class="pre">socket</span></code></a> to a <code class="xref c c-type docutils literal notranslate"><span class="pre">file</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>file status flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">dname</span></code></dt><dd><p>protocol name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns the <code class="xref c c-type docutils literal notranslate"><span class="pre">file</span></code> bound with <strong>sock</strong>, implicitly storing it
in sock-&gt;file. If dname is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, sets to “”.
On failure the return is a ERR pointer (see linux/err.h).
This function uses GFP_KERNEL internally.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sock_from_file">
struct <a class="reference internal" href="#c.socket" title="socket">socket</a> * <code class="sig-name descname">sock_from_file</code><span class="sig-paren">(</span>struct file *<em> file</em>, int *<em> err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <a class="reference internal" href="#c.socket" title="socket"><code class="xref c c-type docutils literal notranslate"><span class="pre">socket</span></code></a> bounded to <strong>file</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">err</span></code></dt><dd><p>pointer to an error code return</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>On failure returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and assigns -ENOTSOCK to <strong>err</strong>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sockfd_lookup">
struct <a class="reference internal" href="#c.socket" title="socket">socket</a> * <code class="sig-name descname">sockfd_lookup</code><span class="sig-paren">(</span>int<em> fd</em>, int *<em> err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sockfd_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Go from a file number to its socket slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>file handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">err</span></code></dt><dd><p>pointer to an error code return</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The file handle passed in is locked and the socket it is bound
to is returned. If an error occurs the err pointer is overwritten
with a negative errno code and NULL is returned. The function checks
for both invalid handles and passing a handle which is not a socket.</p>
<p>On a success the socket object pointer is returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sock_alloc">
struct <a class="reference internal" href="#c.socket" title="socket">socket</a> * <code class="sig-name descname">sock_alloc</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.sock_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a new inode and socket object. The two are bound together
and initialised. The socket is then returned. If we are out of inodes
NULL is returned. This functions uses GFP_KERNEL internally.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sock_sendmsg">
int <code class="sig-name descname">sock_sendmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, struct msghdr *<em> msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_sendmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>send a message through <strong>sock</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>message to send</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Sends <strong>msg</strong> through <strong>sock</strong>, passing through LSM.
Returns the number of bytes sent, or an error code.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_sendmsg">
int <code class="sig-name descname">kernel_sendmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, struct msghdr *<em> msg</em>, struct kvec *<em> vec</em>, size_t<em> num</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sendmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>send a message through <strong>sock</strong> (kernel-space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>message header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*</span> <span class="pre">vec</span></code></dt><dd><p>kernel vec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num</span></code></dt><dd><p>vec array length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>total message data size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Builds the message data with <strong>vec</strong> and sends it through <strong>sock</strong>.
Returns the number of bytes sent, or an error code.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_sendmsg_locked">
int <code class="sig-name descname">kernel_sendmsg_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, struct msghdr *<em> msg</em>, struct kvec *<em> vec</em>, size_t<em> num</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sendmsg_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>send a message through <strong>sock</strong> (kernel-space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>sock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>message header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*</span> <span class="pre">vec</span></code></dt><dd><p>output s/g array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num</span></code></dt><dd><p>output s/g array length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>total message data size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Builds the message data with <strong>vec</strong> and sends it through <strong>sock</strong>.
Returns the number of bytes sent, or an error code.
Caller must hold <strong>sk</strong>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sock_recvmsg">
int <code class="sig-name descname">sock_recvmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, struct msghdr *<em> msg</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_recvmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>receive a message from <strong>sock</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>message to receive</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>message flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Receives <strong>msg</strong> from <strong>sock</strong>, passing through LSM. Returns the total number
of bytes received, or an error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_recvmsg">
int <code class="sig-name descname">kernel_recvmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, struct msghdr *<em> msg</em>, struct kvec *<em> vec</em>, size_t<em> num</em>, size_t<em> size</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_recvmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a message from a socket (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>The socket to receive the message from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>Received message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*</span> <span class="pre">vec</span></code></dt><dd><p>Input s/g array for message data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num</span></code></dt><dd><p>Size of input s/g array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Number of bytes to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>Message flags (MSG_DONTWAIT, etc…)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>On return the msg structure contains the scatter/gather array passed in the
vec argument. The array is modified so that it consists of the unfilled
portion of the original array.</p>
<p>The returned value is the total number of bytes received, or an error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.get_net_ns">
struct ns_common * <code class="sig-name descname">get_net_ns</code><span class="sig-paren">(</span>struct ns_common *<em> ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_net_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>increment the refcount of the network namespace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ns_common</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt><dd><p>common namespace (net)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns the net’s common namespace.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sock_create_lite">
int <code class="sig-name descname">sock_create_lite</code><span class="sig-paren">(</span>int<em> family</em>, int<em> type</em>, int<em> protocol</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a> **<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_create_lite" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family (AF_INET, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>communication type (SOCK_STREAM, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>protocol (0, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**</span> <span class="pre">res</span></code></dt><dd><p>new socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Creates a new socket and assigns it to <strong>res</strong>, passing through LSM.
The new socket initialization is not complete, see <a class="reference internal" href="#c.kernel_accept" title="kernel_accept"><code class="xref c c-func docutils literal notranslate"><span class="pre">kernel_accept()</span></code></a>.
Returns 0 or an error. On failure <strong>res</strong> is set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
This function internally uses GFP_KERNEL.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__sock_create">
int <code class="sig-name descname">__sock_create</code><span class="sig-paren">(</span>struct net *<em> net</em>, int<em> family</em>, int<em> type</em>, int<em> protocol</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a> **<em> res</em>, int<em> kern</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sock_create" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family (AF_INET, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>communication type (SOCK_STREAM, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>protocol (0, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**</span> <span class="pre">res</span></code></dt><dd><p>new socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kern</span></code></dt><dd><p>boolean for kernel space sockets</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Creates a new socket and assigns it to <strong>res</strong>, passing through LSM.
Returns 0 or an error. On failure <strong>res</strong> is set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. <strong>kern</strong> must
be set to true if the socket resides in kernel space.
This function internally uses GFP_KERNEL.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sock_create">
int <code class="sig-name descname">sock_create</code><span class="sig-paren">(</span>int<em> family</em>, int<em> type</em>, int<em> protocol</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a> **<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_create" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family (AF_INET, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>communication type (SOCK_STREAM, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>protocol (0, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**</span> <span class="pre">res</span></code></dt><dd><p>new socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>A wrapper around <a class="reference internal" href="#c.__sock_create" title="__sock_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">__sock_create()</span></code></a>.
Returns 0 or an error. This function internally uses GFP_KERNEL.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sock_create_kern">
int <code class="sig-name descname">sock_create_kern</code><span class="sig-paren">(</span>struct net *<em> net</em>, int<em> family</em>, int<em> type</em>, int<em> protocol</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a> **<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_create_kern" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a socket (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family (AF_INET, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>communication type (SOCK_STREAM, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>protocol (0, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**</span> <span class="pre">res</span></code></dt><dd><p>new socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>A wrapper around <a class="reference internal" href="#c.__sock_create" title="__sock_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">__sock_create()</span></code></a>.
Returns 0 or an error. This function internally uses GFP_KERNEL.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sock_register">
int <code class="sig-name descname">sock_register</code><span class="sig-paren">(</span>const struct net_proto_family *<em> ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_register" title="Permalink to this definition">¶</a></dt>
<dd><p>add a socket protocol handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_proto_family</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>description of protocol</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is called by a protocol handler that wants to
advertise its address family, and have it linked into the
socket interface. The value ops-&gt;family corresponds to the
socket system call protocol family.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sock_unregister">
void <code class="sig-name descname">sock_unregister</code><span class="sig-paren">(</span>int<em> family</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a protocol handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is called by a protocol handler that wants to
remove its address family, and have it unlinked from the
new socket creation.</p>
<p>If protocol handler is a module, then it can use module reference
counts to protect against new references. If protocol handler is not
a module then it needs to provide its own protection in
the ops-&gt;create routine.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_bind">
int <code class="sig-name descname">kernel_bind</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, struct sockaddr *<em> addr</em>, int<em> addrlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>bind an address to a socket (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addrlen</span></code></dt><dd><p>length of address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 or an error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_listen">
int <code class="sig-name descname">kernel_listen</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, int<em> backlog</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_listen" title="Permalink to this definition">¶</a></dt>
<dd><p>move socket to listening state (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">backlog</span></code></dt><dd><p>pending connections queue size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 or an error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_accept">
int <code class="sig-name descname">kernel_accept</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a> **<em> newsock</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>accept a connection (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>listening socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**</span> <span class="pre">newsock</span></code></dt><dd><p>new connected socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>flags</strong> must be SOCK_CLOEXEC, SOCK_NONBLOCK or 0.
If it fails, <strong>newsock</strong> is guaranteed to be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
Returns 0 or an error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_connect">
int <code class="sig-name descname">kernel_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, struct sockaddr *<em> addr</em>, int<em> addrlen</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect a socket (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addrlen</span></code></dt><dd><p>address length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags (O_NONBLOCK, …)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>For datagram sockets, <strong>addr</strong> is the addres to which datagrams are sent
by default, and the only address from which datagrams are received.
For stream sockets, attempts to connect to <strong>addr</strong>.
Returns 0 or an error code.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_getsockname">
int <code class="sig-name descname">kernel_getsockname</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, struct sockaddr *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_getsockname" title="Permalink to this definition">¶</a></dt>
<dd><p>get the address which the socket is bound (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>address holder</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Fills the <strong>addr</strong> pointer with the address which the socket is bound.
Returns 0 or an error code.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_getpeername">
int <code class="sig-name descname">kernel_getpeername</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, struct sockaddr *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_getpeername" title="Permalink to this definition">¶</a></dt>
<dd><p>get the address which the socket is connected (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>address holder</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Fills the <strong>addr</strong> pointer with the address which the socket is connected.
Returns 0 or an error code.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_getsockopt">
int <code class="sig-name descname">kernel_getsockopt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, int<em> level</em>, int<em> optname</em>, char *<em> optval</em>, int *<em> optlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_getsockopt" title="Permalink to this definition">¶</a></dt>
<dd><p>get a socket option (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">level</span></code></dt><dd><p>API level (SOL_SOCKET, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">optname</span></code></dt><dd><p>option tag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">optval</span></code></dt><dd><p>option value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">optlen</span></code></dt><dd><p>option length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Assigns the option length to <strong>optlen</strong>.
Returns 0 or an error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_setsockopt">
int <code class="sig-name descname">kernel_setsockopt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, int<em> level</em>, int<em> optname</em>, char *<em> optval</em>, unsigned int<em> optlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_setsockopt" title="Permalink to this definition">¶</a></dt>
<dd><p>set a socket option (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">level</span></code></dt><dd><p>API level (SOL_SOCKET, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">optname</span></code></dt><dd><p>option tag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">optval</span></code></dt><dd><p>option value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">optlen</span></code></dt><dd><p>option length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 or an error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_sendpage">
int <code class="sig-name descname">kernel_sendpage</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, struct page *<em> page</em>, int<em> offset</em>, size_t<em> size</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sendpage" title="Permalink to this definition">¶</a></dt>
<dd><p>send a <code class="xref c c-type docutils literal notranslate"><span class="pre">page</span></code> through a socket (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt><dd><p>page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>page offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>total size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags (MSG_DONTWAIT, …)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns the total amount sent in bytes or an error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_sendpage_locked">
int <code class="sig-name descname">kernel_sendpage_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, struct page *<em> page</em>, int<em> offset</em>, size_t<em> size</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sendpage_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>send a <code class="xref c c-type docutils literal notranslate"><span class="pre">page</span></code> through the locked sock (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>sock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt><dd><p>page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>page offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>total size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags (MSG_DONTWAIT, …)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns the total amount sent in bytes or an error.
Caller must hold <strong>sk</strong>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_sock_shutdown">
int <code class="sig-name descname">kernel_sock_shutdown</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, enum <a class="reference internal" href="#c.sock_shutdown_cmd" title="sock_shutdown_cmd">sock_shutdown_cmd</a><em> how</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sock_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>shut down part of a full-duplex connection (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">sock_shutdown_cmd</span> <span class="pre">how</span></code></dt><dd><p>connection part</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 or an error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.kernel_sock_ip_overhead">
u32 <code class="sig-name descname">kernel_sock_ip_overhead</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sock_ip_overhead" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the IP overhead imposed by a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This routine returns the IP overhead imposed by a socket i.e.
the length of the underlying IP header, depending on whether
this is an IPv4 or IPv6 socket and the length from IP options turned
on at the socket. Assumes that the caller has a lock on the socket.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__alloc_skb</code><span class="sig-paren">(</span>unsigned int<em> size</em>, gfp_t<em> gfp_mask</em>, int<em> flags</em>, int<em> node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a network buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>If SKB_ALLOC_FCLONE is set, allocate from fclone cache
instead of head cache and allocate a cloned (child) skb.
If SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for
allocations in case the data is required for writeback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>numa node to allocate memory on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a new <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>. The returned buffer has no headroom and a
tail room of at least size bytes. The object has a reference count
of one. The return is the buffer. On a failure the return is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>Buffers may only be allocated from interrupts using a <strong>gfp_mask</strong> of
<code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.build_skb_around">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">build_skb_around</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, void *<em> data</em>, unsigned int<em> frag_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.build_skb_around" title="Permalink to this definition">¶</a></dt>
<dd><p>build a network buffer around provided skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>sk_buff provide by caller, must be memset cleared</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>data buffer provided by caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">frag_size</span></code></dt><dd><p>size of data, or 0 if head was kmalloced</p>
</dd>
</dl>
<dl class="function">
<dt id="c.netdev_alloc_frag">
void * <code class="sig-name descname">netdev_alloc_frag</code><span class="sig-paren">(</span>unsigned int<em> fragsz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_alloc_frag" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a page fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fragsz</span></code></dt><dd><p>fragment size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a frag from a page for receive buffer.
Uses GFP_ATOMIC allocations.</p>
<dl class="function">
<dt id="c.__netdev_alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__netdev_alloc_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, unsigned int<em> len</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__netdev_alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an skbuff for rx on a specific device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device to receive on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>get_free_pages mask, passed to alloc_skb</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a new <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and assign it a usage count of one. The
buffer has NET_SKB_PAD headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__napi_alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__napi_alloc_skb</code><span class="sig-paren">(</span>struct napi_struct *<em> napi</em>, unsigned int<em> len</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__napi_alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate skbuff for rx in a specific NAPI instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">napi</span></code></dt><dd><p>napi instance this buffer was allocated for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>get_free_pages mask, passed to alloc_skb and alloc_pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a new sk_buff for use in NAPI receive.  This buffer will
attempt to allocate the head from a special reserved region used
only for NAPI Rx allocation.  By doing this we can save several
CPU cycles by avoiding having to disable and re-enable IRQs.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__kfree_skb">
void <code class="sig-name descname">__kfree_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__kfree_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>private function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Free an sk_buff. Release anything attached to the buffer.
Clean the state. This is an internal helper function. Users should
always call kfree_skb</p>
</div></blockquote>
<dl class="function">
<dt id="c.kfree_skb">
void <code class="sig-name descname">kfree_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>free an sk_buff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Drop a reference to the buffer and free it if the usage count has
hit zero.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_tx_error">
void <code class="sig-name descname">skb_tx_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tx_error" title="Permalink to this definition">¶</a></dt>
<dd><p>report an sk_buff xmit error</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer that triggered an error</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Report xmit error if a device callback is tracking this skb.
skb must be freed afterwards.</p>
</div></blockquote>
<dl class="function">
<dt id="c.consume_skb">
void <code class="sig-name descname">consume_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.consume_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>free an skbuff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Drop a ref to the buffer and free it if the usage count has hit zero
Functions identically to kfree_skb, but kfree_skb assumes that the frame
is being dropped after a failure and notes that</p>
</div></blockquote>
<dl class="function">
<dt id="c.alloc_skb_for_msg">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">alloc_skb_for_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> first</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_skb_for_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate sk_buff to wrap frag list forming a msg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">first</span></code></dt><dd><p>first sk_buff of the msg</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_morph">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_morph</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> dst</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_morph" title="Permalink to this definition">¶</a></dt>
<dd><p>morph one skb into another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>the skb to receive the contents</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>the skb to supply the contents</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This is identical to skb_clone except that the target skb is
supplied by the user.</p>
<p>The target skb is returned upon exit.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy_ubufs">
int <code class="sig-name descname">skb_copy_ubufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_ubufs" title="Permalink to this definition">¶</a></dt>
<dd><p>copy userspace skb frags buffers to kernel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the skb to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This must be called on SKBTX_DEV_ZEROCOPY skb.
It will copy all frags into kernel and drop the reference
to userspace pages.</p>
<p>If this function is called from an interrupt gfp_mask() must be
<code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>.</p>
<p>Returns 0 on success or a negative error code on failure
to allocate kernel memory to copy to.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_clone">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_clone</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an sk_buff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to clone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Duplicate an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>. The new one is not owned by a socket. Both
copies share the same packet data but not structure. The new
buffer has a reference count of 1. If the allocation fails the
function returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise the new buffer is returned.</p>
<p>If this function is called from an interrupt gfp_mask() must be
<code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_copy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>create private copy of an sk_buff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Make a copy of both an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and its data. This is used when the
caller wishes to modify the data and needs a private copy of the
data to alter. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure or the pointer to the buffer
on success. The returned buffer has a reference count of 1.</p>
<p>As by-product this function converts non-linear <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> to linear
one, so that <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> becomes completely private and caller is allowed
to modify all the data of returned buffer. This means that this
function is not recommended for use in circumstances when only
header is going to be modified. Use pskb_copy() instead.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__pskb_copy_fclone">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__pskb_copy_fclone</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> headroom</em>, gfp_t<em> gfp_mask</em>, bool<em> fclone</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pskb_copy_fclone" title="Permalink to this definition">¶</a></dt>
<dd><p>create copy of an sk_buff with private head.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">headroom</span></code></dt><dd><p>headroom of new skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">fclone</span></code></dt><dd><p>if true allocate the copy of the skb from the fclone
cache instead of the head cache; it is recommended to set this
to true for the cases where the copy will likely be cloned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Make a copy of both an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and part of its data, located
in header. Fragmented data remain shared. This is used when
the caller wishes to modify only header of <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and needs
private copy of the header to alter. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure
or the pointer to the buffer on success.
The returned buffer has a reference count of 1.</p>
</div></blockquote>
<dl class="function">
<dt id="c.pskb_expand_head">
int <code class="sig-name descname">pskb_expand_head</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> nhead</em>, int<em> ntail</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_expand_head" title="Permalink to this definition">¶</a></dt>
<dd><p>reallocate header of <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to reallocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nhead</span></code></dt><dd><p>room to add at head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ntail</span></code></dt><dd><p>room to add at tail</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Expands (or creates identical copy, if <strong>nhead</strong> and <strong>ntail</strong> are zero)
header of <strong>skb</strong>. <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> itself is not changed. <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> MUST have
reference count of 1. Returns zero in the case of success or error,
if expansion failed. In the last case, <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> is not changed.</p>
<p>All the pointers pointing into skb header may change and must be
reloaded after call to this function.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy_expand">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_copy_expand</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> newheadroom</em>, int<em> newtailroom</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>copy and expand sk_buff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">newheadroom</span></code></dt><dd><p>new free bytes at head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">newtailroom</span></code></dt><dd><p>new free bytes at tail</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Make a copy of both an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and its data and while doing so
allocate additional space.</p>
<p>This is used when the caller wishes to modify the data and needs a
private copy of the data to alter as well as more space for new fields.
Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure or the pointer to the buffer
on success. The returned buffer has a reference count of 1.</p>
<p>You must pass <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code> as the allocation priority if this function
is called from an interrupt.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_pad">
int <code class="sig-name descname">__skb_pad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> pad</em>, bool<em> free_on_error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>zero pad the tail of an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pad</span></code></dt><dd><p>space to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">free_on_error</span></code></dt><dd><p>free buffer on error</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Ensure that a buffer is followed by a padding area that is zero
filled. Used by network drivers which may DMA or transfer data
beyond the buffer end onto the wire.</p>
<p>May return error in out of memory cases. The skb is freed on error
if <strong>free_on_error</strong> is true.</p>
</div></blockquote>
<dl class="function">
<dt id="c.pskb_put">
void * <code class="sig-name descname">pskb_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> tail</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_put" title="Permalink to this definition">¶</a></dt>
<dd><p>add data to the tail of a potentially fragmented buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>start of the buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">tail</span></code></dt><dd><p>tail fragment of the buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function extends the used data area of the potentially
fragmented buffer. <strong>tail</strong> must be the last fragment of <strong>skb</strong> – or
<strong>skb</strong> itself. If this would exceed the total buffer size the kernel
will panic. A pointer to the first byte of the extra data is
returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_put">
void * <code class="sig-name descname">skb_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_put" title="Permalink to this definition">¶</a></dt>
<dd><p>add data to a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function extends the used data area of the buffer. If this would
exceed the total buffer size the kernel will panic. A pointer to the
first byte of the extra data is returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_push">
void * <code class="sig-name descname">skb_push</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_push" title="Permalink to this definition">¶</a></dt>
<dd><p>add data to the start of a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function extends the used data area of the buffer at the buffer
start. If this would exceed the total buffer headroom the kernel will
panic. A pointer to the first byte of the extra data is returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_pull">
void * <code class="sig-name descname">skb_pull</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pull" title="Permalink to this definition">¶</a></dt>
<dd><p>remove data from the start of a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function removes data from the start of a buffer, returning
the memory to the headroom. A pointer to the next data in the buffer
is returned. Once the data has been pulled future pushes will overwrite
the old data.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_trim">
void <code class="sig-name descname">skb_trim</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_trim" title="Permalink to this definition">¶</a></dt>
<dd><p>remove end from a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to alter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>new length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Cut the length of a buffer down by removing data from the tail. If
the buffer is already under the length specified it is not modified.
The skb must be linear.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__pskb_pull_tail">
void * <code class="sig-name descname">__pskb_pull_tail</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> delta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pskb_pull_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>advance tail of skb header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to reallocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">delta</span></code></dt><dd><p>number of bytes to advance tail</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The function makes a sense only on a fragmented <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>,
it expands header moving its tail forward and copying necessary
data from fragmented part.</p>
<p><a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> MUST have reference count of 1.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (and <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> does not change) if pull failed
or value of new tail of skb in the case of success.</p>
<p>All the pointers pointing into skb header may change and must be
reloaded after call to this function.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy_bits">
int <code class="sig-name descname">skb_copy_bits</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> offset</em>, void *<em> to</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>copy bits from skb to kernel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>source skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">to</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Copy the specified number of bytes from the source skb to the
destination buffer.</p>
<dl class="simple">
<dt>CAUTION ! :</dt><dd><p>If its prototype is ever changed,
check arch/{*}/net/{*}.S files,
since it is called from BPF assembly code.</p>
</dd>
</dl>
</div></blockquote>
<dl class="function">
<dt id="c.skb_store_bits">
int <code class="sig-name descname">skb_store_bits</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> offset</em>, const void *<em> from</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_store_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>store bits from kernel buffer to skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">from</span></code></dt><dd><p>source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Copy the specified number of bytes from the source buffer to the
destination skb.  This function handles all the messy bits of
traversing fragment lists and such.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_zerocopy">
int <code class="sig-name descname">skb_zerocopy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> to</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> from</em>, int<em> len</em>, int<em> hlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_zerocopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero copy skb to skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">to</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">from</span></code></dt><dd><p>source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy from source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hlen</span></code></dt><dd><p>size of linear headroom in destination buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Copies up to <cite>len</cite> bytes from <cite>from</cite> to <cite>to</cite> by creating references
to the frags in the source buffer.</p>
<p>The <cite>hlen</cite> as calculated by skb_zerocopy_headlen() specifies the
headroom in the <cite>to</cite> buffer.</p>
<p>Return value:
0: everything is OK
-ENOMEM: couldn’t orphan frags of <strong>from</strong> due to lack of memory
-EFAULT: <a class="reference internal" href="#c.skb_copy_bits" title="skb_copy_bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_copy_bits()</span></code></a> found some problem with skb geometry</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_dequeue">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_dequeue</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dequeue" title="Permalink to this definition">¶</a></dt>
<dd><p>remove from the head of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to dequeue from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove the head of the list. The list lock is taken so the function
may be used safely with other locking list functions. The head item is
returned or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the list is empty.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_dequeue_tail">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_dequeue_tail</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dequeue_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>remove from the tail of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to dequeue from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove the tail of the list. The list lock is taken so the function
may be used safely with other locking list functions. The tail item is
returned or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the list is empty.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_purge">
void <code class="sig-name descname">skb_queue_purge</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_purge" title="Permalink to this definition">¶</a></dt>
<dd><p>empty a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to empty</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Delete all buffers on an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> list. Each buffer is removed from
the list and one reference dropped. This function takes the list
lock and is atomic with respect to other list locking functions.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_head">
void <code class="sig-name descname">skb_queue_head</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_head" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt><dd><p>buffer to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a buffer at the start of the list. This function takes the
list lock and can be used safely with other locking <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> functions
safely.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_tail">
void <code class="sig-name descname">skb_queue_tail</code><span class="sig-paren">(</span>struct sk_buff_head *<em> list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list tail</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt><dd><p>buffer to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a buffer at the tail of the list. This function takes the
list lock and can be used safely with other locking <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> functions
safely.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_unlink">
void <code class="sig-name descname">skb_unlink</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a buffer from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a packet from a list. The list locks are taken and this
function is atomic with respect to other list locked calls</p>
<p>You must know what list the SKB is on.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_append">
void <code class="sig-name descname">skb_append</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> old</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> newsk</em>, struct sk_buff_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_append" title="Permalink to this definition">¶</a></dt>
<dd><p>append a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>buffer to insert after</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt><dd><p>buffer to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Place a packet after a given packet in a list. The list locks are taken
and this function is atomic with respect to other list locked calls.
A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_split">
void <code class="sig-name descname">skb_split</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb1</em>, const u32<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split fragmented skb to two parts at length len.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the buffer to split</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb1</span></code></dt><dd><p>the buffer to receive the second part</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">len</span></code></dt><dd><p>new length for skb</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_prepare_seq_read">
void <code class="sig-name descname">skb_prepare_seq_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> from</em>, unsigned int<em> to</em>, struct skb_seq_state *<em> st</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_prepare_seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a sequential read of skb data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the buffer to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">from</span></code></dt><dd><p>lower offset of data to be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">to</span></code></dt><dd><p>upper offset of data to be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skb_seq_state</span> <span class="pre">*</span> <span class="pre">st</span></code></dt><dd><p>state variable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the specified state variable. Must be called before
invoking <a class="reference internal" href="#c.skb_seq_read" title="skb_seq_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_seq_read()</span></code></a> for the first time.</p>
<dl class="function">
<dt id="c.skb_seq_read">
unsigned int <code class="sig-name descname">skb_seq_read</code><span class="sig-paren">(</span>unsigned int<em> consumed</em>, const u8 **<em> data</em>, struct skb_seq_state *<em> st</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Sequentially read skb data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">consumed</span></code></dt><dd><p>number of bytes consumed by the caller so far</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">**</span> <span class="pre">data</span></code></dt><dd><p>destination pointer for data to be returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skb_seq_state</span> <span class="pre">*</span> <span class="pre">st</span></code></dt><dd><p>state variable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a block of skb data at <strong>consumed</strong> relative to the
lower offset specified to <a class="reference internal" href="#c.skb_prepare_seq_read" title="skb_prepare_seq_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_prepare_seq_read()</span></code></a>. Assigns
the head of the data block to <strong>data</strong> and returns the length
of the block or 0 if the end of the skb data or the upper
offset has been reached.</p>
<p>The caller is not required to consume all of the data
returned, i.e. <strong>consumed</strong> is typically set to the number
of bytes already consumed and the next call to
<a class="reference internal" href="#c.skb_seq_read" title="skb_seq_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_seq_read()</span></code></a> will return the remaining part of the block.</p>
<dl class="simple">
<dt>Note 1: The size of each block of data returned can be arbitrary,</dt><dd><p>this limitation is the cost for zerocopy sequential
reads of potentially non linear data.</p>
</dd>
<dt>Note 2: Fragment lists within fragments are not implemented</dt><dd><p>at the moment, state-&gt;root_skb could be replaced with
a stack for this purpose.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_abort_seq_read">
void <code class="sig-name descname">skb_abort_seq_read</code><span class="sig-paren">(</span>struct skb_seq_state *<em> st</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_abort_seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Abort a sequential read of skb data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skb_seq_state</span> <span class="pre">*</span> <span class="pre">st</span></code></dt><dd><p>state variable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called if <a class="reference internal" href="#c.skb_seq_read" title="skb_seq_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_seq_read()</span></code></a> was not called until it
returned 0.</p>
<dl class="function">
<dt id="c.skb_find_text">
unsigned int <code class="sig-name descname">skb_find_text</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> from</em>, unsigned int<em> to</em>, struct ts_config *<em> config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_find_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a text pattern in skb data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the buffer to look in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">from</span></code></dt><dd><p>search offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">to</span></code></dt><dd><p>search limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt><dd><p>textsearch configuration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds a pattern in the skb data according to the specified
textsearch configuration. Use <a class="reference internal" href="../core-api/kernel-api.html#c.textsearch_next" title="textsearch_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_next()</span></code></a> to retrieve
subsequent occurrences of the pattern. Returns the offset
to the first occurrence or UINT_MAX if no match was found.</p>
<dl class="function">
<dt id="c.skb_pull_rcsum">
void * <code class="sig-name descname">skb_pull_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pull_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>pull skb and update receive checksum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data pulled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function performs an skb_pull on the packet and updates
the CHECKSUM_COMPLETE checksum.  It should be used on
receive path processing instead of skb_pull unless you know
that the checksum difference is zero (e.g., a valid IP header)
or you are setting ip_summed to CHECKSUM_NONE.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_segment">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_segment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> head_skb</em>, netdev_features_t<em> features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform protocol segmentation on skb.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">head_skb</span></code></dt><dd><p>buffer to segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt><dd><p>features for the output path (see dev-&gt;features)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function performs segmentation on the given skb.  It returns
a pointer to the first in a list of new skbs for the segments.
In case of error it returns ERR_PTR(err).</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_to_sgvec">
int <code class="sig-name descname">skb_to_sgvec</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct scatterlist *<em> sg</em>, int<em> offset</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_to_sgvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a scatter-gather list from a socket buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>Socket buffer containing the buffers to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt><dd><p>The scatter-gather list to map into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>The offset into the buffer’s contents to start mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of buffer space to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Fill the specified scatter-gather list with mappings/pointers into a
region of the buffer space attached to a socket buffer. Returns either
the number of scatterlist items used, or -EMSGSIZE if the contents
could not fit.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_cow_data">
int <code class="sig-name descname">skb_cow_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> tailbits</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> **<em> trailer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cow_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that a socket buffer’s data buffers are writable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>The socket buffer to check.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">tailbits</span></code></dt><dd><p>Amount of trailing space to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**</span> <span class="pre">trailer</span></code></dt><dd><p>Returned pointer to the skb where the <strong>tailbits</strong> space begins</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Make sure that the data buffers attached to a socket buffer are
writable. If they are not, private copies are made of the data buffers
and the socket buffer is set to use these instead.</p>
<p>If <strong>tailbits</strong> is given, make sure that there is space to write <strong>tailbits</strong>
bytes of data beyond current end of socket buffer.  <strong>trailer</strong> will be
set to point to the skb in which this space begins.</p>
<p>The number of scatterlist elements required to completely map the
COW’d and extended socket buffer will be returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_clone_sk">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_clone_sk</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_clone_sk" title="Permalink to this definition">¶</a></dt>
<dd><p>create clone of skb, and take reference to socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the skb to clone</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a clone of a buffer that holds a reference on
sk_refcnt.  Buffers created via this function are meant to be
returned using sock_queue_err_skb, or free via kfree_skb.</p>
<p>When passing buffers allocated with this function to sock_queue_err_skb
it is necessary to wrap the call with sock_hold/sock_put in order to
prevent the socket from being released prior to being enqueued on
the sk_error_queue.</p>
<dl class="function">
<dt id="c.skb_partial_csum_set">
bool <code class="sig-name descname">skb_partial_csum_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, u16<em> start</em>, u16<em> off</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_partial_csum_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set up and verify partial csum values for packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the skb to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">start</span></code></dt><dd><p>the number of bytes after skb-&gt;data to start checksumming.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">off</span></code></dt><dd><p>the offset from start to place the checksum.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For untrusted partially-checksummed packets, we need to make sure the values
for skb-&gt;csum_start and skb-&gt;csum_offset are valid so we don’t oops.</p>
<p>This function checks and sets those values and skb-&gt;ip_summed: if this
returns false you should drop the packet.</p>
<dl class="function">
<dt id="c.skb_checksum_setup">
int <code class="sig-name descname">skb_checksum_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, bool<em> recalculate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>set up partial checksum offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the skb to set up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">recalculate</span></code></dt><dd><p>if true the pseudo-header checksum will be recalculated</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_checksum_trimmed">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_checksum_trimmed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> transport_len</em>, __sum16(*skb_chkf) (struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_trimmed" title="Permalink to this definition">¶</a></dt>
<dd><p>validate checksum of an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the skb to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">transport_len</span></code></dt><dd><p>the data length beyond the network header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__sum16(*)(struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb)</span> <span class="pre">skb_chkf</span></code></dt><dd><p>checksum function to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Applies the given checksum function skb_chkf to the provided skb.
Returns a checked and maybe trimmed skb. Returns NULL on error.</p>
<p>If the skb has data beyond the given transport length, then a
trimmed &amp; cloned skb is checked and returned.</p>
<p>Caller needs to set the skb transport header and free any returned skb if it
differs from the provided skb.</p>
<dl class="function">
<dt id="c.skb_try_coalesce">
bool <code class="sig-name descname">skb_try_coalesce</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> to</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> from</em>, bool *<em> fragstolen</em>, int *<em> delta_truesize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_try_coalesce" title="Permalink to this definition">¶</a></dt>
<dd><p>try to merge skb to prior one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">to</span></code></dt><dd><p>prior buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">from</span></code></dt><dd><p>buffer to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">fragstolen</span></code></dt><dd><p>pointer to boolean</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">delta_truesize</span></code></dt><dd><p>how much more was allocated than was requested</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_scrub_packet">
void <code class="sig-name descname">skb_scrub_packet</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, bool<em> xnet</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_scrub_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>scrub an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to clean</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">xnet</span></code></dt><dd><p>packet is crossing netns</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>skb_scrub_packet can be used after encapsulating or decapsulting a packet
into/from a tunnel. Some information have to be cleared during these
operations.
skb_scrub_packet can also be used to clean a skb before injecting it in
another namespace (<strong>xnet</strong> == true). We have to clear all information in the
skb that could impact namespace isolation.</p>
<dl class="function">
<dt id="c.skb_gso_validate_network_len">
bool <code class="sig-name descname">skb_gso_validate_network_len</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> mtu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_gso_validate_network_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Will a split GSO skb fit into a given MTU?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>GSO skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mtu</span></code></dt><dd><p>MTU to validate against</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>skb_gso_validate_network_len validates if a given skb will fit a
wanted MTU once split. It considers L3 headers, L4 headers, and the
payload.</p>
<dl class="function">
<dt id="c.skb_gso_validate_mac_len">
bool <code class="sig-name descname">skb_gso_validate_mac_len</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_gso_validate_mac_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Will a split GSO skb fit in a given length?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>GSO skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length to validate against</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>skb_gso_validate_mac_len validates if a given skb will fit a wanted
length once split, including L2, L3 and L4 headers and the payload.</p>
<dl class="function">
<dt id="c.skb_mpls_push">
int <code class="sig-name descname">skb_mpls_push</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, __be32<em> mpls_lse</em>, __be16<em> mpls_proto</em>, int<em> mac_len</em>, bool<em> ethernet</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_mpls_push" title="Permalink to this definition">¶</a></dt>
<dd><p>push a new MPLS header after mac_len bytes from start of the packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">mpls_lse</span></code></dt><dd><p>MPLS label stack entry to push</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be16</span> <span class="pre">mpls_proto</span></code></dt><dd><p>ethertype of the new MPLS header (expects 0x8847 or 0x8848)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mac_len</span></code></dt><dd><p>length of the MAC header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">ethernet</span></code></dt><dd><p>flag to indicate if the resulting packet after skb_mpls_push is
ethernet</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expects skb-&gt;data at mac header.</p>
<p>Returns 0 on success, -errno otherwise.</p>
<dl class="function">
<dt id="c.skb_mpls_pop">
int <code class="sig-name descname">skb_mpls_pop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, __be16<em> next_proto</em>, int<em> mac_len</em>, bool<em> ethernet</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_mpls_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>pop the outermost MPLS header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be16</span> <span class="pre">next_proto</span></code></dt><dd><p>ethertype of header after popped MPLS header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mac_len</span></code></dt><dd><p>length of the MAC header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">ethernet</span></code></dt><dd><p>flag to indicate if the packet is ethernet</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expects skb-&gt;data at mac header.</p>
<p>Returns 0 on success, -errno otherwise.</p>
<dl class="function">
<dt id="c.skb_mpls_update_lse">
int <code class="sig-name descname">skb_mpls_update_lse</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, __be32<em> mpls_lse</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_mpls_update_lse" title="Permalink to this definition">¶</a></dt>
<dd><p>modify outermost MPLS header and update csum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">mpls_lse</span></code></dt><dd><p>new MPLS label stack entry to update to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expects skb-&gt;data at mac header.</p>
<p>Returns 0 on success, -errno otherwise.</p>
<dl class="function">
<dt id="c.skb_mpls_dec_ttl">
int <code class="sig-name descname">skb_mpls_dec_ttl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_mpls_dec_ttl" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement the TTL of the outermost MPLS header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expects skb-&gt;data at mac header.</p>
<p>Returns 0 on success, -errno otherwise.</p>
<dl class="function">
<dt id="c.alloc_skb_with_frags">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">alloc_skb_with_frags</code><span class="sig-paren">(</span>unsigned long<em> header_len</em>, unsigned long<em> data_len</em>, int<em> max_page_order</em>, int *<em> errcode</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_skb_with_frags" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate skb with page frags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">header_len</span></code></dt><dd><p>size of linear part</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">data_len</span></code></dt><dd><p>needed length in frags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_page_order</span></code></dt><dd><p>max page order desired.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">errcode</span></code></dt><dd><p>pointer to error code if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used to allocate a paged skb, given a maximal order for frags.</p>
<dl class="function">
<dt id="c.skb_ext_add">
void * <code class="sig-name descname">skb_ext_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, enum skb_ext_id<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_ext_add" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate space for given extension, COW if needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">skb_ext_id</span> <span class="pre">id</span></code></dt><dd><p>extension to allocate space for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates enough space for the given extension.
If the extension is already present, a pointer to that extension
is returned.</p>
<p>If the skb was cloned, COW applies and the returned memory can be
modified without changing the extension space of clones buffers.</p>
<p>Returns pointer to the extension or NULL on allocation failure.</p>
<dl class="function">
<dt id="c.sk_ns_capable">
bool <code class="sig-name descname">sk_ns_capable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, struct user_namespace *<em> user_ns</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_ns_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>General socket capability test</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>Socket to use a capability on or through</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*</span> <span class="pre">user_ns</span></code></dt><dd><p>The user namespace of the capability to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>The capability to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test to see if the opener of the socket had when the socket was
created and the current process has the capability <strong>cap</strong> in the user
namespace <strong>user_ns</strong>.</p>
<dl class="function">
<dt id="c.sk_capable">
bool <code class="sig-name descname">sk_capable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>Socket global capability test</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>Socket to use a capability on or through</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>The global capability to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test to see if the opener of the socket had when the socket was
created and the current process has the capability <strong>cap</strong> in all user
namespaces.</p>
<dl class="function">
<dt id="c.sk_net_capable">
bool <code class="sig-name descname">sk_net_capable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_net_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>Network namespace socket capability test</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>Socket to use a capability on or through</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>The capability to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test to see if the opener of the socket had when the socket was created
and the current process has the capability <strong>cap</strong> over the network namespace
the socket is a member of.</p>
<dl class="function">
<dt id="c.sk_set_memalloc">
void <code class="sig-name descname">sk_set_memalloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_set_memalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>sets <code class="docutils literal notranslate"><span class="pre">SOCK_MEMALLOC</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket to set it on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set <code class="docutils literal notranslate"><span class="pre">SOCK_MEMALLOC</span></code> on a socket for access to emergency reserves.
It’s the responsibility of the admin to adjust min_free_kbytes
to meet the requirements</p>
<dl class="function">
<dt id="c.sk_alloc">
struct <a class="reference internal" href="#c.sock" title="sock">sock</a> * <code class="sig-name descname">sk_alloc</code><span class="sig-paren">(</span>struct net *<em> net</em>, int<em> family</em>, gfp_t<em> priority</em>, struct proto *<em> prot</em>, int<em> kern</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>All socket objects are allocated here</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt><dd><p>for allocation (<code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>, <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">proto</span> <span class="pre">*</span> <span class="pre">prot</span></code></dt><dd><p>struct proto associated with this new sock instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kern</span></code></dt><dd><p>is this to be a kernel socket?</p>
</dd>
</dl>
<dl class="function">
<dt id="c.sk_clone_lock">
struct <a class="reference internal" href="#c.sock" title="sock">sock</a> * <code class="sig-name descname">sk_clone_lock</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, const gfp_t<em> priority</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_clone_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>clone a socket, and lock its clone</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>the socket to clone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt><dd><p>for allocation (<code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>, <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>, etc)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Caller must unlock socket even in error path (bh_unlock_sock(newsk))</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_page_frag_refill">
bool <code class="sig-name descname">skb_page_frag_refill</code><span class="sig-paren">(</span>unsigned int<em> sz</em>, struct page_frag *<em> pfrag</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_page_frag_refill" title="Permalink to this definition">¶</a></dt>
<dd><p>check that a page_frag contains enough room</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz</span></code></dt><dd><p>minimum size of the fragment we want to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_frag</span> <span class="pre">*</span> <span class="pre">pfrag</span></code></dt><dd><p>pointer to page_frag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>priority for memory allocation</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>While this allocator tries to use high order pages, there is
no guarantee that allocations succeed. Therefore, <strong>sz</strong> MUST be
less or equal than PAGE_SIZE.</p>
<dl class="function">
<dt id="c.sk_wait_data">
int <code class="sig-name descname">sk_wait_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, long *<em> timeo</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_wait_data" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for data to arrive at sk_receive_queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>sock to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">timeo</span></code></dt><dd><p>for how long</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>last skb seen on sk_receive_queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Now socket state including sk-&gt;sk_err is changed only under lock,
hence we may omit checks after joining wait queue.
We check receive queue before schedule() only as optimization;
it is very likely that release_sock() added new data.</p>
<dl class="function">
<dt id="c.__sk_mem_raise_allocated">
int <code class="sig-name descname">__sk_mem_raise_allocated</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, int<em> size</em>, int<em> amt</em>, int<em> kind</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sk_mem_raise_allocated" title="Permalink to this definition">¶</a></dt>
<dd><p>increase memory_allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>memory size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">amt</span></code></dt><dd><p>pages to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kind</span></code></dt><dd><p>allocation type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Similar to <a class="reference internal" href="#c.__sk_mem_schedule" title="__sk_mem_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">__sk_mem_schedule()</span></code></a>, but does not update sk_forward_alloc</p>
</div></blockquote>
<dl class="function">
<dt id="c.__sk_mem_schedule">
int <code class="sig-name descname">__sk_mem_schedule</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, int<em> size</em>, int<em> kind</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sk_mem_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>increase sk_forward_alloc and memory_allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>memory size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kind</span></code></dt><dd><p>allocation type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If kind is SK_MEM_SEND, it means wmem allocation. Otherwise it means
rmem allocation. This function assumes that protocols which have
memory_pressure use sk_wmem_queued as write buffer accounting.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__sk_mem_reduce_allocated">
void <code class="sig-name descname">__sk_mem_reduce_allocated</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, int<em> amount</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sk_mem_reduce_allocated" title="Permalink to this definition">¶</a></dt>
<dd><p>reclaim memory_allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">amount</span></code></dt><dd><p>number of quanta</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Similar to <a class="reference internal" href="#c.__sk_mem_reclaim" title="__sk_mem_reclaim"><code class="xref c c-func docutils literal notranslate"><span class="pre">__sk_mem_reclaim()</span></code></a>, but does not update sk_forward_alloc</p>
</div></blockquote>
<dl class="function">
<dt id="c.__sk_mem_reclaim">
void <code class="sig-name descname">__sk_mem_reclaim</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, int<em> amount</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sk_mem_reclaim" title="Permalink to this definition">¶</a></dt>
<dd><p>reclaim sk_forward_alloc and memory_allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">amount</span></code></dt><dd><p>number of bytes (rounded down to a SK_MEM_QUANTUM multiple)</p>
</dd>
</dl>
<dl class="function">
<dt id="c.lock_sock_fast">
bool <code class="sig-name descname">lock_sock_fast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_sock_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>fast version of lock_sock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This version should be used for very small section, where process wont block
return false if fast path is taken:</p>
<blockquote>
<div><p>sk_lock.slock locked, owned = 0, BH disabled</p>
</div></blockquote>
<p>return true if slow path is taken:</p>
<blockquote>
<div><p>sk_lock.slock unlocked, owned = 1, BH enabled</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_try_recv_datagram">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__skb_try_recv_datagram</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, struct sk_buff_head *<em> queue</em>, unsigned int<em> flags</em>, int *<em> off</em>, int *<em> err</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> **<em> last</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_try_recv_datagram" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a datagram skbuff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">queue</span></code></dt><dd><p>socket queue from which to receive</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>MSG_ flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">off</span></code></dt><dd><p>an offset in bytes to peek skb from. Returns an offset
within an skb where data actually starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">err</span></code></dt><dd><p>error code returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**</span> <span class="pre">last</span></code></dt><dd><p>set to last peeked message to inform the wait function
what to look for when peeking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Get a datagram skbuff, understands the peeking, nonblocking wakeups
and possible races. This replaces identical code in packet, raw and
udp, as well as the IPX AX.25 and Appletalk. It also finally fixes
the long standing peek and read race for datagram sockets. If you
alter this routine remember it must be re-entrant.</p>
<p>This function will lock the socket if a skb is returned, so
the caller needs to unlock the socket in that case (usually by
calling skb_free_datagram). Returns NULL with <strong>err</strong> set to
-EAGAIN if no data was available or to some other value if an
error was detected.</p>
<ul class="simple">
<li><p>It does not lock socket since today. This function is</p></li>
<li><p>free of race conditions. This measure should/can improve</p></li>
<li><p>significantly datagram socket latencies at high loads,</p></li>
<li><p>when data copying to user space takes lots of time.</p></li>
<li><p>(BTW I’ve just killed the last cli() in IP/IPv6/core/netlink/packet</p></li>
<li><ol class="arabic simple" start="8">
<li><p>Great win.)</p></li>
</ol>
</li>
<li><p>–ANK (980729)</p></li>
</ul>
<p>The order of the tests when we find no data waiting are specified
quite explicitly by POSIX 1003.1g, don’t change them without having
the standard around please.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_kill_datagram">
int <code class="sig-name descname">skb_kill_datagram</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_kill_datagram" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a datagram skbuff forcibly</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>datagram skbuff</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>MSG_ flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function frees a datagram skbuff that was received by
skb_recv_datagram.  The flags argument must match the one
used for skb_recv_datagram.</p>
<p>If the MSG_PEEK flag is set, and the packet is still on the
receive queue of the socket, it will be taken off the queue
before it is freed.</p>
<p>This function currently only disables BH when acquiring the
sk_receive_queue lock.  Therefore it must not be used in a
context where that lock is acquired in an IRQ context.</p>
<p>It returns 0 if the packet was removed by us.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy_and_hash_datagram_iter">
int <code class="sig-name descname">skb_copy_and_hash_datagram_iter</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> offset</em>, struct iov_iter *<em> to</em>, int<em> len</em>, struct ahash_request *<em> hash</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_and_hash_datagram_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy datagram to an iovec iterator and update a hash.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in the buffer to start copying from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">to</span></code></dt><dd><p>iovec iterator to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to copy from buffer to iovec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ahash_request</span> <span class="pre">*</span> <span class="pre">hash</span></code></dt><dd><p>hash request to update</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_copy_datagram_iter">
int <code class="sig-name descname">skb_copy_datagram_iter</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> offset</em>, struct iov_iter *<em> to</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_datagram_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a datagram to an iovec iterator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in the buffer to start copying from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">to</span></code></dt><dd><p>iovec iterator to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to copy from buffer to iovec</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_copy_datagram_from_iter">
int <code class="sig-name descname">skb_copy_datagram_from_iter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> offset</em>, struct iov_iter *<em> from</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_datagram_from_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a datagram from an iov_iter.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in the buffer to start copying to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">from</span></code></dt><dd><p>the copy source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to copy to buffer from iovec</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 or -EFAULT.</p>
</div></blockquote>
<dl class="function">
<dt id="c.zerocopy_sg_from_iter">
int <code class="sig-name descname">zerocopy_sg_from_iter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct iov_iter *<em> from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.zerocopy_sg_from_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a zerocopy datagram from an iov_iter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">from</span></code></dt><dd><p>the source to copy from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The function will first copy up to headlen, and then pin the userspace
pages and build frags through them.</p>
<p>Returns 0, -EFAULT or -EMSGSIZE.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy_and_csum_datagram_msg">
int <code class="sig-name descname">skb_copy_and_csum_datagram_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> hlen</em>, struct msghdr *<em> msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_and_csum_datagram_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy and checksum skb to user iovec.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>skbuff</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hlen</span></code></dt><dd><p>hardware length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>destination</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Caller _must_ check that skb will fit to this iovec.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0       - success.</dt><dd><p>-EINVAL - checksum failure.
-EFAULT - fault during copy.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.datagram_poll">
__poll_t <code class="sig-name descname">datagram_poll</code><span class="sig-paren">(</span>struct file *<em> file</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em> sock</em>, poll_table *<em> wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.datagram_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>generic datagram poll</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>file struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt><dd><p>poll table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Datagram poll: Again totally generic. This also handles
sequenced packet sockets providing the socket receive queue
is only ever holding data ready to receive.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>when you <em>don’t</em> use this routine for this protocol,</dt><dd><p>and you use a different write policy from sock_writeable()
then please supply your own write_space callback.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.sk_stream_wait_connect">
int <code class="sig-name descname">sk_stream_wait_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, long *<em> timeo_p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_stream_wait_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for a socket to get into the connected state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>sock to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">timeo_p</span></code></dt><dd><p>for how long to wait</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called with the socket locked.</p>
<dl class="function">
<dt id="c.sk_stream_wait_memory">
int <code class="sig-name descname">sk_stream_wait_memory</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, long *<em> timeo_p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_stream_wait_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for more memory for a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>socket to wait for memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">timeo_p</span></code></dt><dd><p>for how long</p>
</dd>
</dl>
</div>
<div class="section" id="socket-filter">
<h3>Socket Filter<a class="headerlink" href="#socket-filter" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.sk_filter_trim_cap">
int <code class="sig-name descname">sk_filter_trim_cap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_filter_trim_cap" title="Permalink to this definition">¶</a></dt>
<dd><p>run a packet through a socket filter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>sock associated with <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to filter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>limit on how short the eBPF program may trim the packet</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Run the eBPF program and then cut skb-&gt;data to correct size returned by
the program. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller
than pkt_len we keep whole skb-&gt;data. This is the socket level
wrapper to BPF_PROG_RUN. It returns 0 if the packet should
be accepted or -EPERM if the packet should be tossed.</p>
<dl class="function">
<dt id="c.bpf_prog_create">
int <code class="sig-name descname">bpf_prog_create</code><span class="sig-paren">(</span>struct bpf_prog **<em> pfp</em>, struct sock_fprog_kern *<em> fprog</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bpf_prog_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an unattached filter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_prog</span> <span class="pre">**</span> <span class="pre">pfp</span></code></dt><dd><p>the unattached filter that is created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock_fprog_kern</span> <span class="pre">*</span> <span class="pre">fprog</span></code></dt><dd><p>the filter program</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a filter independent of any socket. We first run some
sanity checks on it to make sure it does not explode on us later.
If an error occurs or there is insufficient memory for the filter
a negative errno code is returned. On success the return is zero.</p>
<dl class="function">
<dt id="c.bpf_prog_create_from_user">
int <code class="sig-name descname">bpf_prog_create_from_user</code><span class="sig-paren">(</span>struct bpf_prog **<em> pfp</em>, struct sock_fprog *<em> fprog</em>, bpf_aux_classic_check_t<em> trans</em>, bool<em> save_orig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bpf_prog_create_from_user" title="Permalink to this definition">¶</a></dt>
<dd><p>create an unattached filter from user buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_prog</span> <span class="pre">**</span> <span class="pre">pfp</span></code></dt><dd><p>the unattached filter that is created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock_fprog</span> <span class="pre">*</span> <span class="pre">fprog</span></code></dt><dd><p>the filter program</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpf_aux_classic_check_t</span> <span class="pre">trans</span></code></dt><dd><p>post-classic verifier transformation handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">save_orig</span></code></dt><dd><p>save classic BPF program</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function effectively does the same as <a class="reference internal" href="#c.bpf_prog_create" title="bpf_prog_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">bpf_prog_create()</span></code></a>, only
that it builds up its insns buffer from user space provided buffer.
It also allows for passing a bpf_aux_classic_check_t handler.</p>
<dl class="function">
<dt id="c.sk_attach_filter">
int <code class="sig-name descname">sk_attach_filter</code><span class="sig-paren">(</span>struct sock_fprog *<em> fprog</em>, struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_attach_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a socket filter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock_fprog</span> <span class="pre">*</span> <span class="pre">fprog</span></code></dt><dd><p>the filter program</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>the socket to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attach the user’s filter code. We first run some sanity checks on
it to make sure it does not explode on us later. If an error
occurs or there is insufficient memory for the filter a negative
errno code is returned. On success the return is zero.</p>
</div>
<div class="section" id="generic-network-statistics">
<h3>Generic Network Statistics<a class="headerlink" href="#generic-network-statistics" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.gnet_stats_basic">
struct <code class="sig-name descname">gnet_stats_basic</code><a class="headerlink" href="#c.gnet_stats_basic" title="Permalink to this definition">¶</a></dt>
<dd><p>byte/packet throughput statistics</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gnet_stats_basic {
  __u64 bytes;
  __u32 packets;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code></dt><dd><p>number of seen bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">packets</span></code></dt><dd><p>number of seen packets</p>
</dd>
</dl>
<dl class="type">
<dt id="c.gnet_stats_rate_est">
struct <code class="sig-name descname">gnet_stats_rate_est</code><a class="headerlink" href="#c.gnet_stats_rate_est" title="Permalink to this definition">¶</a></dt>
<dd><p>rate estimator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gnet_stats_rate_est {
  __u32 bps;
  __u32 pps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bps</span></code></dt><dd><p>current byte rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps</span></code></dt><dd><p>current packet rate</p>
</dd>
</dl>
<dl class="type">
<dt id="c.gnet_stats_rate_est64">
struct <code class="sig-name descname">gnet_stats_rate_est64</code><a class="headerlink" href="#c.gnet_stats_rate_est64" title="Permalink to this definition">¶</a></dt>
<dd><p>rate estimator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gnet_stats_rate_est64 {
  __u64 bps;
  __u64 pps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bps</span></code></dt><dd><p>current byte rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps</span></code></dt><dd><p>current packet rate</p>
</dd>
</dl>
<dl class="type">
<dt id="c.gnet_stats_queue">
struct <code class="sig-name descname">gnet_stats_queue</code><a class="headerlink" href="#c.gnet_stats_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>queuing statistics</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gnet_stats_queue {
  __u32 qlen;
  __u32 backlog;
  __u32 drops;
  __u32 requeues;
  __u32 overlimits;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qlen</span></code></dt><dd><p>queue length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlog</span></code></dt><dd><p>backlog size of queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drops</span></code></dt><dd><p>number of dropped packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">requeues</span></code></dt><dd><p>number of requeues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">overlimits</span></code></dt><dd><p>number of enqueues over the limit</p>
</dd>
</dl>
<dl class="type">
<dt id="c.gnet_estimator">
struct <code class="sig-name descname">gnet_estimator</code><a class="headerlink" href="#c.gnet_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>rate estimator configuration</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gnet_estimator {
  signed char     interval;
  unsigned char   ewma_log;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">interval</span></code></dt><dd><p>sampling period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ewma_log</span></code></dt><dd><p>the log of measurement window weight</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gnet_stats_start_copy_compat">
int <code class="sig-name descname">gnet_stats_start_copy_compat</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> type</em>, int<em> tc_stats_type</em>, int<em> xstats_type</em>, spinlock_t *<em> lock</em>, struct gnet_dump *<em> d</em>, int<em> padattr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_start_copy_compat" title="Permalink to this definition">¶</a></dt>
<dd><p>start dumping procedure in compatibility mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>socket buffer to put statistics TLVs into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>TLV type for top level statistic TLV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">tc_stats_type</span></code></dt><dd><p>TLV type for backward compatibility struct tc_stats TLV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">xstats_type</span></code></dt><dd><p>TLV type for backward compatibility xstats TLV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt><dd><p>statistics lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">padattr</span></code></dt><dd><p>padding attribute</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the dumping handle, grabs the statistic lock and appends
an empty TLV header to the socket buffer for use a container for all
other statistic TLVS.</p>
<p>The dumping handle is marked to be in backward compatibility mode telling
all gnet_stats_copy_XXX() functions to fill a local copy of struct tc_stats.</p>
<p>Returns 0 on success or -1 if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_start_copy">
int <code class="sig-name descname">gnet_stats_start_copy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, int<em> type</em>, spinlock_t *<em> lock</em>, struct gnet_dump *<em> d</em>, int<em> padattr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_start_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>start dumping procedure in compatibility mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>socket buffer to put statistics TLVs into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>TLV type for top level statistic TLV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt><dd><p>statistics lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">padattr</span></code></dt><dd><p>padding attribute</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the dumping handle, grabs the statistic lock and appends
an empty TLV header to the socket buffer for use a container for all
other statistic TLVS.</p>
<p>Returns 0 on success or -1 if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_copy_basic">
int <code class="sig-name descname">gnet_stats_copy_basic</code><span class="sig-paren">(</span>const seqcount_t *<em> running</em>, struct gnet_dump *<em> d</em>, struct gnet_stats_basic_cpu __percpu *<em> cpu</em>, struct gnet_stats_basic_packed *<em> b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_basic" title="Permalink to this definition">¶</a></dt>
<dd><p>copy basic statistics into statistic TLV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">seqcount_t</span> <span class="pre">*</span> <span class="pre">running</span></code></dt><dd><p>seqcount_t pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_cpu</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">cpu</span></code></dt><dd><p>copy statistic per cpu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_packed</span> <span class="pre">*</span> <span class="pre">b</span></code></dt><dd><p>basic statistics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the basic statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy()</span></code></a>.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_copy_basic_hw">
int <code class="sig-name descname">gnet_stats_copy_basic_hw</code><span class="sig-paren">(</span>const seqcount_t *<em> running</em>, struct gnet_dump *<em> d</em>, struct gnet_stats_basic_cpu __percpu *<em> cpu</em>, struct gnet_stats_basic_packed *<em> b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_basic_hw" title="Permalink to this definition">¶</a></dt>
<dd><p>copy basic hw statistics into statistic TLV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">seqcount_t</span> <span class="pre">*</span> <span class="pre">running</span></code></dt><dd><p>seqcount_t pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_cpu</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">cpu</span></code></dt><dd><p>copy statistic per cpu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_packed</span> <span class="pre">*</span> <span class="pre">b</span></code></dt><dd><p>basic statistics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the basic statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy()</span></code></a>.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_copy_rate_est">
int <code class="sig-name descname">gnet_stats_copy_rate_est</code><span class="sig-paren">(</span>struct gnet_dump *<em> d</em>, struct net_rate_estimator __rcu **<em> rate_est</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_rate_est" title="Permalink to this definition">¶</a></dt>
<dd><p>copy rate estimator statistics into statistics TLV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**</span> <span class="pre">rate_est</span></code></dt><dd><p>rate estimator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the rate estimator statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy()</span></code></a>.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_copy_queue">
int <code class="sig-name descname">gnet_stats_copy_queue</code><span class="sig-paren">(</span>struct gnet_dump *<em> d</em>, struct <a class="reference internal" href="#c.gnet_stats_queue" title="gnet_stats_queue">gnet_stats_queue</a> __percpu *<em> cpu_q</em>, struct <a class="reference internal" href="#c.gnet_stats_queue" title="gnet_stats_queue">gnet_stats_queue</a> *<em> q</em>, __u32<em> qlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>copy queue statistics into statistics TLV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_queue</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">cpu_q</span></code></dt><dd><p>per cpu queue statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>queue statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u32</span> <span class="pre">qlen</span></code></dt><dd><p>queue length statistics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the queue statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy()</span></code></a>. Using per cpu queue statistics if
they are available.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_copy_app">
int <code class="sig-name descname">gnet_stats_copy_app</code><span class="sig-paren">(</span>struct gnet_dump *<em> d</em>, void *<em> st</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_app" title="Permalink to this definition">¶</a></dt>
<dd><p>copy application specific statistics into statistics TLV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">st</span></code></dt><dd><p>application specific statistics data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the application specific statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy()</span></code></a> and remembers the data for XSTATS if the dumping
handle is in backward compatibility mode.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_finish_copy">
int <code class="sig-name descname">gnet_stats_finish_copy</code><span class="sig-paren">(</span>struct gnet_dump *<em> d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_finish_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>finish dumping procedure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt><dd><p>dumping handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Corrects the length of the top level TLV to include all TLVs added
by gnet_stats_copy_XXX() calls. Adds the backward compatibility TLVs
if <a class="reference internal" href="#c.gnet_stats_start_copy_compat" title="gnet_stats_start_copy_compat"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy_compat()</span></code></a> was used and releases the statistics
lock.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gen_new_estimator">
int <code class="sig-name descname">gen_new_estimator</code><span class="sig-paren">(</span>struct gnet_stats_basic_packed *<em> bstats</em>, struct gnet_stats_basic_cpu __percpu *<em> cpu_bstats</em>, struct net_rate_estimator __rcu **<em> rate_est</em>, spinlock_t *<em> lock</em>, seqcount_t *<em> running</em>, struct nlattr *<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_new_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new rate estimator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_packed</span> <span class="pre">*</span> <span class="pre">bstats</span></code></dt><dd><p>basic statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_cpu</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">cpu_bstats</span></code></dt><dd><p>bstats per cpu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**</span> <span class="pre">rate_est</span></code></dt><dd><p>rate estimator statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt><dd><p>lock for statistics and control path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seqcount_t</span> <span class="pre">*</span> <span class="pre">running</span></code></dt><dd><p>qdisc running seqcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*</span> <span class="pre">opt</span></code></dt><dd><p>rate estimator configuration TLV</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new rate estimator with <code class="xref c c-type docutils literal notranslate"><span class="pre">bstats</span></code> as source and <code class="xref c c-type docutils literal notranslate"><span class="pre">rate_est</span></code>
as destination. A new timer with the interval specified in the
configuration TLV is created. Upon each interval, the latest statistics
will be read from <code class="xref c c-type docutils literal notranslate"><span class="pre">bstats</span></code> and the estimated rate will be stored in
<code class="xref c c-type docutils literal notranslate"><span class="pre">rate_est</span></code> with the statistics lock grabbed during this period.</p>
<p>Returns 0 on success or a negative error code.</p>
<dl class="function">
<dt id="c.gen_kill_estimator">
void <code class="sig-name descname">gen_kill_estimator</code><span class="sig-paren">(</span>struct net_rate_estimator __rcu **<em> rate_est</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_kill_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a rate estimator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**</span> <span class="pre">rate_est</span></code></dt><dd><p>rate estimator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the rate estimator.</p>
<dl class="function">
<dt id="c.gen_replace_estimator">
int <code class="sig-name descname">gen_replace_estimator</code><span class="sig-paren">(</span>struct gnet_stats_basic_packed *<em> bstats</em>, struct gnet_stats_basic_cpu __percpu *<em> cpu_bstats</em>, struct net_rate_estimator __rcu **<em> rate_est</em>, spinlock_t *<em> lock</em>, seqcount_t *<em> running</em>, struct nlattr *<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_replace_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>replace rate estimator configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_packed</span> <span class="pre">*</span> <span class="pre">bstats</span></code></dt><dd><p>basic statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_cpu</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">cpu_bstats</span></code></dt><dd><p>bstats per cpu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**</span> <span class="pre">rate_est</span></code></dt><dd><p>rate estimator statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt><dd><p>lock for statistics and control path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seqcount_t</span> <span class="pre">*</span> <span class="pre">running</span></code></dt><dd><p>qdisc running seqcount (might be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*</span> <span class="pre">opt</span></code></dt><dd><p>rate estimator configuration TLV</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replaces the configuration of a rate estimator by calling
<a class="reference internal" href="#c.gen_kill_estimator" title="gen_kill_estimator"><code class="xref c c-func docutils literal notranslate"><span class="pre">gen_kill_estimator()</span></code></a> and <a class="reference internal" href="#c.gen_new_estimator" title="gen_new_estimator"><code class="xref c c-func docutils literal notranslate"><span class="pre">gen_new_estimator()</span></code></a>.</p>
<p>Returns 0 on success or a negative error code.</p>
<dl class="function">
<dt id="c.gen_estimator_active">
bool <code class="sig-name descname">gen_estimator_active</code><span class="sig-paren">(</span>struct net_rate_estimator __rcu **<em> rate_est</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_estimator_active" title="Permalink to this definition">¶</a></dt>
<dd><p>test if estimator is currently in use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**</span> <span class="pre">rate_est</span></code></dt><dd><p>rate estimator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if estimator is active, and false if not.</p>
</div>
<div class="section" id="sun-rpc-subsystem">
<h3>SUN RPC subsystem<a class="headerlink" href="#sun-rpc-subsystem" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.xdr_encode_opaque_fixed">
__be32 * <code class="sig-name descname">xdr_encode_opaque_fixed</code><span class="sig-paren">(</span>__be32 *<em> p</em>, const void *<em> ptr</em>, unsigned int<em> nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_encode_opaque_fixed" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode fixed length opaque data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>pointer to current position in XDR buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt><dd><p>pointer to data to encode (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt><dd><p>size of data.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the array of data of length nbytes at ptr to the XDR buffer
at position p, then align to the next 32-bit boundary by padding
with zero bytes (see RFC1832).</p>
<p><strong>Note</strong></p>
<p>if ptr is NULL, only the padding is performed.</p>
<p>Returns the updated current XDR buffer position</p>
<dl class="function">
<dt id="c.xdr_encode_opaque">
__be32 * <code class="sig-name descname">xdr_encode_opaque</code><span class="sig-paren">(</span>__be32 *<em> p</em>, const void *<em> ptr</em>, unsigned int<em> nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_encode_opaque" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode variable length opaque data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>pointer to current position in XDR buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt><dd><p>pointer to data to encode (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt><dd><p>size of data.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated current XDR buffer position</p>
<dl class="function">
<dt id="c.xdr_terminate_string">
void <code class="sig-name descname">xdr_terminate_string</code><span class="sig-paren">(</span>struct xdr_buf *<em> buf</em>, const u32<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_terminate_string" title="Permalink to this definition">¶</a></dt>
<dd><p>‘0’-terminate a string residing in an xdr_buf</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>XDR buffer where string resides</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">len</span></code></dt><dd><p>length of string, in bytes</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xdr_inline_pages">
void <code class="sig-name descname">xdr_inline_pages</code><span class="sig-paren">(</span>struct xdr_buf *<em> xdr</em>, unsigned int<em> offset</em>, struct page **<em> pages</em>, unsigned int<em> base</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_inline_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare receive buffer for a large reply</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>xdr_buf into which reply will be placed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>expected offset where data payload will start, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt><dd><p>vector of struct page pointers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>offset in first page where receive should start, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>expected size of the upper layer data payload, in bytes</p>
</dd>
</dl>
<dl class="function">
<dt id="c._copy_from_pages">
void <code class="sig-name descname">_copy_from_pages</code><span class="sig-paren">(</span>char *<em> p</em>, struct page **<em> pages</em>, size_t<em> pgbase</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c._copy_from_pages" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>pointer to destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt><dd><p>array of pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">pgbase</span></code></dt><dd><p>offset of source data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data into an arbitrary memory location from an array of pages
The copy is assumed to be non-overlapping.</p>
<dl class="function">
<dt id="c.xdr_stream_pos">
unsigned int <code class="sig-name descname">xdr_stream_pos</code><span class="sig-paren">(</span>const struct xdr_stream *<em> xdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current offset from the start of the xdr_stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to struct xdr_stream</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xdr_init_encode">
void <code class="sig-name descname">xdr_init_encode</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, struct xdr_buf *<em> buf</em>, __be32 *<em> p</em>, struct rpc_rqst *<em> rqst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_init_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a struct xdr_stream for sending data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>pointer to XDR buffer in which to encode data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>current pointer inside XDR buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*</span> <span class="pre">rqst</span></code></dt><dd><p>pointer to controlling rpc_rqst, for debugging</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>at the moment the RPC client only passes the length of our</dt><dd><p>scratch buffer in the xdr_buf’s header kvec. Previously this
meant we needed to call xdr_adjust_iovec() after encoding the
data. With the new scheme, the xdr_stream manages the details
of the buffer length, and takes care of adjusting the kvec
length for us.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xdr_commit_encode">
void <code class="sig-name descname">xdr_commit_encode</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_commit_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure all data is written to buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We handle encoding across page boundaries by giving the caller a
temporary location to write to, then later copying the data into
place; xdr_commit_encode does that copying.</p>
<p>Normally the caller doesn’t need to call this directly, as the
following xdr_reserve_space will do it.  But an explicit call may be
required at the end of encoding, or any other time when the xdr_buf
data might be read.</p>
<dl class="function">
<dt id="c.xdr_reserve_space">
__be32 * <code class="sig-name descname">xdr_reserve_space</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, size_t<em> nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_reserve_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve buffer space for sending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nbytes</span></code></dt><dd><p>number of bytes to reserve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that we have enough buffer space to encode ‘nbytes’ more
bytes of data. If so, update the total xdr_buf length, and
adjust the length of the current kvec.</p>
<dl class="function">
<dt id="c.xdr_truncate_encode">
void <code class="sig-name descname">xdr_truncate_encode</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_truncate_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate an encode buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>new length of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Truncates the xdr stream, so that xdr-&gt;buf-&gt;len == len,
and xdr-&gt;p points at offset len from the start of the buffer, and
head, tail, and page lengths are adjusted to correspond.</p>
<p>If this means moving xdr-&gt;p to a different buffer, we assume that
that the end pointer should be set to the end of the current page,
except in the case of the head buffer when we assume the head
buffer’s current length represents the end of the available buffer.</p>
<p>This is <em>not</em> safe to use on a buffer that already has inlined page
cache pages (as in a zero-copy server read reply), except for the
simple case of truncating from one position in the tail to another.</p>
<dl class="function">
<dt id="c.xdr_restrict_buflen">
int <code class="sig-name descname">xdr_restrict_buflen</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, int<em> newbuflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_restrict_buflen" title="Permalink to this definition">¶</a></dt>
<dd><p>decrease available buffer space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">newbuflen</span></code></dt><dd><p>new maximum number of bytes available</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adjust our idea of how much space is available in the buffer.
If we’ve already used too much space in the buffer, returns -1.
If the available space is already smaller than newbuflen, returns 0
and does nothing.  Otherwise, adjusts xdr-&gt;buf-&gt;buflen to newbuflen
and ensures xdr-&gt;end is set at most offset newbuflen from the start
of the buffer.</p>
<dl class="function">
<dt id="c.xdr_write_pages">
void <code class="sig-name descname">xdr_write_pages</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, struct page **<em> pages</em>, unsigned int<em> base</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_write_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a list of pages into an XDR buffer for sending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt><dd><p>list of pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>offset of first byte</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data in bytes</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xdr_init_decode">
void <code class="sig-name descname">xdr_init_decode</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, struct xdr_buf *<em> buf</em>, __be32 *<em> p</em>, struct rpc_rqst *<em> rqst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_init_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an xdr_stream for decoding data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>pointer to XDR buffer from which to decode data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>current pointer inside XDR buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*</span> <span class="pre">rqst</span></code></dt><dd><p>pointer to controlling rpc_rqst, for debugging</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xdr_init_decode_pages">
void <code class="sig-name descname">xdr_init_decode_pages</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, struct xdr_buf *<em> buf</em>, struct page **<em> pages</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_init_decode_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an xdr_stream for decoding into pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>pointer to XDR buffer from which to decode data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt><dd><p>list of pages to decode into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length in bytes of buffer in pages</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xdr_set_scratch_buffer">
void <code class="sig-name descname">xdr_set_scratch_buffer</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, void *<em> buf</em>, size_t<em> buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_set_scratch_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a scratch buffer for decoding data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>pointer to an empty buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">buflen</span></code></dt><dd><p>size of ‘buf’</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The scratch buffer is used when decoding from an array of pages.
If an <a class="reference internal" href="#c.xdr_inline_decode" title="xdr_inline_decode"><code class="xref c c-func docutils literal notranslate"><span class="pre">xdr_inline_decode()</span></code></a> call spans across page boundaries, then
we copy the data into the scratch buffer in order to allow linear
access.</p>
<dl class="function">
<dt id="c.xdr_inline_decode">
__be32 * <code class="sig-name descname">xdr_inline_decode</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, size_t<em> nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_inline_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve XDR data to decode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nbytes</span></code></dt><dd><p>number of bytes of data to decode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the input buffer is long enough to enable us to decode
‘nbytes’ more bytes of data starting at the current position.
If so return the current pointer, then update the current
pointer position.</p>
<dl class="function">
<dt id="c.xdr_read_pages">
unsigned int <code class="sig-name descname">xdr_read_pages</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_read_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure page-based XDR data to decode is aligned at current pointer position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes of page data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Moves data beyond the current pointer position from the XDR head[] buffer
into the page list. Any data that lies beyond current position + “len”
bytes is moved into the XDR tail[].</p>
<p>Returns the number of XDR encoded bytes now contained in the pages</p>
<dl class="function">
<dt id="c.xdr_enter_page">
void <code class="sig-name descname">xdr_enter_page</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_enter_page" title="Permalink to this definition">¶</a></dt>
<dd><p>decode data from the XDR page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes of page data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Moves data beyond the current pointer position from the XDR head[] buffer
into the page list. Any data that lies beyond current position + “len”
bytes is moved into the XDR tail[]. The current pointer is then
repositioned at the beginning of the first XDR page.</p>
<dl class="function">
<dt id="c.xdr_buf_subsegment">
int <code class="sig-name descname">xdr_buf_subsegment</code><span class="sig-paren">(</span>struct xdr_buf *<em> buf</em>, struct xdr_buf *<em> subbuf</em>, unsigned int<em> base</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_buf_subsegment" title="Permalink to this definition">¶</a></dt>
<dd><p>set subbuf to a portion of buf</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>an xdr buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">subbuf</span></code></dt><dd><p>the result buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>beginning of range in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of range in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>sets <strong>subbuf</strong> to an xdr buffer representing the portion of <strong>buf</strong> of
length <strong>len</strong> starting at offset <strong>base</strong>.</p>
<p><strong>buf</strong> and <strong>subbuf</strong> may be pointers to the same struct xdr_buf.</p>
<p>Returns -1 if base of length are out of bounds.</p>
<dl class="function">
<dt id="c.xdr_stream_decode_opaque">
ssize_t <code class="sig-name descname">xdr_stream_decode_opaque</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, void *<em> ptr</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_decode_opaque" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode variable length opaque</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt><dd><p>location to store opaque data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of storage buffer <strong>ptr</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return values:</dt><dd><p>On success, returns size of object stored in <strong>*ptr</strong>
<code class="docutils literal notranslate"><span class="pre">-EBADMSG</span></code> on XDR buffer overflow
<code class="docutils literal notranslate"><span class="pre">-EMSGSIZE</span></code> on overflow of storage buffer <strong>ptr</strong></p>
</dd>
</dl>
<dl class="function">
<dt id="c.xdr_stream_decode_opaque_dup">
ssize_t <code class="sig-name descname">xdr_stream_decode_opaque_dup</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, void **<em> ptr</em>, size_t<em> maxlen</em>, gfp_t<em> gfp_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_decode_opaque_dup" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode and duplicate variable length opaque</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">ptr</span></code></dt><dd><p>location to store pointer to opaque data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">maxlen</span></code></dt><dd><p>maximum acceptable object size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_flags</span></code></dt><dd><p>GFP mask to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return values:</dt><dd><p>On success, returns size of object stored in <strong>*ptr</strong>
<code class="docutils literal notranslate"><span class="pre">-EBADMSG</span></code> on XDR buffer overflow
<code class="docutils literal notranslate"><span class="pre">-EMSGSIZE</span></code> if the size of the object would exceed <strong>maxlen</strong>
<code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> on memory allocation failure</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xdr_stream_decode_string">
ssize_t <code class="sig-name descname">xdr_stream_decode_string</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, char *<em> str</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_decode_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode variable length string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt><dd><p>location to store string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of storage buffer <strong>str</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return values:</dt><dd><p>On success, returns length of NUL-terminated string stored in <strong>*str</strong>
<code class="docutils literal notranslate"><span class="pre">-EBADMSG</span></code> on XDR buffer overflow
<code class="docutils literal notranslate"><span class="pre">-EMSGSIZE</span></code> on overflow of storage buffer <strong>str</strong></p>
</dd>
</dl>
<dl class="function">
<dt id="c.xdr_stream_decode_string_dup">
ssize_t <code class="sig-name descname">xdr_stream_decode_string_dup</code><span class="sig-paren">(</span>struct xdr_stream *<em> xdr</em>, char **<em> str</em>, size_t<em> maxlen</em>, gfp_t<em> gfp_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_decode_string_dup" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode and duplicate variable length string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">str</span></code></dt><dd><p>location to store pointer to string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">maxlen</span></code></dt><dd><p>maximum acceptable string length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_flags</span></code></dt><dd><p>GFP mask to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return values:</dt><dd><p>On success, returns length of NUL-terminated string stored in <strong>*ptr</strong>
<code class="docutils literal notranslate"><span class="pre">-EBADMSG</span></code> on XDR buffer overflow
<code class="docutils literal notranslate"><span class="pre">-EMSGSIZE</span></code> if the size of the string would exceed <strong>maxlen</strong>
<code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> on memory allocation failure</p>
</dd>
</dl>
<dl class="function">
<dt id="c.svc_print_addr">
char * <code class="sig-name descname">svc_print_addr</code><span class="sig-paren">(</span>struct svc_rqst *<em> rqstp</em>, char *<em> buf</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_print_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Format rq_addr field for printing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_rqst</span> <span class="pre">*</span> <span class="pre">rqstp</span></code></dt><dd><p>svc_rqst struct containing address to print</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>target buffer for formatted address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of target buffer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.svc_reserve">
void <code class="sig-name descname">svc_reserve</code><span class="sig-paren">(</span>struct svc_rqst *<em> rqstp</em>, int<em> space</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>change the space reserved for the reply to a request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_rqst</span> <span class="pre">*</span> <span class="pre">rqstp</span></code></dt><dd><p>The request in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">space</span></code></dt><dd><p>new max space to reserve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each request reserves some space on the output queue of the transport
to make sure the reply fits.  This function reduces that reserved
space to be the amount of space used already, plus <strong>space</strong>.</p>
<dl class="function">
<dt id="c.svc_find_xprt">
struct svc_xprt * <code class="sig-name descname">svc_find_xprt</code><span class="sig-paren">(</span>struct svc_serv *<em> serv</em>, const char *<em> xcl_name</em>, struct net *<em> net</em>, const sa_family_t<em> af</em>, const unsigned short<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_find_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>find an RPC transport instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_serv</span> <span class="pre">*</span> <span class="pre">serv</span></code></dt><dd><p>pointer to svc_serv to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">xcl_name</span></code></dt><dd><p>C string containing transport’s class name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>owner net pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">sa_family_t</span> <span class="pre">af</span></code></dt><dd><p>Address family of transport’s local address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">port</span></code></dt><dd><p>transport’s IP port number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the transport instance pointer for the endpoint accepting
connections/peer traffic from the specified transport class,
address family and port.</p>
<p>Specifying 0 for the address family or port is effectively a
wild-card, and will result in matching the first transport in the
service’s list that has a matching class name.</p>
<dl class="function">
<dt id="c.svc_xprt_names">
int <code class="sig-name descname">svc_xprt_names</code><span class="sig-paren">(</span>struct svc_serv *<em> serv</em>, char *<em> buf</em>, const int<em> buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_xprt_names" title="Permalink to this definition">¶</a></dt>
<dd><p>format a buffer with a list of transport names</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_serv</span> <span class="pre">*</span> <span class="pre">serv</span></code></dt><dd><p>pointer to an RPC service</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>pointer to a buffer to be filled in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt><dd><p>length of buffer to be filled in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fills in <strong>buf</strong> with a string containing a list of transport names,
each name terminated with ‘n’.</p>
<p>Returns positive length of the filled-in string on success; otherwise
a negative errno value is returned if an error occurs.</p>
<dl class="function">
<dt id="c.xprt_register_transport">
int <code class="sig-name descname">xprt_register_transport</code><span class="sig-paren">(</span>struct xprt_class *<em> transport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_register_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>register a transport implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xprt_class</span> <span class="pre">*</span> <span class="pre">transport</span></code></dt><dd><p>transport to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a transport implementation is loaded as a kernel module, it can
call this interface to make itself known to the RPC client.</p>
<p><strong>Return</strong></p>
<p>0:           transport successfully registered
-EEXIST:     transport already registered
-EINVAL:     transport module being unloaded</p>
<dl class="function">
<dt id="c.xprt_unregister_transport">
int <code class="sig-name descname">xprt_unregister_transport</code><span class="sig-paren">(</span>struct xprt_class *<em> transport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_unregister_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a transport implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xprt_class</span> <span class="pre">*</span> <span class="pre">transport</span></code></dt><dd><p>transport to unregister</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0:           transport successfully unregistered
-ENOENT:     transport never registered</p>
<dl class="function">
<dt id="c.xprt_load_transport">
int <code class="sig-name descname">xprt_load_transport</code><span class="sig-paren">(</span>const char *<em> transport_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_load_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>load a transport implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">transport_name</span></code></dt><dd><p>transport to load</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0:           transport successfully loaded
-ENOENT:     transport module not available</p>
<dl class="function">
<dt id="c.xprt_reserve_xprt">
int <code class="sig-name descname">xprt_reserve_xprt</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em>, struct rpc_task *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_reserve_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>serialize write access to transports</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>pointer to the target transport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>task that is requesting access to the transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prevents mixing the payload of separate requests, and prevents
transport connects from colliding with writes.  No congestion control
is provided.</p>
<dl class="function">
<dt id="c.xprt_release_xprt">
void <code class="sig-name descname">xprt_release_xprt</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em>, struct rpc_task *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_release_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>allow other requests to use a transport</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>transport with other tasks potentially waiting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>task that is releasing access to the transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that “task” can be NULL.  No congestion control is provided.</p>
<dl class="function">
<dt id="c.xprt_release_xprt_cong">
void <code class="sig-name descname">xprt_release_xprt_cong</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em>, struct rpc_task *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_release_xprt_cong" title="Permalink to this definition">¶</a></dt>
<dd><p>allow other requests to use a transport</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>transport with other tasks potentially waiting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>task that is releasing access to the transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that “task” can be NULL.  Another task is awoken to use the
transport if the transport’s congestion window allows it.</p>
<dl class="function">
<dt id="c.xprt_request_get_cong">
bool <code class="sig-name descname">xprt_request_get_cong</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em>, struct rpc_rqst *<em> req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_request_get_cong" title="Permalink to this definition">¶</a></dt>
<dd><p>Request congestion control credits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>pointer to transport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*</span> <span class="pre">req</span></code></dt><dd><p>pointer to RPC request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Useful for transports that require congestion control.</p>
<dl class="function">
<dt id="c.xprt_release_rqst_cong">
void <code class="sig-name descname">xprt_release_rqst_cong</code><span class="sig-paren">(</span>struct rpc_task *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_release_rqst_cong" title="Permalink to this definition">¶</a></dt>
<dd><p>housekeeping when request is complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>RPC request that recently completed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Useful for transports that require congestion control.</p>
<dl class="function">
<dt id="c.xprt_adjust_cwnd">
void <code class="sig-name descname">xprt_adjust_cwnd</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em>, struct rpc_task *<em> task</em>, int<em> result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_adjust_cwnd" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust transport congestion window</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>pointer to xprt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>recently completed RPC request used to adjust window</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">result</span></code></dt><dd><p>result code of completed RPC request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The transport code maintains an estimate on the maximum number of out-
standing RPC requests, using a smoothed version of the congestion
avoidance implemented in 44BSD. This is basically the Van Jacobson
congestion algorithm: If a retransmit occurs, the congestion window is
halved; otherwise, it is incremented by 1/cwnd when</p>
<blockquote>
<div><ul class="simple">
<li><p>a reply is received and</p></li>
<li><p>a full number of requests are outstanding and</p></li>
<li><p>the congestion window hasn’t been updated recently.</p></li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.xprt_wake_pending_tasks">
void <code class="sig-name descname">xprt_wake_pending_tasks</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em>, int<em> status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_wake_pending_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>wake all tasks on a transport’s pending queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>transport with waiting tasks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>result code to plant in each task before waking it</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xprt_wait_for_buffer_space">
void <code class="sig-name descname">xprt_wait_for_buffer_space</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_wait_for_buffer_space" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for transport output buffer to clear</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that we only set the timer for the case of RPC_IS_SOFT(), since
we don’t in general want to force a socket disconnection due to
an incomplete RPC call transmission.</p>
<dl class="function">
<dt id="c.xprt_write_space">
bool <code class="sig-name descname">xprt_write_space</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_write_space" title="Permalink to this definition">¶</a></dt>
<dd><p>wake the task waiting for transport output buffer space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>transport with waiting tasks</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Can be called in a soft IRQ context, so xprt_write_space never sleeps.</p>
<dl class="function">
<dt id="c.xprt_disconnect_done">
void <code class="sig-name descname">xprt_disconnect_done</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_disconnect_done" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a transport as disconnected</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>transport to flag for disconnect</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xprt_force_disconnect">
void <code class="sig-name descname">xprt_force_disconnect</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_force_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>force a transport to disconnect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>transport to disconnect</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xprt_reconnect_delay">
unsigned long <code class="sig-name descname">xprt_reconnect_delay</code><span class="sig-paren">(</span>const struct rpc_xprt *<em> xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_reconnect_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the wait before scheduling a connect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>transport instance</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xprt_reconnect_backoff">
void <code class="sig-name descname">xprt_reconnect_backoff</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em>, unsigned long<em> init_to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_reconnect_backoff" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the new re-establish timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>transport instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">init_to</span></code></dt><dd><p>initial reestablish timeout</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xprt_lookup_rqst">
struct rpc_rqst * <code class="sig-name descname">xprt_lookup_rqst</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em>, __be32<em> xid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_lookup_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>find an RPC request corresponding to an XID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>transport on which the original request was transmitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">xid</span></code></dt><dd><p>RPC XID of incoming reply</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller holds xprt-&gt;queue_lock.</p>
<dl class="function">
<dt id="c.xprt_pin_rqst">
void <code class="sig-name descname">xprt_pin_rqst</code><span class="sig-paren">(</span>struct rpc_rqst *<em> req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_pin_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin a request on the transport receive list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*</span> <span class="pre">req</span></code></dt><dd><p>Request to pin</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must ensure this is atomic with the call to <a class="reference internal" href="#c.xprt_lookup_rqst" title="xprt_lookup_rqst"><code class="xref c c-func docutils literal notranslate"><span class="pre">xprt_lookup_rqst()</span></code></a>
so should be holding xprt-&gt;queue_lock.</p>
<dl class="function">
<dt id="c.xprt_unpin_rqst">
void <code class="sig-name descname">xprt_unpin_rqst</code><span class="sig-paren">(</span>struct rpc_rqst *<em> req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_unpin_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpin a request on the transport receive list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*</span> <span class="pre">req</span></code></dt><dd><p>Request to pin</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller should be holding xprt-&gt;queue_lock.</p>
<dl class="function">
<dt id="c.xprt_update_rtt">
void <code class="sig-name descname">xprt_update_rtt</code><span class="sig-paren">(</span>struct rpc_task *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_update_rtt" title="Permalink to this definition">¶</a></dt>
<dd><p>Update RPC RTT statistics</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>RPC request that recently completed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller holds xprt-&gt;queue_lock.</p>
<dl class="function">
<dt id="c.xprt_complete_rqst">
void <code class="sig-name descname">xprt_complete_rqst</code><span class="sig-paren">(</span>struct rpc_task *<em> task</em>, int<em> copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_complete_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>called when reply processing is complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>RPC request that recently completed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">copied</span></code></dt><dd><p>actual number of bytes received from the transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller holds xprt-&gt;queue_lock.</p>
<dl class="function">
<dt id="c.xprt_wait_for_reply_request_def">
void <code class="sig-name descname">xprt_wait_for_reply_request_def</code><span class="sig-paren">(</span>struct rpc_task *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_wait_for_reply_request_def" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for reply</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>pointer to rpc_task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a request’s retransmit timeout based on the transport’s
default timeout parameters.  Used by transports that don’t adjust
the retransmit timeout based on round-trip time estimation,
and put the task to sleep on the pending queue.</p>
<dl class="function">
<dt id="c.xprt_wait_for_reply_request_rtt">
void <code class="sig-name descname">xprt_wait_for_reply_request_rtt</code><span class="sig-paren">(</span>struct rpc_task *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_wait_for_reply_request_rtt" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for reply using RTT estimator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>pointer to rpc_task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a request’s retransmit timeout using the RTT estimator,
and put the task to sleep on the pending queue.</p>
<dl class="function">
<dt id="c.xprt_get">
struct rpc_xprt * <code class="sig-name descname">xprt_get</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_get" title="Permalink to this definition">¶</a></dt>
<dd><p>return a reference to an RPC transport.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>pointer to the transport</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xprt_put">
void <code class="sig-name descname">xprt_put</code><span class="sig-paren">(</span>struct rpc_xprt *<em> xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to an RPC transport.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>pointer to the transport</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_wake_up">
void <code class="sig-name descname">rpc_wake_up</code><span class="sig-paren">(</span>struct rpc_wait_queue *<em> queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_wake_up" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up all rpc_tasks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_wait_queue</span> <span class="pre">*</span> <span class="pre">queue</span></code></dt><dd><p>rpc_wait_queue on which the tasks are sleeping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grabs queue-&gt;lock</p>
<dl class="function">
<dt id="c.rpc_wake_up_status">
void <code class="sig-name descname">rpc_wake_up_status</code><span class="sig-paren">(</span>struct rpc_wait_queue *<em> queue</em>, int<em> status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_wake_up_status" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up all rpc_tasks and set their status value.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_wait_queue</span> <span class="pre">*</span> <span class="pre">queue</span></code></dt><dd><p>rpc_wait_queue on which the tasks are sleeping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>status value to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grabs queue-&gt;lock</p>
<dl class="function">
<dt id="c.rpc_malloc">
int <code class="sig-name descname">rpc_malloc</code><span class="sig-paren">(</span>struct rpc_task *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate RPC buffer resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>RPC task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A single memory region is allocated, which is split between the
RPC call and RPC reply that this task is being used for. When
this RPC is retired, the memory is released by calling rpc_free.</p>
<p>To prevent rpciod from hanging, this allocator never sleeps,
returning -ENOMEM and suppressing warning if the request cannot
be serviced immediately. The caller can arrange to sleep in a
way that is safe for rpciod.</p>
<p>Most requests are ‘small’ (under 2KiB) and can be serviced from a
mempool, ensuring that NFS reads and writes can always proceed,
and that there is good locality of reference for these buffers.</p>
<dl class="function">
<dt id="c.rpc_free">
void <code class="sig-name descname">rpc_free</code><span class="sig-paren">(</span>struct rpc_task *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free RPC buffer resources allocated via rpc_malloc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>RPC task</p>
</dd>
</dl>
<dl class="function">
<dt id="c.csum_partial_copy_to_xdr">
int <code class="sig-name descname">csum_partial_copy_to_xdr</code><span class="sig-paren">(</span>struct xdr_buf *<em> xdr</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.csum_partial_copy_to_xdr" title="Permalink to this definition">¶</a></dt>
<dd><p>checksum and copy data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt><dd><p>target XDR buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>source skb</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We have set things up such that we perform the checksum of the UDP
packet in parallel with the copies into the RPC client iovec.  -DaveM</p>
<dl class="function">
<dt id="c.rpc_alloc_iostats">
struct rpc_iostats * <code class="sig-name descname">rpc_alloc_iostats</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_alloc_iostats" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an rpc_iostats structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>RPC program, version, and xprt</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_free_iostats">
void <code class="sig-name descname">rpc_free_iostats</code><span class="sig-paren">(</span>struct rpc_iostats *<em> stats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_free_iostats" title="Permalink to this definition">¶</a></dt>
<dd><p>release an rpc_iostats structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_iostats</span> <span class="pre">*</span> <span class="pre">stats</span></code></dt><dd><p>doomed rpc_iostats structure</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_count_iostats_metrics">
void <code class="sig-name descname">rpc_count_iostats_metrics</code><span class="sig-paren">(</span>const struct rpc_task *<em> task</em>, struct rpc_iostats *<em> op_metrics</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_count_iostats_metrics" title="Permalink to this definition">¶</a></dt>
<dd><p>tally up per-task stats</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>completed rpc_task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_iostats</span> <span class="pre">*</span> <span class="pre">op_metrics</span></code></dt><dd><p>stat structure for OP that will accumulate stats from <strong>task</strong></p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_count_iostats">
void <code class="sig-name descname">rpc_count_iostats</code><span class="sig-paren">(</span>const struct rpc_task *<em> task</em>, struct rpc_iostats *<em> stats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_count_iostats" title="Permalink to this definition">¶</a></dt>
<dd><p>tally up per-task stats</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>completed rpc_task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_iostats</span> <span class="pre">*</span> <span class="pre">stats</span></code></dt><dd><p>array of stat structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses the statidx from <strong>task</strong></p>
<dl class="function">
<dt id="c.rpc_queue_upcall">
int <code class="sig-name descname">rpc_queue_upcall</code><span class="sig-paren">(</span>struct rpc_pipe *<em> pipe</em>, struct rpc_pipe_msg *<em> msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_queue_upcall" title="Permalink to this definition">¶</a></dt>
<dd><p>queue an upcall message to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt><dd><p>upcall pipe on which to queue given message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_msg</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>message to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call with an <strong>inode</strong> created by rpc_mkpipe() to queue an upcall.
A userspace process may then later read the upcall by performing a
read on an open file for this inode.  It is up to the caller to
initialize the fields of <strong>msg</strong> (other than <strong>msg-&gt;list</strong>) appropriately.</p>
<dl class="function">
<dt id="c.rpc_mkpipe_dentry">
struct dentry * <code class="sig-name descname">rpc_mkpipe_dentry</code><span class="sig-paren">(</span>struct dentry *<em> parent</em>, const char *<em> name</em>, void *<em> private</em>, struct rpc_pipe *<em> pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_mkpipe_dentry" title="Permalink to this definition">¶</a></dt>
<dd><p>make an rpc_pipefs file for kernel&lt;-&gt;userspace communication</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>dentry of directory to create new “pipe” in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name of pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private</span></code></dt><dd><p>private data to associate with the pipe, for the caller’s use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">rpc_pipe</span></code> containing input parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Data is made available for userspace to read by calls to
<a class="reference internal" href="#c.rpc_queue_upcall" title="rpc_queue_upcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">rpc_queue_upcall()</span></code></a>.  The actual reads will result in calls to
<strong>ops-&gt;upcall</strong>, which will be called with the file pointer,
message, and userspace buffer to copy to.</p>
<p>Writes can come at any time, and do not necessarily have to be
responses to upcalls.  They will result in calls to <strong>msg-&gt;downcall</strong>.</p>
<p>The <strong>private</strong> argument passed here will be available to all these methods
from the file pointer, via RPC_I(file_inode(file))-&gt;private.</p>
<dl class="function">
<dt id="c.rpc_unlink">
int <code class="sig-name descname">rpc_unlink</code><span class="sig-paren">(</span>struct dentry *<em> dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt><dd><p>dentry for the pipe, as returned from rpc_mkpipe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this call, lookups will no longer find the pipe, and any
attempts to read or write using preexisting opens of the pipe will
return -EPIPE.</p>
<dl class="function">
<dt id="c.rpc_init_pipe_dir_head">
void <code class="sig-name descname">rpc_init_pipe_dir_head</code><span class="sig-paren">(</span>struct rpc_pipe_dir_head *<em> pdh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_init_pipe_dir_head" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a struct rpc_pipe_dir_head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*</span> <span class="pre">pdh</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_head</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_init_pipe_dir_object">
void <code class="sig-name descname">rpc_init_pipe_dir_object</code><span class="sig-paren">(</span>struct rpc_pipe_dir_object *<em> pdo</em>, const struct rpc_pipe_dir_object_ops *<em> pdo_ops</em>, void *<em> pdo_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_init_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a struct rpc_pipe_dir_object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*</span> <span class="pre">pdo</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object_ops</span> <span class="pre">*</span> <span class="pre">pdo_ops</span></code></dt><dd><p>pointer to const struct rpc_pipe_dir_object_ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pdo_data</span></code></dt><dd><p>pointer to caller-defined data</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_add_pipe_dir_object">
int <code class="sig-name descname">rpc_add_pipe_dir_object</code><span class="sig-paren">(</span>struct net *<em> net</em>, struct rpc_pipe_dir_head *<em> pdh</em>, struct rpc_pipe_dir_object *<em> pdo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_add_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a rpc_pipe_dir_object to a directory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>pointer to struct net</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*</span> <span class="pre">pdh</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*</span> <span class="pre">pdo</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_object</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_remove_pipe_dir_object">
void <code class="sig-name descname">rpc_remove_pipe_dir_object</code><span class="sig-paren">(</span>struct net *<em> net</em>, struct rpc_pipe_dir_head *<em> pdh</em>, struct rpc_pipe_dir_object *<em> pdo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_remove_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a rpc_pipe_dir_object from a directory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>pointer to struct net</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*</span> <span class="pre">pdh</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*</span> <span class="pre">pdo</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_object</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_find_or_alloc_pipe_dir_object">
struct rpc_pipe_dir_object * <code class="sig-name descname">rpc_find_or_alloc_pipe_dir_object</code><span class="sig-paren">(</span>struct net *<em> net</em>, struct rpc_pipe_dir_head *<em> pdh</em>, int (*match) (struct rpc_pipe_dir_object<em> *</em>, void<em> *</em>, struct rpc_pipe_dir_object *(*alloc) (void<em> *</em>, void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_find_or_alloc_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>pointer to struct net</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*</span> <span class="pre">pdh</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">match</span></code></dt><dd><p>match struct rpc_pipe_dir_object to data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*(*)(void</span> <span class="pre">*)</span> <span class="pre">alloc</span></code></dt><dd><p>allocate a new struct rpc_pipe_dir_object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>user defined data for match() and alloc()</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpcb_getport_async">
void <code class="sig-name descname">rpcb_getport_async</code><span class="sig-paren">(</span>struct rpc_task *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpcb_getport_async" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the port for a given RPC service on a given host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>task that is waiting for portmapper request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This one can be called for an ongoing RPC request, and can be used in
an async (rpciod) context.</p>
<dl class="function">
<dt id="c.rpc_create">
struct rpc_clnt * <code class="sig-name descname">rpc_create</code><span class="sig-paren">(</span>struct rpc_create_args *<em> args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an RPC client and transport with one call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_create_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>rpc_clnt create argument structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates and initializes an RPC transport and an RPC client.</p>
<p>It can ping the server in order to determine if it is up, and to see if
it supports this program and version.  RPC_CLNT_CREATE_NOPING disables
this behavior so asynchronous tasks can also use rpc_create.</p>
<dl class="function">
<dt id="c.rpc_clone_client">
struct rpc_clnt * <code class="sig-name descname">rpc_clone_client</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clone_client" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone an RPC client structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>RPC client whose parameters are copied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a fresh RPC client or an ERR_PTR.</p>
<dl class="function">
<dt id="c.rpc_clone_client_set_auth">
struct rpc_clnt * <code class="sig-name descname">rpc_clone_client_set_auth</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, rpc_authflavor_t<em> flavor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clone_client_set_auth" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone an RPC client structure and set its auth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>RPC client whose parameters are copied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rpc_authflavor_t</span> <span class="pre">flavor</span></code></dt><dd><p>security flavor for new client</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a fresh RPC client or an ERR_PTR.</p>
<dl class="function">
<dt id="c.rpc_switch_client_transport">
int <code class="sig-name descname">rpc_switch_client_transport</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, struct xprt_create *<em> args</em>, const struct rpc_timeout *<em> timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_switch_client_transport" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>pointer to a struct rpc_clnt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xprt_create</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>pointer to the new transport arguments</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_timeout</span> <span class="pre">*</span> <span class="pre">timeout</span></code></dt><dd><p>pointer to the new timeout parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows the caller to switch the RPC transport for the
rpc_clnt structure ‘clnt’ to allow it to connect to a mirrored NFS
server, for instance.  It assumes that the caller has ensured that
there are no active RPC tasks by using some form of locking.</p>
<p>Returns zero if “clnt” is now using the new xprt.  Otherwise a
negative errno is returned, and “clnt” continues to use the old
xprt.</p>
<dl class="function">
<dt id="c.rpc_clnt_iterate_for_each_xprt">
int <code class="sig-name descname">rpc_clnt_iterate_for_each_xprt</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, int (*fn) (struct rpc_clnt<em> *</em>, struct rpc_xprt<em> *</em>, void<em> *</em>, void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_iterate_for_each_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to all transports</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>pointer to client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt><dd><p>function to apply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>void pointer to function data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of RPC transports currently attached to the
client and applies the function fn(clnt, xprt, data).</p>
<p>On error, the iteration stops, and the function returns the error value.</p>
<dl class="function">
<dt id="c.rpc_bind_new_program">
struct rpc_clnt * <code class="sig-name descname">rpc_bind_new_program</code><span class="sig-paren">(</span>struct rpc_clnt *<em> old</em>, const struct rpc_program *<em> program</em>, u32<em> vers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_bind_new_program" title="Permalink to this definition">¶</a></dt>
<dd><p>bind a new RPC program to an existing client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>old rpc_client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_program</span> <span class="pre">*</span> <span class="pre">program</span></code></dt><dd><p>rpc program to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">vers</span></code></dt><dd><p>rpc program version</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clones the rpc client and sets up a new RPC program. This is mainly
of use for enabling different RPC programs to share the same transport.
The Sun NFSv2/v3 ACL protocol can do this.</p>
<dl class="function">
<dt id="c.rpc_run_task">
struct rpc_task * <code class="sig-name descname">rpc_run_task</code><span class="sig-paren">(</span>const struct rpc_task_setup *<em> task_setup_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_run_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a new RPC task, then run rpc_execute against it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_task_setup</span> <span class="pre">*</span> <span class="pre">task_setup_data</span></code></dt><dd><p>pointer to task initialisation data</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_call_sync">
int <code class="sig-name descname">rpc_call_sync</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, const struct rpc_message *<em> msg</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_call_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a synchronous RPC call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>pointer to RPC client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_message</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>RPC call parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>RPC call flags</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_call_async">
int <code class="sig-name descname">rpc_call_async</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, const struct rpc_message *<em> msg</em>, int<em> flags</em>, const struct rpc_call_ops *<em> tk_ops</em>, void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_call_async" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an asynchronous RPC call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>pointer to RPC client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_message</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>RPC call parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>RPC call flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_call_ops</span> <span class="pre">*</span> <span class="pre">tk_ops</span></code></dt><dd><p>RPC call ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>user call data</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_prepare_reply_pages">
void <code class="sig-name descname">rpc_prepare_reply_pages</code><span class="sig-paren">(</span>struct rpc_rqst *<em> req</em>, struct page **<em> pages</em>, unsigned int<em> base</em>, unsigned int<em> len</em>, unsigned int<em> hdrsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_prepare_reply_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare to receive a reply data payload into pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*</span> <span class="pre">req</span></code></dt><dd><p>RPC request to prepare</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt><dd><p>vector of struct page pointers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>offset in first page where receive should start, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>expected size of the upper layer data payload, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hdrsize</span></code></dt><dd><p>expected size of upper layer reply header, in XDR words</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_peeraddr">
size_t <code class="sig-name descname">rpc_peeraddr</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, struct sockaddr *<em> buf</em>, size_t<em> bufsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_peeraddr" title="Permalink to this definition">¶</a></dt>
<dd><p>extract remote peer address from clnt’s xprt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>RPC client structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>target buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">bufsize</span></code></dt><dd><p>length of target buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes that are actually in the stored address.</p>
<dl class="function">
<dt id="c.rpc_peeraddr2str">
const char * <code class="sig-name descname">rpc_peeraddr2str</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, enum rpc_display_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_peeraddr2str" title="Permalink to this definition">¶</a></dt>
<dd><p>return remote peer address in printable format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>RPC client structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rpc_display_format_t</span> <span class="pre">format</span></code></dt><dd><p>address format</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>NB: the lifetime of the memory referenced by the returned pointer is
the same as the rpc_xprt itself.  As long as the caller uses this
pointer, it must hold the RCU read lock.</p>
<dl class="function">
<dt id="c.rpc_localaddr">
int <code class="sig-name descname">rpc_localaddr</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, struct sockaddr *<em> buf</em>, size_t<em> buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_localaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>discover local endpoint address for an RPC client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>RPC client structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>target buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">buflen</span></code></dt><dd><p>size of target buffer, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero and fills in “buf” and “buflen” if successful;
otherwise, a negative errno is returned.</p>
<p>This works even if the underlying transport is not currently connected,
or if the upper layer never previously provided a source address.</p>
<p>The result of this function call is transient: multiple calls in
succession may give different results, depending on how local
networking configuration changes over time.</p>
<dl class="function">
<dt id="c.rpc_net_ns">
struct net * <code class="sig-name descname">rpc_net_ns</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_net_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the network namespace for this RPC client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>RPC client to query</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_max_payload">
size_t <code class="sig-name descname">rpc_max_payload</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_max_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Get maximum payload size for a transport, in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>RPC client to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For stream transports, this is one RPC record fragment (see RFC
1831), as we don’t support multi-record requests yet.  For datagram
transports, this is the size of an IP packet minus the IP, UDP, and
RPC header sizes.</p>
<dl class="function">
<dt id="c.rpc_max_bc_payload">
size_t <code class="sig-name descname">rpc_max_bc_payload</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_max_bc_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Get maximum backchannel payload size, in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>RPC client to query</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_force_rebind">
void <code class="sig-name descname">rpc_force_rebind</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_force_rebind" title="Permalink to this definition">¶</a></dt>
<dd><p>force transport to check that remote port is unchanged</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>client to rebind</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_clnt_test_and_add_xprt">
int <code class="sig-name descname">rpc_clnt_test_and_add_xprt</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, struct rpc_xprt_switch *<em> xps</em>, struct rpc_xprt *<em> xprt</em>, void *<em> dummy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_test_and_add_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>Test and add a new transport to a rpc_clnt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>pointer to struct rpc_clnt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt_switch</span> <span class="pre">*</span> <span class="pre">xps</span></code></dt><dd><p>pointer to struct rpc_xprt_switch,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>pointer struct rpc_xprt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dummy</span></code></dt><dd><p>unused</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rpc_clnt_setup_test_and_add_xprt">
int <code class="sig-name descname">rpc_clnt_setup_test_and_add_xprt</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, struct rpc_xprt_switch *<em> xps</em>, struct rpc_xprt *<em> xprt</em>, void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_setup_test_and_add_xprt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>struct rpc_clnt to get the new transport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt_switch</span> <span class="pre">*</span> <span class="pre">xps</span></code></dt><dd><p>the rpc_xprt_switch to hold the new transport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt><dd><p>the rpc_xprt to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>a struct rpc_add_xprt_test pointer that holds the test function
and test function call data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>This is an rpc_clnt_add_xprt setup() function which returns 1 so:</dt><dd><p>1) caller of the test function must dereference the rpc_xprt_switch
and the rpc_xprt.
2) test function must call rpc_xprt_switch_add_xprt, usually in
the rpc_call_done routine.</p>
</dd>
</dl>
<p>Upon success (return of 1), the test function adds the new
transport to the rpc_clnt xprt switch</p>
<dl class="function">
<dt id="c.rpc_clnt_add_xprt">
int <code class="sig-name descname">rpc_clnt_add_xprt</code><span class="sig-paren">(</span>struct rpc_clnt *<em> clnt</em>, struct xprt_create *<em> xprtargs</em>, int (*setup) (struct rpc_clnt<em> *</em>, struct rpc_xprt_switch<em> *</em>, struct rpc_xprt<em> *</em>, void<em> *</em>, void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_add_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new transport to a rpc_clnt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt><dd><p>pointer to struct rpc_clnt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xprt_create</span> <span class="pre">*</span> <span class="pre">xprtargs</span></code></dt><dd><p>pointer to struct xprt_create</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">rpc_xprt_switch</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">setup</span></code></dt><dd><p>callback to test and/or set up the connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>pointer to setup function data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new transport using the parameters set in args and
adds it to clnt.
If ping is set, then test that connectivity succeeds before
adding the new transport.</p>
</div>
<div class="section" id="wimax">
<h3>WiMAX<a class="headerlink" href="#wimax" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.wimax_msg_alloc">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">wimax_msg_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em>, const char *<em> pipe_name</em>, const void *<em> msg</em>, size_t<em> size</em>, gfp_t<em> gfp_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new skb for sending a message to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pipe_name</span></code></dt><dd><p>“named pipe” the message will be sent to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>pointer to the message data to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the message to send (in bytes), including the header.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_flags</span></code></dt><dd><p>flags for memory allocation.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> if ok, negative errno code on error</p>
<p><strong>Description</strong></p>
<p>Allocates an skb that will contain the message to send to user
space over the messaging pipe and initializes it, copying the
payload.</p>
<p>Once this call is done, you can deliver it with
<a class="reference internal" href="#c.wimax_msg_send" title="wimax_msg_send"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_msg_send()</span></code></a>.</p>
<p>IMPORTANT:</p>
<p>Don’t use <a class="reference internal" href="#c.skb_push" title="skb_push"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_push()</span></code></a>/<a class="reference internal" href="#c.skb_pull" title="skb_pull"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_pull()</span></code></a>/<a class="reference internal" href="#c.skb_reserve" title="skb_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_reserve()</span></code></a> on the skb, as
<a class="reference internal" href="#c.wimax_msg_send" title="wimax_msg_send"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_msg_send()</span></code></a> depends on skb-&gt;data being placed at the
beginning of the user message.</p>
<p>Unlike other WiMAX stack calls, this call can be used way early,
even before <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_add()</span></code></a> is called, as long as the
wimax_dev-&gt;net_dev pointer is set to point to a proper
net_dev. This is so that drivers can use it early in case they need
to send stuff around or communicate with user space.</p>
<dl class="function">
<dt id="c.wimax_msg_data_len">
const void * <code class="sig-name descname">wimax_msg_data_len</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> msg</em>, size_t *<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg_data_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pointer and size of a message’s payload</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>Pointer to a message created with <a class="reference internal" href="#c.wimax_msg_alloc" title="wimax_msg_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_msg_alloc()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">size</span></code></dt><dd><p>Pointer to where to store the message’s size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the pointer to the message data.</p>
<dl class="function">
<dt id="c.wimax_msg_data">
const void * <code class="sig-name descname">wimax_msg_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pointer to a message’s payload</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>Pointer to a message created with <a class="reference internal" href="#c.wimax_msg_alloc" title="wimax_msg_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_msg_alloc()</span></code></a></p>
</dd>
</dl>
<dl class="function">
<dt id="c.wimax_msg_len">
ssize_t <code class="sig-name descname">wimax_msg_len</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a message’s payload length</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>Pointer to a message created with <a class="reference internal" href="#c.wimax_msg_alloc" title="wimax_msg_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_msg_alloc()</span></code></a></p>
</dd>
</dl>
<dl class="function">
<dt id="c.wimax_msg_send">
int <code class="sig-name descname">wimax_msg_send</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg_send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a pre-allocated message to user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p><a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span></code></a> returned by <a class="reference internal" href="#c.wimax_msg_alloc" title="wimax_msg_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_msg_alloc()</span></code></a>. Note the
ownership of <strong>skb</strong> is transferred to this function.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if ok, &lt; 0 errno code on error</p>
<p><strong>Description</strong></p>
<p>Sends a free-form message that was preallocated with
<a class="reference internal" href="#c.wimax_msg_alloc" title="wimax_msg_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_msg_alloc()</span></code></a> and filled up.</p>
<p>Assumes that once you pass an skb to this function for sending, it
owns it and will release it when done (on success).</p>
<p>IMPORTANT:</p>
<p>Don’t use <a class="reference internal" href="#c.skb_push" title="skb_push"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_push()</span></code></a>/<a class="reference internal" href="#c.skb_pull" title="skb_pull"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_pull()</span></code></a>/<a class="reference internal" href="#c.skb_reserve" title="skb_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_reserve()</span></code></a> on the skb, as
<a class="reference internal" href="#c.wimax_msg_send" title="wimax_msg_send"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_msg_send()</span></code></a> depends on skb-&gt;data being placed at the
beginning of the user message.</p>
<p>Unlike other WiMAX stack calls, this call can be used way early,
even before <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_add()</span></code></a> is called, as long as the
wimax_dev-&gt;net_dev pointer is set to point to a proper
net_dev. This is so that drivers can use it early in case they need
to send stuff around or communicate with user space.</p>
<dl class="function">
<dt id="c.wimax_msg">
int <code class="sig-name descname">wimax_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em>, const char *<em> pipe_name</em>, const void *<em> buf</em>, size_t<em> size</em>, gfp_t<em> gfp_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a message to user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor (properly referenced)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pipe_name</span></code></dt><dd><p>“named pipe” the message will be sent to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>pointer to the message to send.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the buffer pointed to by <strong>buf</strong> (in bytes).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_flags</span></code></dt><dd><p>flags for memory allocation.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> if ok, negative errno code on error.</p>
<p><strong>Description</strong></p>
<p>Sends a free-form message to user space on the device <strong>wimax_dev</strong>.</p>
<p><strong>NOTES</strong></p>
<p>Once the <strong>skb</strong> is given to this function, who will own it and will
release it when done (unless it returns error).</p>
<dl class="function">
<dt id="c.wimax_reset">
int <code class="sig-name descname">wimax_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset a WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> if ok and a warm reset was done (the device still exists in
the system).</p>
<p>-<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> if a cold/bus reset had to be done (device has
disconnected and reconnected, so current handle is not valid
any more).</p>
<p>-<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> if the device is not even registered.</p>
<p>Any other negative error code shall be considered as
non-recoverable.</p>
<p><strong>Description</strong></p>
<p>Called when wanting to reset the device for any reason. Device is
taken back to power on status.</p>
<p>This call blocks; on successful return, the device has completed the
reset process and is ready to operate.</p>
<dl class="function">
<dt id="c.wimax_report_rfkill_hw">
void <code class="sig-name descname">wimax_report_rfkill_hw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em>, enum wimax_rf_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_report_rfkill_hw" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports changes in the hardware RF switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wimax_rf_state</span> <span class="pre">state</span></code></dt><dd><p>New state of the RF Kill switch. <code class="docutils literal notranslate"><span class="pre">WIMAX_RF_ON</span></code> radio on,
<code class="docutils literal notranslate"><span class="pre">WIMAX_RF_OFF</span></code> radio off.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the device detects a change in the state of thehardware RF
switch, it must call this function to let the WiMAX kernel stack
know that the state has changed so it can be properly propagated.</p>
<p>The WiMAX stack caches the state (the driver doesn’t need to). As
well, as the change is propagated it will come back as a request to
change the software state to mirror the hardware state.</p>
<p>If the device doesn’t have a hardware kill switch, just report
it on initialization as always on (<code class="docutils literal notranslate"><span class="pre">WIMAX_RF_ON</span></code>, radio on).</p>
<dl class="function">
<dt id="c.wimax_report_rfkill_sw">
void <code class="sig-name descname">wimax_report_rfkill_sw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em>, enum wimax_rf_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_report_rfkill_sw" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports changes in the software RF switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wimax_rf_state</span> <span class="pre">state</span></code></dt><dd><p>New state of the RF kill switch. <code class="docutils literal notranslate"><span class="pre">WIMAX_RF_ON</span></code> radio on,
<code class="docutils literal notranslate"><span class="pre">WIMAX_RF_OFF</span></code> radio off.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reports changes in the software RF switch state to the WiMAX stack.</p>
<p>The main use is during initialization, so the driver can query the
device for its current software radio kill switch state and feed it
to the system.</p>
<p>On the side, the device does not change the software state by
itself. In practice, this can happen, as the device might decide to
switch (in software) the radio off for different reasons.</p>
<dl class="function">
<dt id="c.wimax_rfkill">
int <code class="sig-name descname">wimax_rfkill</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em>, enum wimax_rf_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_rfkill" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the software RF switch state for a WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wimax_rf_state</span> <span class="pre">state</span></code></dt><dd><p>New RF state.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>&gt;= 0 toggle state if ok, &lt; 0 errno code on error. The toggle state
is returned as a bitmap, bit 0 being the hardware RF state, bit 1
the software RF state.</p>
<p>0 means disabled (<code class="docutils literal notranslate"><span class="pre">WIMAX_RF_ON</span></code>, radio on), 1 means enabled radio
off (<code class="docutils literal notranslate"><span class="pre">WIMAX_RF_OFF</span></code>).</p>
<p><strong>Description</strong></p>
<p>Called by the user when he wants to request the WiMAX radio to be
switched on (<code class="docutils literal notranslate"><span class="pre">WIMAX_RF_ON</span></code>) or off (<code class="docutils literal notranslate"><span class="pre">WIMAX_RF_OFF</span></code>). With
<code class="docutils literal notranslate"><span class="pre">WIMAX_RF_QUERY</span></code>, just the current state is returned.</p>
<p><strong>NOTE</strong></p>
<p>This call will block until the operation is complete.</p>
<dl class="function">
<dt id="c.wimax_state_change">
void <code class="sig-name descname">wimax_state_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em>, enum <a class="reference internal" href="#c.wimax_st" title="wimax_st">wimax_st</a><em> new_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_state_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the current state of a WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor (properly referenced)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wimax_st</span> <span class="pre">new_state</span></code></dt><dd><p>New state to switch to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This implements the state changes for the wimax devices. It will</p>
<ul class="simple">
<li><p>verify that the state transition is legal (for now it’ll just
print a warning if not) according to the table in
linux/wimax.h’s documentation for ‘enum wimax_st’.</p></li>
<li><p>perform the actions needed for leaving the current state and
whichever are needed for entering the new state.</p></li>
<li><p>issue a report to user space indicating the new state (and an
optional payload with information about the new state).</p></li>
</ul>
<p><strong>NOTE</strong></p>
<p><strong>wimax_dev</strong> must be locked</p>
<dl class="function">
<dt id="c.wimax_state_get">
enum <a class="reference internal" href="#c.wimax_st" title="wimax_st">wimax_st</a> <code class="sig-name descname">wimax_state_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_state_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current state of a WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Current state of the device according to its driver.</p>
<dl class="function">
<dt id="c.wimax_dev_init">
void <code class="sig-name descname">wimax_dev_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_dev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a newly allocated instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor to initialize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes fields of a freshly allocated <strong>wimax_dev</strong> instance. This
function assumes that after allocation, the memory occupied by
<strong>wimax_dev</strong> was zeroed.</p>
<dl class="function">
<dt id="c.wimax_dev_add">
int <code class="sig-name descname">wimax_dev_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> net_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_dev_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a new WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor (as embedded in your <strong>net_dev</strong>’s
priv data). You must have called <a class="reference internal" href="#c.wimax_dev_init" title="wimax_dev_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_init()</span></code></a> on it before.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">net_dev</span></code></dt><dd><p>net device the <strong>wimax_dev</strong> is associated with. The
function expects SET_NETDEV_DEV() and <a class="reference internal" href="#c.register_netdev" title="register_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdev()</span></code></a> were
already called on it.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers the new WiMAX device, sets up the user-kernel control
interface (generic netlink) and common WiMAX infrastructure.</p>
<p>Note that the parts that will allow interaction with user space are
setup at the very end, when the rest is in place, as once that
happens, the driver might get user space control requests via
netlink or from debugfs that might translate into calls into
wimax_dev-&gt;op_*().</p>
<dl class="function">
<dt id="c.wimax_dev_rm">
void <code class="sig-name descname">wimax_dev_rm</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em> wimax_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_dev_rm" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister an existing WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt><dd><p>WiMAX device descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters a WiMAX device previously registered for use with
wimax_add_rm().</p>
<p>IMPORTANT! Must call before calling <a class="reference internal" href="#c.unregister_netdev" title="unregister_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">unregister_netdev()</span></code></a>.</p>
<p>After this function returns, you will not get any more user space
control requests (via netlink or debugfs) and thus to wimax_dev-&gt;ops.</p>
<p>Reentrancy control is ensured by setting the state to
<code class="docutils literal notranslate"><span class="pre">__WIMAX_ST_QUIESCING</span></code>. rfkill operations coming through
wimax_*rfkill*() will be stopped by the quiescing state; ops coming
from the rfkill subsystem will be stopped by the support being
removed by wimax_rfkill_rm().</p>
<dl class="type">
<dt id="c.wimax_dev">
struct <code class="sig-name descname">wimax_dev</code><a class="headerlink" href="#c.wimax_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic WiMAX device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct wimax_dev {
  struct net_device *net_dev;
  struct list_head id_table_node;
  struct mutex mutex;
  struct mutex mutex_reset;
  enum wimax_st state;
  int (*op_msg_from_user)(struct wimax_dev *wimax_dev,const char *,const void *, size_t, const struct genl_info *info);
  int (*op_rfkill_sw_toggle)(struct wimax_dev *wimax_dev, enum wimax_rf_state);
  int (*op_reset)(struct wimax_dev *wimax_dev);
  struct rfkill *rfkill;
  unsigned int rf_hw;
  unsigned int rf_sw;
  char name[32];
  struct dentry *debugfs_dentry;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">net_dev</span></code></dt><dd><p>[fill] Pointer to the <a class="reference internal" href="#c.net_device" title="net_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span></code></a> this WiMAX
device implements.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id_table_node</span></code></dt><dd><p>[private] link to the list of wimax devices kept by
id-table.c. Protected by it’s own spinlock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>[private] Serializes all concurrent access and execution of
operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex_reset</span></code></dt><dd><p>[private] Serializes reset operations. Needs to be a
different mutex because as part of the reset operation, the
driver has to call back into the stack to do things such as
state change, that require wimax_dev-&gt;mutex.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>[private] Current state of the WiMAX device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op_msg_from_user</span></code></dt><dd><p>[fill] Driver-specific operation to
handle a raw message from user space to the driver. The
driver can send messages to user space using with
wimax_msg_to_user().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op_rfkill_sw_toggle</span></code></dt><dd><p>[fill] Driver-specific operation to act on
userspace (or any other agent) requesting the WiMAX device to
change the RF Kill software switch (WIMAX_RF_ON or
WIMAX_RF_OFF).
If such hardware support is not present, it is assumed the
radio cannot be switched off and it is always on (and the stack
will error out when trying to switch it off). In such case,
this function pointer can be left as NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op_reset</span></code></dt><dd><p>[fill] Driver specific operation to reset the
device.
This operation should always attempt first a warm reset that
does not disconnect the device from the bus and return 0.
If that fails, it should resort to some sort of cold or bus
reset (even if it implies a bus disconnection and device
disappearance). In that case, -ENODEV should be returned to
indicate the device is gone.
This operation has to be synchronous, and return only when the
reset is complete. In case of having had to resort to bus/cold
reset implying a device disconnection, the call is allowed to
return immediately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rfkill</span></code></dt><dd><p>[private] integration into the RF-Kill infrastructure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rf_hw</span></code></dt><dd><p>[private] State of the hardware radio switch (OFF/ON)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rf_sw</span></code></dt><dd><p>[private] State of the software radio switch (OFF/ON)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>[fill] A way to identify this device. We need to register a
name with many subsystems (rfkill, workqueue creation, etc).
We can’t use the network device name as that
might change and in some instances we don’t know it yet (until
we don’t call <a class="reference internal" href="#c.register_netdev" title="register_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdev()</span></code></a>). So we generate an unique one
using the driver name and device bus id, place it here and use
it across the board. Recommended naming:
DRIVERNAME-BUSNAME:BUSID (dev-&gt;bus-&gt;name, dev-&gt;bus_id).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfs_dentry</span></code></dt><dd><p>[private] Used to hook up a debugfs entry. This
shows up in the debugfs root as wimax:DEVICENAME.</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<dl class="simple">
<dt>wimax_dev-&gt;mutex is NOT locked when this op is being</dt><dd><p>called; however, wimax_dev-&gt;mutex_reset IS locked to ensure
serialization of calls to <a class="reference internal" href="#c.wimax_reset" title="wimax_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_reset()</span></code></a>.
See <a class="reference internal" href="#c.wimax_reset" title="wimax_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_reset()</span></code></a>’s documentation.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure defines a common interface to access all WiMAX
devices from different vendors and provides a common API as well as
a free-form device-specific messaging channel.</p>
<dl class="simple">
<dt>Usage:</dt><dd><ol class="arabic simple">
<li><p>Embed a <a class="reference internal" href="#c.wimax_dev" title="wimax_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wimax_dev</span></code></a> at <em>the beginning</em> the network
device structure so that <a class="reference internal" href="#c.netdev_priv" title="netdev_priv"><code class="xref c c-func docutils literal notranslate"><span class="pre">netdev_priv()</span></code></a> points to it.</p></li>
<li><p><a class="reference internal" href="../core-api/kernel-api.html#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> it to zero</p></li>
<li><p>Initialize with <a class="reference internal" href="#c.wimax_dev_init" title="wimax_dev_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_init()</span></code></a>. This will leave the WiMAX
device in the <code class="docutils literal notranslate"><span class="pre">__WIMAX_ST_NULL</span></code> state.</p></li>
<li><p>Fill all the fields marked with [fill]; once called
<a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_add()</span></code></a>, those fields CANNOT be modified.</p></li>
<li><p>Call <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_add()</span></code></a> <em>after</em> registering the network
device. This will leave the WiMAX device in the <code class="docutils literal notranslate"><span class="pre">WIMAX_ST_DOWN</span></code>
state.
Protect the driver’s net_device-&gt;open() against succeeding if
the wimax device state is lower than <code class="docutils literal notranslate"><span class="pre">WIMAX_ST_DOWN</span></code>.</p></li>
<li><p>Select when the device is going to be turned on/initialized;
for example, it could be initialized on ‘ifconfig up’ (when the
netdev op ‘open()’ is called on the driver).</p></li>
</ol>
</dd>
</dl>
<p>When the device is initialized (at <cite>ifconfig up</cite> time, or right
after calling <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_add()</span></code></a> from _probe(), make sure the
following steps are taken</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>Move the device to <code class="docutils literal notranslate"><span class="pre">WIMAX_ST_UNINITIALIZED</span></code>. This is needed so
some API calls that shouldn’t work until the device is ready
can be blocked.</p></li>
<li><p>Initialize the device. Make sure to turn the SW radio switch
off and move the device to state <code class="docutils literal notranslate"><span class="pre">WIMAX_ST_RADIO_OFF</span></code> when
done. When just initialized, a device should be left in RADIO
OFF state until user space devices to turn it on.</p></li>
<li><p>Query the device for the state of the hardware rfkill switch
and call wimax_rfkill_report_hw() and wimax_rfkill_report_sw()
as needed. See below.</p></li>
</ol>
</div></blockquote>
<p><a class="reference internal" href="#c.wimax_dev_rm" title="wimax_dev_rm"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_rm()</span></code></a> undoes before unregistering the network device. Once
<a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_add()</span></code></a> is called, the driver can get called on the
wimax_dev-&gt;op_* function pointers</p>
<p>CONCURRENCY:</p>
<p>The stack provides a mutex for each device that will disallow API
calls happening concurrently; thus, op calls into the driver
through the wimax_dev-&gt;op*() function pointers will always be
serialized and <em>never</em> concurrent.</p>
<p>For locking, take wimax_dev-&gt;mutex is taken; (most) operations in
the API have to check for wimax_dev_is_ready() to return 0 before
continuing (this is done internally).</p>
<p>REFERENCE COUNTING:</p>
<p>The WiMAX device is reference counted by the associated network
device. The only operation that can be used to reference the device
is wimax_dev_get_by_genl_info(), and the reference it acquires has
to be released with dev_put(wimax_dev-&gt;net_dev).</p>
<p>RFKILL:</p>
<p>At startup, both HW and SW radio switchess are assumed to be off.</p>
<p>At initialization time [after calling <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_add()</span></code></a>], have the
driver query the device for the status of the software and hardware
RF kill switches and call <a class="reference internal" href="#c.wimax_report_rfkill_hw" title="wimax_report_rfkill_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_report_rfkill_hw()</span></code></a> and
wimax_rfkill_report_sw() to indicate their state. If any is
missing, just call it to indicate it is ON (radio always on).</p>
<p>Whenever the driver detects a change in the state of the RF kill
switches, it should call <a class="reference internal" href="#c.wimax_report_rfkill_hw" title="wimax_report_rfkill_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_report_rfkill_hw()</span></code></a> or
<a class="reference internal" href="#c.wimax_report_rfkill_sw" title="wimax_report_rfkill_sw"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_report_rfkill_sw()</span></code></a> to report it to the stack.</p>
<dl class="type">
<dt id="c.wimax_st">
enum <code class="sig-name descname">wimax_st</code><a class="headerlink" href="#c.wimax_st" title="Permalink to this definition">¶</a></dt>
<dd><p>The different states of a WiMAX device</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__WIMAX_ST_NULL</span></code></dt><dd><p>The device structure has been allocated and zeroed,
but still <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_add()</span></code></a> hasn’t been called. There is no state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIMAX_ST_DOWN</span></code></dt><dd><p>The device has been registered with the WiMAX and
networking stacks, but it is not initialized (normally that is
done with ‘ifconfig DEV up’ [or equivalent], which can upload
firmware and enable communications with the device).
In this state, the device is powered down and using as less
power as possible.
This state is the default after a call to <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_add()</span></code></a>. It
is ok to have drivers move directly to <code class="docutils literal notranslate"><span class="pre">WIMAX_ST_UNINITIALIZED</span></code>
or <code class="docutils literal notranslate"><span class="pre">WIMAX_ST_RADIO_OFF</span></code> in _probe() after the call to
<a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_dev_add()</span></code></a>.
It is recommended that the driver leaves this state when
calling ‘ifconfig DEV up’ and enters it back on ‘ifconfig DEV
down’.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__WIMAX_ST_QUIESCING</span></code></dt><dd><p>The device is being torn down, so no API
operations are allowed to proceed except the ones needed to
complete the device clean up process.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIMAX_ST_UNINITIALIZED</span></code></dt><dd><p>[optional] Communication with the device
is setup, but the device still requires some configuration
before being operational.
Some WiMAX API calls might work.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIMAX_ST_RADIO_OFF</span></code></dt><dd><p>The device is fully up; radio is off (wether
by hardware or software switches).
It is recommended to always leave the device in this state
after initialization.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIMAX_ST_READY</span></code></dt><dd><p>The device is fully up and radio is on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIMAX_ST_SCANNING</span></code></dt><dd><p>[optional] The device has been instructed to
scan. In this state, the device cannot be actively connected to
a network.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIMAX_ST_CONNECTING</span></code></dt><dd><p>The device is connecting to a network. This
state exists because in some devices, the connect process can
include a number of negotiations between user space, kernel
space and the device. User space needs to know what the device
is doing. If the connect sequence in a device is atomic and
fast, the device can transition directly to CONNECTED</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIMAX_ST_CONNECTED</span></code></dt><dd><p>The device is connected to a network.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__WIMAX_ST_INVALID</span></code></dt><dd><p>This is an invalid state used to mark the
maximum numeric value of states.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Transitions from one state to another one are atomic and can only
be caused in kernel space with <a class="reference internal" href="#c.wimax_state_change" title="wimax_state_change"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_state_change()</span></code></a>. To read the
state, use <a class="reference internal" href="#c.wimax_state_get" title="wimax_state_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">wimax_state_get()</span></code></a>.</p>
<p>States starting with __ are internal and shall not be used or
referred to by drivers or userspace. They look ugly, but that’s the
point – if any use is made non-internal to the stack, it is easier
to catch on review.</p>
<p>All API operations [with well defined exceptions] will take the
device mutex before starting and then check the state. If the state
is <code class="docutils literal notranslate"><span class="pre">__WIMAX_ST_NULL</span></code>, <code class="docutils literal notranslate"><span class="pre">WIMAX_ST_DOWN</span></code>, <code class="docutils literal notranslate"><span class="pre">WIMAX_ST_UNINITIALIZED</span></code> or
<code class="docutils literal notranslate"><span class="pre">__WIMAX_ST_QUIESCING</span></code>, it will drop the lock and quit with
-<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>, -<code class="docutils literal notranslate"><span class="pre">ENOMEDIUM</span></code>, -<code class="docutils literal notranslate"><span class="pre">ENOTCONN</span></code> or -<code class="docutils literal notranslate"><span class="pre">ESHUTDOWN</span></code>.</p>
<p>The order of the definitions is important, so we can do numerical
comparisons (eg: &lt; <code class="docutils literal notranslate"><span class="pre">WIMAX_ST_RADIO_OFF</span></code> means the device is not ready
to operate).</p>
</div>
</div>
<div class="section" id="network-device-support">
<h2>Network device support<a class="headerlink" href="#network-device-support" title="Permalink to this headline">¶</a></h2>
<div class="section" id="driver-support">
<h3>Driver Support<a class="headerlink" href="#driver-support" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.dev_add_pack">
void <code class="sig-name descname">dev_add_pack</code><span class="sig-paren">(</span>struct packet_type *<em> pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_add_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>add packet handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">packet_type</span> <span class="pre">*</span> <span class="pre">pt</span></code></dt><dd><p>packet type declaration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Add a protocol handler to the networking stack. The passed <code class="xref c c-type docutils literal notranslate"><span class="pre">packet_type</span></code>
is linked into kernel lists and may not be freed until it has been
removed from the kernel lists.</p>
<p>This call does not sleep therefore it can not
guarantee all CPU’s that are in middle of receiving packets
will see the new packet type (until the next received packet).</p>
</div></blockquote>
<dl class="function">
<dt id="c.__dev_remove_pack">
void <code class="sig-name descname">__dev_remove_pack</code><span class="sig-paren">(</span>struct packet_type *<em> pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_remove_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>remove packet handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">packet_type</span> <span class="pre">*</span> <span class="pre">pt</span></code></dt><dd><p>packet type declaration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a protocol handler that was previously added to the kernel
protocol handlers by <a class="reference internal" href="#c.dev_add_pack" title="dev_add_pack"><code class="xref c c-func docutils literal notranslate"><span class="pre">dev_add_pack()</span></code></a>. The passed <code class="xref c c-type docutils literal notranslate"><span class="pre">packet_type</span></code> is removed
from the kernel lists and can be freed or reused once this function
returns.</p>
<p>The packet type might still be in use by receivers
and must not be freed until after all the CPU’s have gone
through a quiescent state.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_remove_pack">
void <code class="sig-name descname">dev_remove_pack</code><span class="sig-paren">(</span>struct packet_type *<em> pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_remove_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>remove packet handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">packet_type</span> <span class="pre">*</span> <span class="pre">pt</span></code></dt><dd><p>packet type declaration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a protocol handler that was previously added to the kernel
protocol handlers by <a class="reference internal" href="#c.dev_add_pack" title="dev_add_pack"><code class="xref c c-func docutils literal notranslate"><span class="pre">dev_add_pack()</span></code></a>. The passed <code class="xref c c-type docutils literal notranslate"><span class="pre">packet_type</span></code> is removed
from the kernel lists and can be freed or reused once this function
returns.</p>
<p>This call sleeps to guarantee that no CPU is looking at the packet
type after return.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_add_offload">
void <code class="sig-name descname">dev_add_offload</code><span class="sig-paren">(</span>struct packet_offload *<em> po</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_add_offload" title="Permalink to this definition">¶</a></dt>
<dd><p>register offload handlers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">packet_offload</span> <span class="pre">*</span> <span class="pre">po</span></code></dt><dd><p>protocol offload declaration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Add protocol offload handlers to the networking stack. The passed
<code class="xref c c-type docutils literal notranslate"><span class="pre">proto_offload</span></code> is linked into kernel lists and may not be freed until
it has been removed from the kernel lists.</p>
<p>This call does not sleep therefore it can not
guarantee all CPU’s that are in middle of receiving packets
will see the new offload handlers (until the next received packet).</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_remove_offload">
void <code class="sig-name descname">dev_remove_offload</code><span class="sig-paren">(</span>struct packet_offload *<em> po</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_remove_offload" title="Permalink to this definition">¶</a></dt>
<dd><p>remove packet offload handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">packet_offload</span> <span class="pre">*</span> <span class="pre">po</span></code></dt><dd><p>packet offload declaration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a packet offload handler that was previously added to the kernel
offload handlers by <a class="reference internal" href="#c.dev_add_offload" title="dev_add_offload"><code class="xref c c-func docutils literal notranslate"><span class="pre">dev_add_offload()</span></code></a>. The passed <code class="xref c c-type docutils literal notranslate"><span class="pre">offload_type</span></code> is
removed from the kernel lists and can be freed or reused once this
function returns.</p>
<p>This call sleeps to guarantee that no CPU is looking at the packet
type after return.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_boot_setup_check">
int <code class="sig-name descname">netdev_boot_setup_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_boot_setup_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check boot time settings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the netdevice</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check boot time settings for the device.
The found settings are set for the device to be used
later in the device probing.
Returns 0 if no settings found, 1 if they are.</p>
<dl class="function">
<dt id="c.dev_get_iflink">
int <code class="sig-name descname">dev_get_iflink</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_iflink" title="Permalink to this definition">¶</a></dt>
<dd><p>get ‘iflink’ value of a interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>targeted interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Indicates the ifindex the interface is linked to.
Physical interfaces have the same ‘ifindex’ and ‘iflink’ values.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_fill_metadata_dst">
int <code class="sig-name descname">dev_fill_metadata_dst</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_fill_metadata_dst" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve tunnel egress information.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>targeted interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>The packet.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>For better visibility of tunnel traffic OVS needs to retrieve
egress tunnel information for a packet. Following API allows
user to get this info.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__dev_get_by_name">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">__dev_get_by_name</code><span class="sig-paren">(</span>struct net *<em> net</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_get_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name to find</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Find an interface by name. Must be called under RTNL semaphore
or <strong>dev_base_lock</strong>. If the name is found a pointer to the device
is returned. If the name is not found then <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned. The
reference counters are not incremented so the caller must be
careful with locks.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_get_by_name_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_get_by_name_rcu</code><span class="sig-paren">(</span>struct net *<em> net</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_name_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name to find</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find an interface by name.
If the name is found a pointer to the device is returned.
If the name is not found then <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.
The reference counters are not incremented so the caller must be
careful with locks. The caller must hold RCU lock.</p>
<dl class="function">
<dt id="c.dev_get_by_name">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_get_by_name</code><span class="sig-paren">(</span>struct net *<em> net</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name to find</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Find an interface by name. This can be called from any
context and does its own locking. The returned handle has
the usage count incremented and the caller must use <a class="reference internal" href="#c.dev_put" title="dev_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dev_put()</span></code></a> to
release it when it is no longer needed. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if no
matching device is found.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__dev_get_by_index">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">__dev_get_by_index</code><span class="sig-paren">(</span>struct net *<em> net</em>, int<em> ifindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_get_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its ifindex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ifindex</span></code></dt><dd><p>index of device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Search for an interface by index. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the device
is not found or a pointer to the device. The device has not
had its reference counter increased so the caller must be careful
about locking. The caller must hold either the RTNL semaphore
or <strong>dev_base_lock</strong>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_get_by_index_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_get_by_index_rcu</code><span class="sig-paren">(</span>struct net *<em> net</em>, int<em> ifindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_index_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its ifindex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ifindex</span></code></dt><dd><p>index of device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Search for an interface by index. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the device
is not found or a pointer to the device. The device has not
had its reference counter increased so the caller must be careful
about locking. The caller must hold RCU lock.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_get_by_index">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_get_by_index</code><span class="sig-paren">(</span>struct net *<em> net</em>, int<em> ifindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its ifindex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ifindex</span></code></dt><dd><p>index of device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Search for an interface by index. Returns NULL if the device
is not found or a pointer to the device. The device returned has
had a reference added and the pointer is safe until the user calls
dev_put to indicate they have finished with it.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_get_by_napi_id">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_get_by_napi_id</code><span class="sig-paren">(</span>unsigned int<em> napi_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_napi_id" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by napi_id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">napi_id</span></code></dt><dd><p>ID of the NAPI struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Search for an interface by NAPI ID. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the device
is not found or a pointer to the device. The device has not had
its reference counter increased so the caller must be careful
about locking. The caller must hold RCU lock.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_getbyhwaddr_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_getbyhwaddr_rcu</code><span class="sig-paren">(</span>struct net *<em> net</em>, unsigned short<em> type</em>, const char *<em> ha</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_getbyhwaddr_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its hardware address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">type</span></code></dt><dd><p>media type of device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ha</span></code></dt><dd><p>hardware address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Search for an interface by MAC address. Returns NULL if the device
is not found or a pointer to the device.
The caller must hold RCU or RTNL.
The returned device has not had its ref count increased
and the caller must therefore be careful about locking</p>
</div></blockquote>
<dl class="function">
<dt id="c.__dev_get_by_flags">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">__dev_get_by_flags</code><span class="sig-paren">(</span>struct net *<em> net</em>, unsigned short<em> if_flags</em>, unsigned short<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_get_by_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>find any device with given flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">if_flags</span></code></dt><dd><p>IFF_* values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">mask</span></code></dt><dd><p>bitmask of bits in if_flags to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Search for any interface with the given flags. Returns NULL if a device
is not found or a pointer to the device. Must be called inside
rtnl_lock(), and result refcount is unchanged.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_valid_name">
bool <code class="sig-name descname">dev_valid_name</code><span class="sig-paren">(</span>const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_valid_name" title="Permalink to this definition">¶</a></dt>
<dd><p>check if name is okay for network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Network device names need to be valid file names to
to allow sysfs to work.  We also disallow any kind of
whitespace.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_alloc_name">
int <code class="sig-name descname">dev_alloc_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_alloc_name" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a name for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Passed a format string - eg “lt``d``” it will try and find a suitable
id. It scans list of devices to build up a free map, then chooses
the first empty slot. The caller must hold the dev_base or rtnl lock
while allocating the name and adding the device in order to avoid
duplicates.
Limited to bits_per_byte * page size devices (ie 32K on most platforms).
Returns the number of the unit assigned or a negative errno code.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_set_alias">
int <code class="sig-name descname">dev_set_alias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const char *<em> alias</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>change ifalias of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alias</span></code></dt><dd><p>name up to IFALIASZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>limit of bytes to copy from info</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Set ifalias for a device,</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_features_change">
void <code class="sig-name descname">netdev_features_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_features_change" title="Permalink to this definition">¶</a></dt>
<dd><p>device changes features</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to cause notification</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Called to indicate a device has changed features.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_state_change">
void <code class="sig-name descname">netdev_state_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_state_change" title="Permalink to this definition">¶</a></dt>
<dd><p>device changes state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to cause notification</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Called to indicate a device has changed state. This function calls
the notifier chains for netdev_chain and sends a NEWLINK message
to the routing socket.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_notify_peers">
void <code class="sig-name descname">netdev_notify_peers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_notify_peers" title="Permalink to this definition">¶</a></dt>
<dd><p>notify network peers about existence of <strong>dev</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate traffic such that interested network peers are aware of
<strong>dev</strong>, such as by generating a gratuitous ARP. This may be used when
a device wants to inform the rest of the network about some sort of
reconfiguration such as a failover event or virtual machine
migration.</p>
<dl class="function">
<dt id="c.dev_open">
int <code class="sig-name descname">dev_open</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct netlink_ext_ack *<em> extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_open" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare an interface for use.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to open</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*</span> <span class="pre">extack</span></code></dt><dd><p>netlink extended ack</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Takes a device from down to up state. The device’s private open
function is invoked and then the multicast lists are loaded. Finally
the device is moved into the up state and a <code class="docutils literal notranslate"><span class="pre">NETDEV_UP</span></code> message is
sent to the netdev notifier chain.</p>
<p>Calling this function on an active interface is a nop. On a failure
a negative errno code is returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_close">
void <code class="sig-name descname">dev_close</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_close" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown an interface.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to shutdown</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function moves an active device into down state. A
<code class="docutils literal notranslate"><span class="pre">NETDEV_GOING_DOWN</span></code> is sent to the netdev notifier chain. The device
is then deactivated and finally a <code class="docutils literal notranslate"><span class="pre">NETDEV_DOWN</span></code> is sent to the notifier
chain.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_disable_lro">
void <code class="sig-name descname">dev_disable_lro</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_disable_lro" title="Permalink to this definition">¶</a></dt>
<dd><p>disable Large Receive Offload on a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable Large Receive Offload (LRO) on a net device.  Must be
called under RTNL.  This is needed if received packets may be
forwarded to another interface.</p>
</div></blockquote>
<dl class="function">
<dt id="c.register_netdevice_notifier">
int <code class="sig-name descname">register_netdevice_notifier</code><span class="sig-paren">(</span>struct notifier_block *<em> nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdevice_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>register a network notifier block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt><dd><p>notifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a notifier to be called when network device events occur.
The notifier passed is linked into the kernel structures and must
not be reused until it has been unregistered. A negative errno code
is returned on a failure.</p>
<p>When registered all registration and up events are replayed
to the new notifier to allow device to have a race free
view of the network device list.</p>
<dl class="function">
<dt id="c.unregister_netdevice_notifier">
int <code class="sig-name descname">unregister_netdevice_notifier</code><span class="sig-paren">(</span>struct notifier_block *<em> nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a network notifier block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt><dd><p>notifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister a notifier previously registered by
<a class="reference internal" href="#c.register_netdevice_notifier" title="register_netdevice_notifier"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdevice_notifier()</span></code></a>. The notifier is unlinked into the
kernel structures and may then be reused. A negative errno code
is returned on a failure.</p>
<p>After unregistering unregister and down device events are synthesized
for all devices on the device list to the removed notifier to remove
the need for special case cleanup code.</p>
<dl class="function">
<dt id="c.register_netdevice_notifier_net">
int <code class="sig-name descname">register_netdevice_notifier_net</code><span class="sig-paren">(</span>struct net *<em> net</em>, struct notifier_block *<em> nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdevice_notifier_net" title="Permalink to this definition">¶</a></dt>
<dd><p>register a per-netns network notifier block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>network namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt><dd><p>notifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a notifier to be called when network device events occur.
The notifier passed is linked into the kernel structures and must
not be reused until it has been unregistered. A negative errno code
is returned on a failure.</p>
<p>When registered all registration and up events are replayed
to the new notifier to allow device to have a race free
view of the network device list.</p>
<dl class="function">
<dt id="c.unregister_netdevice_notifier_net">
int <code class="sig-name descname">unregister_netdevice_notifier_net</code><span class="sig-paren">(</span>struct net *<em> net</em>, struct notifier_block *<em> nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_notifier_net" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a per-netns network notifier block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>network namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt><dd><p>notifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister a notifier previously registered by
<a class="reference internal" href="#c.register_netdevice_notifier" title="register_netdevice_notifier"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdevice_notifier()</span></code></a>. The notifier is unlinked into the
kernel structures and may then be reused. A negative errno code
is returned on a failure.</p>
<p>After unregistering unregister and down device events are synthesized
for all devices on the device list to the removed notifier to remove
the need for special case cleanup code.</p>
<dl class="function">
<dt id="c.call_netdevice_notifiers">
int <code class="sig-name descname">call_netdevice_notifiers</code><span class="sig-paren">(</span>unsigned long<em> val</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_netdevice_notifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>call all network notifier blocks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">val</span></code></dt><dd><p>value passed unmodified to notifier function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>net_device pointer passed unmodified to notifier function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Call all network notifier blocks.  Parameters and return value
are as for raw_notifier_call_chain().</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_forward_skb">
int <code class="sig-name descname">dev_forward_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_forward_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>loopback an skb to another netif</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>destination network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to forward</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>return values:</dt><dd><p>NET_RX_SUCCESS  (no congestion)
NET_RX_DROP     (packet was dropped, but freed)</p>
</dd>
</dl>
<p>dev_forward_skb can be used for injecting an skb from the
start_xmit function of one device into the receive queue
of another device.</p>
<p>The receiving device may be in another namespace, so
we have to clear all information in the skb that could
impact namespace isolation.</p>
<dl class="function">
<dt id="c.dev_nit_active">
bool <code class="sig-name descname">dev_nit_active</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_nit_active" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if any network interface taps are in use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device to check for the presence of taps</p>
</dd>
</dl>
<dl class="function">
<dt id="c.netif_set_real_num_rx_queues">
int <code class="sig-name descname">netif_set_real_num_rx_queues</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, unsigned int<em> rxq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_set_real_num_rx_queues" title="Permalink to this definition">¶</a></dt>
<dd><p>set actual number of RX queues used</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rxq</span></code></dt><dd><p>Actual number of RX queues</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This must be called either with the rtnl_lock held or before
registration of the net device.  Returns 0 on success, or a
negative error code.  If called before registration, it always
succeeds.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_get_num_default_rss_queues">
int <code class="sig-name descname">netif_get_num_default_rss_queues</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.netif_get_num_default_rss_queues" title="Permalink to this definition">¶</a></dt>
<dd><p>default number of RSS queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine should set an upper limit on the number of RSS queues
used by default by multiqueue devices.</p>
<dl class="function">
<dt id="c.netif_device_detach">
void <code class="sig-name descname">netif_device_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_device_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as removed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark device as removed from system and therefore no longer available.</p>
<dl class="function">
<dt id="c.netif_device_attach">
void <code class="sig-name descname">netif_device_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_device_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as attached</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark device as attached from system and restart if needed.</p>
<dl class="function">
<dt id="c.skb_mac_gso_segment">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_mac_gso_segment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, netdev_features_t<em> features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_mac_gso_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>mac layer segmentation handler.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt><dd><p>features for the output path (see dev-&gt;features)</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__skb_gso_segment">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__skb_gso_segment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, netdev_features_t<em> features</em>, bool<em> tx_path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_gso_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform segmentation on skb.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt><dd><p>features for the output path (see dev-&gt;features)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">tx_path</span></code></dt><dd><p>whether it is called in TX path</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function segments the given skb and returns a list of segments.</p>
<p>It may return NULL if the skb requires no segmentation.  This is
only possible when GSO is used for verifying header integrity.</p>
<p>Segmentation preserves SKB_GSO_CB_OFFSET bytes of previous skb cb.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_loopback_xmit">
int <code class="sig-name descname">dev_loopback_xmit</code><span class="sig-paren">(</span>struct net *<em> net</em>, struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em> sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_loopback_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>loop back <strong>skb</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>network namespace this loopback is happening in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>sk needed to be a netfilter okfn</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to transmit</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rps_may_expire_flow">
bool <code class="sig-name descname">rps_may_expire_flow</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, u16<em> rxq_index</em>, u32<em> flow_id</em>, u16<em> filter_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rps_may_expire_flow" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether an RFS hardware filter may be removed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device on which the filter was set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">rxq_index</span></code></dt><dd><p>RX queue index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flow_id</span></code></dt><dd><p>Flow ID passed to ndo_rx_flow_steer()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">filter_id</span></code></dt><dd><p>Filter ID returned by ndo_rx_flow_steer()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers that implement ndo_rx_flow_steer() should periodically call
this function for each installed filter and remove the filters for
which it returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<dl class="function">
<dt id="c.netif_rx">
int <code class="sig-name descname">netif_rx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>post buffer to the network code</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to post</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function receives a packet from a device driver and queues it for
the upper (protocol) levels to process.  It always succeeds. The buffer
may be dropped during processing for congestion control or by the
protocol layers.</p>
<p>return values:
NET_RX_SUCCESS  (no congestion)
NET_RX_DROP     (packet was dropped)</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_is_rx_handler_busy">
bool <code class="sig-name descname">netdev_is_rx_handler_busy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_is_rx_handler_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if receive handler is registered</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Check if a receive handler is already registered for a given device.
Return true if there one.</p>
<p>The caller must hold the rtnl_mutex.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_rx_handler_register">
int <code class="sig-name descname">netdev_rx_handler_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, rx_handler_func_t *<em> rx_handler</em>, void *<em> rx_handler_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_rx_handler_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register receive handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to register a handler for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_handler_func_t</span> <span class="pre">*</span> <span class="pre">rx_handler</span></code></dt><dd><p>receive handler to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">rx_handler_data</span></code></dt><dd><p>data pointer that is used by rx handler</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Register a receive handler for a device. This handler will then be
called from __netif_receive_skb. A negative errno code is returned
on a failure.</p>
<p>The caller must hold the rtnl_mutex.</p>
<p>For a general description of rx_handler, see enum rx_handler_result.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_rx_handler_unregister">
void <code class="sig-name descname">netdev_rx_handler_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_rx_handler_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister receive handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to unregister a handler from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Unregister a receive handler from a device.</p>
<p>The caller must hold the rtnl_mutex.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_receive_skb_core">
int <code class="sig-name descname">netif_receive_skb_core</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_receive_skb_core" title="Permalink to this definition">¶</a></dt>
<dd><p>special purpose version of netif_receive_skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to process</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>More direct receive version of <a class="reference internal" href="#c.netif_receive_skb" title="netif_receive_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_receive_skb()</span></code></a>.  It should
only be used by callers that have a need to skip RPS and Generic XDP.
Caller must also take care of handling if <code class="docutils literal notranslate"><span class="pre">(page_is_)pfmemalloc</span></code>.</p>
<p>This function may only be called from softirq context and interrupts
should be enabled.</p>
<p>Return values (usually ignored):
NET_RX_SUCCESS: no congestion
NET_RX_DROP: packet was dropped</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_receive_skb">
int <code class="sig-name descname">netif_receive_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_receive_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>process receive buffer from network</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to process</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#c.netif_receive_skb" title="netif_receive_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_receive_skb()</span></code></a> is the main receive data processing function.
It always succeeds. The buffer may be dropped during processing
for congestion control or by the protocol layers.</p>
<p>This function may only be called from softirq context and interrupts
should be enabled.</p>
<p>Return values (usually ignored):
NET_RX_SUCCESS: no congestion
NET_RX_DROP: packet was dropped</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_receive_skb_list">
void <code class="sig-name descname">netif_receive_skb_list</code><span class="sig-paren">(</span>struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_receive_skb_list" title="Permalink to this definition">¶</a></dt>
<dd><p>process many receive buffers from network</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>list of skbs to process.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Since return value of <a class="reference internal" href="#c.netif_receive_skb" title="netif_receive_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_receive_skb()</span></code></a> is normally ignored, and
wouldn’t be meaningful for a list, this function returns void.</p>
<p>This function may only be called from softirq context and interrupts
should be enabled.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__napi_schedule">
void <code class="sig-name descname">__napi_schedule</code><span class="sig-paren">(</span>struct napi_struct *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__napi_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule for receive</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>entry to schedule</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The entry’s receive function will be scheduled to run.
Consider using <a class="reference internal" href="#c.__napi_schedule_irqoff" title="__napi_schedule_irqoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">__napi_schedule_irqoff()</span></code></a> if hard irqs are masked.</p>
<dl class="function">
<dt id="c.napi_schedule_prep">
bool <code class="sig-name descname">napi_schedule_prep</code><span class="sig-paren">(</span>struct napi_struct *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_schedule_prep" title="Permalink to this definition">¶</a></dt>
<dd><p>check if napi can be scheduled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>napi context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if NAPI routine is already running, and if not mark
it as running.  This is used as a condition variable
insure only one NAPI poll instance runs.  We also make
sure there is no pending NAPI disable.</p>
<dl class="function">
<dt id="c.__napi_schedule_irqoff">
void <code class="sig-name descname">__napi_schedule_irqoff</code><span class="sig-paren">(</span>struct napi_struct *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__napi_schedule_irqoff" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule for receive</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>entry to schedule</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Variant of <a class="reference internal" href="#c.__napi_schedule" title="__napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">__napi_schedule()</span></code></a> assuming hard irqs are masked</p>
<dl class="function">
<dt id="c.netdev_has_upper_dev">
bool <code class="sig-name descname">netdev_has_upper_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> upper_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_has_upper_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device is linked to an upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">upper_dev</span></code></dt><dd><p>upper device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out if a device is linked to specified upper device and return true
in case it is. Note that this checks only immediate upper device,
not through a complete stack of devices. The caller must hold the RTNL lock.</p>
<dl class="function">
<dt id="c.netdev_has_upper_dev_all_rcu">
bool <code class="sig-name descname">netdev_has_upper_dev_all_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> upper_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_has_upper_dev_all_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device is linked to an upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">upper_dev</span></code></dt><dd><p>upper device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out if a device is linked to specified upper device and return true
in case it is. Note that this checks the entire upper device chain.
The caller must hold rcu lock.</p>
<dl class="function">
<dt id="c.netdev_has_any_upper_dev">
bool <code class="sig-name descname">netdev_has_any_upper_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_has_any_upper_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device is linked to some device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out if a device is linked to an upper device and return true in case
it is. The caller must hold the RTNL lock.</p>
<dl class="function">
<dt id="c.netdev_master_upper_dev_get">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">netdev_master_upper_dev_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_master_upper_dev_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get master upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a master upper device and return pointer to it or NULL in case
it’s not there. The caller must hold the RTNL lock.</p>
<dl class="function">
<dt id="c.netdev_upper_get_next_dev_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">netdev_upper_get_next_dev_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct list_head **<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_upper_get_next_dev_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next dev from upper list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**</span> <span class="pre">iter</span></code></dt><dd><p>list_head ** of the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next device from the dev’s upper list, starting from iter
position. The caller must hold RCU read lock.</p>
<dl class="function">
<dt id="c.netdev_lower_get_next_private">
void * <code class="sig-name descname">netdev_lower_get_next_private</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct list_head **<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_next_private" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next -&gt;private from the lower neighbour list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**</span> <span class="pre">iter</span></code></dt><dd><p>list_head ** of the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next netdev_adjacent-&gt;private from the dev’s lower neighbour
list, starting from iter position. The caller must hold either hold the
RTNL lock or its own locking that guarantees that the neighbour lower
list will remain unchanged.</p>
<dl class="function">
<dt id="c.netdev_lower_get_next_private_rcu">
void * <code class="sig-name descname">netdev_lower_get_next_private_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct list_head **<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_next_private_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next -&gt;private from the lower neighbour list, RCU variant</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**</span> <span class="pre">iter</span></code></dt><dd><p>list_head ** of the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next netdev_adjacent-&gt;private from the dev’s lower neighbour
list, starting from iter position. The caller must hold RCU read lock.</p>
<dl class="function">
<dt id="c.netdev_lower_get_next">
void * <code class="sig-name descname">netdev_lower_get_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct list_head **<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next device from the lower neighbour list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**</span> <span class="pre">iter</span></code></dt><dd><p>list_head ** of the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next netdev_adjacent from the dev’s lower neighbour
list, starting from iter position. The caller must hold RTNL lock or
its own locking that guarantees that the neighbour lower
list will remain unchanged.</p>
<dl class="function">
<dt id="c.netdev_lower_get_first_private_rcu">
void * <code class="sig-name descname">netdev_lower_get_first_private_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_first_private_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first -&gt;private from the lower neighbour list, RCU variant</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the first netdev_adjacent-&gt;private from the dev’s lower neighbour
list. The caller must hold RCU read lock.</p>
<dl class="function">
<dt id="c.netdev_master_upper_dev_get_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">netdev_master_upper_dev_get_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_master_upper_dev_get_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get master upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a master upper device and return pointer to it or NULL in case
it’s not there. The caller must hold the RCU read lock.</p>
<dl class="function">
<dt id="c.netdev_upper_dev_link">
int <code class="sig-name descname">netdev_upper_dev_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> upper_dev</em>, struct netlink_ext_ack *<em> extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_upper_dev_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a link to the upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">upper_dev</span></code></dt><dd><p>new upper device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*</span> <span class="pre">extack</span></code></dt><dd><p>netlink extended ack</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a link to device which is upper to this one. The caller must hold
the RTNL lock. On a failure a negative errno code is returned.
On success the reference counts are adjusted and the function
returns zero.</p>
<dl class="function">
<dt id="c.netdev_master_upper_dev_link">
int <code class="sig-name descname">netdev_master_upper_dev_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> upper_dev</em>, void *<em> upper_priv</em>, void *<em> upper_info</em>, struct netlink_ext_ack *<em> extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_master_upper_dev_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a master link to the upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">upper_dev</span></code></dt><dd><p>new upper device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">upper_priv</span></code></dt><dd><p>upper device private</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">upper_info</span></code></dt><dd><p>upper info to be passed down via notifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*</span> <span class="pre">extack</span></code></dt><dd><p>netlink extended ack</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a link to device which is upper to this one. In this case, only
one master upper device can be linked, although other non-master devices
might be linked as well. The caller must hold the RTNL lock.
On a failure a negative errno code is returned. On success the reference
counts are adjusted and the function returns zero.</p>
<dl class="function">
<dt id="c.netdev_upper_dev_unlink">
void <code class="sig-name descname">netdev_upper_dev_unlink</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> upper_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_upper_dev_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a link to upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">upper_dev</span></code></dt><dd><p>new upper device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a link to device which is upper to this one. The caller must hold
the RTNL lock.</p>
<dl class="function">
<dt id="c.netdev_bonding_info_change">
void <code class="sig-name descname">netdev_bonding_info_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct netdev_bonding_info *<em> bonding_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_bonding_info_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispatch event about slave change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_bonding_info</span> <span class="pre">*</span> <span class="pre">bonding_info</span></code></dt><dd><p>info to dispatch</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send NETDEV_BONDING_INFO to netdev notifiers with info.
The caller must hold the RTNL lock.</p>
<dl class="function">
<dt id="c.netdev_lower_state_changed">
void <code class="sig-name descname">netdev_lower_state_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> lower_dev</em>, void *<em> lower_state_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_state_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispatch event about lower device state change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">lower_dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">lower_state_info</span></code></dt><dd><p>state to dispatch</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send NETDEV_CHANGELOWERSTATE to netdev notifiers with info.
The caller must hold the RTNL lock.</p>
<dl class="function">
<dt id="c.dev_set_promiscuity">
int <code class="sig-name descname">dev_set_promiscuity</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, int<em> inc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_promiscuity" title="Permalink to this definition">¶</a></dt>
<dd><p>update promiscuity count on a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inc</span></code></dt><dd><p>modifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Add or remove promiscuity from a device. While the count in the device
remains above zero the interface remains promiscuous. Once it hits zero
the device reverts back to normal filtering operation. A negative inc
value is used to drop promiscuity on the device.
Return 0 if successful or a negative errno code on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_set_allmulti">
int <code class="sig-name descname">dev_set_allmulti</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, int<em> inc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_allmulti" title="Permalink to this definition">¶</a></dt>
<dd><p>update allmulti count on a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inc</span></code></dt><dd><p>modifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Add or remove reception of all multicast frames to a device. While the
count in the device remains above zero the interface remains listening
to all interfaces. Once it hits zero the device reverts back to normal
filtering operation. A negative <strong>inc</strong> value is used to drop the counter
when releasing a resource needing all multicasts.
Return 0 if successful or a negative errno code on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_get_flags">
unsigned int <code class="sig-name descname">dev_get_flags</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>get flags reported to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Get the combination of flag bits exported through APIs to userspace.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_change_flags">
int <code class="sig-name descname">dev_change_flags</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, unsigned int<em> flags</em>, struct netlink_ext_ack *<em> extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_change_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>change device settings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>device state flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*</span> <span class="pre">extack</span></code></dt><dd><p>netlink extended ack</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Change settings on device based state flags. The flags are
in the userspace exported format.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_set_group">
void <code class="sig-name descname">dev_set_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, int<em> new_group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Change group this device belongs to</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new_group</span></code></dt><dd><p>group this device should belong to</p>
</dd>
</dl>
<dl class="function">
<dt id="c.dev_pre_changeaddr_notify">
int <code class="sig-name descname">dev_pre_changeaddr_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const char *<em> addr</em>, struct netlink_ext_ack *<em> extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_pre_changeaddr_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Call NETDEV_PRE_CHANGEADDR.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>new address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*</span> <span class="pre">extack</span></code></dt><dd><p>netlink extended ack</p>
</dd>
</dl>
<dl class="function">
<dt id="c.dev_set_mac_address">
int <code class="sig-name descname">dev_set_mac_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct sockaddr *<em> sa</em>, struct netlink_ext_ack *<em> extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_mac_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Change Media Access Control Address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">sa</span></code></dt><dd><p>new address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*</span> <span class="pre">extack</span></code></dt><dd><p>netlink extended ack</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Change the hardware (MAC) address of the device</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_change_carrier">
int <code class="sig-name descname">dev_change_carrier</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, bool<em> new_carrier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_change_carrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Change device carrier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">new_carrier</span></code></dt><dd><p>new value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Change device carrier</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_get_phys_port_id">
int <code class="sig-name descname">dev_get_phys_port_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct netdev_phys_item_id *<em> ppid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_phys_port_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device physical port ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_phys_item_id</span> <span class="pre">*</span> <span class="pre">ppid</span></code></dt><dd><p>port ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Get device physical port ID</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_get_phys_port_name">
int <code class="sig-name descname">dev_get_phys_port_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, char *<em> name</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_phys_port_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device physical port name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>port name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>limit of bytes to copy to name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Get device physical port name</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_get_port_parent_id">
int <code class="sig-name descname">dev_get_port_parent_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct netdev_phys_item_id *<em> ppid</em>, bool<em> recurse</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_port_parent_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the device’s port parent identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_phys_item_id</span> <span class="pre">*</span> <span class="pre">ppid</span></code></dt><dd><p>pointer to a storage for the port’s parent identifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">recurse</span></code></dt><dd><p>allow/disallow recursion to lower devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Get the devices’s port parent identifier</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_port_same_parent_id">
bool <code class="sig-name descname">netdev_port_same_parent_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> a</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_port_same_parent_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if two network devices have the same port parent identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">a</span></code></dt><dd><p>first network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">b</span></code></dt><dd><p>second network device</p>
</dd>
</dl>
<dl class="function">
<dt id="c.dev_change_proto_down">
int <code class="sig-name descname">dev_change_proto_down</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, bool<em> proto_down</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_change_proto_down" title="Permalink to this definition">¶</a></dt>
<dd><p>update protocol port state information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">proto_down</span></code></dt><dd><p>new value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This info can be used by switch drivers to set the phys state of the
port.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_change_proto_down_generic">
int <code class="sig-name descname">dev_change_proto_down_generic</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, bool<em> proto_down</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_change_proto_down_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>generic implementation for ndo_change_proto_down that sets carrier according to proto_down.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">proto_down</span></code></dt><dd><p>new value</p>
</dd>
</dl>
<dl class="function">
<dt id="c.netdev_update_features">
void <code class="sig-name descname">netdev_update_features</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_update_features" title="Permalink to this definition">¶</a></dt>
<dd><p>recalculate device features</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Recalculate dev-&gt;features set and send notifications if it
has changed. Should be called after driver or hardware dependent
conditions might have changed that influence the features.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_change_features">
void <code class="sig-name descname">netdev_change_features</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_change_features" title="Permalink to this definition">¶</a></dt>
<dd><p>recalculate device features</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Recalculate dev-&gt;features set and send notifications even
if they have not changed. Should be called instead of
<a class="reference internal" href="#c.netdev_update_features" title="netdev_update_features"><code class="xref c c-func docutils literal notranslate"><span class="pre">netdev_update_features()</span></code></a> if also dev-&gt;vlan_features might
have changed to allow the changes to be propagated to stacked
VLAN devices.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_stacked_transfer_operstate">
void <code class="sig-name descname">netif_stacked_transfer_operstate</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> rootdev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_stacked_transfer_operstate" title="Permalink to this definition">¶</a></dt>
<dd><p>transfer operstate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">rootdev</span></code></dt><dd><p>the root or lower level device to transfer state from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the device to transfer operstate to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Transfer operational state from root to device. This is normally
called when a stacking relationship exists between the root
device and the device(a leaf device).</p>
</div></blockquote>
<dl class="function">
<dt id="c.register_netdevice">
int <code class="sig-name descname">register_netdevice</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdevice" title="Permalink to this definition">¶</a></dt>
<dd><p>register a network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Take a completed network device structure and add it to the kernel
interfaces. A <code class="docutils literal notranslate"><span class="pre">NETDEV_REGISTER</span></code> message is sent to the netdev notifier
chain. 0 is returned on success. A negative errno code is returned
on a failure to set up the device, or if the name is a duplicate.</p>
<p>Callers must hold the rtnl semaphore. You may want
<a class="reference internal" href="#c.register_netdev" title="register_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdev()</span></code></a> instead of this.</p>
<p>BUGS:
The locking appears insufficient to guarantee two parallel registers
will not get the same name.</p>
</div></blockquote>
<dl class="function">
<dt id="c.init_dummy_netdev">
int <code class="sig-name descname">init_dummy_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_dummy_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>init a dummy network device for NAPI</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to init</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This takes a network device structure and initialize the minimum
amount of fields so it can be used to schedule NAPI polls without
registering a full blown interface. This is to be used by drivers
that need to tie several hardware interfaces to a single NAPI
poll scheduler due to HW limitations.</p>
</div></blockquote>
<dl class="function">
<dt id="c.register_netdev">
int <code class="sig-name descname">register_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>register a network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Take a completed network device structure and add it to the kernel
interfaces. A <code class="docutils literal notranslate"><span class="pre">NETDEV_REGISTER</span></code> message is sent to the netdev notifier
chain. 0 is returned on success. A negative errno code is returned
on a failure to set up the device, or if the name is a duplicate.</p>
<p>This is a wrapper around register_netdevice that takes the rtnl semaphore
and expands the device name if you passed a format string to
alloc_netdev.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_get_stats">
struct rtnl_link_stats64 * <code class="sig-name descname">dev_get_stats</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct rtnl_link_stats64 *<em> storage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>get network device statistics</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to get statistics from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rtnl_link_stats64</span> <span class="pre">*</span> <span class="pre">storage</span></code></dt><dd><p>place to store stats</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Get network statistics from device. Return <strong>storage</strong>.
The device driver may provide its own method by setting
dev-&gt;netdev_ops-&gt;get_stats64 or dev-&gt;netdev_ops-&gt;get_stats;
otherwise the internal statistics structure is used.</p>
</div></blockquote>
<dl class="function">
<dt id="c.alloc_netdev_mqs">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">alloc_netdev_mqs</code><span class="sig-paren">(</span>int<em> sizeof_priv</em>, const char *<em> name</em>, unsigned char<em> name_assign_type</em>, void (*setup) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *</em>, unsigned int<em> txqs</em>, unsigned int<em> rxqs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_netdev_mqs" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sizeof_priv</span></code></dt><dd><p>size of private data to allocate space for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>device name format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">name_assign_type</span></code></dt><dd><p>origin of device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span> <span class="pre">setup</span></code></dt><dd><p>callback to initialize device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">txqs</span></code></dt><dd><p>the number of TX subqueues to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rxqs</span></code></dt><dd><p>the number of RX subqueues to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a struct net_device with private data area for driver use
and performs basic initialization.  Also allocates subqueue structs
for each queue on the device.</p>
<dl class="function">
<dt id="c.free_netdev">
void <code class="sig-name descname">free_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>free network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does the last stage of destroying an allocated device
interface. The reference to the device object is released. If this
is the last reference then it will be freed.Must be called in process
context.</p>
<dl class="function">
<dt id="c.synchronize_net">
void <code class="sig-name descname">synchronize_net</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_net" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchronize with packet receive processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Wait for packets currently being received to be done.
Does not block later packets from starting.</p>
</div></blockquote>
<dl class="function">
<dt id="c.unregister_netdevice_queue">
void <code class="sig-name descname">unregister_netdevice_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>remove device from the kernel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function shuts down a device interface and removes it
from the kernel tables.
If head not NULL, device is queued to be unregistered later.</p>
<p>Callers must hold the rtnl semaphore.  You may want
<a class="reference internal" href="#c.unregister_netdev" title="unregister_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">unregister_netdev()</span></code></a> instead of this.</p>
</div></blockquote>
<dl class="function">
<dt id="c.unregister_netdevice_many">
void <code class="sig-name descname">unregister_netdevice_many</code><span class="sig-paren">(</span>struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_many" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister many devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>list of devices</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>As most callers use a stack allocated list_head,</dt><dd><p>we force a <a class="reference internal" href="../core-api/kernel-api.html#c.list_del" title="list_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del()</span></code></a> to make sure stack wont be corrupted later.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.unregister_netdev">
void <code class="sig-name descname">unregister_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>remove device from the kernel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function shuts down a device interface and removes it
from the kernel tables.</p>
<p>This is just a wrapper for unregister_netdevice that takes
the rtnl semaphore.  In general you want to use this and not
unregister_netdevice.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_change_net_namespace">
int <code class="sig-name descname">dev_change_net_namespace</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct net *<em> net</em>, const char *<em> pat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_change_net_namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>move device to different nethost namespace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt><dd><p>network namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pat</span></code></dt><dd><p>If not NULL name pattern to try if the current device name
is already taken in the destination network namespace.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function shuts down a device interface and moves it
to a new network namespace. On success 0 is returned, on
a failure a netagive errno code is returned.</p>
<p>Callers must hold the rtnl semaphore.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_increment_features">
netdev_features_t <code class="sig-name descname">netdev_increment_features</code><span class="sig-paren">(</span>netdev_features_t<em> all</em>, netdev_features_t<em> one</em>, netdev_features_t<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_increment_features" title="Permalink to this definition">¶</a></dt>
<dd><p>increment feature set by one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">all</span></code></dt><dd><p>current feature set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">one</span></code></dt><dd><p>new feature set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">mask</span></code></dt><dd><p>mask feature set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Computes a new feature set after adding a device with feature set
<strong>one</strong> to the master device with current feature set <strong>all</strong>.  Will not
enable anything that is off in <strong>mask</strong>. Returns the new feature set.</p>
</div></blockquote>
<dl class="function">
<dt id="c.eth_header">
int <code class="sig-name descname">eth_header</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, unsigned short<em> type</em>, const void *<em> daddr</em>, const void *<em> saddr</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header" title="Permalink to this definition">¶</a></dt>
<dd><p>create the Ethernet header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>buffer to alter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>source device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">type</span></code></dt><dd><p>Ethernet type field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">daddr</span></code></dt><dd><p>destination address (NULL leave destination address)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">saddr</span></code></dt><dd><p>source address (NULL use device source address)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>packet length (&lt;= skb-&gt;len)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the protocol type. For a packet of type ETH_P_802_3/2 we put the length
in here instead.</p>
<dl class="function">
<dt id="c.eth_get_headlen">
u32 <code class="sig-name descname">eth_get_headlen</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, void *<em> data</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_get_headlen" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the length of header for an ethernet frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>pointer to network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>pointer to start of frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>total length of frame</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make a best effort attempt to pull the length for all of the headers for
a given frame in a linear buffer.</p>
<dl class="function">
<dt id="c.eth_type_trans">
__be16 <code class="sig-name descname">eth_type_trans</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_type_trans" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the packet’s protocol ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>received socket data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>receiving network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The rule here is that we
assume 802.3 if the type field is short enough to be a length.
This is normal practice and works for any ‘now in use’ protocol.</p>
<dl class="function">
<dt id="c.eth_header_parse">
int <code class="sig-name descname">eth_header_parse</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, unsigned char *<em> haddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>extract hardware address from packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>packet to extract header from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">haddr</span></code></dt><dd><p>destination buffer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.eth_header_cache">
int <code class="sig-name descname">eth_header_cache</code><span class="sig-paren">(</span>const struct neighbour *<em> neigh</em>, struct hh_cache *<em> hh</em>, __be16<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>fill cache entry from neighbour</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">neighbour</span> <span class="pre">*</span> <span class="pre">neigh</span></code></dt><dd><p>source neighbour</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hh_cache</span> <span class="pre">*</span> <span class="pre">hh</span></code></dt><dd><p>destination cache entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be16</span> <span class="pre">type</span></code></dt><dd><p>Ethernet type field</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create an Ethernet header template from the neighbour.</p>
<dl class="function">
<dt id="c.eth_header_cache_update">
void <code class="sig-name descname">eth_header_cache_update</code><span class="sig-paren">(</span>struct hh_cache *<em> hh</em>, const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const unsigned char *<em> haddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_cache_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update cache entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hh_cache</span> <span class="pre">*</span> <span class="pre">hh</span></code></dt><dd><p>destination cache entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">haddr</span></code></dt><dd><p>new hardware address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by Address Resolution module to notify changes in address.</p>
<dl class="function">
<dt id="c.eth_header_parse_protocol">
__be16 <code class="sig-name descname">eth_header_parse_protocol</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_parse_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>extract protocol from L2 header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>packet to extract protocol from</p>
</dd>
</dl>
<dl class="function">
<dt id="c.eth_prepare_mac_addr_change">
int <code class="sig-name descname">eth_prepare_mac_addr_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, void *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_prepare_mac_addr_change" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare for mac change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>socket address</p>
</dd>
</dl>
<dl class="function">
<dt id="c.eth_commit_mac_addr_change">
void <code class="sig-name descname">eth_commit_mac_addr_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, void *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_commit_mac_addr_change" title="Permalink to this definition">¶</a></dt>
<dd><p>commit mac change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>socket address</p>
</dd>
</dl>
<dl class="function">
<dt id="c.eth_mac_addr">
int <code class="sig-name descname">eth_mac_addr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, void *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_mac_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>set new Ethernet hardware address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>socket address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change hardware address of device.</p>
<p>This doesn’t change hardware matching, so needs to be overridden
for most real devices.</p>
<dl class="function">
<dt id="c.ether_setup">
void <code class="sig-name descname">ether_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>setup Ethernet network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the fields of the device structure with Ethernet-generic values.</p>
<dl class="function">
<dt id="c.alloc_etherdev_mqs">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">alloc_etherdev_mqs</code><span class="sig-paren">(</span>int<em> sizeof_priv</em>, unsigned int<em> txqs</em>, unsigned int<em> rxqs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_etherdev_mqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates and sets up an Ethernet device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sizeof_priv</span></code></dt><dd><p>Size of additional driver-private structure to be allocated
for this Ethernet device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">txqs</span></code></dt><dd><p>The number of TX queues this device has.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rxqs</span></code></dt><dd><p>The number of RX queues this device has.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the fields of the device structure with Ethernet-generic
values. Basically does everything except registering the device.</p>
<p>Constructs a new net device, complete with a private data area of
size (sizeof_priv).  A 32-byte (not bit) alignment is enforced for
this private data area.</p>
<dl class="function">
<dt id="c.nvmem_get_mac_address">
int <code class="sig-name descname">nvmem_get_mac_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, void *<em> addrbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nvmem_get_mac_address" title="Permalink to this definition">¶</a></dt>
<dd><p>address’ associated with given device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device with which the mac-address cell is associated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addrbuf</span></code></dt><dd><p>Buffer to which the MAC address will be copied on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error number on failure.</p>
<dl class="function">
<dt id="c.netif_carrier_on">
void <code class="sig-name descname">netif_carrier_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_carrier_on" title="Permalink to this definition">¶</a></dt>
<dd><p>set carrier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device has detected acquisition of carrier.</p>
<dl class="function">
<dt id="c.netif_carrier_off">
void <code class="sig-name descname">netif_carrier_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_carrier_off" title="Permalink to this definition">¶</a></dt>
<dd><p>clear carrier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device has detected loss of carrier.</p>
<dl class="function">
<dt id="c.is_link_local_ether_addr">
bool <code class="sig-name descname">is_link_local_ether_addr</code><span class="sig-paren">(</span>const u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_link_local_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given Ethernet address is link-local</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if address is link local reserved addr (01:80:c2:00:00:0X) per
IEEE 802.1Q 8.6.3 Frame filtering.</p>
<p>Please note: addr must be aligned to u16.</p>
<dl class="function">
<dt id="c.is_zero_ether_addr">
bool <code class="sig-name descname">is_zero_ether_addr</code><span class="sig-paren">(</span>const u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_zero_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if give Ethernet address is all zeros.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is all zeroes.</p>
<p>Please note: addr must be aligned to u16.</p>
<dl class="function">
<dt id="c.is_multicast_ether_addr">
bool <code class="sig-name descname">is_multicast_ether_addr</code><span class="sig-paren">(</span>const u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_multicast_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is a multicast.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is a multicast address.
By definition the broadcast address is also a multicast address.</p>
<dl class="function">
<dt id="c.is_local_ether_addr">
bool <code class="sig-name descname">is_local_ether_addr</code><span class="sig-paren">(</span>const u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_local_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is locally-assigned one (IEEE 802).</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is a local address.</p>
<dl class="function">
<dt id="c.is_broadcast_ether_addr">
bool <code class="sig-name descname">is_broadcast_ether_addr</code><span class="sig-paren">(</span>const u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_broadcast_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is broadcast</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is the broadcast address.</p>
<p>Please note: addr must be aligned to u16.</p>
<dl class="function">
<dt id="c.is_unicast_ether_addr">
bool <code class="sig-name descname">is_unicast_ether_addr</code><span class="sig-paren">(</span>const u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_unicast_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is unicast</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is a unicast address.</p>
<dl class="function">
<dt id="c.is_valid_ether_addr">
bool <code class="sig-name descname">is_valid_ether_addr</code><span class="sig-paren">(</span>const u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_valid_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the given Ethernet address is valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not
a multicast address, and is not FF:FF:FF:FF:FF:FF.</p>
<p>Return true if the address is valid.</p>
<p>Please note: addr must be aligned to u16.</p>
<dl class="function">
<dt id="c.eth_proto_is_802_3">
bool <code class="sig-name descname">eth_proto_is_802_3</code><span class="sig-paren">(</span>__be16<em> proto</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_proto_is_802_3" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a given Ethertype/length is a protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__be16</span> <span class="pre">proto</span></code></dt><dd><p>Ethertype/length value to be tested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check that the value from the Ethertype/length field is a valid Ethertype.</p>
<p>Return true if the valid is an 802.3 supported Ethertype.</p>
<dl class="function">
<dt id="c.eth_random_addr">
void <code class="sig-name descname">eth_random_addr</code><span class="sig-paren">(</span>u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_random_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate software assigned random Ethernet address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate a random Ethernet address (MAC) that is not multicast
and has the local assigned bit set.</p>
<dl class="function">
<dt id="c.eth_broadcast_addr">
void <code class="sig-name descname">eth_broadcast_addr</code><span class="sig-paren">(</span>u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_broadcast_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign broadcast address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assign the broadcast address to the given address array.</p>
<dl class="function">
<dt id="c.eth_zero_addr">
void <code class="sig-name descname">eth_zero_addr</code><span class="sig-paren">(</span>u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_zero_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign zero address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assign the zero address to the given address array.</p>
<dl class="function">
<dt id="c.eth_hw_addr_random">
void <code class="sig-name descname">eth_hw_addr_random</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_hw_addr_random" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate software assigned random Ethernet and set device flag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate a random Ethernet address (MAC) to be used by a net device
and set addr_assign_type so the state can be read by sysfs and be
used by userspace.</p>
<dl class="function">
<dt id="c.ether_addr_copy">
void <code class="sig-name descname">ether_addr_copy</code><span class="sig-paren">(</span>u8 *<em> dst</em>, const u8 *<em> src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy an Ethernet address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>Pointer to a six-byte array Ethernet address destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>Pointer to a six-byte array Ethernet address source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Please note: dst &amp; src must both be aligned to u16.</p>
<dl class="function">
<dt id="c.eth_hw_addr_inherit">
void <code class="sig-name descname">eth_hw_addr_inherit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dst</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_hw_addr_inherit" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy dev_addr from another net_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>pointer to net_device to copy dev_addr to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>pointer to net_device to copy dev_addr from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the Ethernet address from one net_device to another along with
the address attributes (addr_assign_type).</p>
<dl class="function">
<dt id="c.ether_addr_equal">
bool <code class="sig-name descname">ether_addr_equal</code><span class="sig-paren">(</span>const u8 *<em> addr1</em>, const u8 *<em> addr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet addresses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr1</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr2</span></code></dt><dd><p>Pointer other six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses, returns true if equal</p>
<p>Please note: addr1 &amp; addr2 must both be aligned to u16.</p>
<dl class="function">
<dt id="c.ether_addr_equal_64bits">
bool <code class="sig-name descname">ether_addr_equal_64bits</code><span class="sig-paren">(</span>const u8<em> addr1</em>, const u8<em> addr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal_64bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet addresses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">addr1</span></code></dt><dd><p>Pointer to an array of 8 bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">addr2</span></code></dt><dd><p>Pointer to an other array of 8 bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses, returns true if equal, false otherwise.</p>
<p>The function doesn’t need any conditional branches and possibly uses
word memory accesses on CPU allowing cheap unaligned memory reads.
arrays = { byte1, byte2, byte3, byte4, byte5, byte6, pad1, pad2 }</p>
<p>Please note that alignment of addr1 &amp; addr2 are only guaranteed to be 16 bits.</p>
<dl class="function">
<dt id="c.ether_addr_equal_unaligned">
bool <code class="sig-name descname">ether_addr_equal_unaligned</code><span class="sig-paren">(</span>const u8 *<em> addr1</em>, const u8 *<em> addr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal_unaligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two not u16 aligned Ethernet addresses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr1</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr2</span></code></dt><dd><p>Pointer other six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses, returns true if equal</p>
<p>Please note: Use only when any Ethernet address may not be u16 aligned.</p>
<dl class="function">
<dt id="c.ether_addr_equal_masked">
bool <code class="sig-name descname">ether_addr_equal_masked</code><span class="sig-paren">(</span>const u8 *<em> addr1</em>, const u8 *<em> addr2</em>, const u8 *<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet addresses with a mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr1</span></code></dt><dd><p>Pointer to a six-byte array containing the 1st Ethernet address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr2</span></code></dt><dd><p>Pointer to a six-byte array containing the 2nd Ethernet address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">mask</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address bitmask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses with a mask, returns true if for every bit
set in the bitmask the equivalent bits in the ethernet addresses are equal.
Using a mask with all bits set is a slower ether_addr_equal.</p>
<dl class="function">
<dt id="c.ether_addr_to_u64">
u64 <code class="sig-name descname">ether_addr_to_u64</code><span class="sig-paren">(</span>const u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_to_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an Ethernet address into a u64 value.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return a u64 value of the address</p>
<dl class="function">
<dt id="c.u64_to_ether_addr">
void <code class="sig-name descname">u64_to_ether_addr</code><span class="sig-paren">(</span>u64<em> u</em>, u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.u64_to_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a u64 to an Ethernet address.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">u</span></code></dt><dd><p>u64 to convert to an Ethernet MAC address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array to contain the Ethernet address</p>
</dd>
</dl>
<dl class="function">
<dt id="c.eth_addr_dec">
void <code class="sig-name descname">eth_addr_dec</code><span class="sig-paren">(</span>u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_addr_dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement the given MAC address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing Ethernet address to decrement</p>
</dd>
</dl>
<dl class="function">
<dt id="c.eth_addr_inc">
void <code class="sig-name descname">eth_addr_inc</code><span class="sig-paren">(</span>u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_addr_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the given MAC address.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing Ethernet address to increment.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.is_etherdev_addr">
bool <code class="sig-name descname">is_etherdev_addr</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_etherdev_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell if given Ethernet address belongs to the device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Pointer to a device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare passed address with all addresses of the device. Return true if the
address if one of the device addresses.</p>
<p>Note that this function calls <a class="reference internal" href="#c.ether_addr_equal_64bits" title="ether_addr_equal_64bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">ether_addr_equal_64bits()</span></code></a> so take care of
the right padding.</p>
<dl class="function">
<dt id="c.compare_ether_header">
unsigned long <code class="sig-name descname">compare_ether_header</code><span class="sig-paren">(</span>const void *<em> a</em>, const void *<em> b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.compare_ether_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet headers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">a</span></code></dt><dd><p>Pointer to Ethernet header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">b</span></code></dt><dd><p>Pointer to Ethernet header</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet headers, returns 0 if equal.
This assumes that the network header (i.e., IP header) is 4-byte
aligned OR the platform can handle unaligned access.  This is the
case for all packets coming into netif_receive_skb or similar
entry points.</p>
<dl class="function">
<dt id="c.eth_skb_pad">
int <code class="sig-name descname">eth_skb_pad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_skb_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad buffer to mininum number of octets for Ethernet frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>Buffer to pad</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An Ethernet frame should have a minimum size of 60 bytes.  This function
takes short frames and pads them with zeros up to the 60 byte limit.</p>
<dl class="function">
<dt id="c.napi_schedule">
void <code class="sig-name descname">napi_schedule</code><span class="sig-paren">(</span>struct napi_struct *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule NAPI poll</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule NAPI poll routine to be called if it is not already
running.</p>
<dl class="function">
<dt id="c.napi_schedule_irqoff">
void <code class="sig-name descname">napi_schedule_irqoff</code><span class="sig-paren">(</span>struct napi_struct *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_schedule_irqoff" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule NAPI poll</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Variant of <a class="reference internal" href="#c.napi_schedule" title="napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_schedule()</span></code></a>, assuming hard irqs are masked.</p>
<dl class="function">
<dt id="c.napi_complete">
bool <code class="sig-name descname">napi_complete</code><span class="sig-paren">(</span>struct napi_struct *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>NAPI processing complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark NAPI processing as complete.
Consider using napi_complete_done() instead.
Return false if device should avoid rearming interrupts.</p>
<dl class="function">
<dt id="c.napi_hash_del">
bool <code class="sig-name descname">napi_hash_del</code><span class="sig-paren">(</span>struct napi_struct *<em> napi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_hash_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a NAPI from global table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">napi</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Warning: caller must observe RCU grace period
before freeing memory containing <strong>napi</strong>, if
this function returns true.</p>
<p><strong>Note</strong></p>
<p>core networking stack automatically calls it
from <a class="reference internal" href="#c.netif_napi_del" title="netif_napi_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_del()</span></code></a>.
Drivers might want to call this helper to combine all
the needed RCU grace periods into a single one.</p>
<dl class="function">
<dt id="c.napi_disable">
void <code class="sig-name descname">napi_disable</code><span class="sig-paren">(</span>struct napi_struct *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>prevent NAPI from scheduling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop NAPI from being scheduled on this context.
Waits till any outstanding processing completes.</p>
<dl class="function">
<dt id="c.napi_enable">
void <code class="sig-name descname">napi_enable</code><span class="sig-paren">(</span>struct napi_struct *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable NAPI scheduling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resume NAPI from being scheduled on this context.
Must be paired with napi_disable.</p>
<dl class="function">
<dt id="c.napi_synchronize">
void <code class="sig-name descname">napi_synchronize</code><span class="sig-paren">(</span>const struct napi_struct *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_synchronize" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until NAPI is not running</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until NAPI is done being scheduled on this context.
Waits till any outstanding processing completes but
does not disable future activations.</p>
<dl class="function">
<dt id="c.napi_if_scheduled_mark_missed">
bool <code class="sig-name descname">napi_if_scheduled_mark_missed</code><span class="sig-paren">(</span>struct napi_struct *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_if_scheduled_mark_missed" title="Permalink to this definition">¶</a></dt>
<dd><p>if napi is running, set the NAPIF_STATE_MISSED</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If napi is running, set the NAPIF_STATE_MISSED, and return true if
NAPI is scheduled.</p>
<dl class="type">
<dt id="c.netdev_priv_flags">
enum <code class="sig-name descname">netdev_priv_flags</code><a class="headerlink" href="#c.netdev_priv_flags" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#c.net_device" title="net_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span></code></a> priv_flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IFF_802_1Q_VLAN</span></code></dt><dd><p>802.1Q VLAN device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_EBRIDGE</span></code></dt><dd><p>Ethernet bridging device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_BONDING</span></code></dt><dd><p>bonding master or slave</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_ISATAP</span></code></dt><dd><p>ISATAP interface (RFC4214)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_WAN_HDLC</span></code></dt><dd><p>WAN HDLC device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_XMIT_DST_RELEASE</span></code></dt><dd><p>dev_hard_start_xmit() is allowed to
release skb-&gt;dst</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_DONT_BRIDGE</span></code></dt><dd><p>disallow bridging this ether dev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_DISABLE_NETPOLL</span></code></dt><dd><p>disable netpoll at run-time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_MACVLAN_PORT</span></code></dt><dd><p>device used as macvlan port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_BRIDGE_PORT</span></code></dt><dd><p>device used as bridge port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_OVS_DATAPATH</span></code></dt><dd><p>device used as Open vSwitch datapath port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_TX_SKB_SHARING</span></code></dt><dd><p>The interface supports sharing skbs on transmit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_UNICAST_FLT</span></code></dt><dd><p>Supports unicast filtering</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_TEAM_PORT</span></code></dt><dd><p>device used as team port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_SUPP_NOFCS</span></code></dt><dd><p>device supports sending custom FCS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_LIVE_ADDR_CHANGE</span></code></dt><dd><p>device supports hardware address
change when it’s running</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_MACVLAN</span></code></dt><dd><p>Macvlan device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_XMIT_DST_RELEASE_PERM</span></code></dt><dd><p>IFF_XMIT_DST_RELEASE not taking into account
underlying stacked devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_L3MDEV_MASTER</span></code></dt><dd><p>device is an L3 master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_NO_QUEUE</span></code></dt><dd><p>device can run without qdisc attached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_OPENVSWITCH</span></code></dt><dd><p>device is a Open vSwitch master</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_L3MDEV_SLAVE</span></code></dt><dd><p>device is enslaved to an L3 master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_TEAM</span></code></dt><dd><p>device is a team device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_RXFH_CONFIGURED</span></code></dt><dd><p>device has had Rx Flow indirection table configured</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_PHONY_HEADROOM</span></code></dt><dd><p>the headroom value is controlled by an external
entity (i.e. the master device for bridged veth)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_MACSEC</span></code></dt><dd><p>device is a MACsec device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_NO_RX_HANDLER</span></code></dt><dd><p>device doesn’t support the rx_handler hook</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_FAILOVER</span></code></dt><dd><p>device is a failover master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_FAILOVER_SLAVE</span></code></dt><dd><p>device is lower dev of a failover master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_L3MDEV_RX_HANDLER</span></code></dt><dd><p>only invoke the rx handler of L3 master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_LIVE_RENAME_OK</span></code></dt><dd><p>rename is allowed while device is up and running</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These are the <a class="reference internal" href="#c.net_device" title="net_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span></code></a>, they are only set internally
by drivers and used in the kernel. These flags are invisible to
userspace; this means that the order of these flags can change
during any kernel release.</p>
<p>You should have a pretty good reason to be extending these flags.</p>
<dl class="type">
<dt id="c.net_device">
struct <code class="sig-name descname">net_device</code><a class="headerlink" href="#c.net_device" title="Permalink to this definition">¶</a></dt>
<dd><p>The DEVICE structure.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct net_device {
  char name[IFNAMSIZ];
  struct netdev_name_node *name_node;
  struct dev_ifalias      __rcu *ifalias;
  unsigned long           mem_end;
  unsigned long           mem_start;
  unsigned long           base_addr;
  int irq;
  unsigned long           state;
  struct list_head        dev_list;
  struct list_head        napi_list;
  struct list_head        unreg_list;
  struct list_head        close_list;
  struct list_head        ptype_all;
  struct list_head        ptype_specific;
  struct {
    struct list_head upper;
    struct list_head lower;
  } adj_list;
  netdev_features_t features;
  netdev_features_t hw_features;
  netdev_features_t wanted_features;
  netdev_features_t vlan_features;
  netdev_features_t hw_enc_features;
  netdev_features_t mpls_features;
  netdev_features_t gso_partial_features;
  int ifindex;
  int group;
  struct net_device_stats stats;
  atomic_long_t rx_dropped;
  atomic_long_t tx_dropped;
  atomic_long_t rx_nohandler;
  atomic_t carrier_up_count;
  atomic_t carrier_down_count;
#ifdef CONFIG_WIRELESS_EXT;
  const struct iw_handler_def *wireless_handlers;
  struct iw_public_data   *wireless_data;
#endif;
  const struct net_device_ops *netdev_ops;
  const struct ethtool_ops *ethtool_ops;
#ifdef CONFIG_NET_L3_MASTER_DEV;
  const struct l3mdev_ops *l3mdev_ops;
#endif;
#if IS_ENABLED(CONFIG_IPV6);
  const struct ndisc_ops *ndisc_ops;
#endif;
#ifdef CONFIG_XFRM_OFFLOAD;
  const struct xfrmdev_ops *xfrmdev_ops;
#endif;
#if IS_ENABLED(CONFIG_TLS_DEVICE);
  const struct tlsdev_ops *tlsdev_ops;
#endif;
  const struct header_ops *header_ops;
  unsigned int            flags;
  unsigned int            priv_flags;
  unsigned short          gflags;
  unsigned short          padded;
  unsigned char           operstate;
  unsigned char           link_mode;
  unsigned char           if_port;
  unsigned char           dma;
  unsigned int            mtu;
  unsigned int            min_mtu;
  unsigned int            max_mtu;
  unsigned short          type;
  unsigned short          hard_header_len;
  unsigned char           min_header_len;
  unsigned short          needed_headroom;
  unsigned short          needed_tailroom;
  unsigned char           perm_addr[MAX_ADDR_LEN];
  unsigned char           addr_assign_type;
  unsigned char           addr_len;
  unsigned char           upper_level;
  unsigned char           lower_level;
  unsigned short          neigh_priv_len;
  unsigned short          dev_id;
  unsigned short          dev_port;
  spinlock_t addr_list_lock;
  unsigned char           name_assign_type;
  bool uc_promisc;
  struct netdev_hw_addr_list      uc;
  struct netdev_hw_addr_list      mc;
  struct netdev_hw_addr_list      dev_addrs;
#ifdef CONFIG_SYSFS;
  struct kset             *queues_kset;
#endif;
  unsigned int            promiscuity;
  unsigned int            allmulti;
#if IS_ENABLED(CONFIG_VLAN_8021Q);
  struct vlan_info __rcu  *vlan_info;
#endif;
#if IS_ENABLED(CONFIG_NET_DSA);
  struct dsa_port         *dsa_ptr;
#endif;
#if IS_ENABLED(CONFIG_TIPC);
  struct tipc_bearer __rcu *tipc_ptr;
#endif;
#if IS_ENABLED(CONFIG_IRDA) || IS_ENABLED(CONFIG_ATALK);
  void *atalk_ptr;
#endif;
  struct in_device __rcu  *ip_ptr;
#if IS_ENABLED(CONFIG_DECNET);
  struct dn_dev __rcu     *dn_ptr;
#endif;
  struct inet6_dev __rcu  *ip6_ptr;
#if IS_ENABLED(CONFIG_AX25);
  void *ax25_ptr;
#endif;
  struct wireless_dev     *ieee80211_ptr;
  struct wpan_dev         *ieee802154_ptr;
#if IS_ENABLED(CONFIG_MPLS_ROUTING);
  struct mpls_dev __rcu   *mpls_ptr;
#endif;
  unsigned char           *dev_addr;
  struct netdev_rx_queue  *_rx;
  unsigned int            num_rx_queues;
  unsigned int            real_num_rx_queues;
  struct bpf_prog __rcu   *xdp_prog;
  unsigned long           gro_flush_timeout;
  rx_handler_func_t __rcu *rx_handler;
  void __rcu              *rx_handler_data;
#ifdef CONFIG_NET_CLS_ACT;
  struct mini_Qdisc __rcu *miniq_ingress;
#endif;
  struct netdev_queue __rcu *ingress_queue;
#ifdef CONFIG_NETFILTER_INGRESS;
  struct nf_hook_entries __rcu *nf_hooks_ingress;
#endif;
  unsigned char           broadcast[MAX_ADDR_LEN];
#ifdef CONFIG_RFS_ACCEL;
  struct cpu_rmap         *rx_cpu_rmap;
#endif;
  struct hlist_node       index_hlist;
  struct netdev_queue     *_tx ;
  unsigned int            num_tx_queues;
  unsigned int            real_num_tx_queues;
  struct Qdisc            *qdisc;
  unsigned int            tx_queue_len;
  spinlock_t tx_global_lock;
  struct xdp_dev_bulk_queue __percpu *xdp_bulkq;
#ifdef CONFIG_XPS;
  struct xps_dev_maps __rcu *xps_cpus_map;
  struct xps_dev_maps __rcu *xps_rxqs_map;
#endif;
#ifdef CONFIG_NET_CLS_ACT;
  struct mini_Qdisc __rcu *miniq_egress;
#endif;
#ifdef CONFIG_NET_SCHED;
  unsigned long qdisc_hash[1 &lt;&lt; ((4) - 1)];
#endif;
  struct timer_list       watchdog_timer;
  int watchdog_timeo;
  struct list_head        todo_list;
  int __percpu            *pcpu_refcnt;
  struct list_head        link_watch_list;
  enum {
    NETREG_UNINITIALIZED=0,
    NETREG_REGISTERED,
    NETREG_UNREGISTERING,
    NETREG_UNREGISTERED,
    NETREG_RELEASED,
    NETREG_DUMMY,
  } reg_state:8;
  bool dismantle;
  enum {
    RTNL_LINK_INITIALIZED,
    RTNL_LINK_INITIALIZING,
  } rtnl_link_state:16;
  bool needs_free_netdev;
  void (*priv_destructor)(struct net_device *dev);
#ifdef CONFIG_NETPOLL;
  struct netpoll_info __rcu       *npinfo;
#endif;
  possible_net_t nd_net;
  union {
    void *ml_priv;
    struct pcpu_lstats __percpu             *lstats;
    struct pcpu_sw_netstats __percpu        *tstats;
    struct pcpu_dstats __percpu             *dstats;
  };
#if IS_ENABLED(CONFIG_GARP);
  struct garp_port __rcu  *garp_port;
#endif;
#if IS_ENABLED(CONFIG_MRP);
  struct mrp_port __rcu   *mrp_port;
#endif;
  struct device           dev;
  const struct attribute_group *sysfs_groups[4];
  const struct attribute_group *sysfs_rx_queue_group;
  const struct rtnl_link_ops *rtnl_link_ops;
#define GSO_MAX_SIZE            65536;
  unsigned int            gso_max_size;
#define GSO_MAX_SEGS            65535;
  u16 gso_max_segs;
#ifdef CONFIG_DCB;
  const struct dcbnl_rtnl_ops *dcbnl_ops;
#endif;
  s16 num_tc;
  struct netdev_tc_txq    tc_to_txq[TC_MAX_QUEUE];
  u8 prio_tc_map[TC_BITMASK + 1];
#if IS_ENABLED(CONFIG_FCOE);
  unsigned int            fcoe_ddp_xid;
#endif;
#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO);
  struct netprio_map __rcu *priomap;
#endif;
  struct phy_device       *phydev;
  struct sfp_bus          *sfp_bus;
  struct lock_class_key   qdisc_tx_busylock_key;
  struct lock_class_key   qdisc_running_key;
  struct lock_class_key   qdisc_xmit_lock_key;
  struct lock_class_key   addr_list_lock_key;
  bool proto_down;
  unsigned wol_enabled:1;
  struct list_head        net_notifier_list;
#if IS_ENABLED(CONFIG_MACSEC);
  const struct macsec_ops *macsec_ops;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>This is the first field of the “visible” part of this structure
(i.e. as seen by users in the “Space.c” file).  It is the name
of the interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name_node</span></code></dt><dd><p>Name hashlist node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ifalias</span></code></dt><dd><p>SNMP alias</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_end</span></code></dt><dd><p>Shared memory end</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_start</span></code></dt><dd><p>Shared memory start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base_addr</span></code></dt><dd><p>Device I/O address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>Device IRQ number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>Generic network queuing layer state, see netdev_state_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_list</span></code></dt><dd><p>The global list of network devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">napi_list</span></code></dt><dd><p>List entry used for polling NAPI devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unreg_list</span></code></dt><dd><p>List entry  when we are unregistering the
device; see the function unregister_netdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">close_list</span></code></dt><dd><p>List entry used when we are closing the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptype_all</span></code></dt><dd><p>Device-specific packet handlers for all protocols</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptype_specific</span></code></dt><dd><p>Device-specific, protocol-specific packet handlers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adj_list</span></code></dt><dd><p>Directly linked devices, like slaves for bonding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">features</span></code></dt><dd><p>Currently active device features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_features</span></code></dt><dd><p>User-changeable features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wanted_features</span></code></dt><dd><p>User-requested features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_features</span></code></dt><dd><p>Mask of features inheritable by VLAN devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_enc_features</span></code></dt><dd><p>Mask of features inherited by encapsulating devices
This field indicates what encapsulation
offloads the hardware is capable of doing,
and drivers will need to set them appropriately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mpls_features</span></code></dt><dd><p>Mask of features inheritable by MPLS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gso_partial_features</span></code></dt><dd><p>value(s) from NETIF_F_GSO*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ifindex</span></code></dt><dd><p>interface index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">group</span></code></dt><dd><p>The group the device belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats</span></code></dt><dd><p>Statistics struct, which was left as a legacy, use
rtnl_link_stats64 instead</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_dropped</span></code></dt><dd><p>Dropped packets by core network,
do not use this in drivers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_dropped</span></code></dt><dd><p>Dropped packets by core network,
do not use this in drivers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_nohandler</span></code></dt><dd><p>nohandler dropped packets by core network on
inactive devices, do not use this in drivers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">carrier_up_count</span></code></dt><dd><p>Number of times the carrier has been up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">carrier_down_count</span></code></dt><dd><p>Number of times the carrier has been down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wireless_handlers</span></code></dt><dd><p>List of functions to handle Wireless Extensions,
instead of ioctl,
see &lt;net/iw_handler.h&gt; for details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wireless_data</span></code></dt><dd><p>Instance data managed by the core of wireless extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_ops</span></code></dt><dd><p>Includes several pointers to callbacks,
if one wants to override the ndo_*() functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ethtool_ops</span></code></dt><dd><p>Management operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l3mdev_ops</span></code></dt><dd><p>Layer 3 master device operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ndisc_ops</span></code></dt><dd><p>Includes callbacks for different IPv6 neighbour
discovery handling. Necessary for e.g. 6LoWPAN.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrmdev_ops</span></code></dt><dd><p>Transformation offload operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tlsdev_ops</span></code></dt><dd><p>Transport Layer Security offload operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header_ops</span></code></dt><dd><p>Includes callbacks for creating,parsing,caching,etc
of Layer 2 headers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Interface flags (a la BSD)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv_flags</span></code></dt><dd><p>Like ‘flags’ but invisible to userspace,
see if.h for the definitions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gflags</span></code></dt><dd><p>Global flags ( kept as legacy )</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">padded</span></code></dt><dd><p>How much padding added by alloc_netdev()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">operstate</span></code></dt><dd><p>RFC2863 operstate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_mode</span></code></dt><dd><p>Mapping policy to operstate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">if_port</span></code></dt><dd><p>Selectable AUI, TP, …</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma</span></code></dt><dd><p>DMA channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mtu</span></code></dt><dd><p>Interface MTU value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_mtu</span></code></dt><dd><p>Interface Minimum MTU value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_mtu</span></code></dt><dd><p>Interface Maximum MTU value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Interface hardware type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hard_header_len</span></code></dt><dd><p>Maximum hardware header length.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_header_len</span></code></dt><dd><p>Minimum hardware header length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needed_headroom</span></code></dt><dd><p>Extra headroom the hardware may need, but not in all
cases can this be guaranteed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needed_tailroom</span></code></dt><dd><p>Extra tailroom the hardware may need, but not in all
cases can this be guaranteed. Some cases also use
LL_MAX_HEADER instead to allocate the skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">perm_addr</span></code></dt><dd><p>Permanent hw address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_assign_type</span></code></dt><dd><p>Hw address assignment type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_len</span></code></dt><dd><p>Hardware address length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">upper_level</span></code></dt><dd><p>Maximum depth level of upper devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lower_level</span></code></dt><dd><p>Maximum depth level of lower devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">neigh_priv_len</span></code></dt><dd><p>Used in neigh_alloc()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_id</span></code></dt><dd><p>Used to differentiate devices that share
the same link layer address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_port</span></code></dt><dd><p>Used to differentiate devices that share
the same function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_list_lock</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name_assign_type</span></code></dt><dd><p>network interface name assignment type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uc_promisc</span></code></dt><dd><p>Counter that indicates promiscuous mode
has been enabled due to the need to listen to
additional unicast addresses in a device that
does not implement ndo_set_rx_mode()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uc</span></code></dt><dd><p>unicast mac addresses</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mc</span></code></dt><dd><p>multicast mac addresses</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_addrs</span></code></dt><dd><p>list of device hw addresses</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queues_kset</span></code></dt><dd><p>Group of all Kobjects in the Tx and RX queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">promiscuity</span></code></dt><dd><p>Number of times the NIC is told to work in
promiscuous mode; if it becomes 0 the NIC will
exit promiscuous mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allmulti</span></code></dt><dd><p>Counter, enables or disables allmulticast mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_info</span></code></dt><dd><p>VLAN info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dsa_ptr</span></code></dt><dd><p>dsa specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tipc_ptr</span></code></dt><dd><p>TIPC specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atalk_ptr</span></code></dt><dd><p>AppleTalk link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip_ptr</span></code></dt><dd><p>IPv4 specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dn_ptr</span></code></dt><dd><p>DECnet specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip6_ptr</span></code></dt><dd><p>IPv6 specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ax25_ptr</span></code></dt><dd><p>AX.25 specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ieee80211_ptr</span></code></dt><dd><p>IEEE 802.11 specific data, assign before registering</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ieee802154_ptr</span></code></dt><dd><p>IEEE 802.15.4 low-rate Wireless Personal Area Network
device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mpls_ptr</span></code></dt><dd><p>mpls_dev struct pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_addr</span></code></dt><dd><p>Hw address (before bcast,
because most packets are unicast)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_rx</span></code></dt><dd><p>Array of RX queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_rx_queues</span></code></dt><dd><p>Number of RX queues
allocated at <a class="reference internal" href="#c.register_netdev" title="register_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdev()</span></code></a> time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">real_num_rx_queues</span></code></dt><dd><p>Number of RX queues currently active in device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xdp_prog</span></code></dt><dd><p>XDP sockets filter program pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code></dt><dd><p>timeout for GRO layer in NAPI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_handler</span></code></dt><dd><p>handler for received packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_handler_data</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">miniq_ingress</span></code></dt><dd><p>ingress/clsact qdisc specific data for
ingress processing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ingress_queue</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nf_hooks_ingress</span></code></dt><dd><p>netfilter hooks executed for ingress packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">broadcast</span></code></dt><dd><p>hw bcast address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_cpu_rmap</span></code></dt><dd><p>CPU reverse-mapping for RX completion interrupts,
indexed by RX queue number. Assigned by driver.
This must only be set if the ndo_rx_flow_steer
operation is defined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index_hlist</span></code></dt><dd><p>Device index hash chain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_tx</span></code></dt><dd><p>Array of TX queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_tx_queues</span></code></dt><dd><p>Number of TX queues allocated at alloc_netdev_mq() time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">real_num_tx_queues</span></code></dt><dd><p>Number of TX queues currently active in device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qdisc</span></code></dt><dd><p>Root qdisc from userspace point of view</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_queue_len</span></code></dt><dd><p>Max frames per queue allowed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_global_lock</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xdp_bulkq</span></code></dt><dd><p>XDP device bulk queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xps_cpus_map</span></code></dt><dd><p>all CPUs map for XPS device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xps_rxqs_map</span></code></dt><dd><p>all RXQs map for XPS device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">miniq_egress</span></code></dt><dd><p>clsact qdisc specific data for
egress processing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qdisc_hash</span></code></dt><dd><p>qdisc hash table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">watchdog_timer</span></code></dt><dd><p>List of timers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">watchdog_timeo</span></code></dt><dd><p>Represents the timeout that is used by
the watchdog (see dev_watchdog())</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">todo_list</span></code></dt><dd><p>Delayed register/unregister</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcpu_refcnt</span></code></dt><dd><p>Number of references to this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_watch_list</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_state</span></code></dt><dd><p>Register/unregister state machine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dismantle</span></code></dt><dd><p>Device is going to be freed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtnl_link_state</span></code></dt><dd><p>This enum represents the phases of creating
a new link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needs_free_netdev</span></code></dt><dd><p>Should unregister perform free_netdev?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv_destructor</span></code></dt><dd><p>Called from unregister</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">npinfo</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nd_net</span></code></dt><dd><p>Network namespace this network device is inside</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ml_priv</span></code></dt><dd><p>Mid-layer private</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lstats</span></code></dt><dd><p>Loopback statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tstats</span></code></dt><dd><p>Tunnel statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dstats</span></code></dt><dd><p>Dummy statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">garp_port</span></code></dt><dd><p>GARP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mrp_port</span></code></dt><dd><p>MRP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Class/net/name entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs_groups</span></code></dt><dd><p>Space for optional device, statistics and wireless
sysfs groups</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs_rx_queue_group</span></code></dt><dd><p>Space for optional per-rx queue attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtnl_link_ops</span></code></dt><dd><p>Rtnl_link_ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gso_max_size</span></code></dt><dd><p>Maximum size of generic segmentation offload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gso_max_segs</span></code></dt><dd><p>Maximum number of segments that can be passed to the
NIC for GSO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dcbnl_ops</span></code></dt><dd><p>Data Center Bridging netlink ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_tc</span></code></dt><dd><p>Number of traffic classes in the net device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tc_to_txq</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prio_tc_map</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fcoe_ddp_xid</span></code></dt><dd><p>Max exchange id for FCoE LRO by ddp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priomap</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phydev</span></code></dt><dd><p>Physical device may attach itself
for hardware timestamping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sfp_bus</span></code></dt><dd><p>attached <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qdisc_tx_busylock_key</span></code></dt><dd><p>lockdep class annotating Qdisc-&gt;busylock
spinlock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qdisc_running_key</span></code></dt><dd><p>lockdep class annotating Qdisc-&gt;running seqcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qdisc_xmit_lock_key</span></code></dt><dd><p>lockdep class annotating
netdev_queue-&gt;_xmit_lock spinlock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_list_lock_key</span></code></dt><dd><p>lockdep class annotating
net_device-&gt;addr_list_lock spinlock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proto_down</span></code></dt><dd><p>protocol port state information can be sent to the
switch driver and used to set the phys state of the
switch port.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wol_enabled</span></code></dt><dd><p>Wake-on-LAN is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">net_notifier_list</span></code></dt><dd><p>List of per-net netdev notifier block
that follow this device when it is moved
to another network namespace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">macsec_ops</span></code></dt><dd><p>MACsec offloading ops</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Actually, this whole structure is a big mistake.  It mixes I/O
data with strictly “high-level” data, and it has to know about
almost every data structure used in the INET module.</p>
<p>interface address info:</p>
<p>FIXME: cleanup struct net_device such that network protocol info
moves out.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_priv">
void * <code class="sig-name descname">netdev_priv</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>access network device private data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get network device private data</p>
<dl class="function">
<dt id="c.netif_napi_add">
void <code class="sig-name descname">netif_napi_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct napi_struct *<em> napi</em>, int (*poll) (struct napi_struct<em> *</em>, int, int<em> weight</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_napi_add" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a NAPI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">napi</span></code></dt><dd><p>NAPI context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">napi_struct</span> <span class="pre">*,</span> <span class="pre">int)</span> <span class="pre">poll</span></code></dt><dd><p>polling function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">weight</span></code></dt><dd><p>default weight</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.netif_napi_add" title="netif_napi_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_add()</span></code></a> must be used to initialize a NAPI context prior to calling
<em>any</em> of the other NAPI-related functions.</p>
<dl class="function">
<dt id="c.netif_tx_napi_add">
void <code class="sig-name descname">netif_tx_napi_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct napi_struct *<em> napi</em>, int (*poll) (struct napi_struct<em> *</em>, int, int<em> weight</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_tx_napi_add" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a NAPI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">napi</span></code></dt><dd><p>NAPI context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">napi_struct</span> <span class="pre">*,</span> <span class="pre">int)</span> <span class="pre">poll</span></code></dt><dd><p>polling function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">weight</span></code></dt><dd><p>default weight</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.netif_napi_add" title="netif_napi_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_add()</span></code></a> should be used from drivers using NAPI
to exclusively poll a TX queue.
This will avoid we add it into napi_hash[], thus polluting this hash table.</p>
<dl class="function">
<dt id="c.netif_napi_del">
void <code class="sig-name descname">netif_napi_del</code><span class="sig-paren">(</span>struct napi_struct *<em> napi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_napi_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a NAPI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">napi</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#c.netif_napi_del" title="netif_napi_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_del()</span></code></a> removes a NAPI context from the network device NAPI list</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_start_queue">
void <code class="sig-name descname">netif_start_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_start_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>allow transmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allow upper layers to call the device hard_start_xmit routine.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_wake_queue">
void <code class="sig-name descname">netif_wake_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_wake_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>restart transmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allow upper layers to call the device hard_start_xmit routine.
Used for flow control when transmit resources are available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_stop_queue">
void <code class="sig-name descname">netif_stop_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_stop_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>stop transmitted packets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Stop upper layers calling the device hard_start_xmit routine.
Used for flow control when transmit resources are unavailable.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_queue_stopped">
bool <code class="sig-name descname">netif_queue_stopped</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_queue_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>test if transmit queue is flowblocked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Test if transmit queue on device is currently unable to send.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_txq_bql_enqueue_prefetchw">
void <code class="sig-name descname">netdev_txq_bql_enqueue_prefetchw</code><span class="sig-paren">(</span>struct netdev_queue *<em> dev_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_txq_bql_enqueue_prefetchw" title="Permalink to this definition">¶</a></dt>
<dd><p>prefetch bql data for write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_queue</span> <span class="pre">*</span> <span class="pre">dev_queue</span></code></dt><dd><p>pointer to transmit queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>BQL enabled drivers might use this helper in their ndo_start_xmit(),
to give appropriate hint to the CPU.</p>
<dl class="function">
<dt id="c.netdev_txq_bql_complete_prefetchw">
void <code class="sig-name descname">netdev_txq_bql_complete_prefetchw</code><span class="sig-paren">(</span>struct netdev_queue *<em> dev_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_txq_bql_complete_prefetchw" title="Permalink to this definition">¶</a></dt>
<dd><p>prefetch bql data for write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_queue</span> <span class="pre">*</span> <span class="pre">dev_queue</span></code></dt><dd><p>pointer to transmit queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>BQL enabled drivers might use this helper in their TX completion path,
to give appropriate hint to the CPU.</p>
<dl class="function">
<dt id="c.netdev_sent_queue">
void <code class="sig-name descname">netdev_sent_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, unsigned int<em> bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_sent_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>report the number of bytes queued to hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bytes</span></code></dt><dd><p>number of bytes queued to the hardware device queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Report the number of bytes queued for sending/completion to the network
device hardware queue. <strong>bytes</strong> should be a good approximation and should
exactly match <a class="reference internal" href="#c.netdev_completed_queue" title="netdev_completed_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">netdev_completed_queue()</span></code></a> <strong>bytes</strong></p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_completed_queue">
void <code class="sig-name descname">netdev_completed_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, unsigned int<em> pkts</em>, unsigned int<em> bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_completed_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>report bytes and packets completed by device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pkts</span></code></dt><dd><p>actual number of packets sent over the medium</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bytes</span></code></dt><dd><p>actual number of bytes sent over the medium</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Report the number of bytes and packets transmitted by the network device
hardware queue over the physical medium, <strong>bytes</strong> must exactly match the
<strong>bytes</strong> amount passed to <a class="reference internal" href="#c.netdev_sent_queue" title="netdev_sent_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">netdev_sent_queue()</span></code></a></p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_reset_queue">
void <code class="sig-name descname">netdev_reset_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_reset_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the packets and bytes count of a network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev_queue</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Reset the bytes and packet count of a network device and clear the
software flow control OFF bit for this network device</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_cap_txqueue">
u16 <code class="sig-name descname">netdev_cap_txqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, u16<em> queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_cap_txqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>check if selected tx queue exceeds device queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt><dd><p>given tx queue index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 if given tx queue index &gt;= number of device tx queues,
otherwise returns the originally passed tx queue index.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_running">
bool <code class="sig-name descname">netif_running</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_running" title="Permalink to this definition">¶</a></dt>
<dd><p>test if up</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Test if the device has been brought up.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_start_subqueue">
void <code class="sig-name descname">netif_start_subqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, u16<em> queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_start_subqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>allow sending packets on subqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt><dd><p>sub queue index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start individual transmit queue of a device with multiple transmit queues.</p>
<dl class="function">
<dt id="c.netif_stop_subqueue">
void <code class="sig-name descname">netif_stop_subqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, u16<em> queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_stop_subqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>stop sending packets on subqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt><dd><p>sub queue index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop individual transmit queue of a device with multiple transmit queues.</p>
<dl class="function">
<dt id="c.__netif_subqueue_stopped">
bool <code class="sig-name descname">__netif_subqueue_stopped</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, u16<em> queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__netif_subqueue_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>test status of subqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt><dd><p>sub queue index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check individual transmit queue of a device with multiple transmit queues.</p>
<dl class="function">
<dt id="c.netif_wake_subqueue">
void <code class="sig-name descname">netif_wake_subqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, u16<em> queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_wake_subqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>allow sending packets on subqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt><dd><p>sub queue index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resume individual transmit queue of a device with multiple transmit queues.</p>
<dl class="function">
<dt id="c.netif_attr_test_mask">
bool <code class="sig-name descname">netif_attr_test_mask</code><span class="sig-paren">(</span>unsigned long<em> j</em>, const unsigned long *<em> mask</em>, unsigned int<em> nr_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_attr_test_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Test a CPU or Rx queue set in a mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>CPU/Rx queue index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">mask</span></code></dt><dd><p>bitmask of all cpus/rx queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bits</span></code></dt><dd><p>number of bits in the bitmask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if a CPU or Rx queue index is set in a mask of all CPU/Rx queues.</p>
<dl class="function">
<dt id="c.netif_attr_test_online">
bool <code class="sig-name descname">netif_attr_test_online</code><span class="sig-paren">(</span>unsigned long<em> j</em>, const unsigned long *<em> online_mask</em>, unsigned int<em> nr_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_attr_test_online" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for online CPU/Rx queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>CPU/Rx queue index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">online_mask</span></code></dt><dd><p>bitmask for CPUs/Rx queues that are online</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bits</span></code></dt><dd><p>number of bits in the bitmask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if a CPU/Rx queue is online.</p>
<dl class="function">
<dt id="c.netif_attrmask_next">
unsigned int <code class="sig-name descname">netif_attrmask_next</code><span class="sig-paren">(</span>int<em> n</em>, const unsigned long *<em> srcp</em>, unsigned int<em> nr_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_attrmask_next" title="Permalink to this definition">¶</a></dt>
<dd><p>get the next CPU/Rx queue in a cpu/Rx queues mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code></dt><dd><p>CPU/Rx queue index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">srcp</span></code></dt><dd><p>the cpumask/Rx queue mask pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bits</span></code></dt><dd><p>number of bits in the bitmask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns &gt;= nr_bits if no further CPUs/Rx queues set.</p>
<dl class="function">
<dt id="c.netif_attrmask_next_and">
int <code class="sig-name descname">netif_attrmask_next_and</code><span class="sig-paren">(</span>int<em> n</em>, const unsigned long *<em> src1p</em>, const unsigned long *<em> src2p</em>, unsigned int<em> nr_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_attrmask_next_and" title="Permalink to this definition">¶</a></dt>
<dd><p>get the next CPU/Rx queue in *src1p &amp; *src2p</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code></dt><dd><p>CPU/Rx queue index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src1p</span></code></dt><dd><p>the first CPUs/Rx queues mask pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src2p</span></code></dt><dd><p>the second CPUs/Rx queues mask pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bits</span></code></dt><dd><p>number of bits in the bitmask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns &gt;= nr_bits if no further CPUs/Rx queues set in both.</p>
<dl class="function">
<dt id="c.netif_is_multiqueue">
bool <code class="sig-name descname">netif_is_multiqueue</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_is_multiqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>test if device has multiple transmit queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if device has multiple transmit queues</p>
<dl class="function">
<dt id="c.dev_put">
void <code class="sig-name descname">dev_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release reference to device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release reference to device to allow it to be freed.</p>
<dl class="function">
<dt id="c.dev_hold">
void <code class="sig-name descname">dev_hold</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_hold" title="Permalink to this definition">¶</a></dt>
<dd><p>get reference to device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hold reference to device to keep it from being freed.</p>
<dl class="function">
<dt id="c.netif_carrier_ok">
bool <code class="sig-name descname">netif_carrier_ok</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_carrier_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>test if carrier present</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if carrier is present on device</p>
<dl class="function">
<dt id="c.netif_dormant_on">
void <code class="sig-name descname">netif_dormant_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_dormant_on" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as dormant.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark device as dormant (as per RFC2863).</p>
<p>The dormant state indicates that the relevant interface is not
actually in a condition to pass packets (i.e., it is not ‘up’) but is
in a “pending” state, waiting for some external event.  For “on-
demand” interfaces, this new state identifies the situation where the
interface is waiting for events to place it in the up state.</p>
<dl class="function">
<dt id="c.netif_dormant_off">
void <code class="sig-name descname">netif_dormant_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_dormant_off" title="Permalink to this definition">¶</a></dt>
<dd><p>set device as not dormant.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device is not in dormant state.</p>
<dl class="function">
<dt id="c.netif_dormant">
bool <code class="sig-name descname">netif_dormant</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_dormant" title="Permalink to this definition">¶</a></dt>
<dd><p>test if device is dormant</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if device is dormant.</p>
<dl class="function">
<dt id="c.netif_oper_up">
bool <code class="sig-name descname">netif_oper_up</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_oper_up" title="Permalink to this definition">¶</a></dt>
<dd><p>test if device is operational</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if carrier is operational</p>
<dl class="function">
<dt id="c.netif_device_present">
bool <code class="sig-name descname">netif_device_present</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_device_present" title="Permalink to this definition">¶</a></dt>
<dd><p>is device available or removed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if device has not been removed from system.</p>
<dl class="function">
<dt id="c.netif_tx_lock">
void <code class="sig-name descname">netif_tx_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_tx_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>grab network device transmit lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get network device transmit lock</p>
<dl class="function">
<dt id="c.__dev_uc_sync">
int <code class="sig-name descname">__dev_uc_sync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, int (*sync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *</em>, const unsigned char<em> *</em>, int (*unsync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *</em>, const unsigned char<em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_uc_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchonize device’s unicast list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">sync</span></code></dt><dd><p>function to call if address should be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">unsync</span></code></dt><dd><p>function to call if address should be removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Add newly added addresses to the interface, and release
addresses that have been deleted.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__dev_uc_unsync">
void <code class="sig-name descname">__dev_uc_unsync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, int (*unsync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *</em>, const unsigned char<em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_uc_unsync" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove synchronized addresses from device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">unsync</span></code></dt><dd><p>function to call if address should be removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove all addresses that were added to the device by dev_uc_sync().</p>
</div></blockquote>
<dl class="function">
<dt id="c.__dev_mc_sync">
int <code class="sig-name descname">__dev_mc_sync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, int (*sync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *</em>, const unsigned char<em> *</em>, int (*unsync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *</em>, const unsigned char<em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_mc_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchonize device’s multicast list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">sync</span></code></dt><dd><p>function to call if address should be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">unsync</span></code></dt><dd><p>function to call if address should be removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Add newly added addresses to the interface, and release
addresses that have been deleted.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__dev_mc_unsync">
void <code class="sig-name descname">__dev_mc_unsync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, int (*unsync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *</em>, const unsigned char<em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_mc_unsync" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove synchronized addresses from device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">unsync</span></code></dt><dd><p>function to call if address should be removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove all addresses that were added to the device by dev_mc_sync().</p>
</div></blockquote>
</div>
<div class="section" id="phy-support">
<h3>PHY Support<a class="headerlink" href="#phy-support" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.phy_print_status">
void <code class="sig-name descname">phy_print_status</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_print_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to print out the current phy status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_restart_aneg">
int <code class="sig-name descname">phy_restart_aneg</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_restart_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>restart auto-negotiation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restart the autonegotiation on <strong>phydev</strong>.  Returns &gt;= 0 on success or
negative errno on error.</p>
<dl class="function">
<dt id="c.phy_aneg_done">
int <code class="sig-name descname">phy_aneg_done</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_aneg_done" title="Permalink to this definition">¶</a></dt>
<dd><p>return auto-negotiation status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the auto-negotiation status from this <strong>phydev</strong>
Returns &gt; 0 on success or &lt; 0 on error. 0 means that auto-negotiation
is still pending.</p>
<dl class="function">
<dt id="c.phy_mii_ioctl">
int <code class="sig-name descname">phy_mii_ioctl</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, struct ifreq *<em> ifr</em>, int<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_mii_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>generic PHY MII ioctl interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span> <span class="pre">*</span> <span class="pre">ifr</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span></code> for socket ioctl’s</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd to execute</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function is currently incompatible with the
PHYCONTROL layer.  It changes registers without regard to
current state.  Use at own risk.</p>
<dl class="function">
<dt id="c.phy_do_ioctl">
int <code class="sig-name descname">phy_do_ioctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct ifreq *<em> ifr</em>, int<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_do_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>generic ndo_do_ioctl implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the net_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span> <span class="pre">*</span> <span class="pre">ifr</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span></code> for socket ioctl’s</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd to execute</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_start_aneg">
int <code class="sig-name descname">phy_start_aneg</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>start auto-negotiation for this PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Sanitizes the settings (if we’re not autonegotiating</dt><dd><p>them), and then calls the driver’s config_aneg function.
If the PHYCONTROL Layer is operating, we change the state to
reflect the beginning of Auto-negotiation or forcing.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_speed_down">
int <code class="sig-name descname">phy_speed_down</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, bool<em> sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_speed_down" title="Permalink to this definition">¶</a></dt>
<dd><p>set speed to lowest speed supported by both link partners</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">sync</span></code></dt><dd><p>perform action synchronously</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Typically used to save energy when waiting for a WoL packet</p>
<p>WARNING: Setting sync to false may cause the system being unable to suspend
in case the PHY generates an interrupt when finishing the autonegotiation.
This interrupt may wake up the system immediately after suspend.
Therefore use sync = false only if you’re sure it’s safe with the respective
network chip.</p>
<dl class="function">
<dt id="c.phy_speed_up">
int <code class="sig-name descname">phy_speed_up</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_speed_up" title="Permalink to this definition">¶</a></dt>
<dd><p>(re)set advertised speeds to all supported speeds</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to revert the effect of phy_speed_down</p>
<dl class="function">
<dt id="c.phy_start_machine">
void <code class="sig-name descname">phy_start_machine</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>start PHY state machine tracking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>The PHY infrastructure can run a state machine</dt><dd><p>which tracks whether the PHY is starting up, negotiating,
etc.  This function starts the delayed workqueue which tracks
the state of the PHY. If you want to maintain your own state machine,
do not call this function.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_request_interrupt">
void <code class="sig-name descname">phy_request_interrupt</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_request_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>request and enable interrupt for a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Request and enable the interrupt for the given PHY.</dt><dd><p>If this fails, then we set irq to PHY_POLL.
This should only be called with a valid IRQ number.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_free_interrupt">
void <code class="sig-name descname">phy_free_interrupt</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_free_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>disable and free interrupt for a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Disable and free the interrupt for the given PHY.</dt><dd><p>This should only be called with a valid IRQ number.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_stop">
void <code class="sig-name descname">phy_stop</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring down the PHY link, and stop checking the status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_start">
void <code class="sig-name descname">phy_start</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start or restart a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Indicates the attached device’s readiness to</dt><dd><p>handle PHY-related work.  Used during startup to start the
PHY, and after a call to <a class="reference internal" href="#c.phy_stop" title="phy_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_stop()</span></code></a> to resume operation.
Also used to indicate the MDIO bus has cleared an error
condition.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_mac_interrupt">
void <code class="sig-name descname">phy_mac_interrupt</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_mac_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>MAC says the link has changed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>phy_device struct with changed link</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The MAC layer is able to indicate there has been a change in the PHY link
status. Trigger the state machine and work a work queue.</p>
<dl class="function">
<dt id="c.phy_init_eee">
int <code class="sig-name descname">phy_init_eee</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, bool<em> clk_stop_enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_init_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>init and check the EEE feature</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">clk_stop_enable</span></code></dt><dd><p>PHY may stop the clock during LPI</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>it checks if the Energy-Efficient Ethernet (EEE)
is supported by looking at the MMD registers 3.20 and 7.60/61
and it programs the MMD register 3.0 setting the “Clock stop enable”
bit if required.</p>
<dl class="function">
<dt id="c.phy_get_eee_err">
int <code class="sig-name descname">phy_get_eee_err</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_get_eee_err" title="Permalink to this definition">¶</a></dt>
<dd><p>report the EEE wake error count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>it is to report the number of time where the PHY
failed to complete its normal wake sequence.</p>
<dl class="function">
<dt id="c.phy_ethtool_get_eee">
int <code class="sig-name descname">phy_ethtool_get_eee</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, struct ethtool_eee *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_get_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>get EEE supported and status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>ethtool_eee data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>it reportes the Supported/Advertisement/LP Advertisement
capabilities.</p>
<dl class="function">
<dt id="c.phy_ethtool_set_eee">
int <code class="sig-name descname">phy_ethtool_set_eee</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, struct ethtool_eee *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_set_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>set EEE supported and status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>ethtool_eee data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>it is to program the Advertisement EEE register.</p>
<dl class="function">
<dt id="c.phy_clear_interrupt">
int <code class="sig-name descname">phy_clear_interrupt</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_clear_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Ack the phy device’s interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the <strong>phydev</strong> driver has an ack_interrupt function, call it to
ack and clear the phy device’s interrupt.</p>
<p>Returns 0 on success or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.phy_config_interrupt">
int <code class="sig-name descname">phy_config_interrupt</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, bool<em> interrupts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_config_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>configure the PHY device for the requested interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">interrupts</span></code></dt><dd><p>interrupt flags to configure for this <strong>phydev</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.phy_find_valid">
const struct phy_setting * <code class="sig-name descname">phy_find_valid</code><span class="sig-paren">(</span>int<em> speed</em>, int<em> duplex</em>, unsigned long *<em> supported</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_find_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>find a PHY setting that matches the requested parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>desired speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duplex</span></code></dt><dd><p>desired duplex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">supported</span></code></dt><dd><p>mask of supported link modes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locate a supported phy setting that is, in priority order:
- an exact match for the specified speed and duplex mode
- a match for the specified speed, or slower speed
- the slowest supported speed
Returns the matched phy_setting entry, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no supported phy
settings were found.</p>
<dl class="function">
<dt id="c.phy_supported_speeds">
unsigned int <code class="sig-name descname">phy_supported_speeds</code><span class="sig-paren">(</span>struct phy_device *<em> phy</em>, unsigned int *<em> speeds</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_supported_speeds" title="Permalink to this definition">¶</a></dt>
<dd><p>return all speeds currently supported by a phy device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phy</span></code></dt><dd><p>The phy device to return supported speeds of.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">speeds</span></code></dt><dd><p>buffer to store supported speeds in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size of speeds buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of supported speeds, and fills the speeds
buffer with the supported speeds. If speeds buffer is too small to contain
all currently supported speeds, will return as many speeds as can fit.</p>
<dl class="function">
<dt id="c.phy_check_valid">
bool <code class="sig-name descname">phy_check_valid</code><span class="sig-paren">(</span>int<em> speed</em>, int<em> duplex</em>, unsigned long *<em> features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_check_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>check if there is a valid PHY setting which matches speed, duplex, and feature mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>speed to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duplex</span></code></dt><dd><p>duplex to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">features</span></code></dt><dd><p>A mask of the valid settings</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if there is a valid setting, false otherwise.</p>
<dl class="function">
<dt id="c.phy_sanitize_settings">
void <code class="sig-name descname">phy_sanitize_settings</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_sanitize_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure the PHY is set to supported speed and duplex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Make sure the PHY is set to supported speeds and</dt><dd><p>duplexes.  Drop down by one in this order:  1000/FULL,
1000/HALF, 100/FULL, 100/HALF, 10/FULL, 10/HALF.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_check_link_status">
int <code class="sig-name descname">phy_check_link_status</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_check_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>check link status and set state accordingly</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for link and whether autoneg was triggered / is running
and set state accordingly</p>
<dl class="function">
<dt id="c.phy_stop_machine">
void <code class="sig-name descname">phy_stop_machine</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_stop_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the PHY state machine tracking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Stops the state machine delayed workqueue, sets the</dt><dd><p>state to UP (unless it wasn’t up yet). This function must be
called BEFORE phy_detach.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_error">
void <code class="sig-name descname">phy_error</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_error" title="Permalink to this definition">¶</a></dt>
<dd><p>enter HALTED state for this PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Moves the PHY to the HALTED state in response to a read
or write error, and tells the controller the link is down.
Must not be called from interrupt context, or while the
phydev-&gt;lock is held.</p>
<dl class="function">
<dt id="c.phy_disable_interrupts">
int <code class="sig-name descname">phy_disable_interrupts</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_disable_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the PHY interrupts from the PHY side</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_interrupt">
irqreturn_t <code class="sig-name descname">phy_interrupt</code><span class="sig-paren">(</span>int<em> irq</em>, void *<em> phy_dat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>PHY interrupt handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>interrupt line</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">phy_dat</span></code></dt><dd><p>phy_device pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle PHY interrupt</p>
<dl class="function">
<dt id="c.phy_enable_interrupts">
int <code class="sig-name descname">phy_enable_interrupts</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_enable_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the interrupts from the PHY side</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_state_machine">
void <code class="sig-name descname">phy_state_machine</code><span class="sig-paren">(</span>struct work_struct *<em> work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_state_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle the state machine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>work_struct that describes the work to be done</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_register_fixup">
int <code class="sig-name descname">phy_register_fixup</code><span class="sig-paren">(</span>const char *<em> bus_id</em>, u32<em> phy_uid</em>, u32<em> phy_uid_mask</em>, int (*run) (struct phy_device<em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_register_fixup" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new phy_fixup and adds it to the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">bus_id</span></code></dt><dd><p>A string which matches phydev-&gt;mdio.dev.bus_id (or PHY_ANY_ID)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">phy_uid</span></code></dt><dd><p>Used to match against phydev-&gt;phy_id (the UID of the PHY)
It can also be PHY_ANY_UID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">phy_uid_mask</span></code></dt><dd><p>Applied to phydev-&gt;phy_id and fixup-&gt;phy_uid before
comparison</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">phy_device</span> <span class="pre">*)</span> <span class="pre">run</span></code></dt><dd><p>The actual code to be run when a matching PHY is found</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_unregister_fixup">
int <code class="sig-name descname">phy_unregister_fixup</code><span class="sig-paren">(</span>const char *<em> bus_id</em>, u32<em> phy_uid</em>, u32<em> phy_uid_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_unregister_fixup" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a phy_fixup from the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">bus_id</span></code></dt><dd><p>A string matches fixup-&gt;bus_id (or PHY_ANY_ID) in phy_fixup_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">phy_uid</span></code></dt><dd><p>A phy id matches fixup-&gt;phy_id (or PHY_ANY_UID) in phy_fixup_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">phy_uid_mask</span></code></dt><dd><p>Applied to phy_uid and fixup-&gt;phy_uid before comparison</p>
</dd>
</dl>
<dl class="function">
<dt id="c.get_phy_device">
struct phy_device * <code class="sig-name descname">get_phy_device</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, bool<em> is_c45</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_phy_device" title="Permalink to this definition">¶</a></dt>
<dd><p>reads the specified PHY device and returns its <strong>phy_device</strong> struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the target MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>PHY address on the MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_c45</span></code></dt><dd><p>If true the PHY uses the 802.3 clause 45 protocol</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Reads the ID registers of the PHY at <strong>addr</strong> on the</dt><dd><p><strong>bus</strong>, then allocates and returns the phy_device to represent it.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_device_register">
int <code class="sig-name descname">phy_device_register</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the phy device on the MDIO bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>phy_device structure to be added to the MDIO bus</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_device_remove">
void <code class="sig-name descname">phy_device_remove</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_device_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a previously registered phy device from the MDIO bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>phy_device structure to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This doesn’t free the phy_device itself, it merely reverses the effects
of <a class="reference internal" href="#c.phy_device_register" title="phy_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_device_register()</span></code></a>. Use phy_device_free() to free the device
after calling this function.</p>
<dl class="function">
<dt id="c.phy_find_first">
struct phy_device * <code class="sig-name descname">phy_find_first</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_find_first" title="Permalink to this definition">¶</a></dt>
<dd><p>finds the first PHY device on the bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the target MII bus</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_connect_direct">
int <code class="sig-name descname">phy_connect_direct</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct phy_device *<em> phydev</em>, void (*handler) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *</em>, phy_interface_t<em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_connect_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>connect an ethernet device to a specific phy_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the network device to connect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>the pointer to the phy device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span> <span class="pre">handler</span></code></dt><dd><p>callback function for state change notifications</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>PHY device’s interface</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_connect">
struct phy_device * <code class="sig-name descname">phy_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const char *<em> bus_id</em>, void (*handler) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *</em>, phy_interface_t<em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect an ethernet device to a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the network device to connect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">bus_id</span></code></dt><dd><p>the id string of the PHY device to connect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span> <span class="pre">handler</span></code></dt><dd><p>callback function for state change notifications</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>PHY device’s interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Convenience function for connecting ethernet</dt><dd><p>devices to PHY devices.  The default behavior is for
the PHY infrastructure to handle everything, and only notify
the connected driver when the link status changes.  If you
don’t want, or can’t use the provided functionality, you may
choose to call only the subset of functions which provide
the desired functionality.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_disconnect">
void <code class="sig-name descname">phy_disconnect</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disable interrupts, stop state machine, and detach a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_sfp_attach">
void <code class="sig-name descname">phy_sfp_attach</code><span class="sig-paren">(</span>void *<em> upstream</em>, struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_sfp_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach the SFP bus to the PHY upstream network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">upstream</span></code></dt><dd><p>pointer to the phy device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>sfp bus representing cage being attached</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to fill in the sfp_upstream_ops .attach member.</p>
<dl class="function">
<dt id="c.phy_sfp_detach">
void <code class="sig-name descname">phy_sfp_detach</code><span class="sig-paren">(</span>void *<em> upstream</em>, struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_sfp_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detach the SFP bus from the PHY upstream network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">upstream</span></code></dt><dd><p>pointer to the phy device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>sfp bus representing cage being attached</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to fill in the sfp_upstream_ops .detach member.</p>
<dl class="function">
<dt id="c.phy_sfp_probe">
int <code class="sig-name descname">phy_sfp_probe</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, const struct <a class="reference internal" href="#c.sfp_upstream_ops" title="sfp_upstream_ops">sfp_upstream_ops</a> *<em> ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_sfp_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>probe for a SFP cage attached to this PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>Pointer to phy_device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sfp_upstream_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>SFP’s upstream operations</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_attach_direct">
int <code class="sig-name descname">phy_attach_direct</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct phy_device *<em> phydev</em>, u32<em> flags</em>, phy_interface_t<em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_attach_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a network device to a given PHY device pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>Pointer to phy_device to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>PHY device’s dev_flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>PHY device’s interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Called by drivers to attach to a particular PHY</dt><dd><p>device. The phy_device is found, and properly hooked up
to the phy_driver.  If no driver is attached, then a
generic driver is used.  The phy_device is given a ptr to
the attaching device, and given a callback for link status
change.  The phy_device is returned to the attaching driver.
This function takes a reference on the phy device.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_attach">
struct phy_device * <code class="sig-name descname">phy_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const char *<em> bus_id</em>, phy_interface_t<em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a network device to a particular PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">bus_id</span></code></dt><dd><p>Bus ID of PHY device to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>PHY device’s interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Same as phy_attach_direct() except that a PHY bus_id</dt><dd><p>string is passed instead of a pointer to a struct phy_device.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_detach">
void <code class="sig-name descname">phy_detach</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detach a PHY device from its network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This detaches the phy device from its network device and the phy
driver, and drops the reference count taken in <a class="reference internal" href="#c.phy_attach_direct" title="phy_attach_direct"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_attach_direct()</span></code></a>.</p>
<dl class="function">
<dt id="c.phy_reset_after_clk_enable">
int <code class="sig-name descname">phy_reset_after_clk_enable</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_reset_after_clk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a PHY reset if needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Some PHYs are known to need a reset after their refclk was</dt><dd><p>enabled. This function evaluates the flags and perform the reset if it’s
needed. Returns &lt; 0 on error, 0 if the phy wasn’t reset and 1 if the phy
was reset.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_config_eee_advert">
int <code class="sig-name descname">genphy_config_eee_advert</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_config_eee_advert" title="Permalink to this definition">¶</a></dt>
<dd><p>disable unwanted eee mode advertisement</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Writes MDIO_AN_EEE_ADV after disabling unsupported energy</dt><dd><p>efficent ethernet modes. Returns 0 if the PHY’s advertisement hasn’t
changed, and 1 if it has changed.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_setup_forced">
int <code class="sig-name descname">genphy_setup_forced</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_setup_forced" title="Permalink to this definition">¶</a></dt>
<dd><p>configures/forces speed/duplex from <strong>phydev</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Configures MII_BMCR to force speed/duplex</dt><dd><p>to the values in phydev. Assumes that the values are valid.
Please see <a class="reference internal" href="#c.phy_sanitize_settings" title="phy_sanitize_settings"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_sanitize_settings()</span></code></a>.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_restart_aneg">
int <code class="sig-name descname">genphy_restart_aneg</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_restart_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable and Restart Autonegotiation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_check_and_restart_aneg">
int <code class="sig-name descname">genphy_check_and_restart_aneg</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, bool<em> restart</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_check_and_restart_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable and restart auto-negotiation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">restart</span></code></dt><dd><p>whether aneg restart is requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check, and restart auto-negotiation if needed.</p>
<dl class="function">
<dt id="c.__genphy_config_aneg">
int <code class="sig-name descname">__genphy_config_aneg</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, bool<em> changed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__genphy_config_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>restart auto-negotiation or write BMCR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">changed</span></code></dt><dd><p>whether autoneg is requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>If auto-negotiation is enabled, we configure the</dt><dd><p>advertising, and then restart auto-negotiation.  If it is not
enabled, then we write the BMCR.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_c37_config_aneg">
int <code class="sig-name descname">genphy_c37_config_aneg</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c37_config_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>restart auto-negotiation or write BMCR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>If auto-negotiation is enabled, we configure the</dt><dd><p>advertising, and then restart auto-negotiation.  If it is not
enabled, then we write the BMCR. This function is intended
for use with Clause 37 1000Base-X mode.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_aneg_done">
int <code class="sig-name descname">genphy_aneg_done</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_aneg_done" title="Permalink to this definition">¶</a></dt>
<dd><p>return auto-negotiation status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Reads the status register and returns 0 either if</dt><dd><p>auto-negotiation is incomplete, or if there was an error.
Returns BMSR_ANEGCOMPLETE if auto-negotiation is done.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_update_link">
int <code class="sig-name descname">genphy_update_link</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_update_link" title="Permalink to this definition">¶</a></dt>
<dd><p>update link status in <strong>phydev</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Update the value in phydev-&gt;link to reflect the</dt><dd><p>current link value.  In order to do this, we need to read
the status register twice, keeping the second value.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_read_status_fixed">
int <code class="sig-name descname">genphy_read_status_fixed</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_read_status_fixed" title="Permalink to this definition">¶</a></dt>
<dd><p>read the link parameters for !aneg mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the current duplex and speed state for a PHY operating with
autonegotiation disabled.</p>
<dl class="function">
<dt id="c.genphy_read_status">
int <code class="sig-name descname">genphy_read_status</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_read_status" title="Permalink to this definition">¶</a></dt>
<dd><p>check the link status and update current link state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Check the link, then figure out the current state</dt><dd><p>by comparing what we advertise with what the link partner
advertises.  Start by checking the gigabit possibilities,
then move on to 10/100.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_c37_read_status">
int <code class="sig-name descname">genphy_c37_read_status</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c37_read_status" title="Permalink to this definition">¶</a></dt>
<dd><p>check the link status and update current link state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Check the link, then figure out the current state</dt><dd><p>by comparing what we advertise with what the link partner
advertises. This function is for Clause 37 1000Base-X mode.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_soft_reset">
int <code class="sig-name descname">genphy_soft_reset</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_soft_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>software reset the PHY via BMCR_RESET bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a software PHY reset using the standard
BMCR_RESET bit and poll for the reset bit to be cleared.</p>
<p><strong>Return</strong></p>
<p>0 on success, &lt; 0 on failure</p>
<dl class="function">
<dt id="c.genphy_read_abilities">
int <code class="sig-name descname">genphy_read_abilities</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_read_abilities" title="Permalink to this definition">¶</a></dt>
<dd><p>read PHY abilities from Clause 22 registers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads the PHY’s abilities and populates
phydev-&gt;supported accordingly.</p>
<p><strong>Return</strong></p>
<p>0 on success, &lt; 0 on failure</p>
<dl class="function">
<dt id="c.phy_remove_link_mode">
void <code class="sig-name descname">phy_remove_link_mode</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, u32<em> link_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_remove_link_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a supported link mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>phy_device structure to remove link mode from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">link_mode</span></code></dt><dd><p>Link mode to be removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some MACs don’t support all link modes which the PHY
does.  e.g. a 1G MAC often does not support 1000Half. Add a helper
to remove a link mode.</p>
<dl class="function">
<dt id="c.phy_advertise_supported">
void <code class="sig-name descname">phy_advertise_supported</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_advertise_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>Advertise all supported modes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called to advertise all supported modes, doesn’t touch
pause mode advertising.</p>
<dl class="function">
<dt id="c.phy_support_sym_pause">
void <code class="sig-name descname">phy_support_sym_pause</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_support_sym_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable support of symmetrical pause</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by the MAC to indicate is supports symmetrical
Pause, but not asym pause.</p>
<dl class="function">
<dt id="c.phy_support_asym_pause">
void <code class="sig-name descname">phy_support_asym_pause</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_support_asym_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable support of asym pause</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by the MAC to indicate is supports Asym Pause.</p>
<dl class="function">
<dt id="c.phy_set_sym_pause">
void <code class="sig-name descname">phy_set_sym_pause</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, bool<em> rx</em>, bool<em> tx</em>, bool<em> autoneg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_set_sym_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure symmetric Pause</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">rx</span></code></dt><dd><p>Receiver Pause is supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">tx</span></code></dt><dd><p>Transmit Pause is supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">autoneg</span></code></dt><dd><p>Auto neg should be used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure advertised Pause support depending on if
receiver pause and pause auto neg is supported. Generally called
from the set_pauseparam .ndo.</p>
<dl class="function">
<dt id="c.phy_set_asym_pause">
void <code class="sig-name descname">phy_set_asym_pause</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, bool<em> rx</em>, bool<em> tx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_set_asym_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure Pause and Asym Pause</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">rx</span></code></dt><dd><p>Receiver Pause is supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">tx</span></code></dt><dd><p>Transmit Pause is supported</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure advertised Pause support depending on if
transmit and receiver pause is supported. If there has been a
change in adverting, trigger a new autoneg. Generally called from
the set_pauseparam .ndo.</p>
<dl class="function">
<dt id="c.phy_validate_pause">
bool <code class="sig-name descname">phy_validate_pause</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, struct ethtool_pauseparam *<em> pp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_validate_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the PHY/MAC support the pause configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_pauseparam</span> <span class="pre">*</span> <span class="pre">pp</span></code></dt><dd><p>requested pause configuration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if the PHY/MAC combination supports the Pause
configuration the user is requesting. Returns True if it is
supported, false otherwise.</p>
<dl class="function">
<dt id="c.phy_get_pause">
void <code class="sig-name descname">phy_get_pause</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, bool *<em> tx_pause</em>, bool *<em> rx_pause</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_get_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>resolve negotiated pause modes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">tx_pause</span></code></dt><dd><p>pointer to bool to indicate whether transmit pause should be
enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">rx_pause</span></code></dt><dd><p>pointer to bool to indicate whether receive pause should be
enabled.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resolve and return the flow control modes according to the negotiation
result. This includes checking that we are operating in full duplex mode.
See linkmode_resolve_pause() for further details.</p>
<dl class="function">
<dt id="c.phy_driver_register">
int <code class="sig-name descname">phy_driver_register</code><span class="sig-paren">(</span>struct phy_driver *<em> new_driver</em>, struct module *<em> owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_driver_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a phy_driver with the PHY layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_driver</span> <span class="pre">*</span> <span class="pre">new_driver</span></code></dt><dd><p>new phy_driver to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt><dd><p>module owning this PHY</p>
</dd>
</dl>
<dl class="function">
<dt id="c.get_phy_c45_ids">
int <code class="sig-name descname">get_phy_c45_ids</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, u32 *<em> phy_id</em>, struct phy_c45_device_ids *<em> c45_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_phy_c45_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>reads the specified addr for its 802.3-c45 IDs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the target MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>PHY address on the MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">phy_id</span></code></dt><dd><p>where to store the ID retrieved.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_c45_device_ids</span> <span class="pre">*</span> <span class="pre">c45_ids</span></code></dt><dd><p>where to store the c45 ID information.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If the PHY devices-in-package appears to be valid, it and the
corresponding identifiers are stored in <strong>c45_ids</strong>, zero is stored
in <strong>phy_id</strong>.  Otherwise 0xffffffff is stored in <strong>phy_id</strong>.  Returns
zero on success.</p>
</div></blockquote>
<dl class="function">
<dt id="c.get_phy_id">
int <code class="sig-name descname">get_phy_id</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, u32 *<em> phy_id</em>, bool<em> is_c45</em>, struct phy_c45_device_ids *<em> c45_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_phy_id" title="Permalink to this definition">¶</a></dt>
<dd><p>reads the specified addr for its ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the target MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>PHY address on the MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">phy_id</span></code></dt><dd><p>where to store the ID retrieved.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_c45</span></code></dt><dd><p>If true the PHY uses the 802.3 clause 45 protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_c45_device_ids</span> <span class="pre">*</span> <span class="pre">c45_ids</span></code></dt><dd><p>where to store the c45 ID information.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl>
<dt>In the case of a 802.3-c22 PHY, reads the ID registers</dt><dd><p>of the PHY at <strong>addr</strong> on the <strong>bus</strong>, stores it in <strong>phy_id</strong> and returns
zero on success.</p>
<p>In the case of a 802.3-c45 PHY, <a class="reference internal" href="#c.get_phy_c45_ids" title="get_phy_c45_ids"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_phy_c45_ids()</span></code></a> is invoked, and
its return value is in turn returned.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_prepare_link">
void <code class="sig-name descname">phy_prepare_link</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em>, void (*handler) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_prepare_link" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares the PHY layer to monitor link status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span> <span class="pre">handler</span></code></dt><dd><p>callback function for link status change notifications</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Tells the PHY infrastructure to handle the</dt><dd><p>gory details on monitoring link status (whether through
polling or an interrupt), and to call back to the
connected device driver when the link status changes.
If you want to monitor your own link state, don’t call
this function.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_poll_reset">
int <code class="sig-name descname">phy_poll_reset</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_poll_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely wait until a PHY reset has properly completed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>The PHY device to poll</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl>
<dt>According to IEEE 802.3, Section 2, Subsection 22.2.4.1.1, as</dt><dd><p>published in 2008, a PHY reset may take up to 0.5 seconds.  The MII BMCR
register must be polled until the BMCR_RESET bit clears.</p>
<p>Furthermore, any attempts to write to PHY registers may have no effect
or even generate MDIO bus errors until this is complete.</p>
<p>Some PHYs (such as the Marvell 88E1111) don’t entirely conform to the
standard and do not fully reset after the BMCR_RESET bit is set, and may
even <em>REQUIRE</em> a soft-reset to properly restart autonegotiation.  In an
effort to support such broken PHYs, this function is separate from the
standard phy_init_hw() which will zero all the other bits in the BMCR
and reapply all driver-specific and board-specific fixups.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_config_advert">
int <code class="sig-name descname">genphy_config_advert</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_config_advert" title="Permalink to this definition">¶</a></dt>
<dd><p>sanitize and advertise auto-negotiation parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Writes MII_ADVERTISE with the appropriate values,</dt><dd><p>after sanitizing the values to make sure we only advertise
what is supported.  Returns &lt; 0 on error, 0 if the PHY’s advertisement
hasn’t changed, and &gt; 0 if it has changed.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_c37_config_advert">
int <code class="sig-name descname">genphy_c37_config_advert</code><span class="sig-paren">(</span>struct phy_device *<em> phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c37_config_advert" title="Permalink to this definition">¶</a></dt>
<dd><p>sanitize and advertise auto-negotiation parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Writes MII_ADVERTISE with the appropriate values,</dt><dd><p>after sanitizing the values to make sure we only advertise
what is supported.  Returns &lt; 0 on error, 0 if the PHY’s advertisement
hasn’t changed, and &gt; 0 if it has changed. This function is intended
for Clause 37 1000Base-X mode.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_probe">
int <code class="sig-name descname">phy_probe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>probe and init a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to probe and init</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Take care of setting up the phy_device structure,</dt><dd><p>set the state to READY (the driver’s init function should
set it to STARTING if needed).</p>
</dd>
</dl>
<dl class="function">
<dt id="c.mdiobus_alloc_size">
struct mii_bus * <code class="sig-name descname">mdiobus_alloc_size</code><span class="sig-paren">(</span>size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_alloc_size" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a mii_bus structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>extra amount of memory to allocate for private storage.
If non-zero, then bus-&gt;priv is points to that memory.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called by a bus driver to allocate an mii_bus
structure to fill in.</p>
<dl class="function">
<dt id="c.devm_mdiobus_alloc_size">
struct mii_bus * <code class="sig-name descname">devm_mdiobus_alloc_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, int<em> sizeof_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_mdiobus_alloc_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.mdiobus_alloc_size" title="mdiobus_alloc_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">mdiobus_alloc_size()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to allocate mii_bus for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sizeof_priv</span></code></dt><dd><p>Space to allocate for private structure.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed mdiobus_alloc_size. mii_bus allocated with this function is
automatically freed on driver detach.</p>
<p>If an mii_bus allocated with this function needs to be freed separately,
<a class="reference internal" href="#c.devm_mdiobus_free" title="devm_mdiobus_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_mdiobus_free()</span></code></a> must be used.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated mii_bus on success, NULL on failure.</p>
<dl class="function">
<dt id="c.devm_mdiobus_free">
void <code class="sig-name descname">devm_mdiobus_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct mii_bus *<em> bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_mdiobus_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.mdiobus_free" title="mdiobus_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">mdiobus_free()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device this mii_bus belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the mii_bus associated with the device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free mii_bus allocated with <a class="reference internal" href="#c.devm_mdiobus_alloc_size" title="devm_mdiobus_alloc_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_mdiobus_alloc_size()</span></code></a>.</p>
<dl class="function">
<dt id="c.mdio_find_bus">
struct mii_bus * <code class="sig-name descname">mdio_find_bus</code><span class="sig-paren">(</span>const char *<em> mdio_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdio_find_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the name of a mdiobus, find the mii_bus.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">mdio_name</span></code></dt><dd><p><em>undescribed</em></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a reference to the mii_bus, or NULL if none found.  The
embedded struct device will have its reference count incremented,
and this must be put_deviced’ed once the bus is finished with.</p>
<dl class="function">
<dt id="c.of_mdio_find_bus">
struct mii_bus * <code class="sig-name descname">of_mdio_find_bus</code><span class="sig-paren">(</span>struct device_node *<em> mdio_bus_np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_mdio_find_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an mii_bus node, find the mii_bus.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">mdio_bus_np</span></code></dt><dd><p>Pointer to the mii_bus.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a reference to the mii_bus, or NULL if none found.  The
embedded struct device will have its reference count incremented,
and this must be put once the bus is finished with.</p>
<p>Because the association of a device_node and mii_bus is made via
of_mdiobus_register(), the mii_bus cannot be found before it is
registered with of_mdiobus_register().</p>
<dl class="function">
<dt id="c.__mdiobus_register">
int <code class="sig-name descname">__mdiobus_register</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, struct module *<em> owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mdiobus_register" title="Permalink to this definition">¶</a></dt>
<dd><p>bring up all the PHYs on a given bus and attach them to bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>target mii_bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt><dd><p>module containing bus accessor functions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Called by a bus driver to bring up all the PHYs</dt><dd><p>on a given bus, and attach them to the bus. Drivers should use
mdiobus_register() rather than <a class="reference internal" href="#c.__mdiobus_register" title="__mdiobus_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">__mdiobus_register()</span></code></a> unless they
need to pass a specific owner module. MDIO devices which are not
PHYs will not be brought up by this function. They are expected to
to be explicitly listed in DT and instantiated by of_mdiobus_register().</p>
</dd>
</dl>
<p>Returns 0 on success or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.mdiobus_free">
void <code class="sig-name descname">mdiobus_free</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a struct mii_bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>mii_bus to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function releases the reference to the underlying device
object in the mii_bus.  If this is the last reference, the mii_bus
will be freed.</p>
<dl class="function">
<dt id="c.mdiobus_scan">
struct phy_device * <code class="sig-name descname">mdiobus_scan</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>scan a bus for MDIO devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>mii_bus to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>address on bus to scan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function scans the MDIO bus, looking for devices which can be
identified using a vendor/product ID in registers 2 and 3. Not all
MDIO devices have such registers, but PHY devices typically
do. Hence this function assumes anything found is a PHY, or can be
treated as a PHY. Other MDIO devices, such as switches, will
probably not be found during the scan.</p>
<dl class="function">
<dt id="c.__mdiobus_read">
int <code class="sig-name descname">__mdiobus_read</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mdiobus_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlocked version of the mdiobus_read function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read a MDIO bus register. Caller must hold the mdio bus lock.</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context.</p>
<dl class="function">
<dt id="c.__mdiobus_write">
int <code class="sig-name descname">__mdiobus_write</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mdiobus_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlocked version of the mdiobus_write function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write a MDIO bus register. Caller must hold the mdio bus lock.</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context.</p>
<dl class="function">
<dt id="c.__mdiobus_modify_changed">
int <code class="sig-name descname">__mdiobus_modify_changed</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mdiobus_modify_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlocked version of the mdiobus_modify function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>bit mask of bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read, modify, and if any change, write the register value back to the
device. Any error returns a negative number.</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context.</p>
<dl class="function">
<dt id="c.mdiobus_read_nested">
int <code class="sig-name descname">mdiobus_read_nested</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_read_nested" title="Permalink to this definition">¶</a></dt>
<dd><p>Nested version of the mdiobus_read function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In case of nested MDIO bus access avoid lockdep false positives by
using mutex_lock_nested().</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
<dl class="function">
<dt id="c.mdiobus_read">
int <code class="sig-name descname">mdiobus_read</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for reading a given MII mgmt register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to read</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
<dl class="function">
<dt id="c.mdiobus_write_nested">
int <code class="sig-name descname">mdiobus_write_nested</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_write_nested" title="Permalink to this definition">¶</a></dt>
<dd><p>Nested version of the mdiobus_write function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In case of nested MDIO bus access avoid lockdep false positives by
using mutex_lock_nested().</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
<dl class="function">
<dt id="c.mdiobus_write">
int <code class="sig-name descname">mdiobus_write</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for writing a given MII mgmt register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
<dl class="function">
<dt id="c.mdiobus_modify">
int <code class="sig-name descname">mdiobus_modify</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_modify" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for modifying a given mdio device register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>bit mask of bits to set</p>
</dd>
</dl>
<dl class="function">
<dt id="c.mdiobus_release">
void <code class="sig-name descname">mdiobus_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_release" title="Permalink to this definition">¶</a></dt>
<dd><p>mii_bus device release callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">d</span></code></dt><dd><p>the target struct device that contains the mii_bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called when the last reference to an mii_bus is
dropped, to free the underlying memory.</p>
<dl class="function">
<dt id="c.mdiobus_create_device">
int <code class="sig-name descname">mdiobus_create_device</code><span class="sig-paren">(</span>struct mii_bus *<em> bus</em>, struct mdio_board_info *<em> bi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_create_device" title="Permalink to this definition">¶</a></dt>
<dd><p>create a full MDIO device given a mdio_board_info structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>MDIO bus to create the devices on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_board_info</span> <span class="pre">*</span> <span class="pre">bi</span></code></dt><dd><p>mdio_board_info structure describing the devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.mdio_bus_match">
int <code class="sig-name descname">mdio_bus_match</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct device_driver *<em> drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdio_bus_match" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if given MDIO driver supports the given MDIO device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target MDIO device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt><dd><p>given MDIO driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Given a MDIO device, and a MDIO driver, return 1 if</dt><dd><p>the driver supports the device.  Otherwise, return 0. This may
require calling the devices own match function, since different classes
of MDIO devices have different match criteria.</p>
</dd>
</dl>
</div>
<div class="section" id="phylink">
<h3>PHYLINK<a class="headerlink" href="#phylink" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>PHYLINK interfaces traditional network drivers with PHYLIB, fixed-links,
and SFF modules (eg, hot-pluggable SFP) that may contain PHYs.  PHYLINK
provides management of the link state and link modes.</p>
</div></blockquote>
<dl class="type">
<dt id="c.phylink_link_state">
struct <code class="sig-name descname">phylink_link_state</code><a class="headerlink" href="#c.phylink_link_state" title="Permalink to this definition">¶</a></dt>
<dd><p>link state structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink_link_state {
  __ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
  __ETHTOOL_DECLARE_LINK_MODE_MASK(lp_advertising);
  phy_interface_t interface;
  int speed;
  int duplex;
  int pause;
  unsigned int link:1;
  unsigned int an_enabled:1;
  unsigned int an_complete:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">interface</span></code></dt><dd><p>link <code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code> mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">speed</span></code></dt><dd><p>link speed, one of the SPEED_* constants.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duplex</span></code></dt><dd><p>link duplex mode, one of DUPLEX_* constants.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pause</span></code></dt><dd><p>link pause state, described by MLO_PAUSE_* constants.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link</span></code></dt><dd><p>true if the link is up.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">an_enabled</span></code></dt><dd><p>true if autonegotiation is enabled/desired.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">an_complete</span></code></dt><dd><p>true if autonegotiation has completed.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.phylink_config">
struct <code class="sig-name descname">phylink_config</code><a class="headerlink" href="#c.phylink_config" title="Permalink to this definition">¶</a></dt>
<dd><p>PHYLINK configuration structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink_config {
  struct device *dev;
  enum phylink_op_type type;
  bool pcs_poll;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>a pointer to a struct device associated with the MAC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>operation type of PHYLINK instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcs_poll</span></code></dt><dd><p>MAC PCS cannot provide link change interrupt</p>
</dd>
</dl>
<dl class="type">
<dt id="c.phylink_mac_ops">
struct <code class="sig-name descname">phylink_mac_ops</code><a class="headerlink" href="#c.phylink_mac_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>MAC operations structure.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink_mac_ops {
  void (*validate)(struct phylink_config *config,unsigned long *supported, struct phylink_link_state *state);
  void (*mac_pcs_get_state)(struct phylink_config *config, struct phylink_link_state *state);
  void (*mac_config)(struct phylink_config *config, unsigned int mode, const struct phylink_link_state *state);
  void (*mac_an_restart)(struct phylink_config *config);
  void (*mac_link_down)(struct phylink_config *config, unsigned int mode, phy_interface_t interface);
  void (*mac_link_up)(struct phylink_config *config,struct phy_device *phy, unsigned int mode,phy_interface_t interface, int speed, int duplex, bool tx_pause, bool rx_pause);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">validate</span></code></dt><dd><p>Validate and update the link configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_pcs_get_state</span></code></dt><dd><p>Read the current link state from the hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_config</span></code></dt><dd><p>configure the MAC for the selected mode and state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_an_restart</span></code></dt><dd><p>restart 802.3z BaseX autonegotiation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_link_down</span></code></dt><dd><p>take the link down.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_link_up</span></code></dt><dd><p>allow the link to come up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The individual methods are described more fully below.</p>
<dl class="function">
<dt id="c.validate">
void <code class="sig-name descname">validate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a> *<em> config</em>, unsigned long *<em> supported</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate and update the link configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">supported</span></code></dt><dd><p>ethtool bitmask for supported link modes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear bits in the <strong>supported</strong> and <strong>state-&gt;advertising</strong> masks that
are not supportable by the MAC.</p>
<p>Note that the PHY may be able to transform from one connection
technology to another, so, eg, don’t clear 1000BaseX just
because the MAC is unable to BaseX mode. This is more about
clearing unsupported speeds and duplex settings. The port modes
should not be cleared; <a class="reference internal" href="#c.phylink_set_port_modes" title="phylink_set_port_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_set_port_modes()</span></code></a> will help with this.</p>
<p>If the <strong>state-&gt;interface</strong> mode is <code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_1000BASEX</span></code>
or <code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_2500BASEX</span></code>, select the appropriate mode
based on <strong>state-&gt;advertising</strong> and/or <strong>state-&gt;speed</strong> and update
<strong>state-&gt;interface</strong> accordingly. See <a class="reference internal" href="#c.phylink_helper_basex_speed" title="phylink_helper_basex_speed"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_helper_basex_speed()</span></code></a>.</p>
<p>When <strong>state-&gt;interface</strong> is <code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_NA</span></code>, phylink expects the
MAC driver to return all supported link modes.</p>
<p>If the <strong>state-&gt;interface</strong> mode is not supported, then the <strong>supported</strong>
mask must be cleared.</p>
<dl class="function">
<dt id="c.mac_pcs_get_state">
void <code class="sig-name descname">mac_pcs_get_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a> *<em> config</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_pcs_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the current inband link state from the hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the current inband link state from the MAC PCS, reporting the
current speed in <strong>state-&gt;speed</strong>, duplex mode in <strong>state-&gt;duplex</strong>, pause
mode in <strong>state-&gt;pause</strong> using the <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_RX</span></code> and <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_TX</span></code> bits,
negotiation completion state in <strong>state-&gt;an_complete</strong>, and link up state
in <strong>state-&gt;link</strong>. If possible, <strong>state-&gt;lp_advertising</strong> should also be
populated.</p>
<dl class="function">
<dt id="c.mac_config">
void <code class="sig-name descname">mac_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a> *<em> config</em>, unsigned int<em> mode</em>, const struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_config" title="Permalink to this definition">¶</a></dt>
<dd><p>configure the MAC for the selected mode and state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>one of <code class="docutils literal notranslate"><span class="pre">MLO_AN_FIXED</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_PHY</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_INBAND</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note - not all members of <strong>state</strong> are valid.  In particular,
<strong>state-&gt;lp_advertising</strong>, <strong>state-&gt;link</strong>, <strong>state-&gt;an_complete</strong> are never
guaranteed to be correct, and so any <a class="reference internal" href="#c.mac_config" title="mac_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_config()</span></code></a> implementation must
never reference these fields.</p>
<dl class="simple">
<dt>(this requires a rewrite - please refer to mac_link_up() for situations</dt><dd><p>where the PCS and MAC are not tightly integrated.)</p>
</dd>
</dl>
<p>In all negotiation modes, as defined by <strong>mode</strong>, <strong>state-&gt;pause</strong> indicates the
pause settings which should be applied as follows. If <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_AN</span></code> is not
set, <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_TX</span></code> and <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_RX</span></code> indicate whether the MAC should send
pause frames and/or act on received pause frames respectively. Otherwise,
the results of in-band negotiation/status from the MAC PCS should be used
to control the MAC pause mode settings.</p>
<p>The action performed depends on the currently selected mode:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">MLO_AN_FIXED</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_PHY</span></code>:</dt><dd><p>Configure for non-inband negotiation mode, where the link settings
are completely communicated via <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a>.  The physical link
protocol from the MAC is specified by <strong>state-&gt;interface</strong>.</p>
<p><strong>state-&gt;advertising</strong> may be used, but is not required.</p>
<p>Older drivers (prior to the <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a> change) may use <strong>state-&gt;speed</strong>,
<strong>state-&gt;duplex</strong> and <strong>state-&gt;pause</strong> to configure the MAC, but this is
deprecated; such drivers should be converted to use <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a>.</p>
<p>Other members of <strong>state</strong> must be ignored.</p>
<p>Valid state members: interface, advertising.
Deprecated state members: speed, duplex, pause.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MLO_AN_INBAND</span></code>:</dt><dd><p>place the link in an inband negotiation mode (such as 802.3z
1000base-X or Cisco SGMII mode depending on the <strong>state-&gt;interface</strong>
mode). In both cases, link state management (whether the link
is up or not) is performed by the MAC, and reported via the
<a class="reference internal" href="#c.mac_pcs_get_state" title="mac_pcs_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_pcs_get_state()</span></code></a> callback. Changes in link state must be made
by calling <a class="reference internal" href="#c.phylink_mac_change" title="phylink_mac_change"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_mac_change()</span></code></a>.</p>
<p>Interface mode specific details are mentioned below.</p>
<p>If in 802.3z mode, the link speed is fixed, dependent on the
<strong>state-&gt;interface</strong>. Duplex and pause modes are negotiated via
the in-band configuration word. Advertised pause modes are set
according to the <strong>state-&gt;an_enabled</strong> and <strong>state-&gt;advertising</strong>
flags. Beware of MACs which only support full duplex at gigabit
and higher speeds.</p>
<p>If in Cisco SGMII mode, the link speed and duplex mode are passed
in the serial bitstream 16-bit configuration word, and the MAC
should be configured to read these bits and acknowledge the
configuration word. Nothing is advertised by the MAC. The MAC is
responsible for reading the configuration word and configuring
itself accordingly.</p>
<p>Valid state members: interface, an_enabled, pause, advertising.</p>
</dd>
</dl>
<p>Implementations are expected to update the MAC to reflect the
requested settings - i.o.w., if nothing has changed between two
calls, no action is expected.  If only flow control settings have
changed, flow control should be updated <em>without</em> taking the link
down.  This “update” behaviour is critical to avoid bouncing the
link up status.</p>
<dl class="function">
<dt id="c.mac_an_restart">
void <code class="sig-name descname">mac_an_restart</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a> *<em> config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_an_restart" title="Permalink to this definition">¶</a></dt>
<dd><p>restart 802.3z BaseX autonegotiation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.mac_link_down">
void <code class="sig-name descname">mac_link_down</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a> *<em> config</em>, unsigned int<em> mode</em>, phy_interface_t<em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_link_down" title="Permalink to this definition">¶</a></dt>
<dd><p>take the link down</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>link autonegotiation mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>link <code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code> mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>mode</strong> is not an in-band negotiation mode (as defined by
phylink_autoneg_inband()), force the link down and disable any
Energy Efficient Ethernet MAC configuration. Interface type
selection must be done in <a class="reference internal" href="#c.mac_config" title="mac_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_config()</span></code></a>.</p>
<dl class="function">
<dt id="c.mac_link_up">
void <code class="sig-name descname">mac_link_up</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a> *<em> config</em>, struct phy_device *<em> phy</em>, unsigned int<em> mode</em>, phy_interface_t<em> interface</em>, int<em> speed</em>, int<em> duplex</em>, bool<em> tx_pause</em>, bool<em> rx_pause</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_link_up" title="Permalink to this definition">¶</a></dt>
<dd><p>allow the link to come up</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phy</span></code></dt><dd><p>any attached phy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>link autonegotiation mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>link <code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code> mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>link speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duplex</span></code></dt><dd><p>link duplex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">tx_pause</span></code></dt><dd><p>link transmit pause enablement status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">rx_pause</span></code></dt><dd><p>link receive pause enablement status</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure the MAC for an established link.</p>
<p><strong>speed</strong>, <strong>duplex</strong>, <strong>tx_pause</strong> and <strong>rx_pause</strong> indicate the finalised link
settings, and should be used to configure the MAC block appropriately
where these settings are not automatically conveyed from the PCS block,
or if in-band negotiation (as defined by phylink_autoneg_inband(<strong>mode</strong>))
is disabled.</p>
<p>Note that when 802.3z in-band negotiation is in use, it is possible
that the user wishes to override the pause settings, and this should
be allowed when considering the implementation of this method.</p>
<p>If in-band negotiation mode is disabled, allow the link to come up. If
<strong>phy</strong> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, configure Energy Efficient Ethernet by calling
<a class="reference internal" href="#c.phy_init_eee" title="phy_init_eee"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_init_eee()</span></code></a> and perform appropriate MAC configuration for EEE.
Interface type selection must be done in <a class="reference internal" href="#c.mac_config" title="mac_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_config()</span></code></a>.</p>
<dl class="type">
<dt id="c.phylink_pcs_ops">
struct <code class="sig-name descname">phylink_pcs_ops</code><a class="headerlink" href="#c.phylink_pcs_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>MAC PCS operations structure.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink_pcs_ops {
  void (*pcs_get_state)(struct phylink_config *config, struct phylink_link_state *state);
  int (*pcs_config)(struct phylink_config *config, unsigned int mode,phy_interface_t interface, const unsigned long *advertising);
  void (*pcs_an_restart)(struct phylink_config *config);
  void (*pcs_link_up)(struct phylink_config *config, unsigned int mode, phy_interface_t interface, int speed, int duplex);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pcs_get_state</span></code></dt><dd><p>read the current MAC PCS link state from the hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcs_config</span></code></dt><dd><p>configure the MAC PCS for the selected mode and state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcs_an_restart</span></code></dt><dd><p>restart 802.3z BaseX autonegotiation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcs_link_up</span></code></dt><dd><p>program the PCS for the resolved link configuration
(where necessary).</p>
</dd>
</dl>
<dl class="function">
<dt id="c.pcs_get_state">
void <code class="sig-name descname">pcs_get_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a> *<em> config</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcs_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the current inband link state from the hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the current inband link state from the MAC PCS, reporting the
current speed in <strong>state-&gt;speed</strong>, duplex mode in <strong>state-&gt;duplex</strong>, pause
mode in <strong>state-&gt;pause</strong> using the <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_RX</span></code> and <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_TX</span></code> bits,
negotiation completion state in <strong>state-&gt;an_complete</strong>, and link up state
in <strong>state-&gt;link</strong>. If possible, <strong>state-&gt;lp_advertising</strong> should also be
populated.</p>
<p>When present, this overrides <a class="reference internal" href="#c.mac_pcs_get_state" title="mac_pcs_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_pcs_get_state()</span></code></a> in <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">phylink_mac_ops</span></code></a>.</p>
<dl class="function">
<dt id="c.int">
<code class="sig-name descname">int</code><span class="sig-paren">(</span>*<em> pcs_config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.int" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the PCS mode and advertisement</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>`` * pcs_config``</dt><dd><p><em>undescribed</em></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure the PCS for the operating mode, the interface mode, and set
the advertisement mask.</p>
<p>When operating in <code class="docutils literal notranslate"><span class="pre">MLO_AN_INBAND</span></code>, inband should always be enabled,
otherwise inband should be disabled.</p>
<p>For SGMII, there is no advertisement from the MAC side, the PCS should
be programmed to acknowledge the inband word from the PHY.</p>
<p>For 1000BASE-X, the advertisement should be programmed into the PCS.</p>
<p>For most 10GBASE-R, there is no advertisement.</p>
<dl class="function">
<dt id="c.void">
<code class="sig-name descname">void</code><span class="sig-paren">(</span>*<em> pcs_an_restart</em><span class="sig-paren">)</span><a class="headerlink" href="#c.void" title="Permalink to this definition">¶</a></dt>
<dd><p>restart 802.3z BaseX autonegotiation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>`` * pcs_an_restart``</dt><dd><p><em>undescribed</em></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When PCS ops are present, this overrides <a class="reference internal" href="#c.mac_an_restart" title="mac_an_restart"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_an_restart()</span></code></a> in <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">phylink_mac_ops</span></code></a>.</p>
<dl class="function">
<dt>
<code class="sig-name descname">void</code><span class="sig-paren">(</span>*<em> pcs_link_up</em><span class="sig-paren">)</span></dt>
<dd><p>program the PCS for the resolved link configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>`` * pcs_link_up``</dt><dd><p><em>undescribed</em></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call will be made just before <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a> to inform the PCS of
the resolved link parameters. For example, a PCS operating in SGMII
mode without in-band AN needs to be manually configured for the link
and duplex setting. Otherwise, this should be a no-op.</p>
<dl class="type">
<dt id="c.phylink">
struct <code class="sig-name descname">phylink</code><a class="headerlink" href="#c.phylink" title="Permalink to this definition">¶</a></dt>
<dd><p>internal data type for phylink</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="function">
<dt id="c.phylink_set_port_modes">
void <code class="sig-name descname">phylink_set_port_modes</code><span class="sig-paren">(</span>unsigned long *<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_set_port_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>set the port type modes in the ethtool mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">mask</span></code></dt><dd><p>ethtool link mode mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets all the port type modes in the ethtool mask.  MAC drivers should
use this in their ‘validate’ callback.</p>
<dl class="function">
<dt id="c.phylink_create">
struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> * <code class="sig-name descname">phylink_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a> *<em> config</em>, struct fwnode_handle *<em> fwnode</em>, phy_interface_t<em> iface</em>, const struct <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops">phylink_mac_ops</a> *<em> mac_ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a phylink instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt><dd><p>a pointer to the target <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span></code> describing the network
interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">iface</span></code></dt><dd><p>the desired link mode defined by <code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">phylink_mac_ops</span> <span class="pre">*</span> <span class="pre">mac_ops</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_mac_ops</span></code></a> for the MAC.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new phylink instance, and parse the link parameters found in <strong>np</strong>.
This will parse in-band modes, fixed-link or SFP configuration.</p>
<p><strong>Note</strong></p>
<p>the rtnl lock must not be held when calling this function.</p>
<p>Returns a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a>, or an error-pointer value. Users
must use IS_ERR() to check for errors from this function.</p>
<dl class="function">
<dt id="c.phylink_destroy">
void <code class="sig-name descname">phylink_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup and destroy the phylink instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroy a phylink instance. Any PHY that has been attached must have been
cleaned up via <a class="reference internal" href="#c.phylink_disconnect_phy" title="phylink_disconnect_phy"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_disconnect_phy()</span></code></a> prior to calling this function.</p>
<p><strong>Note</strong></p>
<p>the rtnl lock must not be held when calling this function.</p>
<dl class="function">
<dt id="c.phylink_connect_phy">
int <code class="sig-name descname">phylink_connect_phy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, struct phy_device *<em> phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_connect_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>connect a PHY to the phylink instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phy</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Connect <strong>phy</strong> to the phylink instance specified by <strong>pl</strong> by calling
<a class="reference internal" href="#c.phy_attach_direct" title="phy_attach_direct"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_attach_direct()</span></code></a>. Configure the <strong>phy</strong> according to the MAC driver’s
capabilities, start the PHYLIB state machine and enable any interrupts
that the PHY supports.</p>
<p>This updates the phylink’s ethtool supported and advertising link mode
masks.</p>
<p>Returns 0 on success or a negative errno.</p>
<dl class="function">
<dt id="c.phylink_of_phy_connect">
int <code class="sig-name descname">phylink_of_phy_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, struct device_node *<em> dn</em>, u32<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_of_phy_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect the PHY specified in the DT mode.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">dn</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>PHY-specific flags to communicate to the PHY device driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Connect the phy specified in the device node <strong>dn</strong> to the phylink instance
specified by <strong>pl</strong>. Actions specified in <a class="reference internal" href="#c.phylink_connect_phy" title="phylink_connect_phy"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_connect_phy()</span></code></a> will be
performed.</p>
<p>Returns 0 on success or a negative errno.</p>
<dl class="function">
<dt id="c.phylink_disconnect_phy">
void <code class="sig-name descname">phylink_disconnect_phy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_disconnect_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect any PHY attached to the phylink instance.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disconnect any current PHY from the phylink instance described by <strong>pl</strong>.</p>
<dl class="function">
<dt id="c.phylink_fixed_state_cb">
int <code class="sig-name descname">phylink_fixed_state_cb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, void (*cb) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_fixed_state_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>allow setting a fixed link callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*dev,</span> <span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state)</span> <span class="pre">cb</span></code></dt><dd><p>callback to execute to determine the fixed link state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The MAC driver should call this driver when the state of its link
can be determined through e.g: an out of band MMIO register.</p>
<dl class="function">
<dt id="c.phylink_mac_change">
void <code class="sig-name descname">phylink_mac_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, bool<em> up</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mac_change" title="Permalink to this definition">¶</a></dt>
<dd><p>notify phylink of a change in MAC state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">up</span></code></dt><dd><p>indicates whether the link is currently up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The MAC driver should call this driver when the state of its link
changes (eg, link failure, new negotiation results, etc.)</p>
<dl class="function">
<dt id="c.phylink_start">
void <code class="sig-name descname">phylink_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start a phylink instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start the phylink instance specified by <strong>pl</strong>, configuring the MAC for the
desired link mode(s) and negotiation style. This should be called from the
network device driver’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device_ops</span></code> ndo_open() method.</p>
<dl class="function">
<dt id="c.phylink_stop">
void <code class="sig-name descname">phylink_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stop a phylink instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop the phylink instance specified by <strong>pl</strong>. This should be called from the
network device driver’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device_ops</span></code> ndo_stop() method.  The
network device’s carrier state should not be changed prior to calling this
function.</p>
<dl class="function">
<dt id="c.phylink_ethtool_get_wol">
void <code class="sig-name descname">phylink_ethtool_get_wol</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, struct ethtool_wolinfo *<em> wol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_get_wol" title="Permalink to this definition">¶</a></dt>
<dd><p>get the wake on lan parameters for the PHY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_wolinfo</span> <span class="pre">*</span> <span class="pre">wol</span></code></dt><dd><p>a pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_wolinfo</span></code> to hold the read parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the wake on lan parameters from the PHY attached to the phylink
instance specified by <strong>pl</strong>. If no PHY is currently attached, report no
support for wake on lan.</p>
<dl class="function">
<dt id="c.phylink_ethtool_set_wol">
int <code class="sig-name descname">phylink_ethtool_set_wol</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, struct ethtool_wolinfo *<em> wol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_set_wol" title="Permalink to this definition">¶</a></dt>
<dd><p>set wake on lan parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_wolinfo</span> <span class="pre">*</span> <span class="pre">wol</span></code></dt><dd><p>a pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_wolinfo</span></code> for the desired parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the wake on lan parameters for the PHY attached to the phylink
instance specified by <strong>pl</strong>. If no PHY is attached, returns <code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>
error.</p>
<p>Returns zero on success or negative errno code.</p>
<dl class="function">
<dt id="c.phylink_ethtool_ksettings_get">
int <code class="sig-name descname">phylink_ethtool_ksettings_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, struct ethtool_link_ksettings *<em> kset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_ksettings_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current link settings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_link_ksettings</span> <span class="pre">*</span> <span class="pre">kset</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_link_ksettings</span></code> to hold link settings</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the current link settings for the phylink instance specified by <strong>pl</strong>.
This will be the link settings read from the MAC, PHY or fixed link
settings depending on the current negotiation mode.</p>
<dl class="function">
<dt id="c.phylink_ethtool_ksettings_set">
int <code class="sig-name descname">phylink_ethtool_ksettings_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, const struct ethtool_link_ksettings *<em> kset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_ksettings_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set the link settings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ethtool_link_ksettings</span> <span class="pre">*</span> <span class="pre">kset</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_link_ksettings</span></code> for the desired modes</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phylink_ethtool_nway_reset">
int <code class="sig-name descname">phylink_ethtool_nway_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_nway_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>restart negotiation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restart negotiation for the phylink instance specified by <strong>pl</strong>. This will
cause any attached phy to restart negotiation with the link partner, and
if the MAC is in a BaseX mode, the MAC will also be requested to restart
negotiation.</p>
<p>Returns zero on success, or negative error code.</p>
<dl class="function">
<dt id="c.phylink_ethtool_get_pauseparam">
void <code class="sig-name descname">phylink_ethtool_get_pauseparam</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, struct ethtool_pauseparam *<em> pause</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_get_pauseparam" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current pause parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_pauseparam</span> <span class="pre">*</span> <span class="pre">pause</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_pauseparam</span></code></p>
</dd>
</dl>
<dl class="function">
<dt id="c.phylink_ethtool_set_pauseparam">
int <code class="sig-name descname">phylink_ethtool_set_pauseparam</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, struct ethtool_pauseparam *<em> pause</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_set_pauseparam" title="Permalink to this definition">¶</a></dt>
<dd><p>set the current pause parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_pauseparam</span> <span class="pre">*</span> <span class="pre">pause</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_pauseparam</span></code></p>
</dd>
</dl>
<dl class="function">
<dt id="c.phylink_get_eee_err">
int <code class="sig-name descname">phylink_get_eee_err</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_get_eee_err" title="Permalink to this definition">¶</a></dt>
<dd><p>read the energy efficient ethernet error counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the Energy Efficient Ethernet error counter from the PHY associated
with the phylink instance specified by <strong>pl</strong>.</p>
<p>Returns positive error counter value, or negative error code.</p>
<dl class="function">
<dt id="c.phylink_init_eee">
int <code class="sig-name descname">phylink_init_eee</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, bool<em> clk_stop_enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_init_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>init and check the EEE features</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">clk_stop_enable</span></code></dt><dd><p>allow PHY to stop receive clock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called either with RTNL held or within <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a></p>
<dl class="function">
<dt id="c.phylink_ethtool_get_eee">
int <code class="sig-name descname">phylink_ethtool_get_eee</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, struct ethtool_eee *<em> eee</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_get_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>read the energy efficient ethernet parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span> <span class="pre">*</span> <span class="pre">eee</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span></code> for the read parameters</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phylink_ethtool_set_eee">
int <code class="sig-name descname">phylink_ethtool_set_eee</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, struct ethtool_eee *<em> eee</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_set_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>set the energy efficient ethernet parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span> <span class="pre">*</span> <span class="pre">eee</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span></code> for the desired parameters</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phylink_mii_ioctl">
int <code class="sig-name descname">phylink_mii_ioctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> *<em> pl</em>, struct ifreq *<em> ifr</em>, int<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mii_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>generic mii ioctl interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*</span> <span class="pre">pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span> <span class="pre">*</span> <span class="pre">ifr</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span></code> for socket ioctls</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd to execute</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform the specified MII ioctl on the PHY attached to the phylink instance
specified by <strong>pl</strong>. If no PHY is attached, emulate the presence of the PHY.</p>
<p><strong>Return</strong></p>
<p>zero on success or negative error code.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SIOCGMIIPHY</span></code>:</dt><dd><p>read register from the current PHY.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SIOCGMIIREG</span></code>:</dt><dd><p>read register from the specified PHY.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SIOCSMIIREG</span></code>:</dt><dd><p>set a register on the specified PHY.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phylink_helper_basex_speed">
void <code class="sig-name descname">phylink_helper_basex_speed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_helper_basex_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>1000BaseX/2500BaseX helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inspect the interface mode, advertising mask or forced speed and
decide whether to run at 2.5Gbit or 1Gbit appropriately, switching
the interface mode to suit.  <strong>state-&gt;interface</strong> is appropriately
updated, and the advertising mask has the “other” baseX_Full flag
cleared.</p>
<dl class="function">
<dt id="c.phylink_mii_c22_pcs_get_state">
void <code class="sig-name descname">phylink_mii_c22_pcs_get_state</code><span class="sig-paren">(</span>struct mdio_device *<em> pcs</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mii_c22_pcs_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>read the MAC PCS state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span> <span class="pre">*</span> <span class="pre">pcs</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for MAC PCS supporting the 802.3 clause 22 register set for
clause 37 negotiation and/or SGMII control.</p>
<p>Read the MAC PCS state from the MII device configured in <strong>config</strong> and
parse the Clause 37 or Cisco SGMII link partner negotiation word into
the phylink <strong>state</strong> structure. This is suitable to be directly plugged
into the <a class="reference internal" href="#c.mac_pcs_get_state" title="mac_pcs_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_pcs_get_state()</span></code></a> member of the struct phylink_mac_ops
structure.</p>
<dl class="function">
<dt id="c.phylink_mii_c22_pcs_set_advertisement">
int <code class="sig-name descname">phylink_mii_c22_pcs_set_advertisement</code><span class="sig-paren">(</span>struct mdio_device *<em> pcs</em>, phy_interface_t<em> interface</em>, const unsigned long *<em> advertising</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mii_c22_pcs_set_advertisement" title="Permalink to this definition">¶</a></dt>
<dd><p>configure the clause 37 PCS advertisement</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span> <span class="pre">*</span> <span class="pre">pcs</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>the PHY interface mode being configured</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">advertising</span></code></dt><dd><p>the ethtool advertisement mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for MAC PCS supporting the 802.3 clause 22 register set for
clause 37 negotiation and/or SGMII control.</p>
<p>Configure the clause 37 PCS advertisement as specified by <strong>state</strong>. This
does not trigger a renegotiation; phylink will do that via the
<a class="reference internal" href="#c.mac_an_restart" title="mac_an_restart"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_an_restart()</span></code></a> method of the struct phylink_mac_ops structure.</p>
<p>Returns negative error code on failure to configure the advertisement,
zero if no change has been made, or one if the advertisement has changed.</p>
<dl class="function">
<dt id="c.phylink_mii_c22_pcs_an_restart">
void <code class="sig-name descname">phylink_mii_c22_pcs_an_restart</code><span class="sig-paren">(</span>struct mdio_device *<em> pcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mii_c22_pcs_an_restart" title="Permalink to this definition">¶</a></dt>
<dd><p>restart 802.3z autonegotiation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span> <span class="pre">*</span> <span class="pre">pcs</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for MAC PCS supporting the 802.3 clause 22 register set for
clause 37 negotiation.</p>
<p>Restart the clause 37 negotiation with the link partner. This is
suitable to be directly plugged into the <a class="reference internal" href="#c.mac_pcs_get_state" title="mac_pcs_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_pcs_get_state()</span></code></a> member
of the struct phylink_mac_ops structure.</p>
</div>
<div class="section" id="sfp-support">
<h3>SFP support<a class="headerlink" href="#sfp-support" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.sfp_bus">
struct <code class="sig-name descname">sfp_bus</code><a class="headerlink" href="#c.sfp_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>internal representation of a sfp bus</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sfp_bus {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="type">
<dt id="c.sfp_eeprom_id">
struct <code class="sig-name descname">sfp_eeprom_id</code><a class="headerlink" href="#c.sfp_eeprom_id" title="Permalink to this definition">¶</a></dt>
<dd><p>raw SFP module identification information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sfp_eeprom_id {
  struct sfp_eeprom_base base;
  struct sfp_eeprom_ext ext;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base SFP module identification structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>extended SFP module identification structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See the SFF-8472 specification and related documents for the definition
of these structure members. This can be obtained from
<a class="reference external" href="https://www.snia.org/technology-communities/sff/specifications">https://www.snia.org/technology-communities/sff/specifications</a></p>
<dl class="type">
<dt id="c.sfp_upstream_ops">
struct <code class="sig-name descname">sfp_upstream_ops</code><a class="headerlink" href="#c.sfp_upstream_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>upstream operations structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sfp_upstream_ops {
  void (*attach)(void *priv, struct sfp_bus *bus);
  void (*detach)(void *priv, struct sfp_bus *bus);
  int (*module_insert)(void *priv, const struct sfp_eeprom_id *id);
  void (*module_remove)(void *priv);
  int (*module_start)(void *priv);
  void (*module_stop)(void *priv);
  void (*link_down)(void *priv);
  void (*link_up)(void *priv);
  int (*connect_phy)(void *priv, struct phy_device *);
  void (*disconnect_phy)(void *priv);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">attach</span></code></dt><dd><p>called when the sfp socket driver is bound to the upstream
(mandatory).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach</span></code></dt><dd><p>called when the sfp socket driver is unbound from the upstream
(mandatory).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module_insert</span></code></dt><dd><p>called after a module has been detected to determine
whether the module is supported for the upstream device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module_remove</span></code></dt><dd><p>called after the module has been removed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module_start</span></code></dt><dd><p>called after the PHY probe step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module_stop</span></code></dt><dd><p>called before the PHY is removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_down</span></code></dt><dd><p>called when the link is non-operational for whatever
reason.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_up</span></code></dt><dd><p>called when the link is operational.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connect_phy</span></code></dt><dd><p>called when an I2C accessible PHY has been detected
on the module.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect_phy</span></code></dt><dd><p>called when a module with an I2C accessible PHY has
been removed.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.sfp_parse_port">
int <code class="sig-name descname">sfp_parse_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em>, const struct <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id">sfp_eeprom_id</a> *<em> id</em>, unsigned long *<em> support</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_parse_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the EEPROM base ID, setting the port type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>a pointer to the module’s <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">support</span></code></dt><dd><p>optional pointer to an array of unsigned long for the
ethtool support mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the EEPROM identification given in <strong>id</strong>, and return one of
<code class="docutils literal notranslate"><span class="pre">PORT_TP</span></code>, <code class="docutils literal notranslate"><span class="pre">PORT_FIBRE</span></code> or <code class="docutils literal notranslate"><span class="pre">PORT_OTHER</span></code>. If <strong>support</strong> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>,
also set the ethtool <code class="docutils literal notranslate"><span class="pre">ETHTOOL_LINK_MODE_xxx_BIT</span></code> corresponding with
the connector type.</p>
<p>If the port type is not known, returns <code class="docutils literal notranslate"><span class="pre">PORT_OTHER</span></code>.</p>
<dl class="function">
<dt id="c.sfp_may_have_phy">
bool <code class="sig-name descname">sfp_may_have_phy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em>, const struct <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id">sfp_eeprom_id</a> *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_may_have_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>indicate whether the module may have a PHY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>a pointer to the module’s <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the EEPROM identification given in <strong>id</strong>, and return whether
this module may have a PHY.</p>
<dl class="function">
<dt id="c.sfp_parse_support">
void <code class="sig-name descname">sfp_parse_support</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em>, const struct <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id">sfp_eeprom_id</a> *<em> id</em>, unsigned long *<em> support</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_parse_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the eeprom id for supported link modes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>a pointer to the module’s <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">support</span></code></dt><dd><p>pointer to an array of unsigned long for the ethtool support mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the EEPROM identification information and derive the supported
ethtool link modes for the module.</p>
<dl class="function">
<dt id="c.sfp_select_interface">
phy_interface_t <code class="sig-name descname">sfp_select_interface</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em>, unsigned long *<em> link_modes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_select_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Select appropriate phy_interface_t mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">link_modes</span></code></dt><dd><p>ethtool link modes mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Derive the phy_interface_t mode for the SFP module from the link
modes mask.</p>
<dl class="function">
<dt id="c.sfp_bus_put">
void <code class="sig-name descname">sfp_bus_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_bus_put" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference on the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> found via <a class="reference internal" href="#c.sfp_bus_find_fwnode" title="sfp_bus_find_fwnode"><code class="xref c c-func docutils literal notranslate"><span class="pre">sfp_bus_find_fwnode()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Put a reference on the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> and free the underlying structure
if this was the last reference.</p>
<dl class="function">
<dt id="c.sfp_get_module_info">
int <code class="sig-name descname">sfp_get_module_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em>, struct ethtool_modinfo *<em> modinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_get_module_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the ethtool_modinfo for a SFP module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_modinfo</span> <span class="pre">*</span> <span class="pre">modinfo</span></code></dt><dd><p>a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_modinfo</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the type and eeprom_len parameters in <strong>modinfo</strong> for a module on
the sfp bus specified by <strong>bus</strong>.</p>
<p>Returns 0 on success or a negative errno number.</p>
<dl class="function">
<dt id="c.sfp_get_module_eeprom">
int <code class="sig-name descname">sfp_get_module_eeprom</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em>, struct ethtool_eeprom *<em> ee</em>, u8 *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_get_module_eeprom" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the SFP module EEPROM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eeprom</span> <span class="pre">*</span> <span class="pre">ee</span></code></dt><dd><p>a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eeprom</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>buffer to contain the EEPROM data (must be at least <strong>ee-&gt;len</strong> bytes)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the EEPROM as specified by the supplied <strong>ee</strong>. See the documentation
for <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eeprom</span></code> for the region to be read.</p>
<p>Returns 0 on success or a negative errno number.</p>
<dl class="function">
<dt id="c.sfp_upstream_start">
void <code class="sig-name descname">sfp_upstream_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_upstream_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Inform the SFP that the network device is up</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the SFP socket that the network device is now up, so that the
module can be enabled by allowing TX_DISABLE to be deasserted. This
should be called from the network device driver’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device_ops</span></code>
ndo_open() method.</p>
<dl class="function">
<dt id="c.sfp_upstream_stop">
void <code class="sig-name descname">sfp_upstream_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_upstream_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Inform the SFP that the network device is down</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the SFP socket that the network device is now up, so that the
module can be disabled by asserting TX_DISABLE, disabling the laser
in optical modules. This should be called from the network device
driver’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device_ops</span></code> ndo_stop() method.</p>
<dl class="function">
<dt id="c.sfp_bus_find_fwnode">
struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> * <code class="sig-name descname">sfp_bus_find_fwnode</code><span class="sig-paren">(</span>struct fwnode_handle *<em> fwnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_bus_find_fwnode" title="Permalink to this definition">¶</a></dt>
<dd><p>parse and locate the SFP bus from fwnode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt><dd><p>firmware node for the parent device (MAC or PHY)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the parent device’s firmware node for a SFP bus, and locate
the sfp_bus structure, incrementing its reference count.  This must
be put via <a class="reference internal" href="#c.sfp_bus_put" title="sfp_bus_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">sfp_bus_put()</span></code></a> when done.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>on success, a pointer to the sfp_bus structure,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no SFP is specified,</p></li>
<li><p>on failure, an error pointer value:</p>
<ul>
<li><p>corresponding to the errors detailed for
fwnode_property_get_reference_args().</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if we failed to allocate the bus.</p></li>
<li><p>an error from the upstream’s connect_phy() method.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.sfp_bus_add_upstream">
int <code class="sig-name descname">sfp_bus_add_upstream</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em>, void *<em> upstream</em>, const struct <a class="reference internal" href="#c.sfp_upstream_ops" title="sfp_upstream_ops">sfp_upstream_ops</a> *<em> ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_bus_add_upstream" title="Permalink to this definition">¶</a></dt>
<dd><p>parse and register the neighbouring device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> found via <a class="reference internal" href="#c.sfp_bus_find_fwnode" title="sfp_bus_find_fwnode"><code class="xref c c-func docutils literal notranslate"><span class="pre">sfp_bus_find_fwnode()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">upstream</span></code></dt><dd><p>the upstream private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sfp_upstream_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>the upstream’s <a class="reference internal" href="#c.sfp_upstream_ops" title="sfp_upstream_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_upstream_ops</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add upstream driver for the SFP bus, and if the bus is complete, register
the SFP bus using sfp_register_upstream().  This takes a reference on the
bus, so it is safe to put the bus after this call.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>on success, a pointer to the sfp_bus structure,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no SFP is specified,</p></li>
<li><p>on failure, an error pointer value:</p>
<ul>
<li><p>corresponding to the errors detailed for
fwnode_property_get_reference_args().</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if we failed to allocate the bus.</p></li>
<li><p>an error from the upstream’s connect_phy() method.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.sfp_bus_del_upstream">
void <code class="sig-name descname">sfp_bus_del_upstream</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> *<em> bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_bus_del_upstream" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a sfp bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Delete a previously registered upstream connection for the SFP
module. <strong>bus</strong> should have been added by <a class="reference internal" href="#c.sfp_bus_add_upstream" title="sfp_bus_add_upstream"><code class="xref c c-func docutils literal notranslate"><span class="pre">sfp_bus_add_upstream()</span></code></a>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="z8530book.html" class="btn btn-neutral float-right" title="Z8530 Programming Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="j1939.html" class="btn btn-neutral float-left" title="J1939 Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>