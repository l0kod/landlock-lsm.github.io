

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.1. Digital TV Common functions &mdash; The Linux Kernel 5.10.0-rc1+ documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2.2. Digital TV Frontend kABI" href="dtv-frontend.html" />
    <link rel="prev" title="2. Digital TV (DVB) devices" href="dtv-core.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">2.1. Digital TV Common functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-frontend.html">2.2. Digital TV Frontend kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-demux.html">2.3. Digital TV Demux kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-ca.html">2.4. Digital TV Conditional Access kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-net.html">2.5. Digital TV Network kABI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">3. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">4. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">5. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">6. MIPI CSI-2</a></li>
<li class="toctree-l3"><a class="reference internal" href="camera-sensor.html">7. Writing camera sensor drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="drivers/index.html">8. Media driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Media subsystem kernel internal API</a> &raquo;</li>
        
          <li><a href="dtv-core.html"><span class="section-number">2. </span>Digital TV (DVB) devices</a> &raquo;</li>
        
      <li><span class="section-number">2.1. </span>Digital TV Common functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/media/dtv-common.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="digital-tv-common-functions">
<h1><span class="section-number">2.1. </span>Digital TV Common functions<a class="headerlink" href="#digital-tv-common-functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="math-functions">
<h2><span class="section-number">2.1.1. </span>Math functions<a class="headerlink" href="#math-functions" title="Permalink to this headline">¶</a></h2>
<p>Provide some commonly-used math functions, usually required in order to
estimate signal strength and signal to noise measurements in dB.</p>
<dl class="c function">
<dt id="c.intlog2">
unsigned int <code class="sig-name descname">intlog2</code><span class="sig-paren">(</span>u32 <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intlog2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>computes log2 of a value; the result is shifted left by 24 bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">value</span></code></dt><dd><p>The value (must be != 0)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>to use rational values you can use the following method:</p>
<blockquote>
<div><p>intlog2(value) = intlog2(value * 2^x) - x * 2^24</p>
</div></blockquote>
<p>Some usecase examples:</p>
<blockquote>
<div><p>intlog2(8) will give 3 &lt;&lt; 24 = 3 * 2^24</p>
<p>intlog2(9) will give 3 &lt;&lt; 24 + … = 3.16… * 2^24</p>
<p>intlog2(1.5) = intlog2(3) - 2^24 = 0.584… * 2^24</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>log2(value) * 2^24</p>
<dl class="c function">
<dt id="c.intlog10">
unsigned int <code class="sig-name descname">intlog10</code><span class="sig-paren">(</span>u32 <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intlog10" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>computes log10 of a value; the result is shifted left by 24 bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">value</span></code></dt><dd><p>The value (must be != 0)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>to use rational values you can use the following method:</p>
<blockquote>
<div><p>intlog10(value) = intlog10(value * 10^x) - x * 2^24</p>
</div></blockquote>
<p>An usecase example:</p>
<blockquote>
<div><blockquote>
<div><p>intlog10(1000) will give 3 &lt;&lt; 24 = 3 * 2^24</p>
</div></blockquote>
<p>due to the implementation intlog10(1000) might be not exactly 3 * 2^24</p>
</div></blockquote>
<p>look at intlog2 for similar examples</p>
<p><strong>Return</strong></p>
<p>log10(value) * 2^24</p>
</div>
<div class="section" id="dvb-devices">
<h2><span class="section-number">2.1.2. </span>DVB devices<a class="headerlink" href="#dvb-devices" title="Permalink to this headline">¶</a></h2>
<p>Those functions are responsible for handling the DVB device nodes.</p>
<dl class="c enum">
<dt id="c.dvb_device_type">
<em class="property">enum </em><code class="sig-name descname">dvb_device_type</code><a class="headerlink" href="#c.dvb_device_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>type of the Digital TV device</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DVB_DEVICE_SEC</span></code></dt><dd><p>Digital TV standalone Common Interface (CI)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_DEVICE_FRONTEND</span></code></dt><dd><p>Digital TV frontend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_DEVICE_DEMUX</span></code></dt><dd><p>Digital TV demux.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_DEVICE_DVR</span></code></dt><dd><p>Digital TV digital video record (DVR).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_DEVICE_CA</span></code></dt><dd><p>Digital TV Conditional Access (CA).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_DEVICE_NET</span></code></dt><dd><p>Digital TV network.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_DEVICE_VIDEO</span></code></dt><dd><p>Digital TV video decoder.
Deprecated. Used only on av7110-av.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_DEVICE_AUDIO</span></code></dt><dd><p>Digital TV audio decoder.
Deprecated. Used only on av7110-av.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_DEVICE_OSD</span></code></dt><dd><p>Digital TV On Screen Display (OSD).
Deprecated. Used only on av7110.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.dvb_adapter">
<em class="property">struct </em><code class="sig-name descname">dvb_adapter</code><a class="headerlink" href="#c.dvb_adapter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>represents a Digital TV adapter using Linux DVB API</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_adapter {
  int num;
  struct list_head list_head;
  struct list_head device_list;
  const char *name;
  u8 proposed_mac [6];
  void* priv;
  struct device *device;
  struct module *module;
  int mfe_shared;
  struct dvb_device *mfe_dvbdev;
  struct mutex mfe_lock;
#if defined(CONFIG_MEDIA_CONTROLLER_DVB);
  struct mutex mdev_lock;
  struct media_device *mdev;
  struct media_entity *conn;
  struct media_pad *conn_pads;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num</span></code></dt><dd><p>Number of the adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list_head</span></code></dt><dd><p>List with the DVB adapters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_list</span></code></dt><dd><p>List with the DVB devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proposed_mac</span></code></dt><dd><p>proposed MAC address for the adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device</span></code></dt><dd><p>pointer to <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module</span></code></dt><dd><p>pointer to struct module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mfe_shared</span></code></dt><dd><p>indicates mutually exclusive frontends.
Use of this flag is currently deprecated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mfe_dvbdev</span></code></dt><dd><p>Frontend device in use, in the case of MFE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mfe_lock</span></code></dt><dd><p>Lock to prevent using the other frontends when MFE is
used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mdev_lock</span></code></dt><dd><p>Protect access to the mdev pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_device" title="media_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span></code></a>, used when the media
controller is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn</span></code></dt><dd><p>RF connector. Used only if the device has no separate
tuner.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn_pads</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_pad" title="media_pad"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pad</span></code></a> associated with <strong>conn</strong>;</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.dvb_device">
<em class="property">struct </em><code class="sig-name descname">dvb_device</code><a class="headerlink" href="#c.dvb_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>represents a DVB device node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_device {
  struct list_head list_head;
  const struct file_operations *fops;
  struct dvb_adapter *adapter;
  enum dvb_device_type type;
  int minor;
  u32 id;
  int readers;
  int writers;
  int users;
  wait_queue_head_t wait_queue;
  int (*kernel_ioctl)(struct file *file, unsigned int cmd, void *arg);
#if defined(CONFIG_MEDIA_CONTROLLER_DVB);
  const char *name;
  struct media_intf_devnode *intf_devnode;
  unsigned tsout_num_entities;
  struct media_entity *entity, *tsout_entity;
  struct media_pad *pads, *tsout_pads;
#endif;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list_head</span></code></dt><dd><p>List head with all DVB devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fops</span></code></dt><dd><p>pointer to struct file_operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adapter</span></code></dt><dd><p>pointer to the adapter that holds this device node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the device, as defined by <a class="reference internal" href="#c.dvb_device_type" title="dvb_device_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dvb_device_type</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p>devnode minor number. Major number is always DVB_MAJOR.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>device ID number, inside the adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">readers</span></code></dt><dd><p>Initialized by the caller. Each call to open() in Read Only mode
decreases this counter by one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writers</span></code></dt><dd><p>Initialized by the caller. Each call to open() in Read/Write
mode decreases this counter by one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">users</span></code></dt><dd><p>Initialized by the caller. Each call to open() in any mode
decreases this counter by one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_queue</span></code></dt><dd><p>wait queue, used to wait for certain events inside one of
the DVB API callers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_ioctl</span></code></dt><dd><p>callback function used to handle ioctl calls from userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name to be used for the device at the Media Controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">intf_devnode</span></code></dt><dd><p>Pointer to media_intf_devnode. Used by the dvbdev core to
store the MC device node interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tsout_num_entities</span></code></dt><dd><p>Number of Transport Stream output entities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entity</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a> associated with the device node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tsout_entity</span></code></dt><dd><p>array with MC entities associated to each TS output node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pads</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_pad" title="media_pad"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pad</span></code></a> associated with <strong>entity</strong>;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tsout_pads</span></code></dt><dd><p>array with the source pads for each <strong>tsout_entity</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is used by the DVB core (frontend, CA, net, demux) in
order to create the device nodes. Usually, driver should not initialize
this struct diretly.</p>
<dl class="c function">
<dt id="c.dvb_register_adapter">
int <code class="sig-name descname">dvb_register_adapter</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>adap</em>, <em class="property">const</em> char *<em>name</em>, <em class="property">struct</em> module *<em>module</em>, <em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>device</em>, short *<em>adapter_nums</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_register_adapter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Registers a new DVB adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Adapter’s name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*module</span></code></dt><dd><p>initialized with THIS_MODULE at the caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>pointer to <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> that corresponds to the device driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">short</span> <span class="pre">*adapter_nums</span></code></dt><dd><p>Array with a list of the numbers for <strong>dvb_register_adapter</strong>;
to select among them. Typically, initialized with:
DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nums)</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_unregister_adapter">
int <code class="sig-name descname">dvb_unregister_adapter</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_unregister_adapter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregisters a DVB adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_register_device">
int <code class="sig-name descname">dvb_register_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>adap</em>, <em class="property">struct</em> <a class="reference internal" href="#c.dvb_device" title="dvb_device">dvb_device</a> **<em>pdvbdev</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.dvb_device" title="dvb_device">dvb_device</a> *<em>template</em>, void *<em>priv</em>, <em class="property">enum</em> <a class="reference internal" href="#c.dvb_device_type" title="dvb_device_type">dvb_device_type</a> <em>type</em>, int <em>demux_sink_pads</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_register_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Registers a new DVB device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_device</span> <span class="pre">**pdvbdev</span></code></dt><dd><p>pointer to the place where the new <a class="reference internal" href="#c.dvb_device" title="dvb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_device</span></code></a> will be
stored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dvb_device</span> <span class="pre">*template</span></code></dt><dd><p>Template used to create <code class="xref c c-type docutils literal notranslate"><span class="pre">pdvbdev</span></code>;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dvb_device_type</span> <span class="pre">type</span></code></dt><dd><p>type of the device, as defined by <a class="reference internal" href="#c.dvb_device_type" title="dvb_device_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dvb_device_type</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">demux_sink_pads</span></code></dt><dd><p>Number of demux outputs, to be used to create the TS
outputs via the Media Controller.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_remove_device">
void <code class="sig-name descname">dvb_remove_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_device" title="dvb_device">dvb_device</a> *<em>dvbdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_remove_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove a registered DVB device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_device</span> <span class="pre">*dvbdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_device" title="dvb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This does not free memory.  To do that, call <a class="reference internal" href="#c.dvb_free_device" title="dvb_free_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_free_device()</span></code></a>.</p>
<dl class="c function">
<dt id="c.dvb_free_device">
void <code class="sig-name descname">dvb_free_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_device" title="dvb_device">dvb_device</a> *<em>dvbdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_free_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free memory occupied by a DVB device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_device</span> <span class="pre">*dvbdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_device" title="dvb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <a class="reference internal" href="#c.dvb_unregister_device" title="dvb_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_unregister_device()</span></code></a> before calling this function.</p>
<dl class="c function">
<dt id="c.dvb_unregister_device">
void <code class="sig-name descname">dvb_unregister_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_device" title="dvb_device">dvb_device</a> *<em>dvbdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_unregister_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregisters a DVB device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_device</span> <span class="pre">*dvbdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_device" title="dvb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a combination of <a class="reference internal" href="#c.dvb_remove_device" title="dvb_remove_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_remove_device()</span></code></a> and <a class="reference internal" href="#c.dvb_free_device" title="dvb_free_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_free_device()</span></code></a>.
Using this function is usually a mistake, and is often an indicator
for a use-after-free bug (when a userspace process keeps a file
handle to a detached device).</p>
<dl class="c function">
<dt id="c.dvb_create_media_graph">
int <code class="sig-name descname">dvb_create_media_graph</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>adap</em>, bool <em>create_rf_connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_create_media_graph" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates media graph for the Digital TV part of the device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">create_rf_connector</span></code></dt><dd><p>if true, it creates the RF connector too</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks all DVB-related functions at the media controller
entities and creates the needed links for the media graph. It is
capable of working with multiple tuners or multiple frontends, but it
won’t create links if the device has multiple tuners and multiple frontends
or if the device has multiple muxes. In such case, the caller driver should
manually create the remaining links.</p>
<dl class="c function">
<dt id="c.dvb_register_media_controller">
void <code class="sig-name descname">dvb_register_media_controller</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>adap</em>, <em class="property">struct</em> <a class="reference internal" href="mc-core.html#c.media_device" title="media_device">media_device</a> *<em>mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_register_media_controller" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>registers a media controller at DVB adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span></code></a></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_get_media_controller">
<em class="property">struct</em> <a class="reference internal" href="mc-core.html#c.media_device" title="media_device">media_device</a> *<code class="sig-name descname">dvb_get_media_controller</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_get_media_controller" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>gets the associated media controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_generic_open">
int <code class="sig-name descname">dvb_generic_open</code><span class="sig-paren">(</span><em class="property">struct</em> inode *<em>inode</em>, <em class="property">struct</em> file *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_generic_open" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Digital TV open function, used by DVB devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks if a DVB devnode is still valid, and if the permissions are
OK and increment negative use count.</p>
<dl class="c function">
<dt id="c.dvb_generic_release">
int <code class="sig-name descname">dvb_generic_release</code><span class="sig-paren">(</span><em class="property">struct</em> inode *<em>inode</em>, <em class="property">struct</em> file *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_generic_release" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Digital TV close function, used by DVB devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks if a DVB devnode is still valid, and if the permissions are
OK and decrement negative use count.</p>
<dl class="c function">
<dt id="c.dvb_generic_ioctl">
long <code class="sig-name descname">dvb_generic_ioctl</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>file</em>, unsigned int <em>cmd</em>, unsigned long <em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_generic_ioctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Digital TV close function, used by DVB devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>Ioctl name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>Ioctl argument.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks if a DVB devnode and struct dvbdev.kernel_ioctl is still valid.
If so, calls <a class="reference internal" href="#c.dvb_usercopy" title="dvb_usercopy"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_usercopy()</span></code></a>.</p>
<dl class="c function">
<dt id="c.dvb_usercopy">
int <code class="sig-name descname">dvb_usercopy</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>file</em>, unsigned int <em>cmd</em>, unsigned long <em>arg</em>, int (*<em>func</em>)<span class="sig-paren">(</span><em class="property">struct</em> file *file, unsigned int cmd, void *arg<span class="sig-paren">)</span><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_usercopy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copies data from/to userspace memory when an ioctl is issued.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>Pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">file</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>Ioctl name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>Ioctl argument.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*func)(struct</span> <span class="pre">file</span> <span class="pre">*file,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd,</span> <span class="pre">void</span> <span class="pre">*arg)</span></code></dt><dd><p>function that will actually handle the ioctl</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ancillary function that uses ioctl direction and size to copy from
userspace. Then, it calls <strong>func</strong>, and, if needed, data is copied back
to userspace.</p>
<dl class="c function">
<dt id="c.dvb_module_probe">
<em class="property">struct</em> <a class="reference internal" href="../i2c.html#c.i2c_client" title="i2c_client">i2c_client</a> *<code class="sig-name descname">dvb_module_probe</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>module_name</em>, <em class="property">const</em> char *<em>name</em>, <em class="property">struct</em> i2c_adapter *<em>adap</em>, unsigned char <em>addr</em>, void *<em>platform_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_module_probe" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>helper routine to probe an I2C module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*module_name</span></code></dt><dd><p>Name of the I2C module to be probed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Optional name for the I2C module. Used for debug purposes.
If <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, defaults to <strong>module_name</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span></code> that describes the I2C adapter where
the module will be bound.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">addr</span></code></dt><dd><p>I2C address of the adapter, in 7-bit notation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*platform_data</span></code></dt><dd><p>Platform data to be passed to the I2C module probed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function binds an I2C device into the DVB core. Should be used by
all drivers that use I2C bus to control the hardware. A module bound
with <a class="reference internal" href="#c.dvb_module_probe" title="dvb_module_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_module_probe()</span></code></a> should use <a class="reference internal" href="#c.dvb_module_release" title="dvb_module_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_module_release()</span></code></a> to unbind.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the past, DVB modules (mainly, frontends) were bound via <a class="reference internal" href="#c.dvb_attach" title="dvb_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_attach()</span></code></a>
macro, with does an ugly hack, using I2C low level functions. Such
usage is deprecated and will be removed soon. Instead, use this routine.</p>
</div>
<p><strong>Return</strong></p>
<blockquote>
<div><p>On success, return an <a class="reference internal" href="../i2c.html#c.i2c_client" title="i2c_client"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_client</span></code></a>, pointing to the bound
I2C device. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</div></blockquote>
<dl class="c function">
<dt id="c.dvb_module_release">
void <code class="sig-name descname">dvb_module_release</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../i2c.html#c.i2c_client" title="i2c_client">i2c_client</a> *<em>client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_module_release" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>releases an I2C device allocated with <a class="reference internal" href="#c.dvb_module_probe" title="dvb_module_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_module_probe()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>pointer to <a class="reference internal" href="../i2c.html#c.i2c_client" title="i2c_client"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_client</span></code></a> with the I2C client to be released.
can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be used to free all resources reserved by
<a class="reference internal" href="#c.dvb_module_probe" title="dvb_module_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_module_probe()</span></code></a> and unbinding the I2C hardware.</p>
<dl class="c macro">
<dt id="c.dvb_attach">
<code class="sig-name descname">dvb_attach</code><a class="headerlink" href="#c.dvb_attach" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">dvb_attach</span> <span class="pre">(FUNCTION,</span> <span class="pre">ARGS...)</span></code></p>
<blockquote>
<div><p>attaches a DVB frontend into the DVB core.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">FUNCTION</span></code></dt><dd><p>function on a frontend module to be called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARGS...</span></code></dt><dd><p><strong>FUNCTION</strong> arguments.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This ancillary function loads a frontend module in runtime and runs
the <strong>FUNCTION</strong> function there, with <strong>ARGS</strong>.
As it increments symbol usage cont, at unregister, <a class="reference internal" href="#c.dvb_detach" title="dvb_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_detach()</span></code></a>
should be called.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the past, DVB modules (mainly, frontends) were bound via <a class="reference internal" href="#c.dvb_attach" title="dvb_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_attach()</span></code></a>
macro, with does an ugly hack, using I2C low level functions. Such
usage is deprecated and will be removed soon. Instead, you should use
<a class="reference internal" href="#c.dvb_module_probe" title="dvb_module_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_module_probe()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt id="c.dvb_detach">
<code class="sig-name descname">dvb_detach</code><a class="headerlink" href="#c.dvb_detach" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">dvb_detach</span> <span class="pre">(FUNC)</span></code></p>
<blockquote>
<div><p>detaches a DVB frontend loaded via <a class="reference internal" href="#c.dvb_attach" title="dvb_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_attach()</span></code></a></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">FUNC</span></code></dt><dd><p>attach function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrements usage count for a function previously called via <a class="reference internal" href="#c.dvb_attach" title="dvb_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_attach()</span></code></a>.</p>
</div>
<div class="section" id="digital-tv-ring-buffer">
<h2><span class="section-number">2.1.3. </span>Digital TV Ring buffer<a class="headerlink" href="#digital-tv-ring-buffer" title="Permalink to this headline">¶</a></h2>
<p>Those routines implement ring buffers used to handle digital TV data and
copy it from/to userspace.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>For performance reasons read and write routines don’t check buffer sizes
and/or number of bytes free/available. This has to be done before these
routines are called. For example:</p></li>
</ol>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* write @buflen: bytes */</span>
<span class="n">free</span> <span class="o">=</span> <span class="n">dvb_ringbuffer_free</span><span class="p">(</span><span class="n">rbuf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">buflen</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">dvb_ringbuffer_write</span><span class="p">(</span><span class="n">rbuf</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
<span class="k">else</span>
        <span class="cm">/* do something */</span>

<span class="cm">/* read min. 1000, max. @bufsize: bytes */</span>
<span class="n">avail</span> <span class="o">=</span> <span class="n">dvb_ringbuffer_avail</span><span class="p">(</span><span class="n">rbuf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">dvb_ringbuffer_read</span><span class="p">(</span><span class="n">rbuf</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">avail</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">));</span>
<span class="k">else</span>
        <span class="cm">/* do something */</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>If there is exactly one reader and one writer, there is no need
to lock read or write operations.
Two or more readers must be locked against each other.
Flushing the buffer counts as a read operation.
Resetting the buffer counts as a read and write operation.
Two or more writers must be locked against each other.</p></li>
</ol>
</div>
<dl class="c struct">
<dt id="c.dvb_ringbuffer">
<em class="property">struct </em><code class="sig-name descname">dvb_ringbuffer</code><a class="headerlink" href="#c.dvb_ringbuffer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Describes a ring buffer used at DVB framework</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_ringbuffer {
  u8 *data;
  ssize_t size;
  ssize_t pread;
  ssize_t pwrite;
  int error;
  wait_queue_head_t queue;
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Area were the ringbuffer data is written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>size of the ringbuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pread</span></code></dt><dd><p>next position to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pwrite</span></code></dt><dd><p>next position to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error</span></code></dt><dd><p>used by ringbuffer clients to indicate that an error happened.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue</span></code></dt><dd><p>Wait queue used by ringbuffer clients to indicate when buffer
was filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Spinlock used to protect the ringbuffer</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_ringbuffer_init">
void <code class="sig-name descname">dvb_ringbuffer_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em>, void *<em>data</em>, size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize ring buffer, lock and queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>pointer to the buffer where the data will be stored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>bytes from ring buffer into <strong>buf</strong></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_ringbuffer_empty">
int <code class="sig-name descname">dvb_ringbuffer_empty</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_empty" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>test whether buffer is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_ringbuffer_free">
ssize_t <code class="sig-name descname">dvb_ringbuffer_free</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns the number of free bytes in the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>number of free bytes in the buffer</p>
<dl class="c function">
<dt id="c.dvb_ringbuffer_avail">
ssize_t <code class="sig-name descname">dvb_ringbuffer_avail</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_avail" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns the number of bytes waiting in the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>number of bytes waiting in the buffer</p>
<dl class="c function">
<dt id="c.dvb_ringbuffer_reset">
void <code class="sig-name descname">dvb_ringbuffer_reset</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>resets the ringbuffer to initial state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the read and write pointers to zero and flush the buffer.</p>
<p>This counts as a read and write operation</p>
<dl class="c function">
<dt id="c.dvb_ringbuffer_flush">
void <code class="sig-name descname">dvb_ringbuffer_flush</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>flush buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_ringbuffer_flush_spinlock_wakeup">
void <code class="sig-name descname">dvb_ringbuffer_flush_spinlock_wakeup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_flush_spinlock_wakeup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>flush buffer protected by spinlock and wake-up waiting task(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.DVB_RINGBUFFER_PEEK">
<code class="sig-name descname">DVB_RINGBUFFER_PEEK</code><a class="headerlink" href="#c.DVB_RINGBUFFER_PEEK" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DVB_RINGBUFFER_PEEK</span> <span class="pre">(rbuf,</span> <span class="pre">offs)</span></code></p>
<blockquote>
<div><p>peek at byte <strong>offs</strong> in the buffer</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offs</span></code></dt><dd><p>offset inside the ringbuffer</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.DVB_RINGBUFFER_SKIP">
<code class="sig-name descname">DVB_RINGBUFFER_SKIP</code><a class="headerlink" href="#c.DVB_RINGBUFFER_SKIP" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DVB_RINGBUFFER_SKIP</span> <span class="pre">(rbuf,</span> <span class="pre">num)</span></code></p>
<blockquote>
<div><p>advance read ptr by <strong>num</strong> bytes</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num</span></code></dt><dd><p>number of bytes to advance</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_ringbuffer_read_user">
ssize_t <code class="sig-name descname">dvb_ringbuffer_read_user</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em>, u8 __user *<em>buf</em>, size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_read_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reads a buffer into a user pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to the buffer where the data will be stored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>bytes from ring buffer into <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant assumes that the buffer is a memory at the userspace. So,
it will internally call copy_to_user().</p>
<p><strong>Return</strong></p>
<p>number of bytes transferred or -EFAULT</p>
<dl class="c function">
<dt id="c.dvb_ringbuffer_read">
void <code class="sig-name descname">dvb_ringbuffer_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em>, u8 *<em>buf</em>, size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reads a buffer into a pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to the buffer where the data will be stored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>bytes from ring buffer into <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant assumes that the buffer is a memory at the Kernel space</p>
<p><strong>Return</strong></p>
<p>number of bytes transferred or -EFAULT</p>
<dl class="c macro">
<dt id="c.DVB_RINGBUFFER_WRITE_BYTE">
<code class="sig-name descname">DVB_RINGBUFFER_WRITE_BYTE</code><a class="headerlink" href="#c.DVB_RINGBUFFER_WRITE_BYTE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DVB_RINGBUFFER_WRITE_BYTE</span> <span class="pre">(rbuf,</span> <span class="pre">byte)</span></code></p>
<blockquote>
<div><p>write single byte to ring buffer</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">byte</span></code></dt><dd><p>byte to write</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_ringbuffer_write">
ssize_t <code class="sig-name descname">dvb_ringbuffer_write</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em>, <em class="property">const</em> u8 *<em>buf</em>, size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_write" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Writes a buffer into the ringbuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to the buffer where the data will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>bytes from ring buffer into <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant assumes that the buffer is a memory at the Kernel space</p>
<p><strong>Return</strong></p>
<p>number of bytes transferred or -EFAULT</p>
<dl class="c function">
<dt id="c.dvb_ringbuffer_write_user">
ssize_t <code class="sig-name descname">dvb_ringbuffer_write_user</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em>, <em class="property">const</em> u8 __user *<em>buf</em>, size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_write_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Writes a buffer received via a user pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to the buffer where the data will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>bytes from ring buffer into <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant assumes that the buffer is a memory at the userspace. So,
it will internally call copy_from_user().</p>
<p><strong>Return</strong></p>
<p>number of bytes transferred or -EFAULT</p>
<dl class="c function">
<dt id="c.dvb_ringbuffer_pkt_write">
ssize_t <code class="sig-name descname">dvb_ringbuffer_pkt_write</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em>, u8 *<em>buf</em>, size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_pkt_write" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a packet into the ringbuffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>Ringbuffer to write to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer to write.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>Length of buffer (currently limited to 65535 bytes max).</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Number of bytes written, or -EFAULT, -ENOMEM, -EVINAL.</p>
<dl class="c function">
<dt id="c.dvb_ringbuffer_pkt_read_user">
ssize_t <code class="sig-name descname">dvb_ringbuffer_pkt_read_user</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em>, size_t <em>idx</em>, int <em>offset</em>, u8 __user *<em>buf</em>, size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_pkt_read_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read from a packet in the ringbuffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>Ringbuffer concerned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">idx</span></code></dt><dd><p>Packet index as returned by <a class="reference internal" href="#c.dvb_ringbuffer_pkt_next" title="dvb_ringbuffer_pkt_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_ringbuffer_pkt_next()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>Offset into packet to read from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>Destination buffer for data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>Size of destination buffer.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Number of bytes read, or -EFAULT.</p>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>unlike <a class="reference internal" href="#c.dvb_ringbuffer_read" title="dvb_ringbuffer_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_ringbuffer_read()</span></code></a>, this does <strong>NOT</strong> update the read pointer
in the ringbuffer. You must use <a class="reference internal" href="#c.dvb_ringbuffer_pkt_dispose" title="dvb_ringbuffer_pkt_dispose"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_ringbuffer_pkt_dispose()</span></code></a> to mark a
packet as no longer required.</p>
</div>
<dl class="c function">
<dt id="c.dvb_ringbuffer_pkt_read">
ssize_t <code class="sig-name descname">dvb_ringbuffer_pkt_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em>, size_t <em>idx</em>, int <em>offset</em>, u8 *<em>buf</em>, size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_pkt_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read from a packet in the ringbuffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>Ringbuffer concerned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">idx</span></code></dt><dd><p>Packet index as returned by <a class="reference internal" href="#c.dvb_ringbuffer_pkt_next" title="dvb_ringbuffer_pkt_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_ringbuffer_pkt_next()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>Offset into packet to read from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>Destination buffer for data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>Size of destination buffer.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>unlike <a class="reference internal" href="#c.dvb_ringbuffer_read_user" title="dvb_ringbuffer_read_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_ringbuffer_read_user()</span></code></a>, this DOES update the read pointer
in the ringbuffer.</p>
<p><strong>Return</strong></p>
<p>Number of bytes read, or -EFAULT.</p>
<dl class="c function">
<dt id="c.dvb_ringbuffer_pkt_dispose">
void <code class="sig-name descname">dvb_ringbuffer_pkt_dispose</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em>, size_t <em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_pkt_dispose" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dispose of a packet in the ring buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>Ring buffer concerned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">idx</span></code></dt><dd><p>Packet index as returned by <a class="reference internal" href="#c.dvb_ringbuffer_pkt_next" title="dvb_ringbuffer_pkt_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_ringbuffer_pkt_next()</span></code></a>.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_ringbuffer_pkt_next">
ssize_t <code class="sig-name descname">dvb_ringbuffer_pkt_next</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>rbuf</em>, size_t <em>idx</em>, size_t *<em>pktlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_pkt_next" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the index of the next packet in a ringbuffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*rbuf</span></code></dt><dd><p>Ringbuffer concerned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">idx</span></code></dt><dd><p>Previous packet index, or -1 to return the first packet index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*pktlen</span></code></dt><dd><p>On success, will be updated to contain the length of the packet
in bytes.
returns Packet index (if &gt;=0), or -1 if no packets available.</p>
</dd>
</dl>
</div>
<div class="section" id="digital-tv-vb2-handler">
<h2><span class="section-number">2.1.4. </span>Digital TV VB2 handler<a class="headerlink" href="#digital-tv-vb2-handler" title="Permalink to this headline">¶</a></h2>
<dl class="c enum">
<dt id="c.dvb_buf_type">
<em class="property">enum </em><code class="sig-name descname">dvb_buf_type</code><a class="headerlink" href="#c.dvb_buf_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>types of Digital TV memory-mapped buffers</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DVB_BUF_TYPE_CAPTURE</span></code></dt><dd><p>buffer is filled by the Kernel,
with a received Digital TV stream</p>
</dd>
</dl>
<dl class="c enum">
<dt id="c.dvb_vb2_states">
<em class="property">enum </em><code class="sig-name descname">dvb_vb2_states</code><a class="headerlink" href="#c.dvb_vb2_states" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>states to control VB2 state machine</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DVB_VB2_STATE_NONE</span></code></dt><dd><p>VB2 engine not initialized yet, init failed or VB2 was released.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_VB2_STATE_INIT</span></code></dt><dd><p>VB2 engine initialized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_VB2_STATE_REQBUFS</span></code></dt><dd><p>Buffers were requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVB_VB2_STATE_STREAMON</span></code></dt><dd><p>VB2 is streaming. Callers should not check it directly. Instead,
they should use <a class="reference internal" href="#c.dvb_vb2_is_streaming" title="dvb_vb2_is_streaming"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_vb2_is_streaming()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p><strong>Description</strong></p>
<p>Callers should not touch at the state machine directly. This
is handled inside dvb_vb2.c.</p>
<dl class="c struct">
<dt id="c.dvb_buffer">
<em class="property">struct </em><code class="sig-name descname">dvb_buffer</code><a class="headerlink" href="#c.dvb_buffer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>video buffer information for v4l2.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_buffer {
  struct vb2_buffer       vb;
  struct list_head        list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vb</span></code></dt><dd><p>embedded struct <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_buffer</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>list of <a class="reference internal" href="#c.dvb_buffer" title="dvb_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_buffer</span></code></a>.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.dvb_vb2_ctx">
<em class="property">struct </em><code class="sig-name descname">dvb_vb2_ctx</code><a class="headerlink" href="#c.dvb_vb2_ctx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>control struct for VB2 handler</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_vb2_ctx {
  struct vb2_queue        vb_q;
  struct mutex            mutex;
  spinlock_t slock;
  struct list_head        dvb_q;
  struct dvb_buffer       *buf;
  int offset;
  int remain;
  int state;
  int buf_siz;
  int buf_cnt;
  int nonblocking;
  enum dmx_buffer_flags flags;
  u32 count;
  char name[DVB_VB2_NAME_MAX + 1];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vb_q</span></code></dt><dd><p>pointer to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>mutex to serialize vb2 operations. Used by
vb2 core <code class="docutils literal notranslate"><span class="pre">wait_prepare</span></code> and <code class="docutils literal notranslate"><span class="pre">wait_finish</span></code> operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slock</span></code></dt><dd><p>spin lock used to protect buffer filling at dvb_vb2.c.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dvb_q</span></code></dt><dd><p>List of buffers that are not filled yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>Pointer to the buffer that are currently being filled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>index to the next position at the <strong>buf</strong> to be filled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remain</span></code></dt><dd><p>How many bytes are left to be filled at <strong>buf</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>bitmask of buffer states as defined by <a class="reference internal" href="#c.dvb_vb2_states" title="dvb_vb2_states"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dvb_vb2_states</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_siz</span></code></dt><dd><p>size of each VB2 buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_cnt</span></code></dt><dd><p>number of VB2 buffers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nonblocking</span></code></dt><dd><p>If different than zero, device is operating on non-blocking
mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>buffer flags as defined by <a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_buffer_flags" title="dmx_buffer_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dmx_buffer_flags</span></code></a>.
Filled only at <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_DQBUF</span></code>. <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_QBUF</span></code> should zero this field.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>monotonic counter for filled buffers. Helps to identify
data stream loses. Filled only at <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_DQBUF</span></code>. <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_QBUF</span></code> should
zero this field.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the device type. Currently, it can either be
“dvr” or “demux_filter”.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_vb2_init">
int <code class="sig-name descname">dvb_vb2_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em>, <em class="property">const</em> char *<em>name</em>, int <em>non_blocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initializes VB2 handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name for the VB2 handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">non_blocking</span></code></dt><dd><p>if not zero, it means that the device is at non-blocking mode</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_vb2_release">
int <code class="sig-name descname">dvb_vb2_release</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_release" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Releases the VB2 handler allocated resources and put <strong>ctx</strong> at DVB_VB2_STATE_NONE state.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_vb2_is_streaming">
int <code class="sig-name descname">dvb_vb2_is_streaming</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_is_streaming" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>checks if the VB2 handler is streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if not streaming, 1 otherwise.</p>
<dl class="c function">
<dt id="c.dvb_vb2_fill_buffer">
int <code class="sig-name descname">dvb_vb2_fill_buffer</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em>, <em class="property">const</em> unsigned char *<em>src</em>, int <em>len</em>, <em class="property">enum</em> <a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_buffer_flags" title="dmx_buffer_flags">dmx_buffer_flags</a> *<em>buffer_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_fill_buffer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fills a VB2 buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*src</span></code></dt><dd><p>place where the data is stored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to be copied from <strong>src</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dmx_buffer_flags</span> <span class="pre">*buffer_flags</span></code></dt><dd><p>pointer to buffer flags as defined by <a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_buffer_flags" title="dmx_buffer_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dmx_buffer_flags</span></code></a>.
can be NULL.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_vb2_poll">
__poll_t <code class="sig-name descname">dvb_vb2_poll</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em>, <em class="property">struct</em> file *<em>file</em>, poll_table *<em>wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_poll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_streamon" title="vb2_core_streamon"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_streamon()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code> argument passed to the poll
file operation handler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*wait</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">poll_table</span></code> wait argument passed to the poll
file operation handler.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implements poll syscall() logic.</p>
<dl class="c function">
<dt id="c.dvb_vb2_stream_on">
int <code class="sig-name descname">dvb_vb2_stream_on</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_stream_on" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_streamon" title="vb2_core_streamon"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_streamon()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Starts dvb streaming</p>
<dl class="c function">
<dt id="c.dvb_vb2_stream_off">
int <code class="sig-name descname">dvb_vb2_stream_off</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_stream_off" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_streamoff" title="vb2_core_streamoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_streamoff()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops dvb streaming</p>
<dl class="c function">
<dt id="c.dvb_vb2_reqbufs">
int <code class="sig-name descname">dvb_vb2_reqbufs</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em>, <em class="property">struct</em> <a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_requestbuffers" title="dmx_requestbuffers">dmx_requestbuffers</a> *<em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_reqbufs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_reqbufs" title="vb2_core_reqbufs"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_reqbufs()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dmx_requestbuffers</span> <span class="pre">*req</span></code></dt><dd><p><a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_requestbuffers" title="dmx_requestbuffers"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dmx_requestbuffers</span></code></a> passed from userspace in
order to handle <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_REQBUFS</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initiate streaming by requesting a number of buffers. Also used to
free previously requested buffers, is <code class="docutils literal notranslate"><span class="pre">req-&gt;count</span></code> is zero.</p>
<dl class="c function">
<dt id="c.dvb_vb2_querybuf">
int <code class="sig-name descname">dvb_vb2_querybuf</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em>, <em class="property">struct</em> <a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer">dmx_buffer</a> *<em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_querybuf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_querybuf" title="vb2_core_querybuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_querybuf()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dmx_buffer</span> <span class="pre">*b</span></code></dt><dd><p><a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dmx_buffer</span></code></a> passed from userspace in
order to handle <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_QUERYBUF</span></code>.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.dvb_vb2_expbuf">
int <code class="sig-name descname">dvb_vb2_expbuf</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em>, <em class="property">struct</em> <a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_exportbuffer" title="dmx_exportbuffer">dmx_exportbuffer</a> *<em>exp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_expbuf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_expbuf" title="vb2_core_expbuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_expbuf()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dmx_exportbuffer</span> <span class="pre">*exp</span></code></dt><dd><p><a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_exportbuffer" title="dmx_exportbuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dmx_exportbuffer</span></code></a> passed from userspace in
order to handle <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_EXPBUF</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Export a buffer as a file descriptor.</p>
<dl class="c function">
<dt id="c.dvb_vb2_qbuf">
int <code class="sig-name descname">dvb_vb2_qbuf</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em>, <em class="property">struct</em> <a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer">dmx_buffer</a> *<em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_qbuf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_qbuf" title="vb2_core_qbuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_qbuf()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dmx_buffer</span> <span class="pre">*b</span></code></dt><dd><p><a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dmx_buffer</span></code></a> passed from userspace in
order to handle <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_QBUF</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue a Digital TV buffer as requested by userspace</p>
<dl class="c function">
<dt id="c.dvb_vb2_dqbuf">
int <code class="sig-name descname">dvb_vb2_dqbuf</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em>, <em class="property">struct</em> <a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer">dmx_buffer</a> *<em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_dqbuf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_dqbuf" title="vb2_core_dqbuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_dqbuf()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dmx_buffer</span> <span class="pre">*b</span></code></dt><dd><p><a class="reference internal" href="../../userspace-api/media/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dmx_buffer</span></code></a> passed from userspace in
order to handle <code class="xref c c-type docutils literal notranslate"><span class="pre">DMX_DQBUF</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dequeue a Digital TV buffer to the userspace</p>
<dl class="c function">
<dt id="c.dvb_vb2_mmap">
int <code class="sig-name descname">dvb_vb2_mmap</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>ctx</em>, <em class="property">struct</em> vm_area_struct *<em>vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_mmap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_mmap" title="vb2_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_mmap()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>control struct for VB2 handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> with the vma passed
to the mmap file operation handler in the driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>map Digital TV video buffers into application address space.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dtv-frontend.html" class="btn btn-neutral float-right" title="2.2. Digital TV Frontend kABI" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dtv-core.html" class="btn btn-neutral float-left" title="2. Digital TV (DVB) devices" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>