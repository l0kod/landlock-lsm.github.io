

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Generic Counter Interface &mdash; The Linux Kernel 5.12.0-rc3+ documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pblk: Physical Block Device Target" href="lightnvm-pblk.html" />
    <link rel="prev" title="Ordering I/O writes to memory-mapped addresses" href="io_ordering.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.12.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxl/index.html">Compute Express Link</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Generic Counter Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#theory">Theory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#signal">SIGNAL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synapse">SYNAPSE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#count">COUNT</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#paradigm">Paradigm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#userspace-interface">Userspace Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-api">Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#architecture">Architecture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Generic Counter Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/driver-api/generic-counter.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="generic-counter-interface">
<h1>Generic Counter Interface<a class="headerlink" href="#generic-counter-interface" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Counter devices are prevalent among a diverse spectrum of industries.
The ubiquitous presence of these devices necessitates a common interface
and standard of interaction and exposure. This driver API attempts to
resolve the issue of duplicate code found among existing counter device
drivers by introducing a generic counter interface for consumption. The
Generic Counter interface enables drivers to support and expose a common
set of components and functionality present in counter devices.</p>
</div>
<div class="section" id="theory">
<h2>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h2>
<p>Counter devices can vary greatly in design, but regardless of whether
some devices are quadrature encoder counters or tally counters, all
counter devices consist of a core set of components. This core set of
components, shared by all counter devices, is what forms the essence of
the Generic Counter interface.</p>
<p>There are three core components to a counter:</p>
<ul class="simple">
<li><p>Signal:
Stream of data to be evaluated by the counter.</p></li>
<li><p>Synapse:
Association of a Signal, and evaluation trigger, with a Count.</p></li>
<li><p>Count:
Accumulation of the effects of connected Synapses.</p></li>
</ul>
<div class="section" id="signal">
<h3>SIGNAL<a class="headerlink" href="#signal" title="Permalink to this headline">¶</a></h3>
<p>A Signal represents a stream of data. This is the input data that is
evaluated by the counter to determine the count data; e.g. a quadrature
signal output line of a rotary encoder. Not all counter devices provide
user access to the Signal data, so exposure is optional for drivers.</p>
<p>When the Signal data is available for user access, the Generic Counter
interface provides the following available signal values:</p>
<ul class="simple">
<li><p>SIGNAL_LOW:
Signal line is in a low state.</p></li>
<li><p>SIGNAL_HIGH:
Signal line is in a high state.</p></li>
</ul>
<p>A Signal may be associated with one or more Counts.</p>
</div>
<div class="section" id="synapse">
<h3>SYNAPSE<a class="headerlink" href="#synapse" title="Permalink to this headline">¶</a></h3>
<p>A Synapse represents the association of a Signal with a Count. Signal
data affects respective Count data, and the Synapse represents this
relationship.</p>
<p>The Synapse action mode specifies the Signal data condition that
triggers the respective Count’s count function evaluation to update the
count data. The Generic Counter interface provides the following
available action modes:</p>
<ul class="simple">
<li><p>None:
Signal does not trigger the count function. In Pulse-Direction count
function mode, this Signal is evaluated as Direction.</p></li>
<li><p>Rising Edge:
Low state transitions to high state.</p></li>
<li><p>Falling Edge:
High state transitions to low state.</p></li>
<li><p>Both Edges:
Any state transition.</p></li>
</ul>
<p>A counter is defined as a set of input signals associated with count
data that are generated by the evaluation of the state of the associated
input signals as defined by the respective count functions. Within the
context of the Generic Counter interface, a counter consists of Counts
each associated with a set of Signals, whose respective Synapse
instances represent the count function update conditions for the
associated Counts.</p>
<p>A Synapse associates one Signal with one Count.</p>
</div>
<div class="section" id="count">
<h3>COUNT<a class="headerlink" href="#count" title="Permalink to this headline">¶</a></h3>
<p>A Count represents the accumulation of the effects of connected
Synapses; i.e. the count data for a set of Signals. The Generic
Counter interface represents the count data as a natural number.</p>
<p>A Count has a count function mode which represents the update behavior
for the count data. The Generic Counter interface provides the following
available count function modes:</p>
<ul class="simple">
<li><p>Increase:
Accumulated count is incremented.</p></li>
<li><p>Decrease:
Accumulated count is decremented.</p></li>
<li><p>Pulse-Direction:
Rising edges on signal A updates the respective count. The input level
of signal B determines direction.</p></li>
<li><p>Quadrature:
A pair of quadrature encoding signals are evaluated to determine
position and direction. The following Quadrature modes are available:</p>
<ul>
<li><p>x1 A:
If direction is forward, rising edges on quadrature pair signal A
updates the respective count; if the direction is backward, falling
edges on quadrature pair signal A updates the respective count.
Quadrature encoding determines the direction.</p></li>
<li><p>x1 B:
If direction is forward, rising edges on quadrature pair signal B
updates the respective count; if the direction is backward, falling
edges on quadrature pair signal B updates the respective count.
Quadrature encoding determines the direction.</p></li>
<li><p>x2 A:
Any state transition on quadrature pair signal A updates the
respective count. Quadrature encoding determines the direction.</p></li>
<li><p>x2 B:
Any state transition on quadrature pair signal B updates the
respective count. Quadrature encoding determines the direction.</p></li>
<li><p>x4:
Any state transition on either quadrature pair signals updates the
respective count. Quadrature encoding determines the direction.</p></li>
</ul>
</li>
</ul>
<p>A Count has a set of one or more associated Synapses.</p>
</div>
</div>
<div class="section" id="paradigm">
<h2>Paradigm<a class="headerlink" href="#paradigm" title="Permalink to this headline">¶</a></h2>
<p>The most basic counter device may be expressed as a single Count
associated with a single Signal via a single Synapse. Take for example
a counter device which simply accumulates a count of rising edges on a
source input line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        Count                Synapse        Signal
        -----                -------        ------
+---------------------+
| Data: Count         |    Rising Edge     ________
| Function: Increase  |  &lt;-------------   / Source \
|                     |                  ____________
+---------------------+
</pre></div>
</div>
<p>In this example, the Signal is a source input line with a pulsing
voltage, while the Count is a persistent count value which is repeatedly
incremented. The Signal is associated with the respective Count via a
Synapse. The increase function is triggered by the Signal data condition
specified by the Synapse – in this case a rising edge condition on the
voltage input line. In summary, the counter device existence and
behavior is aptly represented by respective Count, Signal, and Synapse
components: a rising edge condition triggers an increase function on an
accumulating count datum.</p>
<p>A counter device is not limited to a single Signal; in fact, in theory
many Signals may be associated with even a single Count. For example, a
quadrature encoder counter device can keep track of position based on
the states of two input lines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           Count                 Synapse     Signal
           -----                 -------     ------
+-------------------------+
| Data: Position          |    Both Edges     ___
| Function: Quadrature x4 |  &lt;------------   / A \
|                         |                 _______
|                         |
|                         |    Both Edges     ___
|                         |  &lt;------------   / B \
|                         |                 _______
+-------------------------+
</pre></div>
</div>
<p>In this example, two Signals (quadrature encoder lines A and B) are
associated with a single Count: a rising or falling edge on either A or
B triggers the “Quadrature x4” function which determines the direction
of movement and updates the respective position data. The “Quadrature
x4” function is likely implemented in the hardware of the quadrature
encoder counter device; the Count, Signals, and Synapses simply
represent this hardware behavior and functionality.</p>
<p>Signals associated with the same Count can have differing Synapse action
mode conditions. For example, a quadrature encoder counter device
operating in a non-quadrature Pulse-Direction mode could have one input
line dedicated for movement and a second input line dedicated for
direction:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           Count                   Synapse      Signal
           -----                   -------      ------
+---------------------------+
| Data: Position            |    Rising Edge     ___
| Function: Pulse-Direction |  &lt;-------------   / A \ (Movement)
|                           |                  _______
|                           |
|                           |       None         ___
|                           |  &lt;-------------   / B \ (Direction)
|                           |                  _______
+---------------------------+
</pre></div>
</div>
<p>Only Signal A triggers the “Pulse-Direction” update function, but the
instantaneous state of Signal B is still required in order to know the
direction so that the position data may be properly updated. Ultimately,
both Signals are associated with the same Count via two respective
Synapses, but only one Synapse has an active action mode condition which
triggers the respective count function while the other is left with a
“None” condition action mode to indicate its respective Signal’s
availability for state evaluation despite its non-triggering mode.</p>
<p>Keep in mind that the Signal, Synapse, and Count are abstract
representations which do not need to be closely married to their
respective physical sources. This allows the user of a counter to
divorce themselves from the nuances of physical components (such as
whether an input line is differential or single-ended) and instead focus
on the core idea of what the data and process represent (e.g. position
as interpreted from quadrature encoding data).</p>
</div>
<div class="section" id="userspace-interface">
<h2>Userspace Interface<a class="headerlink" href="#userspace-interface" title="Permalink to this headline">¶</a></h2>
<p>Several sysfs attributes are generated by the Generic Counter interface,
and reside under the /sys/bus/counter/devices/counterX directory, where
counterX refers to the respective counter device. Please see
Documentation/ABI/testing/sysfs-bus-counter for detailed
information on each Generic Counter interface sysfs attribute.</p>
<p>Through these sysfs attributes, programs and scripts may interact with
the Generic Counter paradigm Counts, Signals, and Synapses of respective
counter devices.</p>
</div>
<div class="section" id="driver-api">
<h2>Driver API<a class="headerlink" href="#driver-api" title="Permalink to this headline">¶</a></h2>
<p>Driver authors may utilize the Generic Counter interface in their code
by including the include/linux/counter.h header file. This header file
provides several core data structures, function prototypes, and macros
for defining a counter device.</p>
<dl class="c struct">
<dt id="c.counter_signal_ext">
<em class="property">struct </em><code class="sig-name descname">counter_signal_ext</code><a class="headerlink" href="#c.counter_signal_ext" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter Signal extensions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_signal_ext {
  const char *name;
  ssize_t (*read)(struct counter_device *counter, struct counter_signal *signal, void *priv, char *buf);
  ssize_t (*write)(struct counter_device *counter,struct counter_signal *signal, void *priv, const char *buf, size_t len);
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>attribute name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>read callback for this attribute; may be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p>write callback for this attribute; may be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>data private to the driver</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_signal">
<em class="property">struct </em><code class="sig-name descname">counter_signal</code><a class="headerlink" href="#c.counter_signal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter Signal node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_signal {
  int id;
  const char *name;
  const struct counter_signal_ext *ext;
  size_t num_ext;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>unique ID used to identify signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device-specific Signal name; ideally, this should match the name
as it appears in the datasheet documentation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>optional array of Counter Signal extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ext</span></code></dt><dd><p>number of Counter Signal extensions specified in <strong>ext</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>optional private data supplied by driver</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_signal_enum_ext">
<em class="property">struct </em><code class="sig-name descname">counter_signal_enum_ext</code><a class="headerlink" href="#c.counter_signal_enum_ext" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Signal enum extension attribute</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_signal_enum_ext {
  const char * const *items;
  size_t num_items;
  int (*get)(struct counter_device *counter, struct counter_signal *signal, size_t *item);
  int (*set)(struct counter_device *counter, struct counter_signal *signal, size_t item);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">items</span></code></dt><dd><p>Array of strings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_items</span></code></dt><dd><p>Number of items specified in <strong>items</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get</span></code></dt><dd><p>Get callback function; may be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set</span></code></dt><dd><p>Set callback function; may be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The counter_signal_enum_ext structure can be used to implement enum style
Signal extension attributes. Enum style attributes are those which have a set
of strings that map to unsigned integer values. The Generic Counter Signal
enum extension helper code takes care of mapping between value and string, as
well as generating a “_available” file which contains a list of all available
items. The get callback is used to query the currently active item; the index
of the item within the respective items array is returned via the ‘item’
parameter. The set callback is called when the attribute is updated; the
‘item’ parameter contains the index of the newly activated item within the
respective items array.</p>
<dl class="c macro">
<dt id="c.COUNTER_SIGNAL_ENUM">
<code class="sig-name descname">COUNTER_SIGNAL_ENUM</code><a class="headerlink" href="#c.COUNTER_SIGNAL_ENUM" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">COUNTER_SIGNAL_ENUM</span> <span class="pre">(_name,</span> <span class="pre">_e)</span></code></p>
<blockquote>
<div><p>Initialize Signal enum extension</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_e</span></code></dt><dd><p>Pointer to a counter_signal_enum_ext structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should usually be used together with <a class="reference internal" href="#c.COUNTER_SIGNAL_ENUM_AVAILABLE" title="COUNTER_SIGNAL_ENUM_AVAILABLE"><code class="xref c c-func docutils literal notranslate"><span class="pre">COUNTER_SIGNAL_ENUM_AVAILABLE()</span></code></a></p>
<dl class="c macro">
<dt id="c.COUNTER_SIGNAL_ENUM_AVAILABLE">
<code class="sig-name descname">COUNTER_SIGNAL_ENUM_AVAILABLE</code><a class="headerlink" href="#c.COUNTER_SIGNAL_ENUM_AVAILABLE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">COUNTER_SIGNAL_ENUM_AVAILABLE</span> <span class="pre">(_name,</span> <span class="pre">_e)</span></code></p>
<blockquote>
<div><p>Initialize Signal enum available extension</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name (“_available” will be appended to the name)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_e</span></code></dt><dd><p>Pointer to a counter_signal_enum_ext structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a read only attribute that lists all the available enum items in a
newline separated list. This should usually be used together with
<a class="reference internal" href="#c.COUNTER_SIGNAL_ENUM" title="COUNTER_SIGNAL_ENUM"><code class="xref c c-func docutils literal notranslate"><span class="pre">COUNTER_SIGNAL_ENUM()</span></code></a></p>
<dl class="c struct">
<dt id="c.counter_synapse">
<em class="property">struct </em><code class="sig-name descname">counter_synapse</code><a class="headerlink" href="#c.counter_synapse" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter Synapse node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_synapse {
  size_t action;
  const enum counter_synapse_action *actions_list;
  size_t num_actions;
  struct counter_signal *signal;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">action</span></code></dt><dd><p>index of current action mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">actions_list</span></code></dt><dd><p>array of available action modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_actions</span></code></dt><dd><p>number of action modes specified in <strong>actions_list</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal</span></code></dt><dd><p>pointer to associated signal</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_count_ext">
<em class="property">struct </em><code class="sig-name descname">counter_count_ext</code><a class="headerlink" href="#c.counter_count_ext" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter Count extension</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_count_ext {
  const char *name;
  ssize_t (*read)(struct counter_device *counter, struct counter_count *count, void *priv, char *buf);
  ssize_t (*write)(struct counter_device *counter,struct counter_count *count, void *priv, const char *buf, size_t len);
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>attribute name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>read callback for this attribute; may be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p>write callback for this attribute; may be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>data private to the driver</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_count">
<em class="property">struct </em><code class="sig-name descname">counter_count</code><a class="headerlink" href="#c.counter_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter Count node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_count {
  int id;
  const char *name;
  size_t function;
  const enum counter_count_function *functions_list;
  size_t num_functions;
  struct counter_synapse *synapses;
  size_t num_synapses;
  const struct counter_count_ext *ext;
  size_t num_ext;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>unique ID used to identify Count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device-specific Count name; ideally, this should match
the name as it appears in the datasheet documentation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function</span></code></dt><dd><p>index of current function mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">functions_list</span></code></dt><dd><p>array available function modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_functions</span></code></dt><dd><p>number of function modes specified in <strong>functions_list</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">synapses</span></code></dt><dd><p>array of synapses for initialization</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_synapses</span></code></dt><dd><p>number of synapses specified in <strong>synapses</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>optional array of Counter Count extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ext</span></code></dt><dd><p>number of Counter Count extensions specified in <strong>ext</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>optional private data supplied by driver</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_count_enum_ext">
<em class="property">struct </em><code class="sig-name descname">counter_count_enum_ext</code><a class="headerlink" href="#c.counter_count_enum_ext" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Count enum extension attribute</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_count_enum_ext {
  const char * const *items;
  size_t num_items;
  int (*get)(struct counter_device *counter, struct counter_count *count, size_t *item);
  int (*set)(struct counter_device *counter, struct counter_count *count, size_t item);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">items</span></code></dt><dd><p>Array of strings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_items</span></code></dt><dd><p>Number of items specified in <strong>items</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get</span></code></dt><dd><p>Get callback function; may be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set</span></code></dt><dd><p>Set callback function; may be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The counter_count_enum_ext structure can be used to implement enum style
Count extension attributes. Enum style attributes are those which have a set
of strings that map to unsigned integer values. The Generic Counter Count
enum extension helper code takes care of mapping between value and string, as
well as generating a “_available” file which contains a list of all available
items. The get callback is used to query the currently active item; the index
of the item within the respective items array is returned via the ‘item’
parameter. The set callback is called when the attribute is updated; the
‘item’ parameter contains the index of the newly activated item within the
respective items array.</p>
<dl class="c macro">
<dt id="c.COUNTER_COUNT_ENUM">
<code class="sig-name descname">COUNTER_COUNT_ENUM</code><a class="headerlink" href="#c.COUNTER_COUNT_ENUM" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">COUNTER_COUNT_ENUM</span> <span class="pre">(_name,</span> <span class="pre">_e)</span></code></p>
<blockquote>
<div><p>Initialize Count enum extension</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_e</span></code></dt><dd><p>Pointer to a counter_count_enum_ext structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should usually be used together with <a class="reference internal" href="#c.COUNTER_COUNT_ENUM_AVAILABLE" title="COUNTER_COUNT_ENUM_AVAILABLE"><code class="xref c c-func docutils literal notranslate"><span class="pre">COUNTER_COUNT_ENUM_AVAILABLE()</span></code></a></p>
<dl class="c macro">
<dt id="c.COUNTER_COUNT_ENUM_AVAILABLE">
<code class="sig-name descname">COUNTER_COUNT_ENUM_AVAILABLE</code><a class="headerlink" href="#c.COUNTER_COUNT_ENUM_AVAILABLE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">COUNTER_COUNT_ENUM_AVAILABLE</span> <span class="pre">(_name,</span> <span class="pre">_e)</span></code></p>
<blockquote>
<div><p>Initialize Count enum available extension</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name (“_available” will be appended to the name)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_e</span></code></dt><dd><p>Pointer to a counter_count_enum_ext structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a read only attribute that lists all the available enum items in a
newline separated list. This should usually be used together with
<a class="reference internal" href="#c.COUNTER_COUNT_ENUM" title="COUNTER_COUNT_ENUM"><code class="xref c c-func docutils literal notranslate"><span class="pre">COUNTER_COUNT_ENUM()</span></code></a></p>
<dl class="c struct">
<dt id="c.counter_device_attr_group">
<em class="property">struct </em><code class="sig-name descname">counter_device_attr_group</code><a class="headerlink" href="#c.counter_device_attr_group" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>internal container for attribute group</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_device_attr_group {
  struct attribute_group attr_group;
  struct list_head attr_list;
  size_t num_attr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">attr_group</span></code></dt><dd><p>Counter sysfs attributes group</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">attr_list</span></code></dt><dd><p>list to keep track of created Counter sysfs attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_attr</span></code></dt><dd><p>number of Counter sysfs attributes</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_device_state">
<em class="property">struct </em><code class="sig-name descname">counter_device_state</code><a class="headerlink" href="#c.counter_device_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>internal state container for a Counter device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_device_state {
  int id;
  struct device dev;
  struct counter_device_attr_group *groups_list;
  size_t num_groups;
  const struct attribute_group **groups;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>unique ID used to identify the Counter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>internal device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">groups_list</span></code></dt><dd><p>attribute groups list (for Signals, Counts, and ext)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_groups</span></code></dt><dd><p>number of attribute groups containers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">groups</span></code></dt><dd><p>Counter sysfs attribute groups (to populate <strong>dev.groups</strong>)</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_ops">
<em class="property">struct </em><code class="sig-name descname">counter_ops</code><a class="headerlink" href="#c.counter_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Callbacks from driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_ops {
  int (*signal_read)(struct counter_device *counter,struct counter_signal *signal, enum counter_signal_value *val);
  int (*count_read)(struct counter_device *counter, struct counter_count *count, unsigned long *val);
  int (*count_write)(struct counter_device *counter, struct counter_count *count, unsigned long val);
  int (*function_get)(struct counter_device *counter, struct counter_count *count, size_t *function);
  int (*function_set)(struct counter_device *counter, struct counter_count *count, size_t function);
  int (*action_get)(struct counter_device *counter,struct counter_count *count, struct counter_synapse *synapse, size_t *action);
  int (*action_set)(struct counter_device *counter,struct counter_count *count, struct counter_synapse *synapse, size_t action);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">signal_read</span></code></dt><dd><p>optional read callback for Signal attribute. The read
value of the respective Signal should be passed back via
the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_read</span></code></dt><dd><p>optional read callback for Count attribute. The read
value of the respective Count should be passed back via
the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_write</span></code></dt><dd><p>optional write callback for Count attribute. The write
value for the respective Count is passed in via the val
parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function_get</span></code></dt><dd><p>function to get the current count function mode. Returns
0 on success and negative error code on error. The index
of the respective Count’s returned function mode should
be passed back via the function parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function_set</span></code></dt><dd><p>function to set the count function mode. function is the
index of the requested function mode from the respective
Count’s functions_list array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">action_get</span></code></dt><dd><p>function to get the current action mode. Returns 0 on
success and negative error code on error. The index of
the respective Synapse’s returned action mode should be
passed back via the action parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">action_set</span></code></dt><dd><p>function to set the action mode. action is the index of
the requested action mode from the respective Synapse’s
actions_list array.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_device_ext">
<em class="property">struct </em><code class="sig-name descname">counter_device_ext</code><a class="headerlink" href="#c.counter_device_ext" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter device extension</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_device_ext {
  const char *name;
  ssize_t (*read)(struct counter_device *counter, void *priv, char *buf);
  ssize_t (*write)(struct counter_device *counter, void *priv, const char *buf, size_t len);
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>attribute name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>read callback for this attribute; may be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p>write callback for this attribute; may be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>data private to the driver</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_device_enum_ext">
<em class="property">struct </em><code class="sig-name descname">counter_device_enum_ext</code><a class="headerlink" href="#c.counter_device_enum_ext" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter enum extension attribute</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_device_enum_ext {
  const char * const *items;
  size_t num_items;
  int (*get)(struct counter_device *counter, size_t *item);
  int (*set)(struct counter_device *counter, size_t item);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">items</span></code></dt><dd><p>Array of strings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_items</span></code></dt><dd><p>Number of items specified in <strong>items</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get</span></code></dt><dd><p>Get callback function; may be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set</span></code></dt><dd><p>Set callback function; may be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The counter_device_enum_ext structure can be used to implement enum style
Counter extension attributes. Enum style attributes are those which have a
set of strings that map to unsigned integer values. The Generic Counter enum
extension helper code takes care of mapping between value and string, as well
as generating a “_available” file which contains a list of all available
items. The get callback is used to query the currently active item; the index
of the item within the respective items array is returned via the ‘item’
parameter. The set callback is called when the attribute is updated; the
‘item’ parameter contains the index of the newly activated item within the
respective items array.</p>
<dl class="c macro">
<dt id="c.COUNTER_DEVICE_ENUM">
<code class="sig-name descname">COUNTER_DEVICE_ENUM</code><a class="headerlink" href="#c.COUNTER_DEVICE_ENUM" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">COUNTER_DEVICE_ENUM</span> <span class="pre">(_name,</span> <span class="pre">_e)</span></code></p>
<blockquote>
<div><p>Initialize Counter enum extension</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_e</span></code></dt><dd><p>Pointer to a counter_device_enum_ext structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should usually be used together with <a class="reference internal" href="#c.COUNTER_DEVICE_ENUM_AVAILABLE" title="COUNTER_DEVICE_ENUM_AVAILABLE"><code class="xref c c-func docutils literal notranslate"><span class="pre">COUNTER_DEVICE_ENUM_AVAILABLE()</span></code></a></p>
<dl class="c macro">
<dt id="c.COUNTER_DEVICE_ENUM_AVAILABLE">
<code class="sig-name descname">COUNTER_DEVICE_ENUM_AVAILABLE</code><a class="headerlink" href="#c.COUNTER_DEVICE_ENUM_AVAILABLE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">COUNTER_DEVICE_ENUM_AVAILABLE</span> <span class="pre">(_name,</span> <span class="pre">_e)</span></code></p>
<blockquote>
<div><p>Initialize Counter enum available extension</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name (“_available” will be appended to the name)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_e</span></code></dt><dd><p>Pointer to a counter_device_enum_ext structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a read only attribute that lists all the available enum items in a
newline separated list. This should usually be used together with
<a class="reference internal" href="#c.COUNTER_DEVICE_ENUM" title="COUNTER_DEVICE_ENUM"><code class="xref c c-func docutils literal notranslate"><span class="pre">COUNTER_DEVICE_ENUM()</span></code></a></p>
<dl class="c struct">
<dt id="c.counter_device">
<em class="property">struct </em><code class="sig-name descname">counter_device</code><a class="headerlink" href="#c.counter_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter data structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_device {
  const char *name;
  struct device *parent;
  struct counter_device_state *device_state;
  const struct counter_ops *ops;
  struct counter_signal *signals;
  size_t num_signals;
  struct counter_count *counts;
  size_t num_counts;
  const struct counter_device_ext *ext;
  size_t num_ext;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the device as it appears in the datasheet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>optional parent device providing the counters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_state</span></code></dt><dd><p>internal device state container</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>callbacks from driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signals</span></code></dt><dd><p>array of Signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_signals</span></code></dt><dd><p>number of Signals specified in <strong>signals</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">counts</span></code></dt><dd><p>array of Counts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_counts</span></code></dt><dd><p>number of Counts specified in <strong>counts</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>optional array of Counter device extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ext</span></code></dt><dd><p>number of Counter device extensions specified in <strong>ext</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>optional private data supplied by driver</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.counter_register">
int <code class="sig-name descname">counter_register</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a> *<em class="property">const</em> <em>counter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.counter_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register Counter to the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>pointer to Counter to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers a Counter to the system. A sysfs “counter” directory
will be created and populated with sysfs attributes correlating with the
Counter Signals, Synapses, and Counts respectively.</p>
<dl class="c function">
<dt id="c.counter_unregister">
void <code class="sig-name descname">counter_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a> *<em class="property">const</em> <em>counter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.counter_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister Counter from the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>pointer to Counter to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The Counter is unregistered from the system; all allocated memory is freed.</p>
<dl class="c function">
<dt id="c.devm_counter_register">
int <code class="sig-name descname">devm_counter_register</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a> *<em class="property">const</em> <em>counter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_counter_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed counter_register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to allocate counter_device for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>pointer to Counter to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed counter_register. The Counter registered with this function is
automatically unregistered on driver detach. This function calls
counter_register internally. Refer to that function for more information.</p>
<p>If an Counter registered with this function needs to be unregistered
separately, devm_counter_unregister must be used.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error number on failure.</p>
<dl class="c function">
<dt id="c.devm_counter_unregister">
void <code class="sig-name descname">devm_counter_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a> *<em class="property">const</em> <em>counter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_counter_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed counter_unregister</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device this counter_device belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>pointer to Counter associated with the device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister Counter registered with devm_counter_register.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>To support a counter device, a driver must first allocate the available
Counter Signals via counter_signal structures. These Signals should
be stored as an array and set to the signals array member of an
allocated counter_device structure before the Counter is registered to
the system.</p>
<p>Counter Counts may be allocated via counter_count structures, and
respective Counter Signal associations (Synapses) made via
counter_synapse structures. Associated counter_synapse structures are
stored as an array and set to the synapses array member of the
respective counter_count structure. These counter_count structures are
set to the counts array member of an allocated counter_device structure
before the Counter is registered to the system.</p>
<p>Driver callbacks should be provided to the counter_device structure via
a constant counter_ops structure in order to communicate with the
device: to read and write various Signals and Counts, and to set and get
the “action mode” and “function mode” for various Synapses and Counts
respectively.</p>
<p>A defined counter_device structure may be registered to the system by
passing it to the counter_register function, and unregistered by passing
it to the counter_unregister function. Similarly, the
devm_counter_register and devm_counter_unregister functions may be used
if device memory-managed registration is desired.</p>
<p>Extension sysfs attributes can be created for auxiliary functionality
and data by passing in defined counter_device_ext, counter_count_ext,
and counter_signal_ext structures. In these cases, the
counter_device_ext structure is used for global/miscellaneous exposure
and configuration of the respective Counter device, while the
counter_count_ext and counter_signal_ext structures allow for auxiliary
exposure and configuration of a specific Count or Signal respectively.</p>
<p>Determining the type of extension to create is a matter of scope.</p>
<ul>
<li><p>Signal extensions are attributes that expose information/control
specific to a Signal. These types of attributes will exist under a
Signal’s directory in sysfs.</p>
<p>For example, if you have an invert feature for a Signal, you can have
a Signal extension called “invert” that toggles that feature:
/sys/bus/counter/devices/counterX/signalY/invert</p>
</li>
<li><p>Count extensions are attributes that expose information/control
specific to a Count. These type of attributes will exist under a
Count’s directory in sysfs.</p>
<p>For example, if you want to pause/unpause a Count from updating, you
can have a Count extension called “enable” that toggles such:
/sys/bus/counter/devices/counterX/countY/enable</p>
</li>
<li><p>Device extensions are attributes that expose information/control
non-specific to a particular Count or Signal. This is where you would
put your global features or other miscellanous functionality.</p>
<p>For example, if your device has an overtemp sensor, you can report the
chip overheated via a device extension called “error_overtemp”:
/sys/bus/counter/devices/counterX/error_overtemp</p>
</li>
</ul>
</div>
<div class="section" id="architecture">
<h2>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<p>When the Generic Counter interface counter module is loaded, the
counter_init function is called which registers a bus_type named
“counter” to the system. Subsequently, when the module is unloaded, the
counter_exit function is called which unregisters the bus_type named
“counter” from the system.</p>
<p>Counter devices are registered to the system via the counter_register
function, and later removed via the counter_unregister function. The
counter_register function establishes a unique ID for the Counter
device and creates a respective sysfs directory, where X is the
mentioned unique ID:</p>
<blockquote>
<div><p>/sys/bus/counter/devices/counterX</p>
</div></blockquote>
<p>Sysfs attributes are created within the counterX directory to expose
functionality, configurations, and data relating to the Counts, Signals,
and Synapses of the Counter device, as well as options and information
for the Counter device itself.</p>
<p>Each Signal has a directory created to house its relevant sysfs
attributes, where Y is the unique ID of the respective Signal:</p>
<blockquote>
<div><p>/sys/bus/counter/devices/counterX/signalY</p>
</div></blockquote>
<p>Similarly, each Count has a directory created to house its relevant
sysfs attributes, where Y is the unique ID of the respective Count:</p>
<blockquote>
<div><p>/sys/bus/counter/devices/counterX/countY</p>
</div></blockquote>
<p>For a more detailed breakdown of the available Generic Counter interface
sysfs attributes, please refer to the
Documentation/ABI/testing/sysfs-bus-counter file.</p>
<p>The Signals and Counts associated with the Counter device are registered
to the system as well by the counter_register function. The
signal_read/signal_write driver callbacks are associated with their
respective Signal attributes, while the count_read/count_write and
function_get/function_set driver callbacks are associated with their
respective Count attributes; similarly, the same is true for the
action_get/action_set driver callbacks and their respective Synapse
attributes. If a driver callback is left undefined, then the respective
read/write permission is left disabled for the relevant attributes.</p>
<p>Similarly, extension sysfs attributes are created for the defined
counter_device_ext, counter_count_ext, and counter_signal_ext
structures that are passed in.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="lightnvm-pblk.html" class="btn btn-neutral float-right" title="pblk: Physical Block Device Target" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="io_ordering.html" class="btn btn-neutral float-left" title="Ordering I/O writes to memory-mapped addresses" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>