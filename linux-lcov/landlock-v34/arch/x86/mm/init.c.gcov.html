<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - landlock.info - arch/x86/mm/init.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">arch/x86/mm</a> - init.c<span style="font-size: 80%;"> (source / <a href="init.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">landlock.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">261</td>
            <td class="headerCovTableEntry">332</td>
            <td class="headerCovTableEntryMed">78.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2021-04-22 12:43:58</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">24</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntryMed">77.4 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #include &lt;linux/gfp.h&gt;</a>
<a name="2"><span class="lineNum">       2 </span>            : #include &lt;linux/initrd.h&gt;</a>
<a name="3"><span class="lineNum">       3 </span>            : #include &lt;linux/ioport.h&gt;</a>
<a name="4"><span class="lineNum">       4 </span>            : #include &lt;linux/swap.h&gt;</a>
<a name="5"><span class="lineNum">       5 </span>            : #include &lt;linux/memblock.h&gt;</a>
<a name="6"><span class="lineNum">       6 </span>            : #include &lt;linux/swapfile.h&gt;</a>
<a name="7"><span class="lineNum">       7 </span>            : #include &lt;linux/swapops.h&gt;</a>
<a name="8"><span class="lineNum">       8 </span>            : #include &lt;linux/kmemleak.h&gt;</a>
<a name="9"><span class="lineNum">       9 </span>            : #include &lt;linux/sched/task.h&gt;</a>
<a name="10"><span class="lineNum">      10 </span>            : </a>
<a name="11"><span class="lineNum">      11 </span>            : #include &lt;asm/set_memory.h&gt;</a>
<a name="12"><span class="lineNum">      12 </span>            : #include &lt;asm/e820/api.h&gt;</a>
<a name="13"><span class="lineNum">      13 </span>            : #include &lt;asm/init.h&gt;</a>
<a name="14"><span class="lineNum">      14 </span>            : #include &lt;asm/page.h&gt;</a>
<a name="15"><span class="lineNum">      15 </span>            : #include &lt;asm/page_types.h&gt;</a>
<a name="16"><span class="lineNum">      16 </span>            : #include &lt;asm/sections.h&gt;</a>
<a name="17"><span class="lineNum">      17 </span>            : #include &lt;asm/setup.h&gt;</a>
<a name="18"><span class="lineNum">      18 </span>            : #include &lt;asm/tlbflush.h&gt;</a>
<a name="19"><span class="lineNum">      19 </span>            : #include &lt;asm/tlb.h&gt;</a>
<a name="20"><span class="lineNum">      20 </span>            : #include &lt;asm/proto.h&gt;</a>
<a name="21"><span class="lineNum">      21 </span>            : #include &lt;asm/dma.h&gt;              /* for MAX_DMA_PFN */</a>
<a name="22"><span class="lineNum">      22 </span>            : #include &lt;asm/microcode.h&gt;</a>
<a name="23"><span class="lineNum">      23 </span>            : #include &lt;asm/kaslr.h&gt;</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &lt;asm/hypervisor.h&gt;</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &lt;asm/cpufeature.h&gt;</a>
<a name="26"><span class="lineNum">      26 </span>            : #include &lt;asm/pti.h&gt;</a>
<a name="27"><span class="lineNum">      27 </span>            : #include &lt;asm/text-patching.h&gt;</a>
<a name="28"><span class="lineNum">      28 </span>            : #include &lt;asm/memtype.h&gt;</a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span>            : /*</a>
<a name="31"><span class="lineNum">      31 </span>            :  * We need to define the tracepoints somewhere, and tlb.c</a>
<a name="32"><span class="lineNum">      32 </span>            :  * is only compied when SMP=y.</a>
<a name="33"><span class="lineNum">      33 </span>            :  */</a>
<a name="34"><span class="lineNum">      34 </span>            : #define CREATE_TRACE_POINTS</a>
<a name="35"><span class="lineNum">      35 </span>            : #include &lt;trace/events/tlb.h&gt;</a>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<a name="37"><span class="lineNum">      37 </span>            : #include &quot;mm_internal.h&quot;</a>
<a name="38"><span class="lineNum">      38 </span>            : </a>
<a name="39"><span class="lineNum">      39 </span>            : /*</a>
<a name="40"><span class="lineNum">      40 </span>            :  * Tables translating between page_cache_type_t and pte encoding.</a>
<a name="41"><span class="lineNum">      41 </span>            :  *</a>
<a name="42"><span class="lineNum">      42 </span>            :  * The default values are defined statically as minimal supported mode;</a>
<a name="43"><span class="lineNum">      43 </span>            :  * WC and WT fall back to UC-.  pat_init() updates these values to support</a>
<a name="44"><span class="lineNum">      44 </span>            :  * more cache modes, WC and WT, when it is safe to do so.  See pat_init()</a>
<a name="45"><span class="lineNum">      45 </span>            :  * for the details.  Note, __early_ioremap() used during early boot-time</a>
<a name="46"><span class="lineNum">      46 </span>            :  * takes pgprot_t (pte encoding) and does not use these tables.</a>
<a name="47"><span class="lineNum">      47 </span>            :  *</a>
<a name="48"><span class="lineNum">      48 </span>            :  *   Index into __cachemode2pte_tbl[] is the cachemode.</a>
<a name="49"><span class="lineNum">      49 </span>            :  *</a>
<a name="50"><span class="lineNum">      50 </span>            :  *   Index into __pte2cachemode_tbl[] are the caching attribute bits of the pte</a>
<a name="51"><span class="lineNum">      51 </span>            :  *   (_PAGE_PWT, _PAGE_PCD, _PAGE_PAT) at index bit positions 0, 1, 2.</a>
<a name="52"><span class="lineNum">      52 </span>            :  */</a>
<a name="53"><span class="lineNum">      53 </span>            : static uint16_t __cachemode2pte_tbl[_PAGE_CACHE_MODE_NUM] = {</a>
<a name="54"><span class="lineNum">      54 </span>            :         [_PAGE_CACHE_MODE_WB      ]     = 0         | 0        ,</a>
<a name="55"><span class="lineNum">      55 </span>            :         [_PAGE_CACHE_MODE_WC      ]     = 0         | _PAGE_PCD,</a>
<a name="56"><span class="lineNum">      56 </span>            :         [_PAGE_CACHE_MODE_UC_MINUS]     = 0         | _PAGE_PCD,</a>
<a name="57"><span class="lineNum">      57 </span>            :         [_PAGE_CACHE_MODE_UC      ]     = _PAGE_PWT | _PAGE_PCD,</a>
<a name="58"><span class="lineNum">      58 </span>            :         [_PAGE_CACHE_MODE_WT      ]     = 0         | _PAGE_PCD,</a>
<a name="59"><span class="lineNum">      59 </span>            :         [_PAGE_CACHE_MODE_WP      ]     = 0         | _PAGE_PCD,</a>
<a name="60"><span class="lineNum">      60 </span>            : };</a>
<a name="61"><span class="lineNum">      61 </span>            : </a>
<a name="62"><span class="lineNum">      62 </span><span class="lineCov">          5 : unsigned long cachemode2protval(enum page_cache_mode pcm)</span></a>
<a name="63"><span class="lineNum">      63 </span>            : {</a>
<a name="64"><span class="lineNum">      64 </span><span class="lineCov">          5 :         if (likely(pcm == 0))</span></a>
<a name="65"><span class="lineNum">      65 </span>            :                 return 0;</a>
<a name="66"><span class="lineNum">      66 </span><span class="lineCov">          5 :         return __cachemode2pte_tbl[pcm];</span></a>
<a name="67"><span class="lineNum">      67 </span>            : }</a>
<a name="68"><span class="lineNum">      68 </span>            : EXPORT_SYMBOL(cachemode2protval);</a>
<a name="69"><span class="lineNum">      69 </span>            : </a>
<a name="70"><span class="lineNum">      70 </span>            : static uint8_t __pte2cachemode_tbl[8] = {</a>
<a name="71"><span class="lineNum">      71 </span>            :         [__pte2cm_idx( 0        | 0         | 0        )] = _PAGE_CACHE_MODE_WB,</a>
<a name="72"><span class="lineNum">      72 </span>            :         [__pte2cm_idx(_PAGE_PWT | 0         | 0        )] = _PAGE_CACHE_MODE_UC_MINUS,</a>
<a name="73"><span class="lineNum">      73 </span>            :         [__pte2cm_idx( 0        | _PAGE_PCD | 0        )] = _PAGE_CACHE_MODE_UC_MINUS,</a>
<a name="74"><span class="lineNum">      74 </span>            :         [__pte2cm_idx(_PAGE_PWT | _PAGE_PCD | 0        )] = _PAGE_CACHE_MODE_UC,</a>
<a name="75"><span class="lineNum">      75 </span>            :         [__pte2cm_idx( 0        | 0         | _PAGE_PAT)] = _PAGE_CACHE_MODE_WB,</a>
<a name="76"><span class="lineNum">      76 </span>            :         [__pte2cm_idx(_PAGE_PWT | 0         | _PAGE_PAT)] = _PAGE_CACHE_MODE_UC_MINUS,</a>
<a name="77"><span class="lineNum">      77 </span>            :         [__pte2cm_idx(0         | _PAGE_PCD | _PAGE_PAT)] = _PAGE_CACHE_MODE_UC_MINUS,</a>
<a name="78"><span class="lineNum">      78 </span>            :         [__pte2cm_idx(_PAGE_PWT | _PAGE_PCD | _PAGE_PAT)] = _PAGE_CACHE_MODE_UC,</a>
<a name="79"><span class="lineNum">      79 </span>            : };</a>
<a name="80"><span class="lineNum">      80 </span>            : </a>
<a name="81"><span class="lineNum">      81 </span>            : /* Check that the write-protect PAT entry is set for write-protect */</a>
<a name="82"><span class="lineNum">      82 </span><span class="lineNoCov">          0 : bool x86_has_pat_wp(void)</span></a>
<a name="83"><span class="lineNum">      83 </span>            : {</a>
<a name="84"><span class="lineNum">      84 </span><span class="lineNoCov">          0 :         return __pte2cachemode_tbl[_PAGE_CACHE_MODE_WP] == _PAGE_CACHE_MODE_WP;</span></a>
<a name="85"><span class="lineNum">      85 </span>            : }</a>
<a name="86"><span class="lineNum">      86 </span>            : </a>
<a name="87"><span class="lineNum">      87 </span><span class="lineCov">         16 : enum page_cache_mode pgprot2cachemode(pgprot_t pgprot)</span></a>
<a name="88"><span class="lineNum">      88 </span>            : {</a>
<a name="89"><span class="lineNum">      89 </span><span class="lineCov">         16 :         unsigned long masked;</span></a>
<a name="90"><span class="lineNum">      90 </span>            : </a>
<a name="91"><span class="lineNum">      91 </span><span class="lineCov">         16 :         masked = pgprot_val(pgprot) &amp; _PAGE_CACHE_MASK;</span></a>
<a name="92"><span class="lineNum">      92 </span><span class="lineCov">         16 :         if (likely(masked == 0))</span></a>
<a name="93"><span class="lineNum">      93 </span>            :                 return 0;</a>
<a name="94"><span class="lineNum">      94 </span><span class="lineNoCov">          0 :         return __pte2cachemode_tbl[__pte2cm_idx(masked)];</span></a>
<a name="95"><span class="lineNum">      95 </span>            : }</a>
<a name="96"><span class="lineNum">      96 </span>            : </a>
<a name="97"><span class="lineNum">      97 </span>            : static unsigned long __initdata pgt_buf_start;</a>
<a name="98"><span class="lineNum">      98 </span>            : static unsigned long __initdata pgt_buf_end;</a>
<a name="99"><span class="lineNum">      99 </span>            : static unsigned long __initdata pgt_buf_top;</a>
<a name="100"><span class="lineNum">     100 </span>            : </a>
<a name="101"><span class="lineNum">     101 </span>            : static unsigned long min_pfn_mapped;</a>
<a name="102"><span class="lineNum">     102 </span>            : </a>
<a name="103"><span class="lineNum">     103 </span>            : static bool __initdata can_use_brk_pgt = true;</a>
<a name="104"><span class="lineNum">     104 </span>            : </a>
<a name="105"><span class="lineNum">     105 </span>            : /*</a>
<a name="106"><span class="lineNum">     106 </span>            :  * Pages returned are already directly mapped.</a>
<a name="107"><span class="lineNum">     107 </span>            :  *</a>
<a name="108"><span class="lineNum">     108 </span>            :  * Changing that is likely to break Xen, see commit:</a>
<a name="109"><span class="lineNum">     109 </span>            :  *</a>
<a name="110"><span class="lineNum">     110 </span>            :  *    279b706 x86,xen: introduce x86_init.mapping.pagetable_reserve</a>
<a name="111"><span class="lineNum">     111 </span>            :  *</a>
<a name="112"><span class="lineNum">     112 </span>            :  * for detailed information.</a>
<a name="113"><span class="lineNum">     113 </span>            :  */</a>
<a name="114"><span class="lineNum">     114 </span><span class="lineCov">          3 : __ref void *alloc_low_pages(unsigned int num)</span></a>
<a name="115"><span class="lineNum">     115 </span>            : {</a>
<a name="116"><span class="lineNum">     116 </span><span class="lineCov">          3 :         unsigned long pfn;</span></a>
<a name="117"><span class="lineNum">     117 </span><span class="lineCov">          3 :         int i;</span></a>
<a name="118"><span class="lineNum">     118 </span>            : </a>
<a name="119"><span class="lineNum">     119 </span><span class="lineCov">          3 :         if (after_bootmem) {</span></a>
<a name="120"><span class="lineNum">     120 </span><span class="lineNoCov">          0 :                 unsigned int order;</span></a>
<a name="121"><span class="lineNum">     121 </span>            : </a>
<a name="122"><span class="lineNum">     122 </span><span class="lineNoCov">          0 :                 order = get_order((unsigned long)num &lt;&lt; PAGE_SHIFT);</span></a>
<a name="123"><span class="lineNum">     123 </span><span class="lineNoCov">          0 :                 return (void *)__get_free_pages(GFP_ATOMIC | __GFP_ZERO, order);</span></a>
<a name="124"><span class="lineNum">     124 </span>            :         }</a>
<a name="125"><span class="lineNum">     125 </span>            : </a>
<a name="126"><span class="lineNum">     126 </span><span class="lineCov">          3 :         if ((pgt_buf_end + num) &gt; pgt_buf_top || !can_use_brk_pgt) {</span></a>
<a name="127"><span class="lineNum">     127 </span><span class="lineNoCov">          0 :                 unsigned long ret = 0;</span></a>
<a name="128"><span class="lineNum">     128 </span>            : </a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :                 if (min_pfn_mapped &lt; max_pfn_mapped) {</span></a>
<a name="130"><span class="lineNum">     130 </span><span class="lineNoCov">          0 :                         ret = memblock_find_in_range(</span></a>
<a name="131"><span class="lineNum">     131 </span><span class="lineNoCov">          0 :                                         min_pfn_mapped &lt;&lt; PAGE_SHIFT,</span></a>
<a name="132"><span class="lineNum">     132 </span><span class="lineNoCov">          0 :                                         max_pfn_mapped &lt;&lt; PAGE_SHIFT,</span></a>
<a name="133"><span class="lineNum">     133 </span><span class="lineNoCov">          0 :                                         PAGE_SIZE * num , PAGE_SIZE);</span></a>
<a name="134"><span class="lineNum">     134 </span>            :                 }</a>
<a name="135"><span class="lineNum">     135 </span><span class="lineNoCov">          0 :                 if (ret)</span></a>
<a name="136"><span class="lineNum">     136 </span><span class="lineNoCov">          0 :                         memblock_reserve(ret, PAGE_SIZE * num);</span></a>
<a name="137"><span class="lineNum">     137 </span><span class="lineNoCov">          0 :                 else if (can_use_brk_pgt)</span></a>
<a name="138"><span class="lineNum">     138 </span><span class="lineNoCov">          0 :                         ret = __pa(extend_brk(PAGE_SIZE * num, PAGE_SIZE));</span></a>
<a name="139"><span class="lineNum">     139 </span>            : </a>
<a name="140"><span class="lineNum">     140 </span><span class="lineNoCov">          0 :                 if (!ret)</span></a>
<a name="141"><span class="lineNum">     141 </span><span class="lineNoCov">          0 :                         panic(&quot;alloc_low_pages: can not alloc memory&quot;);</span></a>
<a name="142"><span class="lineNum">     142 </span>            : </a>
<a name="143"><span class="lineNum">     143 </span><span class="lineNoCov">          0 :                 pfn = ret &gt;&gt; PAGE_SHIFT;</span></a>
<a name="144"><span class="lineNum">     144 </span>            :         } else {</a>
<a name="145"><span class="lineNum">     145 </span><span class="lineCov">          3 :                 pfn = pgt_buf_end;</span></a>
<a name="146"><span class="lineNum">     146 </span><span class="lineCov">          3 :                 pgt_buf_end += num;</span></a>
<a name="147"><span class="lineNum">     147 </span>            :         }</a>
<a name="148"><span class="lineNum">     148 </span>            : </a>
<a name="149"><span class="lineNum">     149 </span><span class="lineCov">          6 :         for (i = 0; i &lt; num; i++) {</span></a>
<a name="150"><span class="lineNum">     150 </span><span class="lineCov">          3 :                 void *adr;</span></a>
<a name="151"><span class="lineNum">     151 </span>            : </a>
<a name="152"><span class="lineNum">     152 </span><span class="lineCov">          3 :                 adr = __va((pfn + i) &lt;&lt; PAGE_SHIFT);</span></a>
<a name="153"><span class="lineNum">     153 </span><span class="lineCov">          3 :                 clear_page(adr);</span></a>
<a name="154"><span class="lineNum">     154 </span>            :         }</a>
<a name="155"><span class="lineNum">     155 </span>            : </a>
<a name="156"><span class="lineNum">     156 </span><span class="lineCov">          3 :         return __va(pfn &lt;&lt; PAGE_SHIFT);</span></a>
<a name="157"><span class="lineNum">     157 </span>            : }</a>
<a name="158"><span class="lineNum">     158 </span>            : </a>
<a name="159"><span class="lineNum">     159 </span>            : /*</a>
<a name="160"><span class="lineNum">     160 </span>            :  * By default need to be able to allocate page tables below PGD firstly for</a>
<a name="161"><span class="lineNum">     161 </span>            :  * the 0-ISA_END_ADDRESS range and secondly for the initial PMD_SIZE mapping.</a>
<a name="162"><span class="lineNum">     162 </span>            :  * With KASLR memory randomization, depending on the machine e820 memory and the</a>
<a name="163"><span class="lineNum">     163 </span>            :  * PUD alignment, twice that many pages may be needed when KASLR memory</a>
<a name="164"><span class="lineNum">     164 </span>            :  * randomization is enabled.</a>
<a name="165"><span class="lineNum">     165 </span>            :  */</a>
<a name="166"><span class="lineNum">     166 </span>            : </a>
<a name="167"><span class="lineNum">     167 </span>            : #ifndef CONFIG_X86_5LEVEL</a>
<a name="168"><span class="lineNum">     168 </span>            : #define INIT_PGD_PAGE_TABLES    3</a>
<a name="169"><span class="lineNum">     169 </span>            : #else</a>
<a name="170"><span class="lineNum">     170 </span>            : #define INIT_PGD_PAGE_TABLES    4</a>
<a name="171"><span class="lineNum">     171 </span>            : #endif</a>
<a name="172"><span class="lineNum">     172 </span>            : </a>
<a name="173"><span class="lineNum">     173 </span>            : #ifndef CONFIG_RANDOMIZE_MEMORY</a>
<a name="174"><span class="lineNum">     174 </span>            : #define INIT_PGD_PAGE_COUNT      (2 * INIT_PGD_PAGE_TABLES)</a>
<a name="175"><span class="lineNum">     175 </span>            : #else</a>
<a name="176"><span class="lineNum">     176 </span>            : #define INIT_PGD_PAGE_COUNT      (4 * INIT_PGD_PAGE_TABLES)</a>
<a name="177"><span class="lineNum">     177 </span>            : #endif</a>
<a name="178"><span class="lineNum">     178 </span>            : </a>
<a name="179"><span class="lineNum">     179 </span>            : #define INIT_PGT_BUF_SIZE       (INIT_PGD_PAGE_COUNT * PAGE_SIZE)</a>
<a name="180"><span class="lineNum">     180 </span><span class="lineNoCov">          0 : RESERVE_BRK(early_pgt_alloc, INIT_PGT_BUF_SIZE);</span></a>
<a name="181"><span class="lineNum">     181 </span><span class="lineCov">          1 : void  __init early_alloc_pgt_buf(void)</span></a>
<a name="182"><span class="lineNum">     182 </span>            : {</a>
<a name="183"><span class="lineNum">     183 </span><span class="lineCov">          1 :         unsigned long tables = INIT_PGT_BUF_SIZE;</span></a>
<a name="184"><span class="lineNum">     184 </span><span class="lineCov">          1 :         phys_addr_t base;</span></a>
<a name="185"><span class="lineNum">     185 </span>            : </a>
<a name="186"><span class="lineNum">     186 </span><span class="lineCov">          1 :         base = __pa(extend_brk(tables, PAGE_SIZE));</span></a>
<a name="187"><span class="lineNum">     187 </span>            : </a>
<a name="188"><span class="lineNum">     188 </span><span class="lineCov">          1 :         pgt_buf_start = base &gt;&gt; PAGE_SHIFT;</span></a>
<a name="189"><span class="lineNum">     189 </span><span class="lineCov">          1 :         pgt_buf_end = pgt_buf_start;</span></a>
<a name="190"><span class="lineNum">     190 </span><span class="lineCov">          1 :         pgt_buf_top = pgt_buf_start + (tables &gt;&gt; PAGE_SHIFT);</span></a>
<a name="191"><span class="lineNum">     191 </span><span class="lineCov">          1 : }</span></a>
<a name="192"><span class="lineNum">     192 </span>            : </a>
<a name="193"><span class="lineNum">     193 </span>            : int after_bootmem;</a>
<a name="194"><span class="lineNum">     194 </span>            : </a>
<a name="195"><span class="lineNum">     195 </span><span class="lineNoCov">          0 : early_param_on_off(&quot;gbpages&quot;, &quot;nogbpages&quot;, direct_gbpages, CONFIG_X86_DIRECT_GBPAGES);</span></a>
<a name="196"><span class="lineNum">     196 </span>            : </a>
<a name="197"><span class="lineNum">     197 </span>            : struct map_range {</a>
<a name="198"><span class="lineNum">     198 </span>            :         unsigned long start;</a>
<a name="199"><span class="lineNum">     199 </span>            :         unsigned long end;</a>
<a name="200"><span class="lineNum">     200 </span>            :         unsigned page_size_mask;</a>
<a name="201"><span class="lineNum">     201 </span>            : };</a>
<a name="202"><span class="lineNum">     202 </span>            : </a>
<a name="203"><span class="lineNum">     203 </span>            : static int page_size_mask;</a>
<a name="204"><span class="lineNum">     204 </span>            : </a>
<a name="205"><span class="lineNum">     205 </span>            : /*</a>
<a name="206"><span class="lineNum">     206 </span>            :  * Save some of cr4 feature set we're using (e.g.  Pentium 4MB</a>
<a name="207"><span class="lineNum">     207 </span>            :  * enable and PPro Global page enable), so that any CPU's that boot</a>
<a name="208"><span class="lineNum">     208 </span>            :  * up after us can get the correct flags. Invoked on the boot CPU.</a>
<a name="209"><span class="lineNum">     209 </span>            :  */</a>
<a name="210"><span class="lineNum">     210 </span><span class="lineCov">          2 : static inline void cr4_set_bits_and_update_boot(unsigned long mask)</span></a>
<a name="211"><span class="lineNum">     211 </span>            : {</a>
<a name="212"><span class="lineNum">     212 </span><span class="lineCov">          2 :         mmu_cr4_features |= mask;</span></a>
<a name="213"><span class="lineNum">     213 </span><span class="lineCov">          2 :         if (trampoline_cr4_features)</span></a>
<a name="214"><span class="lineNum">     214 </span><span class="lineNoCov">          0 :                 *trampoline_cr4_features = mmu_cr4_features;</span></a>
<a name="215"><span class="lineNum">     215 </span><span class="lineCov">          2 :         cr4_set_bits(mask);</span></a>
<a name="216"><span class="lineNum">     216 </span><span class="lineCov">          2 : }</span></a>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<a name="218"><span class="lineNum">     218 </span><span class="lineCov">          1 : static void __init probe_page_size_mask(void)</span></a>
<a name="219"><span class="lineNum">     219 </span>            : {</a>
<a name="220"><span class="lineNum">     220 </span>            :         /*</a>
<a name="221"><span class="lineNum">     221 </span>            :          * For pagealloc debugging, identity mapping will use small pages.</a>
<a name="222"><span class="lineNum">     222 </span>            :          * This will simplify cpa(), which otherwise needs to support splitting</a>
<a name="223"><span class="lineNum">     223 </span>            :          * large pages into small in interrupt context, etc.</a>
<a name="224"><span class="lineNum">     224 </span>            :          */</a>
<a name="225"><span class="lineNum">     225 </span><span class="lineCov">          1 :         if (boot_cpu_has(X86_FEATURE_PSE) &amp;&amp; !debug_pagealloc_enabled())</span></a>
<a name="226"><span class="lineNum">     226 </span><span class="lineCov">          1 :                 page_size_mask |= 1 &lt;&lt; PG_LEVEL_2M;</span></a>
<a name="227"><span class="lineNum">     227 </span>            :         else</a>
<a name="228"><span class="lineNum">     228 </span>            :                 direct_gbpages = 0;</a>
<a name="229"><span class="lineNum">     229 </span>            : </a>
<a name="230"><span class="lineNum">     230 </span>            :         /* Enable PSE if available */</a>
<a name="231"><span class="lineNum">     231 </span><span class="lineCov">          1 :         if (boot_cpu_has(X86_FEATURE_PSE))</span></a>
<a name="232"><span class="lineNum">     232 </span><span class="lineCov">          1 :                 cr4_set_bits_and_update_boot(X86_CR4_PSE);</span></a>
<a name="233"><span class="lineNum">     233 </span>            : </a>
<a name="234"><span class="lineNum">     234 </span>            :         /* Enable PGE if available */</a>
<a name="235"><span class="lineNum">     235 </span><span class="lineCov">          1 :         __supported_pte_mask &amp;= ~_PAGE_GLOBAL;</span></a>
<a name="236"><span class="lineNum">     236 </span><span class="lineCov">          1 :         if (boot_cpu_has(X86_FEATURE_PGE)) {</span></a>
<a name="237"><span class="lineNum">     237 </span><span class="lineCov">          1 :                 cr4_set_bits_and_update_boot(X86_CR4_PGE);</span></a>
<a name="238"><span class="lineNum">     238 </span><span class="lineCov">          1 :                 __supported_pte_mask |= _PAGE_GLOBAL;</span></a>
<a name="239"><span class="lineNum">     239 </span>            :         }</a>
<a name="240"><span class="lineNum">     240 </span>            : </a>
<a name="241"><span class="lineNum">     241 </span>            :         /* By the default is everything supported: */</a>
<a name="242"><span class="lineNum">     242 </span><span class="lineCov">          1 :         __default_kernel_pte_mask = __supported_pte_mask;</span></a>
<a name="243"><span class="lineNum">     243 </span>            :         /* Except when with PTI where the kernel is mostly non-Global: */</a>
<a name="244"><span class="lineNum">     244 </span><span class="lineCov">          1 :         if (cpu_feature_enabled(X86_FEATURE_PTI))</span></a>
<a name="245"><span class="lineNum">     245 </span>            :                 __default_kernel_pte_mask &amp;= ~_PAGE_GLOBAL;</a>
<a name="246"><span class="lineNum">     246 </span>            : </a>
<a name="247"><span class="lineNum">     247 </span>            :         /* Enable 1 GB linear kernel mappings if available: */</a>
<a name="248"><span class="lineNum">     248 </span><span class="lineCov">          2 :         if (direct_gbpages &amp;&amp; boot_cpu_has(X86_FEATURE_GBPAGES)) {</span></a>
<a name="249"><span class="lineNum">     249 </span><span class="lineCov">          1 :                 printk(KERN_INFO &quot;Using GB pages for direct mapping\n&quot;);</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineCov">          1 :                 page_size_mask |= 1 &lt;&lt; PG_LEVEL_1G;</span></a>
<a name="251"><span class="lineNum">     251 </span>            :         } else {</a>
<a name="252"><span class="lineNum">     252 </span><span class="lineNoCov">          0 :                 direct_gbpages = 0;</span></a>
<a name="253"><span class="lineNum">     253 </span>            :         }</a>
<a name="254"><span class="lineNum">     254 </span><span class="lineCov">          1 : }</span></a>
<a name="255"><span class="lineNum">     255 </span>            : </a>
<a name="256"><span class="lineNum">     256 </span><span class="lineCov">          1 : static void setup_pcid(void)</span></a>
<a name="257"><span class="lineNum">     257 </span>            : {</a>
<a name="258"><span class="lineNum">     258 </span><span class="lineCov">          1 :         if (!IS_ENABLED(CONFIG_X86_64))</span></a>
<a name="259"><span class="lineNum">     259 </span>            :                 return;</a>
<a name="260"><span class="lineNum">     260 </span>            : </a>
<a name="261"><span class="lineNum">     261 </span><span class="lineCov">          1 :         if (!boot_cpu_has(X86_FEATURE_PCID))</span></a>
<a name="262"><span class="lineNum">     262 </span>            :                 return;</a>
<a name="263"><span class="lineNum">     263 </span>            : </a>
<a name="264"><span class="lineNum">     264 </span><span class="lineCov">          1 :         if (boot_cpu_has(X86_FEATURE_PGE)) {</span></a>
<a name="265"><span class="lineNum">     265 </span>            :                 /*</a>
<a name="266"><span class="lineNum">     266 </span>            :                  * This can't be cr4_set_bits_and_update_boot() -- the</a>
<a name="267"><span class="lineNum">     267 </span>            :                  * trampoline code can't handle CR4.PCIDE and it wouldn't</a>
<a name="268"><span class="lineNum">     268 </span>            :                  * do any good anyway.  Despite the name,</a>
<a name="269"><span class="lineNum">     269 </span>            :                  * cr4_set_bits_and_update_boot() doesn't actually cause</a>
<a name="270"><span class="lineNum">     270 </span>            :                  * the bits in question to remain set all the way through</a>
<a name="271"><span class="lineNum">     271 </span>            :                  * the secondary boot asm.</a>
<a name="272"><span class="lineNum">     272 </span>            :                  *</a>
<a name="273"><span class="lineNum">     273 </span>            :                  * Instead, we brute-force it and set CR4.PCIDE manually in</a>
<a name="274"><span class="lineNum">     274 </span>            :                  * start_secondary().</a>
<a name="275"><span class="lineNum">     275 </span>            :                  */</a>
<a name="276"><span class="lineNum">     276 </span><span class="lineCov">          1 :                 cr4_set_bits(X86_CR4_PCIDE);</span></a>
<a name="277"><span class="lineNum">     277 </span>            : </a>
<a name="278"><span class="lineNum">     278 </span>            :                 /*</a>
<a name="279"><span class="lineNum">     279 </span>            :                  * INVPCID's single-context modes (2/3) only work if we set</a>
<a name="280"><span class="lineNum">     280 </span>            :                  * X86_CR4_PCIDE, *and* we INVPCID support.  It's unusable</a>
<a name="281"><span class="lineNum">     281 </span>            :                  * on systems that have X86_CR4_PCIDE clear, or that have</a>
<a name="282"><span class="lineNum">     282 </span>            :                  * no INVPCID support at all.</a>
<a name="283"><span class="lineNum">     283 </span>            :                  */</a>
<a name="284"><span class="lineNum">     284 </span><span class="lineCov">          1 :                 if (boot_cpu_has(X86_FEATURE_INVPCID))</span></a>
<a name="285"><span class="lineNum">     285 </span><span class="lineCov">          1 :                         setup_force_cpu_cap(X86_FEATURE_INVPCID_SINGLE);</span></a>
<a name="286"><span class="lineNum">     286 </span>            :         } else {</a>
<a name="287"><span class="lineNum">     287 </span>            :                 /*</a>
<a name="288"><span class="lineNum">     288 </span>            :                  * flush_tlb_all(), as currently implemented, won't work if</a>
<a name="289"><span class="lineNum">     289 </span>            :                  * PCID is on but PGE is not.  Since that combination</a>
<a name="290"><span class="lineNum">     290 </span>            :                  * doesn't exist on real hardware, there's no reason to try</a>
<a name="291"><span class="lineNum">     291 </span>            :                  * to fully support it, but it's polite to avoid corrupting</a>
<a name="292"><span class="lineNum">     292 </span>            :                  * data if we're on an improperly configured VM.</a>
<a name="293"><span class="lineNum">     293 </span>            :                  */</a>
<a name="294"><span class="lineNum">     294 </span><span class="lineNoCov">          0 :                 setup_clear_cpu_cap(X86_FEATURE_PCID);</span></a>
<a name="295"><span class="lineNum">     295 </span>            :         }</a>
<a name="296"><span class="lineNum">     296 </span>            : }</a>
<a name="297"><span class="lineNum">     297 </span>            : </a>
<a name="298"><span class="lineNum">     298 </span>            : #ifdef CONFIG_X86_32</a>
<a name="299"><span class="lineNum">     299 </span>            : #define NR_RANGE_MR 3</a>
<a name="300"><span class="lineNum">     300 </span>            : #else /* CONFIG_X86_64 */</a>
<a name="301"><span class="lineNum">     301 </span>            : #define NR_RANGE_MR 5</a>
<a name="302"><span class="lineNum">     302 </span>            : #endif</a>
<a name="303"><span class="lineNum">     303 </span>            : </a>
<a name="304"><span class="lineNum">     304 </span><span class="lineCov">          8 : static int __meminit save_mr(struct map_range *mr, int nr_range,</span></a>
<a name="305"><span class="lineNum">     305 </span>            :                              unsigned long start_pfn, unsigned long end_pfn,</a>
<a name="306"><span class="lineNum">     306 </span>            :                              unsigned long page_size_mask)</a>
<a name="307"><span class="lineNum">     307 </span>            : {</a>
<a name="308"><span class="lineNum">     308 </span><span class="lineCov">          8 :         if (start_pfn &lt; end_pfn) {</span></a>
<a name="309"><span class="lineNum">     309 </span><span class="lineCov">          5 :                 if (nr_range &gt;= NR_RANGE_MR)</span></a>
<a name="310"><span class="lineNum">     310 </span><span class="lineNoCov">          0 :                         panic(&quot;run out of range for init_memory_mapping\n&quot;);</span></a>
<a name="311"><span class="lineNum">     311 </span><span class="lineCov">          5 :                 mr[nr_range].start = start_pfn&lt;&lt;PAGE_SHIFT;</span></a>
<a name="312"><span class="lineNum">     312 </span><span class="lineCov">          5 :                 mr[nr_range].end   = end_pfn&lt;&lt;PAGE_SHIFT;</span></a>
<a name="313"><span class="lineNum">     313 </span><span class="lineCov">          5 :                 mr[nr_range].page_size_mask = page_size_mask;</span></a>
<a name="314"><span class="lineNum">     314 </span><span class="lineCov">          5 :                 nr_range++;</span></a>
<a name="315"><span class="lineNum">     315 </span>            :         }</a>
<a name="316"><span class="lineNum">     316 </span>            : </a>
<a name="317"><span class="lineNum">     317 </span><span class="lineCov">          8 :         return nr_range;</span></a>
<a name="318"><span class="lineNum">     318 </span>            : }</a>
<a name="319"><span class="lineNum">     319 </span>            : </a>
<a name="320"><span class="lineNum">     320 </span>            : /*</a>
<a name="321"><span class="lineNum">     321 </span>            :  * adjust the page_size_mask for small range to go with</a>
<a name="322"><span class="lineNum">     322 </span>            :  *      big page size instead small one if nearby are ram too.</a>
<a name="323"><span class="lineNum">     323 </span>            :  */</a>
<a name="324"><span class="lineNum">     324 </span><span class="lineCov">          4 : static void __ref adjust_range_page_size_mask(struct map_range *mr,</span></a>
<a name="325"><span class="lineNum">     325 </span>            :                                                          int nr_range)</a>
<a name="326"><span class="lineNum">     326 </span>            : {</a>
<a name="327"><span class="lineNum">     327 </span><span class="lineCov">          4 :         int i;</span></a>
<a name="328"><span class="lineNum">     328 </span>            : </a>
<a name="329"><span class="lineNum">     329 </span><span class="lineCov">          9 :         for (i = 0; i &lt; nr_range; i++) {</span></a>
<a name="330"><span class="lineNum">     330 </span><span class="lineCov">          5 :                 if ((page_size_mask &amp; (1&lt;&lt;PG_LEVEL_2M)) &amp;&amp;</span></a>
<a name="331"><span class="lineNum">     331 </span><span class="lineCov">          5 :                     !(mr[i].page_size_mask &amp; (1&lt;&lt;PG_LEVEL_2M))) {</span></a>
<a name="332"><span class="lineNum">     332 </span><span class="lineCov">          2 :                         unsigned long start = round_down(mr[i].start, PMD_SIZE);</span></a>
<a name="333"><span class="lineNum">     333 </span><span class="lineCov">          2 :                         unsigned long end = round_up(mr[i].end, PMD_SIZE);</span></a>
<a name="334"><span class="lineNum">     334 </span>            : </a>
<a name="335"><span class="lineNum">     335 </span>            : #ifdef CONFIG_X86_32</a>
<a name="336"><span class="lineNum">     336 </span>            :                         if ((end &gt;&gt; PAGE_SHIFT) &gt; max_low_pfn)</a>
<a name="337"><span class="lineNum">     337 </span>            :                                 continue;</a>
<a name="338"><span class="lineNum">     338 </span>            : #endif</a>
<a name="339"><span class="lineNum">     339 </span>            : </a>
<a name="340"><span class="lineNum">     340 </span><span class="lineCov">          2 :                         if (memblock_is_region_memory(start, end - start))</span></a>
<a name="341"><span class="lineNum">     341 </span><span class="lineNoCov">          0 :                                 mr[i].page_size_mask |= 1&lt;&lt;PG_LEVEL_2M;</span></a>
<a name="342"><span class="lineNum">     342 </span>            :                 }</a>
<a name="343"><span class="lineNum">     343 </span><span class="lineCov">          5 :                 if ((page_size_mask &amp; (1&lt;&lt;PG_LEVEL_1G)) &amp;&amp;</span></a>
<a name="344"><span class="lineNum">     344 </span><span class="lineCov">          5 :                     !(mr[i].page_size_mask &amp; (1&lt;&lt;PG_LEVEL_1G))) {</span></a>
<a name="345"><span class="lineNum">     345 </span><span class="lineCov">          5 :                         unsigned long start = round_down(mr[i].start, PUD_SIZE);</span></a>
<a name="346"><span class="lineNum">     346 </span><span class="lineCov">          5 :                         unsigned long end = round_up(mr[i].end, PUD_SIZE);</span></a>
<a name="347"><span class="lineNum">     347 </span>            : </a>
<a name="348"><span class="lineNum">     348 </span><span class="lineCov">          5 :                         if (memblock_is_region_memory(start, end - start))</span></a>
<a name="349"><span class="lineNum">     349 </span><span class="lineNoCov">          0 :                                 mr[i].page_size_mask |= 1&lt;&lt;PG_LEVEL_1G;</span></a>
<a name="350"><span class="lineNum">     350 </span>            :                 }</a>
<a name="351"><span class="lineNum">     351 </span>            :         }</a>
<a name="352"><span class="lineNum">     352 </span><span class="lineCov">          4 : }</span></a>
<a name="353"><span class="lineNum">     353 </span>            : </a>
<a name="354"><span class="lineNum">     354 </span>            : static const char *page_size_string(struct map_range *mr)</a>
<a name="355"><span class="lineNum">     355 </span>            : {</a>
<a name="356"><span class="lineNum">     356 </span>            :         static const char str_1g[] = &quot;1G&quot;;</a>
<a name="357"><span class="lineNum">     357 </span>            :         static const char str_2m[] = &quot;2M&quot;;</a>
<a name="358"><span class="lineNum">     358 </span>            :         static const char str_4m[] = &quot;4M&quot;;</a>
<a name="359"><span class="lineNum">     359 </span>            :         static const char str_4k[] = &quot;4k&quot;;</a>
<a name="360"><span class="lineNum">     360 </span>            : </a>
<a name="361"><span class="lineNum">     361 </span>            :         if (mr-&gt;page_size_mask &amp; (1&lt;&lt;PG_LEVEL_1G))</a>
<a name="362"><span class="lineNum">     362 </span>            :                 return str_1g;</a>
<a name="363"><span class="lineNum">     363 </span>            :         /*</a>
<a name="364"><span class="lineNum">     364 </span>            :          * 32-bit without PAE has a 4M large page size.</a>
<a name="365"><span class="lineNum">     365 </span>            :          * PG_LEVEL_2M is misnamed, but we can at least</a>
<a name="366"><span class="lineNum">     366 </span>            :          * print out the right size in the string.</a>
<a name="367"><span class="lineNum">     367 </span>            :          */</a>
<a name="368"><span class="lineNum">     368 </span>            :         if (IS_ENABLED(CONFIG_X86_32) &amp;&amp;</a>
<a name="369"><span class="lineNum">     369 </span>            :             !IS_ENABLED(CONFIG_X86_PAE) &amp;&amp;</a>
<a name="370"><span class="lineNum">     370 </span>            :             mr-&gt;page_size_mask &amp; (1&lt;&lt;PG_LEVEL_2M))</a>
<a name="371"><span class="lineNum">     371 </span>            :                 return str_4m;</a>
<a name="372"><span class="lineNum">     372 </span>            : </a>
<a name="373"><span class="lineNum">     373 </span>            :         if (mr-&gt;page_size_mask &amp; (1&lt;&lt;PG_LEVEL_2M))</a>
<a name="374"><span class="lineNum">     374 </span>            :                 return str_2m;</a>
<a name="375"><span class="lineNum">     375 </span>            : </a>
<a name="376"><span class="lineNum">     376 </span>            :         return str_4k;</a>
<a name="377"><span class="lineNum">     377 </span>            : }</a>
<a name="378"><span class="lineNum">     378 </span>            : </a>
<a name="379"><span class="lineNum">     379 </span><span class="lineCov">          4 : static int __meminit split_mem_range(struct map_range *mr, int nr_range,</span></a>
<a name="380"><span class="lineNum">     380 </span>            :                                      unsigned long start,</a>
<a name="381"><span class="lineNum">     381 </span>            :                                      unsigned long end)</a>
<a name="382"><span class="lineNum">     382 </span>            : {</a>
<a name="383"><span class="lineNum">     383 </span><span class="lineCov">          4 :         unsigned long start_pfn, end_pfn, limit_pfn;</span></a>
<a name="384"><span class="lineNum">     384 </span><span class="lineCov">          4 :         unsigned long pfn;</span></a>
<a name="385"><span class="lineNum">     385 </span><span class="lineCov">          4 :         int i;</span></a>
<a name="386"><span class="lineNum">     386 </span>            : </a>
<a name="387"><span class="lineNum">     387 </span><span class="lineCov">          4 :         limit_pfn = PFN_DOWN(end);</span></a>
<a name="388"><span class="lineNum">     388 </span>            : </a>
<a name="389"><span class="lineNum">     389 </span>            :         /* head if not big page alignment ? */</a>
<a name="390"><span class="lineNum">     390 </span><span class="lineCov">          4 :         pfn = start_pfn = PFN_DOWN(start);</span></a>
<a name="391"><span class="lineNum">     391 </span>            : #ifdef CONFIG_X86_32</a>
<a name="392"><span class="lineNum">     392 </span>            :         /*</a>
<a name="393"><span class="lineNum">     393 </span>            :          * Don't use a large page for the first 2/4MB of memory</a>
<a name="394"><span class="lineNum">     394 </span>            :          * because there are often fixed size MTRRs in there</a>
<a name="395"><span class="lineNum">     395 </span>            :          * and overlapping MTRRs into large pages can cause</a>
<a name="396"><span class="lineNum">     396 </span>            :          * slowdowns.</a>
<a name="397"><span class="lineNum">     397 </span>            :          */</a>
<a name="398"><span class="lineNum">     398 </span>            :         if (pfn == 0)</a>
<a name="399"><span class="lineNum">     399 </span>            :                 end_pfn = PFN_DOWN(PMD_SIZE);</a>
<a name="400"><span class="lineNum">     400 </span>            :         else</a>
<a name="401"><span class="lineNum">     401 </span>            :                 end_pfn = round_up(pfn, PFN_DOWN(PMD_SIZE));</a>
<a name="402"><span class="lineNum">     402 </span>            : #else /* CONFIG_X86_64 */</a>
<a name="403"><span class="lineNum">     403 </span><span class="lineCov">          4 :         end_pfn = round_up(pfn, PFN_DOWN(PMD_SIZE));</span></a>
<a name="404"><span class="lineNum">     404 </span>            : #endif</a>
<a name="405"><span class="lineNum">     405 </span><span class="lineCov">          4 :         if (end_pfn &gt; limit_pfn)</span></a>
<a name="406"><span class="lineNum">     406 </span>            :                 end_pfn = limit_pfn;</a>
<a name="407"><span class="lineNum">     407 </span><span class="lineCov">          4 :         if (start_pfn &lt; end_pfn) {</span></a>
<a name="408"><span class="lineNum">     408 </span><span class="lineCov">          1 :                 nr_range = save_mr(mr, nr_range, start_pfn, end_pfn, 0);</span></a>
<a name="409"><span class="lineNum">     409 </span><span class="lineCov">          1 :                 pfn = end_pfn;</span></a>
<a name="410"><span class="lineNum">     410 </span>            :         }</a>
<a name="411"><span class="lineNum">     411 </span>            : </a>
<a name="412"><span class="lineNum">     412 </span>            :         /* big page (2M) range */</a>
<a name="413"><span class="lineNum">     413 </span><span class="lineCov">          4 :         start_pfn = round_up(pfn, PFN_DOWN(PMD_SIZE));</span></a>
<a name="414"><span class="lineNum">     414 </span>            : #ifdef CONFIG_X86_32</a>
<a name="415"><span class="lineNum">     415 </span>            :         end_pfn = round_down(limit_pfn, PFN_DOWN(PMD_SIZE));</a>
<a name="416"><span class="lineNum">     416 </span>            : #else /* CONFIG_X86_64 */</a>
<a name="417"><span class="lineNum">     417 </span><span class="lineCov">          4 :         end_pfn = round_up(pfn, PFN_DOWN(PUD_SIZE));</span></a>
<a name="418"><span class="lineNum">     418 </span><span class="lineCov">          4 :         if (end_pfn &gt; round_down(limit_pfn, PFN_DOWN(PMD_SIZE)))</span></a>
<a name="419"><span class="lineNum">     419 </span>            :                 end_pfn = round_down(limit_pfn, PFN_DOWN(PMD_SIZE));</a>
<a name="420"><span class="lineNum">     420 </span>            : #endif</a>
<a name="421"><span class="lineNum">     421 </span>            : </a>
<a name="422"><span class="lineNum">     422 </span><span class="lineCov">          4 :         if (start_pfn &lt; end_pfn) {</span></a>
<a name="423"><span class="lineNum">     423 </span><span class="lineCov">          3 :                 nr_range = save_mr(mr, nr_range, start_pfn, end_pfn,</span></a>
<a name="424"><span class="lineNum">     424 </span><span class="lineCov">          3 :                                 page_size_mask &amp; (1&lt;&lt;PG_LEVEL_2M));</span></a>
<a name="425"><span class="lineNum">     425 </span><span class="lineCov">          3 :                 pfn = end_pfn;</span></a>
<a name="426"><span class="lineNum">     426 </span>            :         }</a>
<a name="427"><span class="lineNum">     427 </span>            : </a>
<a name="428"><span class="lineNum">     428 </span>            : #ifdef CONFIG_X86_64</a>
<a name="429"><span class="lineNum">     429 </span>            :         /* big page (1G) range */</a>
<a name="430"><span class="lineNum">     430 </span><span class="lineCov">          4 :         start_pfn = round_up(pfn, PFN_DOWN(PUD_SIZE));</span></a>
<a name="431"><span class="lineNum">     431 </span><span class="lineCov">          4 :         end_pfn = round_down(limit_pfn, PFN_DOWN(PUD_SIZE));</span></a>
<a name="432"><span class="lineNum">     432 </span><span class="lineCov">          4 :         if (start_pfn &lt; end_pfn) {</span></a>
<a name="433"><span class="lineNum">     433 </span><span class="lineNoCov">          0 :                 nr_range = save_mr(mr, nr_range, start_pfn, end_pfn,</span></a>
<a name="434"><span class="lineNum">     434 </span><span class="lineNoCov">          0 :                                 page_size_mask &amp;</span></a>
<a name="435"><span class="lineNum">     435 </span>            :                                  ((1&lt;&lt;PG_LEVEL_2M)|(1&lt;&lt;PG_LEVEL_1G)));</a>
<a name="436"><span class="lineNum">     436 </span><span class="lineNoCov">          0 :                 pfn = end_pfn;</span></a>
<a name="437"><span class="lineNum">     437 </span>            :         }</a>
<a name="438"><span class="lineNum">     438 </span>            : </a>
<a name="439"><span class="lineNum">     439 </span>            :         /* tail is not big page (1G) alignment */</a>
<a name="440"><span class="lineNum">     440 </span><span class="lineCov">          4 :         start_pfn = round_up(pfn, PFN_DOWN(PMD_SIZE));</span></a>
<a name="441"><span class="lineNum">     441 </span><span class="lineCov">          4 :         end_pfn = round_down(limit_pfn, PFN_DOWN(PMD_SIZE));</span></a>
<a name="442"><span class="lineNum">     442 </span><span class="lineCov">          4 :         if (start_pfn &lt; end_pfn) {</span></a>
<a name="443"><span class="lineNum">     443 </span><span class="lineNoCov">          0 :                 nr_range = save_mr(mr, nr_range, start_pfn, end_pfn,</span></a>
<a name="444"><span class="lineNum">     444 </span><span class="lineNoCov">          0 :                                 page_size_mask &amp; (1&lt;&lt;PG_LEVEL_2M));</span></a>
<a name="445"><span class="lineNum">     445 </span><span class="lineNoCov">          0 :                 pfn = end_pfn;</span></a>
<a name="446"><span class="lineNum">     446 </span>            :         }</a>
<a name="447"><span class="lineNum">     447 </span>            : #endif</a>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<a name="449"><span class="lineNum">     449 </span>            :         /* tail is not big page (2M) alignment */</a>
<a name="450"><span class="lineNum">     450 </span><span class="lineCov">          4 :         start_pfn = pfn;</span></a>
<a name="451"><span class="lineNum">     451 </span><span class="lineCov">          4 :         end_pfn = limit_pfn;</span></a>
<a name="452"><span class="lineNum">     452 </span><span class="lineCov">          4 :         nr_range = save_mr(mr, nr_range, start_pfn, end_pfn, 0);</span></a>
<a name="453"><span class="lineNum">     453 </span>            : </a>
<a name="454"><span class="lineNum">     454 </span><span class="lineCov">          4 :         if (!after_bootmem)</span></a>
<a name="455"><span class="lineNum">     455 </span><span class="lineCov">          4 :                 adjust_range_page_size_mask(mr, nr_range);</span></a>
<a name="456"><span class="lineNum">     456 </span>            : </a>
<a name="457"><span class="lineNum">     457 </span>            :         /* try to merge same page size and continuous */</a>
<a name="458"><span class="lineNum">     458 </span><span class="lineCov">          5 :         for (i = 0; nr_range &gt; 1 &amp;&amp; i &lt; nr_range - 1; i++) {</span></a>
<a name="459"><span class="lineNum">     459 </span><span class="lineCov">          1 :                 unsigned long old_start;</span></a>
<a name="460"><span class="lineNum">     460 </span><span class="lineCov">          1 :                 if (mr[i].end != mr[i+1].start ||</span></a>
<a name="461"><span class="lineNum">     461 </span><span class="lineCov">          1 :                     mr[i].page_size_mask != mr[i+1].page_size_mask)</span></a>
<a name="462"><span class="lineNum">     462 </span><span class="lineCov">          1 :                         continue;</span></a>
<a name="463"><span class="lineNum">     463 </span>            :                 /* move it */</a>
<a name="464"><span class="lineNum">     464 </span><span class="lineNoCov">          0 :                 old_start = mr[i].start;</span></a>
<a name="465"><span class="lineNum">     465 </span><span class="lineNoCov">          0 :                 memmove(&amp;mr[i], &amp;mr[i+1],</span></a>
<a name="466"><span class="lineNum">     466 </span><span class="lineNoCov">          0 :                         (nr_range - 1 - i) * sizeof(struct map_range));</span></a>
<a name="467"><span class="lineNum">     467 </span><span class="lineNoCov">          0 :                 mr[i--].start = old_start;</span></a>
<a name="468"><span class="lineNum">     468 </span><span class="lineNoCov">          0 :                 nr_range--;</span></a>
<a name="469"><span class="lineNum">     469 </span>            :         }</a>
<a name="470"><span class="lineNum">     470 </span>            : </a>
<a name="471"><span class="lineNum">     471 </span><span class="lineCov">          4 :         for (i = 0; i &lt; nr_range; i++)</span></a>
<a name="472"><span class="lineNum">     472 </span>            :                 pr_debug(&quot; [mem %#010lx-%#010lx] page %s\n&quot;,</a>
<a name="473"><span class="lineNum">     473 </span>            :                                 mr[i].start, mr[i].end - 1,</a>
<a name="474"><span class="lineNum">     474 </span>            :                                 page_size_string(&amp;mr[i]));</a>
<a name="475"><span class="lineNum">     475 </span>            : </a>
<a name="476"><span class="lineNum">     476 </span><span class="lineCov">          4 :         return nr_range;</span></a>
<a name="477"><span class="lineNum">     477 </span>            : }</a>
<a name="478"><span class="lineNum">     478 </span>            : </a>
<a name="479"><span class="lineNum">     479 </span>            : struct range pfn_mapped[E820_MAX_ENTRIES];</a>
<a name="480"><span class="lineNum">     480 </span>            : int nr_pfn_mapped;</a>
<a name="481"><span class="lineNum">     481 </span>            : </a>
<a name="482"><span class="lineNum">     482 </span><span class="lineCov">          4 : static void add_pfn_range_mapped(unsigned long start_pfn, unsigned long end_pfn)</span></a>
<a name="483"><span class="lineNum">     483 </span>            : {</a>
<a name="484"><span class="lineNum">     484 </span><span class="lineCov">          4 :         nr_pfn_mapped = add_range_with_merge(pfn_mapped, E820_MAX_ENTRIES,</span></a>
<a name="485"><span class="lineNum">     485 </span>            :                                              nr_pfn_mapped, start_pfn, end_pfn);</a>
<a name="486"><span class="lineNum">     486 </span><span class="lineCov">          4 :         nr_pfn_mapped = clean_sort_range(pfn_mapped, E820_MAX_ENTRIES);</span></a>
<a name="487"><span class="lineNum">     487 </span>            : </a>
<a name="488"><span class="lineNum">     488 </span><span class="lineCov">          4 :         max_pfn_mapped = max(max_pfn_mapped, end_pfn);</span></a>
<a name="489"><span class="lineNum">     489 </span>            : </a>
<a name="490"><span class="lineNum">     490 </span><span class="lineCov">          4 :         if (start_pfn &lt; (1UL&lt;&lt;(32-PAGE_SHIFT)))</span></a>
<a name="491"><span class="lineNum">     491 </span><span class="lineCov">          4 :                 max_low_pfn_mapped = max(max_low_pfn_mapped,</span></a>
<a name="492"><span class="lineNum">     492 </span>            :                                          min(end_pfn, 1UL&lt;&lt;(32-PAGE_SHIFT)));</a>
<a name="493"><span class="lineNum">     493 </span><span class="lineCov">          4 : }</span></a>
<a name="494"><span class="lineNum">     494 </span>            : </a>
<a name="495"><span class="lineNum">     495 </span><span class="lineCov">       1002 : bool pfn_range_is_mapped(unsigned long start_pfn, unsigned long end_pfn)</span></a>
<a name="496"><span class="lineNum">     496 </span>            : {</a>
<a name="497"><span class="lineNum">     497 </span><span class="lineCov">       1002 :         int i;</span></a>
<a name="498"><span class="lineNum">     498 </span>            : </a>
<a name="499"><span class="lineNum">     499 </span><span class="lineCov">       1002 :         for (i = 0; i &lt; nr_pfn_mapped; i++)</span></a>
<a name="500"><span class="lineNum">     500 </span><span class="lineCov">       1002 :                 if ((start_pfn &gt;= pfn_mapped[i].start) &amp;&amp;</span></a>
<a name="501"><span class="lineNum">     501 </span><span class="lineCov">       1002 :                     (end_pfn &lt;= pfn_mapped[i].end))</span></a>
<a name="502"><span class="lineNum">     502 </span>            :                         return true;</a>
<a name="503"><span class="lineNum">     503 </span>            : </a>
<a name="504"><span class="lineNum">     504 </span>            :         return false;</a>
<a name="505"><span class="lineNum">     505 </span>            : }</a>
<a name="506"><span class="lineNum">     506 </span>            : </a>
<a name="507"><span class="lineNum">     507 </span>            : /*</a>
<a name="508"><span class="lineNum">     508 </span>            :  * Setup the direct mapping of the physical memory at PAGE_OFFSET.</a>
<a name="509"><span class="lineNum">     509 </span>            :  * This runs before bootmem is initialized and gets pages directly from</a>
<a name="510"><span class="lineNum">     510 </span>            :  * the physical memory. To access them they are temporarily mapped.</a>
<a name="511"><span class="lineNum">     511 </span>            :  */</a>
<a name="512"><span class="lineNum">     512 </span><span class="lineCov">          4 : unsigned long __ref init_memory_mapping(unsigned long start,</span></a>
<a name="513"><span class="lineNum">     513 </span>            :                                         unsigned long end, pgprot_t prot)</a>
<a name="514"><span class="lineNum">     514 </span>            : {</a>
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">          4 :         struct map_range mr[NR_RANGE_MR];</span></a>
<a name="516"><span class="lineNum">     516 </span><span class="lineCov">          4 :         unsigned long ret = 0;</span></a>
<a name="517"><span class="lineNum">     517 </span><span class="lineCov">          4 :         int nr_range, i;</span></a>
<a name="518"><span class="lineNum">     518 </span>            : </a>
<a name="519"><span class="lineNum">     519 </span><span class="lineCov">          4 :         pr_debug(&quot;init_memory_mapping: [mem %#010lx-%#010lx]\n&quot;,</span></a>
<a name="520"><span class="lineNum">     520 </span>            :                start, end - 1);</a>
<a name="521"><span class="lineNum">     521 </span>            : </a>
<a name="522"><span class="lineNum">     522 </span><span class="lineCov">          4 :         memset(mr, 0, sizeof(mr));</span></a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">          4 :         nr_range = split_mem_range(mr, 0, start, end);</span></a>
<a name="524"><span class="lineNum">     524 </span>            : </a>
<a name="525"><span class="lineNum">     525 </span><span class="lineCov">         13 :         for (i = 0; i &lt; nr_range; i++)</span></a>
<a name="526"><span class="lineNum">     526 </span><span class="lineCov">          5 :                 ret = kernel_physical_mapping_init(mr[i].start, mr[i].end,</span></a>
<a name="527"><span class="lineNum">     527 </span><span class="lineCov">          5 :                                                    mr[i].page_size_mask,</span></a>
<a name="528"><span class="lineNum">     528 </span>            :                                                    prot);</a>
<a name="529"><span class="lineNum">     529 </span>            : </a>
<a name="530"><span class="lineNum">     530 </span><span class="lineCov">          4 :         add_pfn_range_mapped(start &gt;&gt; PAGE_SHIFT, ret &gt;&gt; PAGE_SHIFT);</span></a>
<a name="531"><span class="lineNum">     531 </span>            : </a>
<a name="532"><span class="lineNum">     532 </span><span class="lineCov">          4 :         return ret &gt;&gt; PAGE_SHIFT;</span></a>
<a name="533"><span class="lineNum">     533 </span>            : }</a>
<a name="534"><span class="lineNum">     534 </span>            : </a>
<a name="535"><span class="lineNum">     535 </span>            : /*</a>
<a name="536"><span class="lineNum">     536 </span>            :  * We need to iterate through the E820 memory map and create direct mappings</a>
<a name="537"><span class="lineNum">     537 </span>            :  * for only E820_TYPE_RAM and E820_KERN_RESERVED regions. We cannot simply</a>
<a name="538"><span class="lineNum">     538 </span>            :  * create direct mappings for all pfns from [0 to max_low_pfn) and</a>
<a name="539"><span class="lineNum">     539 </span>            :  * [4GB to max_pfn) because of possible memory holes in high addresses</a>
<a name="540"><span class="lineNum">     540 </span>            :  * that cannot be marked as UC by fixed/variable range MTRRs.</a>
<a name="541"><span class="lineNum">     541 </span>            :  * Depending on the alignment of E820 ranges, this may possibly result</a>
<a name="542"><span class="lineNum">     542 </span>            :  * in using smaller size (i.e. 4K instead of 2M or 1G) page tables.</a>
<a name="543"><span class="lineNum">     543 </span>            :  *</a>
<a name="544"><span class="lineNum">     544 </span>            :  * init_mem_mapping() calls init_range_memory_mapping() with big range.</a>
<a name="545"><span class="lineNum">     545 </span>            :  * That range would have hole in the middle or ends, and only ram parts</a>
<a name="546"><span class="lineNum">     546 </span>            :  * will be mapped in init_range_memory_mapping().</a>
<a name="547"><span class="lineNum">     547 </span>            :  */</a>
<a name="548"><span class="lineNum">     548 </span><span class="lineCov">          3 : static unsigned long __init init_range_memory_mapping(</span></a>
<a name="549"><span class="lineNum">     549 </span>            :                                            unsigned long r_start,</a>
<a name="550"><span class="lineNum">     550 </span>            :                                            unsigned long r_end)</a>
<a name="551"><span class="lineNum">     551 </span>            : {</a>
<a name="552"><span class="lineNum">     552 </span><span class="lineCov">          3 :         unsigned long start_pfn, end_pfn;</span></a>
<a name="553"><span class="lineNum">     553 </span><span class="lineCov">          3 :         unsigned long mapped_ram_size = 0;</span></a>
<a name="554"><span class="lineNum">     554 </span><span class="lineCov">          3 :         int i;</span></a>
<a name="555"><span class="lineNum">     555 </span>            : </a>
<a name="556"><span class="lineNum">     556 </span><span class="lineCov">          9 :         for_each_mem_pfn_range(i, MAX_NUMNODES, &amp;start_pfn, &amp;end_pfn, NULL) {</span></a>
<a name="557"><span class="lineNum">     557 </span><span class="lineCov">          6 :                 u64 start = clamp_val(PFN_PHYS(start_pfn), r_start, r_end);</span></a>
<a name="558"><span class="lineNum">     558 </span><span class="lineCov">          6 :                 u64 end = clamp_val(PFN_PHYS(end_pfn), r_start, r_end);</span></a>
<a name="559"><span class="lineNum">     559 </span><span class="lineCov">          6 :                 if (start &gt;= end)</span></a>
<a name="560"><span class="lineNum">     560 </span><span class="lineCov">          3 :                         continue;</span></a>
<a name="561"><span class="lineNum">     561 </span>            : </a>
<a name="562"><span class="lineNum">     562 </span>            :                 /*</a>
<a name="563"><span class="lineNum">     563 </span>            :                  * if it is overlapping with brk pgt, we need to</a>
<a name="564"><span class="lineNum">     564 </span>            :                  * alloc pgt buf from memblock instead.</a>
<a name="565"><span class="lineNum">     565 </span>            :                  */</a>
<a name="566"><span class="lineNum">     566 </span><span class="lineCov">          3 :                 can_use_brk_pgt = max(start, (u64)pgt_buf_end&lt;&lt;PAGE_SHIFT) &gt;=</span></a>
<a name="567"><span class="lineNum">     567 </span><span class="lineCov">          3 :                                     min(end, (u64)pgt_buf_top&lt;&lt;PAGE_SHIFT);</span></a>
<a name="568"><span class="lineNum">     568 </span><span class="lineCov">          3 :                 init_memory_mapping(start, end, PAGE_KERNEL);</span></a>
<a name="569"><span class="lineNum">     569 </span><span class="lineCov">          3 :                 mapped_ram_size += end - start;</span></a>
<a name="570"><span class="lineNum">     570 </span><span class="lineCov">          3 :                 can_use_brk_pgt = true;</span></a>
<a name="571"><span class="lineNum">     571 </span>            :         }</a>
<a name="572"><span class="lineNum">     572 </span>            : </a>
<a name="573"><span class="lineNum">     573 </span><span class="lineCov">          3 :         return mapped_ram_size;</span></a>
<a name="574"><span class="lineNum">     574 </span>            : }</a>
<a name="575"><span class="lineNum">     575 </span>            : </a>
<a name="576"><span class="lineNum">     576 </span><span class="lineCov">          2 : static unsigned long __init get_new_step_size(unsigned long step_size)</span></a>
<a name="577"><span class="lineNum">     577 </span>            : {</a>
<a name="578"><span class="lineNum">     578 </span>            :         /*</a>
<a name="579"><span class="lineNum">     579 </span>            :          * Initial mapped size is PMD_SIZE (2M).</a>
<a name="580"><span class="lineNum">     580 </span>            :          * We can not set step_size to be PUD_SIZE (1G) yet.</a>
<a name="581"><span class="lineNum">     581 </span>            :          * In worse case, when we cross the 1G boundary, and</a>
<a name="582"><span class="lineNum">     582 </span>            :          * PG_LEVEL_2M is not set, we will need 1+1+512 pages (2M + 8k)</a>
<a name="583"><span class="lineNum">     583 </span>            :          * to map 1G range with PTE. Hence we use one less than the</a>
<a name="584"><span class="lineNum">     584 </span>            :          * difference of page table level shifts.</a>
<a name="585"><span class="lineNum">     585 </span>            :          *</a>
<a name="586"><span class="lineNum">     586 </span>            :          * Don't need to worry about overflow in the top-down case, on 32bit,</a>
<a name="587"><span class="lineNum">     587 </span>            :          * when step_size is 0, round_down() returns 0 for start, and that</a>
<a name="588"><span class="lineNum">     588 </span>            :          * turns it into 0x100000000ULL.</a>
<a name="589"><span class="lineNum">     589 </span>            :          * In the bottom-up case, round_up(x, 0) returns 0 though too, which</a>
<a name="590"><span class="lineNum">     590 </span>            :          * needs to be taken into consideration by the code below.</a>
<a name="591"><span class="lineNum">     591 </span>            :          */</a>
<a name="592"><span class="lineNum">     592 </span><span class="lineCov">          2 :         return step_size &lt;&lt; (PMD_SHIFT - PAGE_SHIFT - 1);</span></a>
<a name="593"><span class="lineNum">     593 </span>            : }</a>
<a name="594"><span class="lineNum">     594 </span>            : </a>
<a name="595"><span class="lineNum">     595 </span>            : /**</a>
<a name="596"><span class="lineNum">     596 </span>            :  * memory_map_top_down - Map [map_start, map_end) top down</a>
<a name="597"><span class="lineNum">     597 </span>            :  * @map_start: start address of the target memory range</a>
<a name="598"><span class="lineNum">     598 </span>            :  * @map_end: end address of the target memory range</a>
<a name="599"><span class="lineNum">     599 </span>            :  *</a>
<a name="600"><span class="lineNum">     600 </span>            :  * This function will setup direct mapping for memory range</a>
<a name="601"><span class="lineNum">     601 </span>            :  * [map_start, map_end) in top-down. That said, the page tables</a>
<a name="602"><span class="lineNum">     602 </span>            :  * will be allocated at the end of the memory, and we map the</a>
<a name="603"><span class="lineNum">     603 </span>            :  * memory in top-down.</a>
<a name="604"><span class="lineNum">     604 </span>            :  */</a>
<a name="605"><span class="lineNum">     605 </span><span class="lineCov">          1 : static void __init memory_map_top_down(unsigned long map_start,</span></a>
<a name="606"><span class="lineNum">     606 </span>            :                                        unsigned long map_end)</a>
<a name="607"><span class="lineNum">     607 </span>            : {</a>
<a name="608"><span class="lineNum">     608 </span><span class="lineCov">          1 :         unsigned long real_end, last_start;</span></a>
<a name="609"><span class="lineNum">     609 </span><span class="lineCov">          1 :         unsigned long step_size;</span></a>
<a name="610"><span class="lineNum">     610 </span><span class="lineCov">          1 :         unsigned long addr;</span></a>
<a name="611"><span class="lineNum">     611 </span><span class="lineCov">          1 :         unsigned long mapped_ram_size = 0;</span></a>
<a name="612"><span class="lineNum">     612 </span>            : </a>
<a name="613"><span class="lineNum">     613 </span>            :         /* xen has big range in reserved near end of ram, skip it at first.*/</a>
<a name="614"><span class="lineNum">     614 </span><span class="lineCov">          1 :         addr = memblock_find_in_range(map_start, map_end, PMD_SIZE, PMD_SIZE);</span></a>
<a name="615"><span class="lineNum">     615 </span><span class="lineCov">          1 :         real_end = addr + PMD_SIZE;</span></a>
<a name="616"><span class="lineNum">     616 </span>            : </a>
<a name="617"><span class="lineNum">     617 </span>            :         /* step_size need to be small so pgt_buf from BRK could cover it */</a>
<a name="618"><span class="lineNum">     618 </span><span class="lineCov">          1 :         step_size = PMD_SIZE;</span></a>
<a name="619"><span class="lineNum">     619 </span><span class="lineCov">          1 :         max_pfn_mapped = 0; /* will get exact value next */</span></a>
<a name="620"><span class="lineNum">     620 </span><span class="lineCov">          1 :         min_pfn_mapped = real_end &gt;&gt; PAGE_SHIFT;</span></a>
<a name="621"><span class="lineNum">     621 </span><span class="lineCov">          1 :         last_start = real_end;</span></a>
<a name="622"><span class="lineNum">     622 </span>            : </a>
<a name="623"><span class="lineNum">     623 </span>            :         /*</a>
<a name="624"><span class="lineNum">     624 </span>            :          * We start from the top (end of memory) and go to the bottom.</a>
<a name="625"><span class="lineNum">     625 </span>            :          * The memblock_find_in_range() gets us a block of RAM from the</a>
<a name="626"><span class="lineNum">     626 </span>            :          * end of RAM in [min_pfn_mapped, max_pfn_mapped) used as new pages</a>
<a name="627"><span class="lineNum">     627 </span>            :          * for page table.</a>
<a name="628"><span class="lineNum">     628 </span>            :          */</a>
<a name="629"><span class="lineNum">     629 </span><span class="lineCov">          4 :         while (last_start &gt; map_start) {</span></a>
<a name="630"><span class="lineNum">     630 </span><span class="lineCov">          3 :                 unsigned long start;</span></a>
<a name="631"><span class="lineNum">     631 </span>            : </a>
<a name="632"><span class="lineNum">     632 </span><span class="lineCov">          3 :                 if (last_start &gt; step_size) {</span></a>
<a name="633"><span class="lineNum">     633 </span><span class="lineCov">          2 :                         start = round_down(last_start - 1, step_size);</span></a>
<a name="634"><span class="lineNum">     634 </span><span class="lineCov">          2 :                         if (start &lt; map_start)</span></a>
<a name="635"><span class="lineNum">     635 </span>            :                                 start = map_start;</a>
<a name="636"><span class="lineNum">     636 </span>            :                 } else</a>
<a name="637"><span class="lineNum">     637 </span>            :                         start = map_start;</a>
<a name="638"><span class="lineNum">     638 </span><span class="lineCov">          3 :                 mapped_ram_size += init_range_memory_mapping(start,</span></a>
<a name="639"><span class="lineNum">     639 </span>            :                                                         last_start);</a>
<a name="640"><span class="lineNum">     640 </span><span class="lineCov">          3 :                 last_start = start;</span></a>
<a name="641"><span class="lineNum">     641 </span><span class="lineCov">          3 :                 min_pfn_mapped = last_start &gt;&gt; PAGE_SHIFT;</span></a>
<a name="642"><span class="lineNum">     642 </span><span class="lineCov">          3 :                 if (mapped_ram_size &gt;= step_size)</span></a>
<a name="643"><span class="lineNum">     643 </span><span class="lineCov">          2 :                         step_size = get_new_step_size(step_size);</span></a>
<a name="644"><span class="lineNum">     644 </span>            :         }</a>
<a name="645"><span class="lineNum">     645 </span>            : </a>
<a name="646"><span class="lineNum">     646 </span><span class="lineCov">          1 :         if (real_end &lt; map_end)</span></a>
<a name="647"><span class="lineNum">     647 </span><span class="lineNoCov">          0 :                 init_range_memory_mapping(real_end, map_end);</span></a>
<a name="648"><span class="lineNum">     648 </span><span class="lineCov">          1 : }</span></a>
<a name="649"><span class="lineNum">     649 </span>            : </a>
<a name="650"><span class="lineNum">     650 </span>            : /**</a>
<a name="651"><span class="lineNum">     651 </span>            :  * memory_map_bottom_up - Map [map_start, map_end) bottom up</a>
<a name="652"><span class="lineNum">     652 </span>            :  * @map_start: start address of the target memory range</a>
<a name="653"><span class="lineNum">     653 </span>            :  * @map_end: end address of the target memory range</a>
<a name="654"><span class="lineNum">     654 </span>            :  *</a>
<a name="655"><span class="lineNum">     655 </span>            :  * This function will setup direct mapping for memory range</a>
<a name="656"><span class="lineNum">     656 </span>            :  * [map_start, map_end) in bottom-up. Since we have limited the</a>
<a name="657"><span class="lineNum">     657 </span>            :  * bottom-up allocation above the kernel, the page tables will</a>
<a name="658"><span class="lineNum">     658 </span>            :  * be allocated just above the kernel and we map the memory</a>
<a name="659"><span class="lineNum">     659 </span>            :  * in [map_start, map_end) in bottom-up.</a>
<a name="660"><span class="lineNum">     660 </span>            :  */</a>
<a name="661"><span class="lineNum">     661 </span><span class="lineNoCov">          0 : static void __init memory_map_bottom_up(unsigned long map_start,</span></a>
<a name="662"><span class="lineNum">     662 </span>            :                                         unsigned long map_end)</a>
<a name="663"><span class="lineNum">     663 </span>            : {</a>
<a name="664"><span class="lineNum">     664 </span><span class="lineNoCov">          0 :         unsigned long next, start;</span></a>
<a name="665"><span class="lineNum">     665 </span><span class="lineNoCov">          0 :         unsigned long mapped_ram_size = 0;</span></a>
<a name="666"><span class="lineNum">     666 </span>            :         /* step_size need to be small so pgt_buf from BRK could cover it */</a>
<a name="667"><span class="lineNum">     667 </span><span class="lineNoCov">          0 :         unsigned long step_size = PMD_SIZE;</span></a>
<a name="668"><span class="lineNum">     668 </span>            : </a>
<a name="669"><span class="lineNum">     669 </span><span class="lineNoCov">          0 :         start = map_start;</span></a>
<a name="670"><span class="lineNum">     670 </span><span class="lineNoCov">          0 :         min_pfn_mapped = start &gt;&gt; PAGE_SHIFT;</span></a>
<a name="671"><span class="lineNum">     671 </span>            : </a>
<a name="672"><span class="lineNum">     672 </span>            :         /*</a>
<a name="673"><span class="lineNum">     673 </span>            :          * We start from the bottom (@map_start) and go to the top (@map_end).</a>
<a name="674"><span class="lineNum">     674 </span>            :          * The memblock_find_in_range() gets us a block of RAM from the</a>
<a name="675"><span class="lineNum">     675 </span>            :          * end of RAM in [min_pfn_mapped, max_pfn_mapped) used as new pages</a>
<a name="676"><span class="lineNum">     676 </span>            :          * for page table.</a>
<a name="677"><span class="lineNum">     677 </span>            :          */</a>
<a name="678"><span class="lineNum">     678 </span><span class="lineNoCov">          0 :         while (start &lt; map_end) {</span></a>
<a name="679"><span class="lineNum">     679 </span><span class="lineNoCov">          0 :                 if (step_size &amp;&amp; map_end - start &gt; step_size) {</span></a>
<a name="680"><span class="lineNum">     680 </span><span class="lineNoCov">          0 :                         next = round_up(start + 1, step_size);</span></a>
<a name="681"><span class="lineNum">     681 </span><span class="lineNoCov">          0 :                         if (next &gt; map_end)</span></a>
<a name="682"><span class="lineNum">     682 </span>            :                                 next = map_end;</a>
<a name="683"><span class="lineNum">     683 </span>            :                 } else {</a>
<a name="684"><span class="lineNum">     684 </span>            :                         next = map_end;</a>
<a name="685"><span class="lineNum">     685 </span>            :                 }</a>
<a name="686"><span class="lineNum">     686 </span>            : </a>
<a name="687"><span class="lineNum">     687 </span><span class="lineNoCov">          0 :                 mapped_ram_size += init_range_memory_mapping(start, next);</span></a>
<a name="688"><span class="lineNum">     688 </span><span class="lineNoCov">          0 :                 start = next;</span></a>
<a name="689"><span class="lineNum">     689 </span>            : </a>
<a name="690"><span class="lineNum">     690 </span><span class="lineNoCov">          0 :                 if (mapped_ram_size &gt;= step_size)</span></a>
<a name="691"><span class="lineNum">     691 </span><span class="lineNoCov">          0 :                         step_size = get_new_step_size(step_size);</span></a>
<a name="692"><span class="lineNum">     692 </span>            :         }</a>
<a name="693"><span class="lineNum">     693 </span><span class="lineNoCov">          0 : }</span></a>
<a name="694"><span class="lineNum">     694 </span>            : </a>
<a name="695"><span class="lineNum">     695 </span>            : /*</a>
<a name="696"><span class="lineNum">     696 </span>            :  * The real mode trampoline, which is required for bootstrapping CPUs</a>
<a name="697"><span class="lineNum">     697 </span>            :  * occupies only a small area under the low 1MB.  See reserve_real_mode()</a>
<a name="698"><span class="lineNum">     698 </span>            :  * for details.</a>
<a name="699"><span class="lineNum">     699 </span>            :  *</a>
<a name="700"><span class="lineNum">     700 </span>            :  * If KASLR is disabled the first PGD entry of the direct mapping is copied</a>
<a name="701"><span class="lineNum">     701 </span>            :  * to map the real mode trampoline.</a>
<a name="702"><span class="lineNum">     702 </span>            :  *</a>
<a name="703"><span class="lineNum">     703 </span>            :  * If KASLR is enabled, copy only the PUD which covers the low 1MB</a>
<a name="704"><span class="lineNum">     704 </span>            :  * area. This limits the randomization granularity to 1GB for both 4-level</a>
<a name="705"><span class="lineNum">     705 </span>            :  * and 5-level paging.</a>
<a name="706"><span class="lineNum">     706 </span>            :  */</a>
<a name="707"><span class="lineNum">     707 </span><span class="lineCov">          1 : static void __init init_trampoline(void)</span></a>
<a name="708"><span class="lineNum">     708 </span>            : {</a>
<a name="709"><span class="lineNum">     709 </span>            : #ifdef CONFIG_X86_64</a>
<a name="710"><span class="lineNum">     710 </span><span class="lineCov">          1 :         if (!kaslr_memory_enabled())</span></a>
<a name="711"><span class="lineNum">     711 </span><span class="lineCov">          1 :                 trampoline_pgd_entry = init_top_pgt[pgd_index(__PAGE_OFFSET)];</span></a>
<a name="712"><span class="lineNum">     712 </span>            :         else</a>
<a name="713"><span class="lineNum">     713 </span>            :                 init_trampoline_kaslr();</a>
<a name="714"><span class="lineNum">     714 </span>            : #endif</a>
<a name="715"><span class="lineNum">     715 </span><span class="lineCov">          1 : }</span></a>
<a name="716"><span class="lineNum">     716 </span>            : </a>
<a name="717"><span class="lineNum">     717 </span><span class="lineCov">          1 : void __init init_mem_mapping(void)</span></a>
<a name="718"><span class="lineNum">     718 </span>            : {</a>
<a name="719"><span class="lineNum">     719 </span><span class="lineCov">          1 :         unsigned long end;</span></a>
<a name="720"><span class="lineNum">     720 </span>            : </a>
<a name="721"><span class="lineNum">     721 </span><span class="lineCov">          1 :         pti_check_boottime_disable();</span></a>
<a name="722"><span class="lineNum">     722 </span><span class="lineCov">          1 :         probe_page_size_mask();</span></a>
<a name="723"><span class="lineNum">     723 </span><span class="lineCov">          1 :         setup_pcid();</span></a>
<a name="724"><span class="lineNum">     724 </span>            : </a>
<a name="725"><span class="lineNum">     725 </span>            : #ifdef CONFIG_X86_64</a>
<a name="726"><span class="lineNum">     726 </span><span class="lineCov">          1 :         end = max_pfn &lt;&lt; PAGE_SHIFT;</span></a>
<a name="727"><span class="lineNum">     727 </span>            : #else</a>
<a name="728"><span class="lineNum">     728 </span>            :         end = max_low_pfn &lt;&lt; PAGE_SHIFT;</a>
<a name="729"><span class="lineNum">     729 </span>            : #endif</a>
<a name="730"><span class="lineNum">     730 </span>            : </a>
<a name="731"><span class="lineNum">     731 </span>            :         /* the ISA range is always mapped regardless of memory holes */</a>
<a name="732"><span class="lineNum">     732 </span><span class="lineCov">          1 :         init_memory_mapping(0, ISA_END_ADDRESS, PAGE_KERNEL);</span></a>
<a name="733"><span class="lineNum">     733 </span>            : </a>
<a name="734"><span class="lineNum">     734 </span>            :         /* Init the trampoline, possibly with KASLR memory offset */</a>
<a name="735"><span class="lineNum">     735 </span><span class="lineCov">          1 :         init_trampoline();</span></a>
<a name="736"><span class="lineNum">     736 </span>            : </a>
<a name="737"><span class="lineNum">     737 </span>            :         /*</a>
<a name="738"><span class="lineNum">     738 </span>            :          * If the allocation is in bottom-up direction, we setup direct mapping</a>
<a name="739"><span class="lineNum">     739 </span>            :          * in bottom-up, otherwise we setup direct mapping in top-down.</a>
<a name="740"><span class="lineNum">     740 </span>            :          */</a>
<a name="741"><span class="lineNum">     741 </span><span class="lineCov">          1 :         if (memblock_bottom_up()) {</span></a>
<a name="742"><span class="lineNum">     742 </span><span class="lineNoCov">          0 :                 unsigned long kernel_end = __pa_symbol(_end);</span></a>
<a name="743"><span class="lineNum">     743 </span>            : </a>
<a name="744"><span class="lineNum">     744 </span>            :                 /*</a>
<a name="745"><span class="lineNum">     745 </span>            :                  * we need two separate calls here. This is because we want to</a>
<a name="746"><span class="lineNum">     746 </span>            :                  * allocate page tables above the kernel. So we first map</a>
<a name="747"><span class="lineNum">     747 </span>            :                  * [kernel_end, end) to make memory above the kernel be mapped</a>
<a name="748"><span class="lineNum">     748 </span>            :                  * as soon as possible. And then use page tables allocated above</a>
<a name="749"><span class="lineNum">     749 </span>            :                  * the kernel to map [ISA_END_ADDRESS, kernel_end).</a>
<a name="750"><span class="lineNum">     750 </span>            :                  */</a>
<a name="751"><span class="lineNum">     751 </span><span class="lineNoCov">          0 :                 memory_map_bottom_up(kernel_end, end);</span></a>
<a name="752"><span class="lineNum">     752 </span><span class="lineNoCov">          0 :                 memory_map_bottom_up(ISA_END_ADDRESS, kernel_end);</span></a>
<a name="753"><span class="lineNum">     753 </span>            :         } else {</a>
<a name="754"><span class="lineNum">     754 </span><span class="lineCov">          1 :                 memory_map_top_down(ISA_END_ADDRESS, end);</span></a>
<a name="755"><span class="lineNum">     755 </span>            :         }</a>
<a name="756"><span class="lineNum">     756 </span>            : </a>
<a name="757"><span class="lineNum">     757 </span>            : #ifdef CONFIG_X86_64</a>
<a name="758"><span class="lineNum">     758 </span><span class="lineCov">          1 :         if (max_pfn &gt; max_low_pfn) {</span></a>
<a name="759"><span class="lineNum">     759 </span>            :                 /* can we preseve max_low_pfn ?*/</a>
<a name="760"><span class="lineNum">     760 </span><span class="lineNoCov">          0 :                 max_low_pfn = max_pfn;</span></a>
<a name="761"><span class="lineNum">     761 </span>            :         }</a>
<a name="762"><span class="lineNum">     762 </span>            : #else</a>
<a name="763"><span class="lineNum">     763 </span>            :         early_ioremap_page_table_range_init();</a>
<a name="764"><span class="lineNum">     764 </span>            : #endif</a>
<a name="765"><span class="lineNum">     765 </span>            : </a>
<a name="766"><span class="lineNum">     766 </span><span class="lineCov">          1 :         load_cr3(swapper_pg_dir);</span></a>
<a name="767"><span class="lineNum">     767 </span><span class="lineCov">          1 :         __flush_tlb_all();</span></a>
<a name="768"><span class="lineNum">     768 </span>            : </a>
<a name="769"><span class="lineNum">     769 </span><span class="lineCov">          1 :         x86_init.hyper.init_mem_mapping();</span></a>
<a name="770"><span class="lineNum">     770 </span>            : </a>
<a name="771"><span class="lineNum">     771 </span><span class="lineCov">          1 :         early_memtest(0, max_pfn_mapped &lt;&lt; PAGE_SHIFT);</span></a>
<a name="772"><span class="lineNum">     772 </span><span class="lineCov">          1 : }</span></a>
<a name="773"><span class="lineNum">     773 </span>            : </a>
<a name="774"><span class="lineNum">     774 </span>            : /*</a>
<a name="775"><span class="lineNum">     775 </span>            :  * Initialize an mm_struct to be used during poking and a pointer to be used</a>
<a name="776"><span class="lineNum">     776 </span>            :  * during patching.</a>
<a name="777"><span class="lineNum">     777 </span>            :  */</a>
<a name="778"><span class="lineNum">     778 </span><span class="lineCov">          1 : void __init poking_init(void)</span></a>
<a name="779"><span class="lineNum">     779 </span>            : {</a>
<a name="780"><span class="lineNum">     780 </span><span class="lineCov">          1 :         spinlock_t *ptl;</span></a>
<a name="781"><span class="lineNum">     781 </span><span class="lineCov">          1 :         pte_t *ptep;</span></a>
<a name="782"><span class="lineNum">     782 </span>            : </a>
<a name="783"><span class="lineNum">     783 </span><span class="lineCov">          1 :         poking_mm = copy_init_mm();</span></a>
<a name="784"><span class="lineNum">     784 </span><span class="lineCov">          1 :         BUG_ON(!poking_mm);</span></a>
<a name="785"><span class="lineNum">     785 </span>            : </a>
<a name="786"><span class="lineNum">     786 </span>            :         /*</a>
<a name="787"><span class="lineNum">     787 </span>            :          * Randomize the poking address, but make sure that the following page</a>
<a name="788"><span class="lineNum">     788 </span>            :          * will be mapped at the same PMD. We need 2 pages, so find space for 3,</a>
<a name="789"><span class="lineNum">     789 </span>            :          * and adjust the address if the PMD ends after the first one.</a>
<a name="790"><span class="lineNum">     790 </span>            :          */</a>
<a name="791"><span class="lineNum">     791 </span><span class="lineCov">          1 :         poking_addr = TASK_UNMAPPED_BASE;</span></a>
<a name="792"><span class="lineNum">     792 </span><span class="lineCov">          1 :         if (IS_ENABLED(CONFIG_RANDOMIZE_BASE))</span></a>
<a name="793"><span class="lineNum">     793 </span>            :                 poking_addr += (kaslr_get_random_long(&quot;Poking&quot;) &amp; PAGE_MASK) %</a>
<a name="794"><span class="lineNum">     794 </span>            :                         (TASK_SIZE - TASK_UNMAPPED_BASE - 3 * PAGE_SIZE);</a>
<a name="795"><span class="lineNum">     795 </span>            : </a>
<a name="796"><span class="lineNum">     796 </span><span class="lineCov">          1 :         if (((poking_addr + PAGE_SIZE) &amp; ~PMD_MASK) == 0)</span></a>
<a name="797"><span class="lineNum">     797 </span><span class="lineNoCov">          0 :                 poking_addr += PAGE_SIZE;</span></a>
<a name="798"><span class="lineNum">     798 </span>            : </a>
<a name="799"><span class="lineNum">     799 </span>            :         /*</a>
<a name="800"><span class="lineNum">     800 </span>            :          * We need to trigger the allocation of the page-tables that will be</a>
<a name="801"><span class="lineNum">     801 </span>            :          * needed for poking now. Later, poking may be performed in an atomic</a>
<a name="802"><span class="lineNum">     802 </span>            :          * section, which might cause allocation to fail.</a>
<a name="803"><span class="lineNum">     803 </span>            :          */</a>
<a name="804"><span class="lineNum">     804 </span><span class="lineCov">          1 :         ptep = get_locked_pte(poking_mm, poking_addr, &amp;ptl);</span></a>
<a name="805"><span class="lineNum">     805 </span><span class="lineCov">          1 :         BUG_ON(!ptep);</span></a>
<a name="806"><span class="lineNum">     806 </span><span class="lineCov">          1 :         pte_unmap_unlock(ptep, ptl);</span></a>
<a name="807"><span class="lineNum">     807 </span><span class="lineCov">          1 : }</span></a>
<a name="808"><span class="lineNum">     808 </span>            : </a>
<a name="809"><span class="lineNum">     809 </span>            : /*</a>
<a name="810"><span class="lineNum">     810 </span>            :  * devmem_is_allowed() checks to see if /dev/mem access to a certain address</a>
<a name="811"><span class="lineNum">     811 </span>            :  * is valid. The argument is a physical page number.</a>
<a name="812"><span class="lineNum">     812 </span>            :  *</a>
<a name="813"><span class="lineNum">     813 </span>            :  * On x86, access has to be given to the first megabyte of RAM because that</a>
<a name="814"><span class="lineNum">     814 </span>            :  * area traditionally contains BIOS code and data regions used by X, dosemu,</a>
<a name="815"><span class="lineNum">     815 </span>            :  * and similar apps. Since they map the entire memory range, the whole range</a>
<a name="816"><span class="lineNum">     816 </span>            :  * must be allowed (for mapping), but any areas that would otherwise be</a>
<a name="817"><span class="lineNum">     817 </span>            :  * disallowed are flagged as being &quot;zero filled&quot; instead of rejected.</a>
<a name="818"><span class="lineNum">     818 </span>            :  * Access has to be given to non-kernel-ram areas as well, these contain the</a>
<a name="819"><span class="lineNum">     819 </span>            :  * PCI mmio resources as well as potential bios/acpi data regions.</a>
<a name="820"><span class="lineNum">     820 </span>            :  */</a>
<a name="821"><span class="lineNum">     821 </span><span class="lineNoCov">          0 : int devmem_is_allowed(unsigned long pagenr)</span></a>
<a name="822"><span class="lineNum">     822 </span>            : {</a>
<a name="823"><span class="lineNum">     823 </span><span class="lineNoCov">          0 :         if (region_intersects(PFN_PHYS(pagenr), PAGE_SIZE,</span></a>
<a name="824"><span class="lineNum">     824 </span>            :                                 IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)</a>
<a name="825"><span class="lineNum">     825 </span>            :                         != REGION_DISJOINT) {</a>
<a name="826"><span class="lineNum">     826 </span>            :                 /*</a>
<a name="827"><span class="lineNum">     827 </span>            :                  * For disallowed memory regions in the low 1MB range,</a>
<a name="828"><span class="lineNum">     828 </span>            :                  * request that the page be shown as all zeros.</a>
<a name="829"><span class="lineNum">     829 </span>            :                  */</a>
<a name="830"><span class="lineNum">     830 </span><span class="lineNoCov">          0 :                 if (pagenr &lt; 256)</span></a>
<a name="831"><span class="lineNum">     831 </span>            :                         return 2;</a>
<a name="832"><span class="lineNum">     832 </span>            : </a>
<a name="833"><span class="lineNum">     833 </span><span class="lineNoCov">          0 :                 return 0;</span></a>
<a name="834"><span class="lineNum">     834 </span>            :         }</a>
<a name="835"><span class="lineNum">     835 </span>            : </a>
<a name="836"><span class="lineNum">     836 </span>            :         /*</a>
<a name="837"><span class="lineNum">     837 </span>            :          * This must follow RAM test, since System RAM is considered a</a>
<a name="838"><span class="lineNum">     838 </span>            :          * restricted resource under CONFIG_STRICT_IOMEM.</a>
<a name="839"><span class="lineNum">     839 </span>            :          */</a>
<a name="840"><span class="lineNum">     840 </span><span class="lineNoCov">          0 :         if (iomem_is_exclusive(pagenr &lt;&lt; PAGE_SHIFT)) {</span></a>
<a name="841"><span class="lineNum">     841 </span>            :                 /* Low 1MB bypasses iomem restrictions. */</a>
<a name="842"><span class="lineNum">     842 </span><span class="lineNoCov">          0 :                 if (pagenr &lt; 256)</span></a>
<a name="843"><span class="lineNum">     843 </span>            :                         return 1;</a>
<a name="844"><span class="lineNum">     844 </span>            : </a>
<a name="845"><span class="lineNum">     845 </span><span class="lineNoCov">          0 :                 return 0;</span></a>
<a name="846"><span class="lineNum">     846 </span>            :         }</a>
<a name="847"><span class="lineNum">     847 </span>            : </a>
<a name="848"><span class="lineNum">     848 </span>            :         return 1;</a>
<a name="849"><span class="lineNum">     849 </span>            : }</a>
<a name="850"><span class="lineNum">     850 </span>            : </a>
<a name="851"><span class="lineNum">     851 </span><span class="lineCov">          4 : void free_init_pages(const char *what, unsigned long begin, unsigned long end)</span></a>
<a name="852"><span class="lineNum">     852 </span>            : {</a>
<a name="853"><span class="lineNum">     853 </span><span class="lineCov">          4 :         unsigned long begin_aligned, end_aligned;</span></a>
<a name="854"><span class="lineNum">     854 </span>            : </a>
<a name="855"><span class="lineNum">     855 </span>            :         /* Make sure boundaries are page aligned */</a>
<a name="856"><span class="lineNum">     856 </span><span class="lineCov">          4 :         begin_aligned = PAGE_ALIGN(begin);</span></a>
<a name="857"><span class="lineNum">     857 </span><span class="lineCov">          4 :         end_aligned   = end &amp; PAGE_MASK;</span></a>
<a name="858"><span class="lineNum">     858 </span>            : </a>
<a name="859"><span class="lineNum">     859 </span><span class="lineCov">          4 :         if (WARN_ON(begin_aligned != begin || end_aligned != end)) {</span></a>
<a name="860"><span class="lineNum">     860 </span><span class="lineNoCov">          0 :                 begin = begin_aligned;</span></a>
<a name="861"><span class="lineNum">     861 </span><span class="lineNoCov">          0 :                 end   = end_aligned;</span></a>
<a name="862"><span class="lineNum">     862 </span>            :         }</a>
<a name="863"><span class="lineNum">     863 </span>            : </a>
<a name="864"><span class="lineNum">     864 </span><span class="lineCov">          4 :         if (begin &gt;= end)</span></a>
<a name="865"><span class="lineNum">     865 </span>            :                 return;</a>
<a name="866"><span class="lineNum">     866 </span>            : </a>
<a name="867"><span class="lineNum">     867 </span>            :         /*</a>
<a name="868"><span class="lineNum">     868 </span>            :          * If debugging page accesses then do not free this memory but</a>
<a name="869"><span class="lineNum">     869 </span>            :          * mark them not present - any buggy init-section access will</a>
<a name="870"><span class="lineNum">     870 </span>            :          * create a kernel page fault:</a>
<a name="871"><span class="lineNum">     871 </span>            :          */</a>
<a name="872"><span class="lineNum">     872 </span><span class="lineCov">          4 :         if (debug_pagealloc_enabled()) {</span></a>
<a name="873"><span class="lineNum">     873 </span>            :                 pr_info(&quot;debug: unmapping init [mem %#010lx-%#010lx]\n&quot;,</a>
<a name="874"><span class="lineNum">     874 </span>            :                         begin, end - 1);</a>
<a name="875"><span class="lineNum">     875 </span>            :                 /*</a>
<a name="876"><span class="lineNum">     876 </span>            :                  * Inform kmemleak about the hole in the memory since the</a>
<a name="877"><span class="lineNum">     877 </span>            :                  * corresponding pages will be unmapped.</a>
<a name="878"><span class="lineNum">     878 </span>            :                  */</a>
<a name="879"><span class="lineNum">     879 </span>            :                 kmemleak_free_part((void *)begin, end - begin);</a>
<a name="880"><span class="lineNum">     880 </span>            :                 set_memory_np(begin, (end - begin) &gt;&gt; PAGE_SHIFT);</a>
<a name="881"><span class="lineNum">     881 </span>            :         } else {</a>
<a name="882"><span class="lineNum">     882 </span>            :                 /*</a>
<a name="883"><span class="lineNum">     883 </span>            :                  * We just marked the kernel text read only above, now that</a>
<a name="884"><span class="lineNum">     884 </span>            :                  * we are going to free part of that, we need to make that</a>
<a name="885"><span class="lineNum">     885 </span>            :                  * writeable and non-executable first.</a>
<a name="886"><span class="lineNum">     886 </span>            :                  */</a>
<a name="887"><span class="lineNum">     887 </span><span class="lineCov">          4 :                 set_memory_nx(begin, (end - begin) &gt;&gt; PAGE_SHIFT);</span></a>
<a name="888"><span class="lineNum">     888 </span><span class="lineCov">          4 :                 set_memory_rw(begin, (end - begin) &gt;&gt; PAGE_SHIFT);</span></a>
<a name="889"><span class="lineNum">     889 </span>            : </a>
<a name="890"><span class="lineNum">     890 </span><span class="lineCov">          4 :                 free_reserved_area((void *)begin, (void *)end,</span></a>
<a name="891"><span class="lineNum">     891 </span>            :                                    POISON_FREE_INITMEM, what);</a>
<a name="892"><span class="lineNum">     892 </span>            :         }</a>
<a name="893"><span class="lineNum">     893 </span>            : }</a>
<a name="894"><span class="lineNum">     894 </span>            : </a>
<a name="895"><span class="lineNum">     895 </span>            : /*</a>
<a name="896"><span class="lineNum">     896 </span>            :  * begin/end can be in the direct map or the &quot;high kernel mapping&quot;</a>
<a name="897"><span class="lineNum">     897 </span>            :  * used for the kernel image only.  free_init_pages() will do the</a>
<a name="898"><span class="lineNum">     898 </span>            :  * right thing for either kind of address.</a>
<a name="899"><span class="lineNum">     899 </span>            :  */</a>
<a name="900"><span class="lineNum">     900 </span><span class="lineCov">          3 : void free_kernel_image_pages(const char *what, void *begin, void *end)</span></a>
<a name="901"><span class="lineNum">     901 </span>            : {</a>
<a name="902"><span class="lineNum">     902 </span><span class="lineCov">          3 :         unsigned long begin_ul = (unsigned long)begin;</span></a>
<a name="903"><span class="lineNum">     903 </span><span class="lineCov">          3 :         unsigned long end_ul = (unsigned long)end;</span></a>
<a name="904"><span class="lineNum">     904 </span><span class="lineCov">          3 :         unsigned long len_pages = (end_ul - begin_ul) &gt;&gt; PAGE_SHIFT;</span></a>
<a name="905"><span class="lineNum">     905 </span>            : </a>
<a name="906"><span class="lineNum">     906 </span><span class="lineCov">          2 :         free_init_pages(what, begin_ul, end_ul);</span></a>
<a name="907"><span class="lineNum">     907 </span>            : </a>
<a name="908"><span class="lineNum">     908 </span>            :         /*</a>
<a name="909"><span class="lineNum">     909 </span>            :          * PTI maps some of the kernel into userspace.  For performance,</a>
<a name="910"><span class="lineNum">     910 </span>            :          * this includes some kernel areas that do not contain secrets.</a>
<a name="911"><span class="lineNum">     911 </span>            :          * Those areas might be adjacent to the parts of the kernel image</a>
<a name="912"><span class="lineNum">     912 </span>            :          * being freed, which may contain secrets.  Remove the &quot;high kernel</a>
<a name="913"><span class="lineNum">     913 </span>            :          * image mapping&quot; for these freed areas, ensuring they are not even</a>
<a name="914"><span class="lineNum">     914 </span>            :          * potentially vulnerable to Meltdown regardless of the specific</a>
<a name="915"><span class="lineNum">     915 </span>            :          * optimizations PTI is currently using.</a>
<a name="916"><span class="lineNum">     916 </span>            :          *</a>
<a name="917"><span class="lineNum">     917 </span>            :          * The &quot;noalias&quot; prevents unmapping the direct map alias which is</a>
<a name="918"><span class="lineNum">     918 </span>            :          * needed to access the freed pages.</a>
<a name="919"><span class="lineNum">     919 </span>            :          *</a>
<a name="920"><span class="lineNum">     920 </span>            :          * This is only valid for 64bit kernels. 32bit has only one mapping</a>
<a name="921"><span class="lineNum">     921 </span>            :          * which can't be treated in this way for obvious reasons.</a>
<a name="922"><span class="lineNum">     922 </span>            :          */</a>
<a name="923"><span class="lineNum">     923 </span><span class="lineCov">          3 :         if (IS_ENABLED(CONFIG_X86_64) &amp;&amp; cpu_feature_enabled(X86_FEATURE_PTI))</span></a>
<a name="924"><span class="lineNum">     924 </span>            :                 set_memory_np_noalias(begin_ul, len_pages);</a>
<a name="925"><span class="lineNum">     925 </span><span class="lineCov">          2 : }</span></a>
<a name="926"><span class="lineNum">     926 </span>            : </a>
<a name="927"><span class="lineNum">     927 </span><span class="lineCov">          1 : void __ref free_initmem(void)</span></a>
<a name="928"><span class="lineNum">     928 </span>            : {</a>
<a name="929"><span class="lineNum">     929 </span><span class="lineCov">          1 :         e820__reallocate_tables();</span></a>
<a name="930"><span class="lineNum">     930 </span>            : </a>
<a name="931"><span class="lineNum">     931 </span><span class="lineCov">          1 :         mem_encrypt_free_decrypted_mem();</span></a>
<a name="932"><span class="lineNum">     932 </span>            : </a>
<a name="933"><span class="lineNum">     933 </span><span class="lineCov">          1 :         free_kernel_image_pages(&quot;unused kernel image (initmem)&quot;,</span></a>
<a name="934"><span class="lineNum">     934 </span>            :                                 &amp;__init_begin, &amp;__init_end);</a>
<a name="935"><span class="lineNum">     935 </span><span class="lineCov">          1 : }</span></a>
<a name="936"><span class="lineNum">     936 </span>            : </a>
<a name="937"><span class="lineNum">     937 </span>            : #ifdef CONFIG_BLK_DEV_INITRD</a>
<a name="938"><span class="lineNum">     938 </span><span class="lineNoCov">          0 : void __init free_initrd_mem(unsigned long start, unsigned long end)</span></a>
<a name="939"><span class="lineNum">     939 </span>            : {</a>
<a name="940"><span class="lineNum">     940 </span>            :         /*</a>
<a name="941"><span class="lineNum">     941 </span>            :          * end could be not aligned, and We can not align that,</a>
<a name="942"><span class="lineNum">     942 </span>            :          * decompresser could be confused by aligned initrd_end</a>
<a name="943"><span class="lineNum">     943 </span>            :          * We already reserve the end partial page before in</a>
<a name="944"><span class="lineNum">     944 </span>            :          *   - i386_start_kernel()</a>
<a name="945"><span class="lineNum">     945 </span>            :          *   - x86_64_start_kernel()</a>
<a name="946"><span class="lineNum">     946 </span>            :          *   - relocate_initrd()</a>
<a name="947"><span class="lineNum">     947 </span>            :          * So here We can do PAGE_ALIGN() safely to get partial page to be freed</a>
<a name="948"><span class="lineNum">     948 </span>            :          */</a>
<a name="949"><span class="lineNum">     949 </span><span class="lineNoCov">          0 :         free_init_pages(&quot;initrd&quot;, start, PAGE_ALIGN(end));</span></a>
<a name="950"><span class="lineNum">     950 </span><span class="lineNoCov">          0 : }</span></a>
<a name="951"><span class="lineNum">     951 </span>            : #endif</a>
<a name="952"><span class="lineNum">     952 </span>            : </a>
<a name="953"><span class="lineNum">     953 </span>            : /*</a>
<a name="954"><span class="lineNum">     954 </span>            :  * Calculate the precise size of the DMA zone (first 16 MB of RAM),</a>
<a name="955"><span class="lineNum">     955 </span>            :  * and pass it to the MM layer - to help it set zone watermarks more</a>
<a name="956"><span class="lineNum">     956 </span>            :  * accurately.</a>
<a name="957"><span class="lineNum">     957 </span>            :  *</a>
<a name="958"><span class="lineNum">     958 </span>            :  * Done on 64-bit systems only for the time being, although 32-bit systems</a>
<a name="959"><span class="lineNum">     959 </span>            :  * might benefit from this as well.</a>
<a name="960"><span class="lineNum">     960 </span>            :  */</a>
<a name="961"><span class="lineNum">     961 </span><span class="lineCov">          1 : void __init memblock_find_dma_reserve(void)</span></a>
<a name="962"><span class="lineNum">     962 </span>            : {</a>
<a name="963"><span class="lineNum">     963 </span>            : #ifdef CONFIG_X86_64</a>
<a name="964"><span class="lineNum">     964 </span><span class="lineCov">          1 :         u64 nr_pages = 0, nr_free_pages = 0;</span></a>
<a name="965"><span class="lineNum">     965 </span><span class="lineCov">          1 :         unsigned long start_pfn, end_pfn;</span></a>
<a name="966"><span class="lineNum">     966 </span><span class="lineCov">          1 :         phys_addr_t start_addr, end_addr;</span></a>
<a name="967"><span class="lineNum">     967 </span><span class="lineCov">          1 :         int i;</span></a>
<a name="968"><span class="lineNum">     968 </span><span class="lineCov">          1 :         u64 u;</span></a>
<a name="969"><span class="lineNum">     969 </span>            : </a>
<a name="970"><span class="lineNum">     970 </span>            :         /*</a>
<a name="971"><span class="lineNum">     971 </span>            :          * Iterate over all memory ranges (free and reserved ones alike),</a>
<a name="972"><span class="lineNum">     972 </span>            :          * to calculate the total number of pages in the first 16 MB of RAM:</a>
<a name="973"><span class="lineNum">     973 </span>            :          */</a>
<a name="974"><span class="lineNum">     974 </span><span class="lineCov">          1 :         nr_pages = 0;</span></a>
<a name="975"><span class="lineNum">     975 </span><span class="lineCov">          3 :         for_each_mem_pfn_range(i, MAX_NUMNODES, &amp;start_pfn, &amp;end_pfn, NULL) {</span></a>
<a name="976"><span class="lineNum">     976 </span><span class="lineCov">          2 :                 start_pfn = min(start_pfn, MAX_DMA_PFN);</span></a>
<a name="977"><span class="lineNum">     977 </span><span class="lineCov">          2 :                 end_pfn   = min(end_pfn,   MAX_DMA_PFN);</span></a>
<a name="978"><span class="lineNum">     978 </span>            : </a>
<a name="979"><span class="lineNum">     979 </span><span class="lineCov">          2 :                 nr_pages += end_pfn - start_pfn;</span></a>
<a name="980"><span class="lineNum">     980 </span>            :         }</a>
<a name="981"><span class="lineNum">     981 </span>            : </a>
<a name="982"><span class="lineNum">     982 </span>            :         /*</a>
<a name="983"><span class="lineNum">     983 </span>            :          * Iterate over free memory ranges to calculate the number of free</a>
<a name="984"><span class="lineNum">     984 </span>            :          * pages in the DMA zone, while not counting potential partial</a>
<a name="985"><span class="lineNum">     985 </span>            :          * pages at the beginning or the end of the range:</a>
<a name="986"><span class="lineNum">     986 </span>            :          */</a>
<a name="987"><span class="lineNum">     987 </span><span class="lineCov">          1 :         nr_free_pages = 0;</span></a>
<a name="988"><span class="lineNum">     988 </span><span class="lineCov">          4 :         for_each_free_mem_range(u, NUMA_NO_NODE, MEMBLOCK_NONE, &amp;start_addr, &amp;end_addr, NULL) {</span></a>
<a name="989"><span class="lineNum">     989 </span><span class="lineCov">          3 :                 start_pfn = min_t(unsigned long, PFN_UP(start_addr), MAX_DMA_PFN);</span></a>
<a name="990"><span class="lineNum">     990 </span><span class="lineCov">          3 :                 end_pfn   = min_t(unsigned long, PFN_DOWN(end_addr), MAX_DMA_PFN);</span></a>
<a name="991"><span class="lineNum">     991 </span>            : </a>
<a name="992"><span class="lineNum">     992 </span><span class="lineCov">          3 :                 if (start_pfn &lt; end_pfn)</span></a>
<a name="993"><span class="lineNum">     993 </span><span class="lineCov">          2 :                         nr_free_pages += end_pfn - start_pfn;</span></a>
<a name="994"><span class="lineNum">     994 </span>            :         }</a>
<a name="995"><span class="lineNum">     995 </span>            : </a>
<a name="996"><span class="lineNum">     996 </span><span class="lineCov">          1 :         set_dma_reserve(nr_pages - nr_free_pages);</span></a>
<a name="997"><span class="lineNum">     997 </span>            : #endif</a>
<a name="998"><span class="lineNum">     998 </span><span class="lineCov">          1 : }</span></a>
<a name="999"><span class="lineNum">     999 </span>            : </a>
<a name="1000"><span class="lineNum">    1000 </span><span class="lineCov">          1 : void __init zone_sizes_init(void)</span></a>
<a name="1001"><span class="lineNum">    1001 </span>            : {</a>
<a name="1002"><span class="lineNum">    1002 </span><span class="lineCov">          1 :         unsigned long max_zone_pfns[MAX_NR_ZONES];</span></a>
<a name="1003"><span class="lineNum">    1003 </span>            : </a>
<a name="1004"><span class="lineNum">    1004 </span><span class="lineCov">          1 :         memset(max_zone_pfns, 0, sizeof(max_zone_pfns));</span></a>
<a name="1005"><span class="lineNum">    1005 </span>            : </a>
<a name="1006"><span class="lineNum">    1006 </span>            : #ifdef CONFIG_ZONE_DMA</a>
<a name="1007"><span class="lineNum">    1007 </span>            :         max_zone_pfns[ZONE_DMA]         = min(MAX_DMA_PFN, max_low_pfn);</a>
<a name="1008"><span class="lineNum">    1008 </span>            : #endif</a>
<a name="1009"><span class="lineNum">    1009 </span>            : #ifdef CONFIG_ZONE_DMA32</a>
<a name="1010"><span class="lineNum">    1010 </span><span class="lineCov">          1 :         max_zone_pfns[ZONE_DMA32]       = min(MAX_DMA32_PFN, max_low_pfn);</span></a>
<a name="1011"><span class="lineNum">    1011 </span>            : #endif</a>
<a name="1012"><span class="lineNum">    1012 </span><span class="lineCov">          1 :         max_zone_pfns[ZONE_NORMAL]      = max_low_pfn;</span></a>
<a name="1013"><span class="lineNum">    1013 </span>            : #ifdef CONFIG_HIGHMEM</a>
<a name="1014"><span class="lineNum">    1014 </span>            :         max_zone_pfns[ZONE_HIGHMEM]     = max_pfn;</a>
<a name="1015"><span class="lineNum">    1015 </span>            : #endif</a>
<a name="1016"><span class="lineNum">    1016 </span>            : </a>
<a name="1017"><span class="lineNum">    1017 </span><span class="lineCov">          1 :         free_area_init(max_zone_pfns);</span></a>
<a name="1018"><span class="lineNum">    1018 </span><span class="lineCov">          1 : }</span></a>
<a name="1019"><span class="lineNum">    1019 </span>            : </a>
<a name="1020"><span class="lineNum">    1020 </span>            : __visible DEFINE_PER_CPU_SHARED_ALIGNED(struct tlb_state, cpu_tlbstate) = {</a>
<a name="1021"><span class="lineNum">    1021 </span>            :         .loaded_mm = &amp;init_mm,</a>
<a name="1022"><span class="lineNum">    1022 </span>            :         .next_asid = 1,</a>
<a name="1023"><span class="lineNum">    1023 </span>            :         .cr4 = ~0UL,    /* fail hard if we screw up cr4 shadow initialization */</a>
<a name="1024"><span class="lineNum">    1024 </span>            : };</a>
<a name="1025"><span class="lineNum">    1025 </span>            : </a>
<a name="1026"><span class="lineNum">    1026 </span><span class="lineCov">          8 : void update_cache_mode_entry(unsigned entry, enum page_cache_mode cache)</span></a>
<a name="1027"><span class="lineNum">    1027 </span>            : {</a>
<a name="1028"><span class="lineNum">    1028 </span>            :         /* entry 0 MUST be WB (hardwired to speed up translations) */</a>
<a name="1029"><span class="lineNum">    1029 </span><span class="lineCov">          8 :         BUG_ON(!entry &amp;&amp; cache != _PAGE_CACHE_MODE_WB);</span></a>
<a name="1030"><span class="lineNum">    1030 </span>            : </a>
<a name="1031"><span class="lineNum">    1031 </span><span class="lineCov">          8 :         __cachemode2pte_tbl[cache] = __cm_idx2pte(entry);</span></a>
<a name="1032"><span class="lineNum">    1032 </span><span class="lineCov">          8 :         __pte2cachemode_tbl[entry] = cache;</span></a>
<a name="1033"><span class="lineNum">    1033 </span><span class="lineCov">          8 : }</span></a>
<a name="1034"><span class="lineNum">    1034 </span>            : </a>
<a name="1035"><span class="lineNum">    1035 </span>            : #ifdef CONFIG_SWAP</a>
<a name="1036"><span class="lineNum">    1036 </span>            : unsigned long max_swapfile_size(void)</a>
<a name="1037"><span class="lineNum">    1037 </span>            : {</a>
<a name="1038"><span class="lineNum">    1038 </span>            :         unsigned long pages;</a>
<a name="1039"><span class="lineNum">    1039 </span>            : </a>
<a name="1040"><span class="lineNum">    1040 </span>            :         pages = generic_max_swapfile_size();</a>
<a name="1041"><span class="lineNum">    1041 </span>            : </a>
<a name="1042"><span class="lineNum">    1042 </span>            :         if (boot_cpu_has_bug(X86_BUG_L1TF) &amp;&amp; l1tf_mitigation != L1TF_MITIGATION_OFF) {</a>
<a name="1043"><span class="lineNum">    1043 </span>            :                 /* Limit the swap file size to MAX_PA/2 for L1TF workaround */</a>
<a name="1044"><span class="lineNum">    1044 </span>            :                 unsigned long long l1tf_limit = l1tf_pfn_limit();</a>
<a name="1045"><span class="lineNum">    1045 </span>            :                 /*</a>
<a name="1046"><span class="lineNum">    1046 </span>            :                  * We encode swap offsets also with 3 bits below those for pfn</a>
<a name="1047"><span class="lineNum">    1047 </span>            :                  * which makes the usable limit higher.</a>
<a name="1048"><span class="lineNum">    1048 </span>            :                  */</a>
<a name="1049"><span class="lineNum">    1049 </span>            : #if CONFIG_PGTABLE_LEVELS &gt; 2</a>
<a name="1050"><span class="lineNum">    1050 </span>            :                 l1tf_limit &lt;&lt;= PAGE_SHIFT - SWP_OFFSET_FIRST_BIT;</a>
<a name="1051"><span class="lineNum">    1051 </span>            : #endif</a>
<a name="1052"><span class="lineNum">    1052 </span>            :                 pages = min_t(unsigned long long, l1tf_limit, pages);</a>
<a name="1053"><span class="lineNum">    1053 </span>            :         }</a>
<a name="1054"><span class="lineNum">    1054 </span>            :         return pages;</a>
<a name="1055"><span class="lineNum">    1055 </span>            : }</a>
<a name="1056"><span class="lineNum">    1056 </span>            : #endif</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
